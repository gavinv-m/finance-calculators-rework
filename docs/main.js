/******/ (() => {
  // webpackBootstrap
  /******/ 'use strict';
  /******/ var __webpack_modules__ = {
    /***/ './downloaders/house-flip-pdf.js':
      /*!***************************************!*\
  !*** ./downloaders/house-flip-pdf.js ***!
  \***************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ setupHouseFlipPdfDownload,
          /* harmony export */
        });
        function setupHouseFlipPdfDownload() {
          document
            .getElementById('download-pdf')
            .addEventListener('click', () => {
              if (window.jspdf && typeof html2canvas !== 'undefined') {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Function to get values from input fields
                function getValue(id) {
                  const element = document.getElementById(id);
                  return element && element.value ? element.value : 'N/A';
                }

                // Combine existing content and house flipping analysis into a single div
                const combinedDiv = document.createElement('div');
                combinedDiv.id = 'combinedContent';
                combinedDiv.style.padding = '20px';
                combinedDiv.style.backgroundColor = '#fff';
                combinedDiv.style.color = '#000';
                combinedDiv.style.width = '800px';
                combinedDiv.style.margin = 'auto';

                // Clone the original content
                const contentDiv = document.getElementById('contentPDF');
                combinedDiv.appendChild(contentDiv.cloneNode(true));

                // Create results section
                const resultsDiv = document.createElement('div');
                resultsDiv.innerHTML = `
            <h2 style="text-align:center; margin-top: 20px;">Inputs</h2>
            <table border="1" cellspacing="0" cellpadding="5" style="width:100%; text-align:left;">
              <tr><td><strong>Property Address:</strong></td><td>$${getValue(
                'propertyAddress'
              )}</td></tr>
              <tr><td><strong>Property Purchase Price:</strong></td><td>$${getValue(
                'purchasePrice'
              )}</td></tr>
              <tr><td><strong>Renovation Costs:</strong></td><td>$${getValue(
                'renoCosts'
              )}</td></tr>
              <tr><td><strong>Closing Costs:</strong></td><td>${getValue(
                'closingCosts'
              )}%</td></tr>
              <tr><td><strong>Holding Costs:</strong></td><td>$${getValue(
                'holdingCosts'
              )}</td></tr>
              <tr><td><strong>After Repair Value:</strong></td><td>$${getValue(
                'afterRepairValue'
              )}</td></tr>
              <tr><td><strong>Project Months:</strong></td><td>${getValue(
                'projectMonths'
              )} Months</td></tr>
              <tr><td><strong>House Monthly Rent:</strong></td><td>$${getValue(
                'houseMonthlyRent'
              )}</td></tr>
              <tr><td><strong>House Interest Rate:</strong></td><td>${getValue(
                'houseinterestRate'
              )}%</td></tr>
              <tr><td><strong>Loan Points:</strong></td><td>${getValue(
                'loanPoints'
              )}%</td></tr>
              <tr><td><strong>Loan Term:</strong></td><td>${getValue(
                'houseLoanYear'
              )} Years</td></tr>
              <tr><td><strong>Gap Costs:</strong></td><td>$${getValue(
                'gapCosts'
              )}</td></tr>
              <tr><td><strong>Down Payment Percent:</strong></td><td>${getValue(
                'downPaymentPercent'
              )}%</td></tr>
              <tr><td><strong>Resale Costs:</strong></td><td>$${getValue(
                'resaleCosts'
              )}</td></tr>
              <tr><td><strong>Desired Profit Margin:</strong></td><td>${getValue(
                'desiredProfitMargin'
              )}%</td></tr>
              <tr><td><strong>Down Payment Based On:</strong></td><td>$${getValue(
                'downPaymentType'
              )}</td></tr>
              <tr><td><strong>Annual Maintenance:</strong></td><td>$${getValue(
                'houseAnnualMaintenance'
              )}</td></tr>
              <tr><td><strong>Annual Utilities:</strong></td><td>$${getValue(
                'houseAnnualUtilities'
              )}</td></tr>
              <tr><td><strong>Annual Insurance:</strong></td><td>$${getValue(
                'insurance'
              )}</td></tr>
              <tr><td><strong>Annual Property Taxes:</strong></td><td>$${getValue(
                'propertyTaxesHF'
              )}</td></tr>
            </table>
          `;
                combinedDiv.appendChild(resultsDiv);
                document.body.appendChild(combinedDiv); // Append to document for rendering

                // Capture content as multiple images
                html2canvas(combinedDiv, {
                  scale: 2,
                  useCORS: true,
                })
                  .then((canvas) => {
                    const imgWidth = 190;
                    const pageHeight = doc.internal.pageSize.height;
                    let imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 10;
                    const imgData = canvas.toDataURL('image/png');

                    // Add first page
                    doc.addImage(
                      imgData,
                      'PNG',
                      10,
                      position,
                      imgWidth,
                      imgHeight
                    );
                    heightLeft -= pageHeight - 20;

                    // Add additional pages if content overflows
                    while (heightLeft > 0) {
                      position = heightLeft - imgHeight;
                      doc.addPage();
                      doc.addImage(
                        imgData,
                        'PNG',
                        10,
                        position,
                        imgWidth,
                        imgHeight
                      );
                      heightLeft -= pageHeight - 20;
                    }
                    doc.save('house_flipping_analysis.pdf');
                    combinedDiv.remove(); // Clean up temporary div
                  })
                  .catch((error) => {
                    console.error('Error capturing HTML content:', error);
                  });
              } else {
                console.error('jsPDF or html2canvas not loaded correctly.');
              }
            });
        }

        /***/
      },

    /***/ './downloaders/pdf-event-listeners.js':
      /*!********************************************!*\
  !*** ./downloaders/pdf-event-listeners.js ***!
  \********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ initializePdfListeners,
          /* harmony export */
        });
        /* harmony import */ var _house_flip_pdf__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./house-flip-pdf */ './downloaders/house-flip-pdf.js'
          );
        /* harmony import */ var _retirement_pdf__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./retirement-pdf */ './downloaders/retirement-pdf.js'
          );
        /* harmony import */ var _rental_pdf__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ./rental-pdf */ './downloaders/rental-pdf.js'
          );

        function initializePdfListeners() {
          (0, _house_flip_pdf__WEBPACK_IMPORTED_MODULE_0__['default'])();
          (0, _retirement_pdf__WEBPACK_IMPORTED_MODULE_1__['default'])();
          (0, _rental_pdf__WEBPACK_IMPORTED_MODULE_2__['default'])();
        }

        /***/
      },

    /***/ './downloaders/rental-pdf.js':
      /*!***********************************!*\
  !*** ./downloaders/rental-pdf.js ***!
  \***********************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ setupRentalPdfDownload,
          /* harmony export */
        });
        function setupRentalPdfDownload() {
          document
            .getElementById('download-pdf3')
            .addEventListener('click', function () {
              if (window.jspdf && typeof html2canvas !== 'undefined') {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Function to get values from input fields
                function getValue(id) {
                  const element = document.getElementById(id);
                  return element && element.value ? element.value : 'N/A';
                }
                const contentDiv = document.getElementById('contentPDF3'); // First page content

                // Step 1: Capture the first section (contentPDF3)
                html2canvas(contentDiv, {
                  scale: 2,
                  useCORS: true,
                })
                  .then((canvas) => {
                    const imgWidth = 190;
                    const pageHeight = doc.internal.pageSize.height;
                    let imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 10;
                    const imgData = canvas.toDataURL('image/png');

                    // Add first page content
                    doc.addImage(
                      imgData,
                      'PNG',
                      10,
                      position,
                      imgWidth,
                      imgHeight
                    );
                    heightLeft -= pageHeight - 20;

                    // Add new pages if necessary
                    while (heightLeft > 0) {
                      position = heightLeft - imgHeight;
                      doc.addPage();
                      doc.addImage(
                        imgData,
                        'PNG',
                        10,
                        position,
                        imgWidth,
                        imgHeight
                      );
                      heightLeft -= pageHeight - 20;
                    }
                    doc.addPage(); // Move to next page for input data

                    // Step 2: Create results section
                    const resultsDiv = document.createElement('div');
                    resultsDiv.style.padding = '20px';
                    resultsDiv.style.backgroundColor = '#fff';
                    resultsDiv.style.color = '#000';
                    resultsDiv.style.width = '800px';
                    resultsDiv.style.margin = 'auto';
                    resultsDiv.innerHTML = `
          <h2 style="text-align:center; margin-top: 20px;">Rental Property Inputs</h2>
          <table border="1" cellspacing="0" cellpadding="5" style="width:100%; text-align:left;">
            <tr><td><strong>Property Price:</strong></td><td>$${getValue(
              'propertyPrice'
            )}</td></tr>
            <tr><td><strong>Down Payment:</strong></td><td>$${getValue(
              'downPayment'
            )}</td></tr>
            <tr><td><strong>Loan Term:</strong></td><td>${getValue(
              'loanTerm'
            )} Years</td></tr>
            <tr><td><strong>Interest Rate:</strong></td><td>${getValue(
              'interestRate'
            )}%</td></tr>
            <tr><td><strong>Monthly Rent:</strong></td><td>$${getValue(
              'monthlyRent'
            )}</td></tr>
            <tr><td><strong>Vacancy Rate:</strong></td><td>${getValue(
              'vacancyRate'
            )}%</td></tr>
            <tr><td><strong>Closing Cost:</strong></td><td>${getValue(
              'closingCostsRent'
            )}%</td></tr>
            <tr><td><strong>Property Taxes:</strong></td><td>$${getValue(
              'propertyTaxes'
            )}</td></tr>
            <tr><td><strong>Annual Renovations:</strong></td><td>$${getValue(
              'renovations'
            )}</td></tr>
            <tr><td><strong>Annual Utilities:</strong></td><td>$${getValue(
              'utilities'
            )}</td></tr>
            <tr><td><strong>Insurance Costs:</strong></td><td>$${getValue(
              'insuranceCosts'
            )}</td></tr>
            <tr><td><strong>Maintenance Costs:</strong></td><td>$${getValue(
              'maintenanceCosts'
            )}</td></tr>
            <tr><td><strong>Management Fees:</strong></td><td>$${getValue(
              'managementFees'
            )}</td></tr>
            <tr><td><strong>Property Appreciation Rate:</strong></td><td>${getValue(
              'appreciationRate'
            )}%</td></tr>
            <tr><td><strong>Annual Rent Growth:</strong></td><td>${getValue(
              'rentGrowth'
            )}%</td></tr>
          </table>
        `;
                    document.body.appendChild(resultsDiv); // Append to document for rendering

                    // Step 3: Capture the results section
                    html2canvas(resultsDiv, {
                      scale: 2,
                      useCORS: true,
                    }).then((canvas2) => {
                      const imgData2 = canvas2.toDataURL('image/png');
                      const imgWidth2 = 190;
                      const imgHeight2 =
                        (canvas2.height * imgWidth2) / canvas2.width;
                      let heightLeft2 = imgHeight2;
                      let position2 = 10;

                      // Add new pages if needed
                      while (heightLeft2 > 0) {
                        doc.addImage(
                          imgData2,
                          'PNG',
                          10,
                          position2,
                          imgWidth2,
                          imgHeight2
                        );
                        heightLeft2 -= pageHeight - 20;
                        if (heightLeft2 > 0) doc.addPage();
                      }
                      doc.save('rental_property_evaluation.pdf'); // Save PDF
                      resultsDiv.remove(); // Clean up temporary div
                    });
                  })
                  .catch((error) => {
                    console.error('Error capturing HTML content:', error);
                  });
              } else {
                console.error('jsPDF or html2canvas not loaded correctly.');
              }
            });
        }

        /***/
      },

    /***/ './downloaders/retirement-pdf.js':
      /*!***************************************!*\
  !*** ./downloaders/retirement-pdf.js ***!
  \***************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ setupRetirementPdfDownload,
          /* harmony export */
        });
        function setupRetirementPdfDownload() {
          document
            .getElementById('download-pdf2')
            .addEventListener('click', function () {
              if (window.jspdf && typeof html2canvas !== 'undefined') {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();

                // Function to get values from input fields
                function getValue(id) {
                  const element = document.getElementById(id);
                  return element && element.value ? element.value : 'N/A';
                }

                // Combine the existing content and retirement planning analysis into a single div
                const combinedDiv = document.createElement('div');
                combinedDiv.id = 'combinedContent';
                combinedDiv.style.padding = '20px';
                combinedDiv.style.backgroundColor = '#fff';
                combinedDiv.style.color = '#000';
                combinedDiv.style.width = '800px';
                combinedDiv.style.margin = 'auto';

                // Clone the original content
                const contentDiv = document.getElementById('contentPDF2');
                combinedDiv.appendChild(contentDiv.cloneNode(true));

                // Create results section
                const resultsDiv = document.createElement('div');
                resultsDiv.innerHTML = `
            <h2 style="text-align:center; margin-top: 20px;">Retirement Planning Inputs</h2>
            <table border="1" cellspacing="0" cellpadding="5" style="width:100%; text-align:left;">
              <tr><td><strong>Current Age:</strong></td><td>${getValue(
                'currentAge'
              )}</td></tr>
              <tr><td><strong>Retirement Age:</strong></td><td>${getValue(
                'retirementAge'
              )}</td></tr>
              <tr><td><strong>Current Savings:</strong></td><td>$${getValue(
                'currentSavings'
              )}</td></tr>
              <tr><td><strong>Monthly Contributions:</strong></td><td>$${getValue(
                'monthlyContributions'
              )}</td></tr>
              <tr><td><strong>Annual Return:</strong></td><td>${getValue(
                'annualReturn'
              )}%</td></tr>
              <tr><td><strong>Inflation Rate:</strong></td><td>${getValue(
                'inflationRate'
              )}%</td></tr>
              <tr><td><strong>Desired Income:</strong></td><td>$${getValue(
                'desiredIncome'
              )}</td></tr>
              <tr><td><strong>Whole Life Insurance Value:</strong></td><td>$${getValue(
                'wholeLifeInsurance'
              )}</td></tr>
              <tr><td><strong>Monthly Contributions to Whole Life Insurance:</strong></td><td>$${getValue(
                'lifeInsuranceMonthlyContributions'
              )}</td></tr>
              <tr><td><strong>Current Stock Value:</strong></td><td>$${getValue(
                'currentStockValue'
              )}</td></tr>
              <tr><td><strong>Current Real Estate Equity:</strong></td><td>$${getValue(
                'currentRealEstateEquity'
              )}</td></tr>
              <tr><td><strong>Current Mortgage Balance:</strong></td><td>$${getValue(
                'mortgageBalance'
              )}</td></tr>
              <tr><td><strong>Mortgage Term (Years):</strong></td><td>$${getValue(
                'mortgageTerm'
              )}</td></tr>
              <tr><td><strong>Mortgage Interest Rate (%):</strong></td><td>$${getValue(
                'mortgageInterestRate'
              )}</td></tr>
            </table>
          `;
                combinedDiv.appendChild(resultsDiv);
                document.body.appendChild(combinedDiv); // Append to document for rendering

                // Capture content as multiple images
                html2canvas(combinedDiv, {
                  scale: 2,
                  useCORS: true,
                })
                  .then((canvas) => {
                    const imgWidth = 190;
                    const pageHeight = doc.internal.pageSize.height;
                    let imgHeight = (canvas.height * imgWidth) / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 10;
                    const imgData = canvas.toDataURL('image/png');

                    // Add first page
                    doc.addImage(
                      imgData,
                      'PNG',
                      10,
                      position,
                      imgWidth,
                      imgHeight
                    );
                    heightLeft -= pageHeight - 20;

                    // Add additional pages if content overflows
                    while (heightLeft > 0) {
                      position = heightLeft - imgHeight;
                      doc.addPage();
                      doc.addImage(
                        imgData,
                        'PNG',
                        10,
                        position,
                        imgWidth,
                        imgHeight
                      );
                      heightLeft -= pageHeight - 20;
                    }
                    doc.save('retirement_planning_calculator.pdf');
                    combinedDiv.remove(); // Clean up temporary div
                  })
                  .catch((error) => {
                    console.error('Error capturing HTML content:', error);
                  });
              } else {
                console.error('jsPDF or html2canvas not loaded correctly.');
              }
            });
        }

        /***/
      },

    /***/ './node_modules/@kurkle/color/dist/color.esm.js':
      /*!******************************************************!*\
  !*** ./node_modules/@kurkle/color/dist/color.esm.js ***!
  \******************************************************/
      /***/ (
        __unused_webpack___webpack_module__,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ Color: () => /* binding */ Color,
          /* harmony export */ b2n: () => /* binding */ b2n,
          /* harmony export */ b2p: () => /* binding */ b2p,
          /* harmony export */ default: () => /* binding */ index_esm,
          /* harmony export */ hexParse: () => /* binding */ hexParse,
          /* harmony export */ hexString: () => /* binding */ hexString,
          /* harmony export */ hsl2rgb: () => /* binding */ hsl2rgb,
          /* harmony export */ hslString: () => /* binding */ hslString,
          /* harmony export */ hsv2rgb: () => /* binding */ hsv2rgb,
          /* harmony export */ hueParse: () => /* binding */ hueParse,
          /* harmony export */ hwb2rgb: () => /* binding */ hwb2rgb,
          /* harmony export */ lim: () => /* binding */ lim,
          /* harmony export */ n2b: () => /* binding */ n2b,
          /* harmony export */ n2p: () => /* binding */ n2p,
          /* harmony export */ nameParse: () => /* binding */ nameParse,
          /* harmony export */ p2b: () => /* binding */ p2b,
          /* harmony export */ rgb2hsl: () => /* binding */ rgb2hsl,
          /* harmony export */ rgbParse: () => /* binding */ rgbParse,
          /* harmony export */ rgbString: () => /* binding */ rgbString,
          /* harmony export */ rotate: () => /* binding */ rotate,
          /* harmony export */ round: () => /* binding */ round,
          /* harmony export */
        });
        /*!
         * @kurkle/color v0.3.4
         * https://github.com/kurkle/color#readme
         * (c) 2024 Jukka Kurkela
         * Released under the MIT License
         */
        function round(v) {
          return (v + 0.5) | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
          return lim(round(v * 2.55), 0, 255);
        }
        function b2p(v) {
          return lim(round(v / 2.55), 0, 100);
        }
        function n2b(v) {
          return lim(round(v * 255), 0, 255);
        }
        function b2n(v) {
          return lim(round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
          return lim(round(v * 100), 0, 100);
        }

        const map$1 = {
          0: 0,
          1: 1,
          2: 2,
          3: 3,
          4: 4,
          5: 5,
          6: 6,
          7: 7,
          8: 8,
          9: 9,
          A: 10,
          B: 11,
          C: 12,
          D: 13,
          E: 14,
          F: 15,
          a: 10,
          b: 11,
          c: 12,
          d: 13,
          e: 14,
          f: 15,
        };
        const hex = [...'0123456789ABCDEF'];
        const h1 = (b) => hex[b & 0xf];
        const h2 = (b) => hex[(b & 0xf0) >> 4] + hex[b & 0xf];
        const eq = (b) => (b & 0xf0) >> 4 === (b & 0xf);
        const isShort = (v) => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
          var len = str.length;
          var ret;
          if (str[0] === '#') {
            if (len === 4 || len === 5) {
              ret = {
                r: 255 & (map$1[str[1]] * 17),
                g: 255 & (map$1[str[2]] * 17),
                b: 255 & (map$1[str[3]] * 17),
                a: len === 5 ? map$1[str[4]] * 17 : 255,
              };
            } else if (len === 7 || len === 9) {
              ret = {
                r: (map$1[str[1]] << 4) | map$1[str[2]],
                g: (map$1[str[3]] << 4) | map$1[str[4]],
                b: (map$1[str[5]] << 4) | map$1[str[6]],
                a: len === 9 ? (map$1[str[7]] << 4) | map$1[str[8]] : 255,
              };
            }
          }
          return ret;
        }
        const alpha = (a, f) => (a < 255 ? f(a) : '');
        function hexString(v) {
          var f = isShort(v) ? h1 : h2;
          return v ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : undefined;
        }

        const HUE_RE =
          /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
          const a = s * Math.min(l, 1 - l);
          const f = (n, k = (n + h / 30) % 12) =>
            l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
          return [f(0), f(8), f(4)];
        }
        function hsv2rgbn(h, s, v) {
          const f = (n, k = (n + h / 60) % 6) =>
            v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
          return [f(5), f(3), f(1)];
        }
        function hwb2rgbn(h, w, b) {
          const rgb = hsl2rgbn(h, 1, 0.5);
          let i;
          if (w + b > 1) {
            i = 1 / (w + b);
            w *= i;
            b *= i;
          }
          for (i = 0; i < 3; i++) {
            rgb[i] *= 1 - w - b;
            rgb[i] += w;
          }
          return rgb;
        }
        function hueValue(r, g, b, d, max) {
          if (r === max) {
            return (g - b) / d + (g < b ? 6 : 0);
          }
          if (g === max) {
            return (b - r) / d + 2;
          }
          return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
          const range = 255;
          const r = v.r / range;
          const g = v.g / range;
          const b = v.b / range;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          let h, s, d;
          if (max !== min) {
            d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            h = hueValue(r, g, b, d, max);
            h = h * 60 + 0.5;
          }
          return [h | 0, s || 0, l];
        }
        function calln(f, a, b, c) {
          return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
          return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
          return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
          return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
          return ((h % 360) + 360) % 360;
        }
        function hueParse(str) {
          const m = HUE_RE.exec(str);
          let a = 255;
          let v;
          if (!m) {
            return;
          }
          if (m[5] !== v) {
            a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
          }
          const h = hue(+m[2]);
          const p1 = +m[3] / 100;
          const p2 = +m[4] / 100;
          if (m[1] === 'hwb') {
            v = hwb2rgb(h, p1, p2);
          } else if (m[1] === 'hsv') {
            v = hsv2rgb(h, p1, p2);
          } else {
            v = hsl2rgb(h, p1, p2);
          }
          return {
            r: v[0],
            g: v[1],
            b: v[2],
            a: a,
          };
        }
        function rotate(v, deg) {
          var h = rgb2hsl(v);
          h[0] = hue(h[0] + deg);
          h = hsl2rgb(h);
          v.r = h[0];
          v.g = h[1];
          v.b = h[2];
        }
        function hslString(v) {
          if (!v) {
            return;
          }
          const a = rgb2hsl(v);
          const h = a[0];
          const s = n2p(a[1]);
          const l = n2p(a[2]);
          return v.a < 255
            ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`
            : `hsl(${h}, ${s}%, ${l}%)`;
        }

        const map = {
          x: 'dark',
          Z: 'light',
          Y: 're',
          X: 'blu',
          W: 'gr',
          V: 'medium',
          U: 'slate',
          A: 'ee',
          T: 'ol',
          S: 'or',
          B: 'ra',
          C: 'lateg',
          D: 'ights',
          R: 'in',
          Q: 'turquois',
          E: 'hi',
          P: 'ro',
          O: 'al',
          N: 'le',
          M: 'de',
          L: 'yello',
          F: 'en',
          K: 'ch',
          G: 'arks',
          H: 'ea',
          I: 'ightg',
          J: 'wh',
        };
        const names$1 = {
          OiceXe: 'f0f8ff',
          antiquewEte: 'faebd7',
          aqua: 'ffff',
          aquamarRe: '7fffd4',
          azuY: 'f0ffff',
          beige: 'f5f5dc',
          bisque: 'ffe4c4',
          black: '0',
          blanKedOmond: 'ffebcd',
          Xe: 'ff',
          XeviTet: '8a2be2',
          bPwn: 'a52a2a',
          burlywood: 'deb887',
          caMtXe: '5f9ea0',
          KartYuse: '7fff00',
          KocTate: 'd2691e',
          cSO: 'ff7f50',
          cSnflowerXe: '6495ed',
          cSnsilk: 'fff8dc',
          crimson: 'dc143c',
          cyan: 'ffff',
          xXe: '8b',
          xcyan: '8b8b',
          xgTMnPd: 'b8860b',
          xWay: 'a9a9a9',
          xgYF: '6400',
          xgYy: 'a9a9a9',
          xkhaki: 'bdb76b',
          xmagFta: '8b008b',
          xTivegYF: '556b2f',
          xSange: 'ff8c00',
          xScEd: '9932cc',
          xYd: '8b0000',
          xsOmon: 'e9967a',
          xsHgYF: '8fbc8f',
          xUXe: '483d8b',
          xUWay: '2f4f4f',
          xUgYy: '2f4f4f',
          xQe: 'ced1',
          xviTet: '9400d3',
          dAppRk: 'ff1493',
          dApskyXe: 'bfff',
          dimWay: '696969',
          dimgYy: '696969',
          dodgerXe: '1e90ff',
          fiYbrick: 'b22222',
          flSOwEte: 'fffaf0',
          foYstWAn: '228b22',
          fuKsia: 'ff00ff',
          gaRsbSo: 'dcdcdc',
          ghostwEte: 'f8f8ff',
          gTd: 'ffd700',
          gTMnPd: 'daa520',
          Way: '808080',
          gYF: '8000',
          gYFLw: 'adff2f',
          gYy: '808080',
          honeyMw: 'f0fff0',
          hotpRk: 'ff69b4',
          RdianYd: 'cd5c5c',
          Rdigo: '4b0082',
          ivSy: 'fffff0',
          khaki: 'f0e68c',
          lavFMr: 'e6e6fa',
          lavFMrXsh: 'fff0f5',
          lawngYF: '7cfc00',
          NmoncEffon: 'fffacd',
          ZXe: 'add8e6',
          ZcSO: 'f08080',
          Zcyan: 'e0ffff',
          ZgTMnPdLw: 'fafad2',
          ZWay: 'd3d3d3',
          ZgYF: '90ee90',
          ZgYy: 'd3d3d3',
          ZpRk: 'ffb6c1',
          ZsOmon: 'ffa07a',
          ZsHgYF: '20b2aa',
          ZskyXe: '87cefa',
          ZUWay: '778899',
          ZUgYy: '778899',
          ZstAlXe: 'b0c4de',
          ZLw: 'ffffe0',
          lime: 'ff00',
          limegYF: '32cd32',
          lRF: 'faf0e6',
          magFta: 'ff00ff',
          maPon: '800000',
          VaquamarRe: '66cdaa',
          VXe: 'cd',
          VScEd: 'ba55d3',
          VpurpN: '9370db',
          VsHgYF: '3cb371',
          VUXe: '7b68ee',
          VsprRggYF: 'fa9a',
          VQe: '48d1cc',
          VviTetYd: 'c71585',
          midnightXe: '191970',
          mRtcYam: 'f5fffa',
          mistyPse: 'ffe4e1',
          moccasR: 'ffe4b5',
          navajowEte: 'ffdead',
          navy: '80',
          Tdlace: 'fdf5e6',
          Tive: '808000',
          TivedBb: '6b8e23',
          Sange: 'ffa500',
          SangeYd: 'ff4500',
          ScEd: 'da70d6',
          pOegTMnPd: 'eee8aa',
          pOegYF: '98fb98',
          pOeQe: 'afeeee',
          pOeviTetYd: 'db7093',
          papayawEp: 'ffefd5',
          pHKpuff: 'ffdab9',
          peru: 'cd853f',
          pRk: 'ffc0cb',
          plum: 'dda0dd',
          powMrXe: 'b0e0e6',
          purpN: '800080',
          YbeccapurpN: '663399',
          Yd: 'ff0000',
          Psybrown: 'bc8f8f',
          PyOXe: '4169e1',
          saddNbPwn: '8b4513',
          sOmon: 'fa8072',
          sandybPwn: 'f4a460',
          sHgYF: '2e8b57',
          sHshell: 'fff5ee',
          siFna: 'a0522d',
          silver: 'c0c0c0',
          skyXe: '87ceeb',
          UXe: '6a5acd',
          UWay: '708090',
          UgYy: '708090',
          snow: 'fffafa',
          sprRggYF: 'ff7f',
          stAlXe: '4682b4',
          tan: 'd2b48c',
          teO: '8080',
          tEstN: 'd8bfd8',
          tomato: 'ff6347',
          Qe: '40e0d0',
          viTet: 'ee82ee',
          JHt: 'f5deb3',
          wEte: 'ffffff',
          wEtesmoke: 'f5f5f5',
          Lw: 'ffff00',
          LwgYF: '9acd32',
        };
        function unpack() {
          const unpacked = {};
          const keys = Object.keys(names$1);
          const tkeys = Object.keys(map);
          let i, j, k, ok, nk;
          for (i = 0; i < keys.length; i++) {
            ok = nk = keys[i];
            for (j = 0; j < tkeys.length; j++) {
              k = tkeys[j];
              nk = nk.replace(k, map[k]);
            }
            k = parseInt(names$1[ok], 16);
            unpacked[nk] = [(k >> 16) & 0xff, (k >> 8) & 0xff, k & 0xff];
          }
          return unpacked;
        }

        let names;
        function nameParse(str) {
          if (!names) {
            names = unpack();
            names.transparent = [0, 0, 0, 0];
          }
          const a = names[str.toLowerCase()];
          return (
            a && {
              r: a[0],
              g: a[1],
              b: a[2],
              a: a.length === 4 ? a[3] : 255,
            }
          );
        }

        const RGB_RE =
          /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
          const m = RGB_RE.exec(str);
          let a = 255;
          let r, g, b;
          if (!m) {
            return;
          }
          if (m[7] !== r) {
            const v = +m[7];
            a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
          }
          r = +m[1];
          g = +m[3];
          b = +m[5];
          r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
          g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
          b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
          return {
            r: r,
            g: g,
            b: b,
            a: a,
          };
        }
        function rgbString(v) {
          return (
            v &&
            (v.a < 255
              ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`
              : `rgb(${v.r}, ${v.g}, ${v.b})`)
          );
        }

        const to = (v) =>
          v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;
        const from = (v) =>
          v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
        function interpolate(rgb1, rgb2, t) {
          const r = from(b2n(rgb1.r));
          const g = from(b2n(rgb1.g));
          const b = from(b2n(rgb1.b));
          return {
            r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
            g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
            b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
            a: rgb1.a + t * (rgb2.a - rgb1.a),
          };
        }

        function modHSL(v, i, ratio) {
          if (v) {
            let tmp = rgb2hsl(v);
            tmp[i] = Math.max(
              0,
              Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1)
            );
            tmp = hsl2rgb(tmp);
            v.r = tmp[0];
            v.g = tmp[1];
            v.b = tmp[2];
          }
        }
        function clone(v, proto) {
          return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
          var v = { r: 0, g: 0, b: 0, a: 255 };
          if (Array.isArray(input)) {
            if (input.length >= 3) {
              v = { r: input[0], g: input[1], b: input[2], a: 255 };
              if (input.length > 3) {
                v.a = n2b(input[3]);
              }
            }
          } else {
            v = clone(input, { r: 0, g: 0, b: 0, a: 1 });
            v.a = n2b(v.a);
          }
          return v;
        }
        function functionParse(str) {
          if (str.charAt(0) === 'r') {
            return rgbParse(str);
          }
          return hueParse(str);
        }
        class Color {
          constructor(input) {
            if (input instanceof Color) {
              return input;
            }
            const type = typeof input;
            let v;
            if (type === 'object') {
              v = fromObject(input);
            } else if (type === 'string') {
              v = hexParse(input) || nameParse(input) || functionParse(input);
            }
            this._rgb = v;
            this._valid = !!v;
          }
          get valid() {
            return this._valid;
          }
          get rgb() {
            var v = clone(this._rgb);
            if (v) {
              v.a = b2n(v.a);
            }
            return v;
          }
          set rgb(obj) {
            this._rgb = fromObject(obj);
          }
          rgbString() {
            return this._valid ? rgbString(this._rgb) : undefined;
          }
          hexString() {
            return this._valid ? hexString(this._rgb) : undefined;
          }
          hslString() {
            return this._valid ? hslString(this._rgb) : undefined;
          }
          mix(color, weight) {
            if (color) {
              const c1 = this.rgb;
              const c2 = color.rgb;
              let w2;
              const p = weight === w2 ? 0.5 : weight;
              const w = 2 * p - 1;
              const a = c1.a - c2.a;
              const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
              w2 = 1 - w1;
              c1.r = 0xff & (w1 * c1.r + w2 * c2.r + 0.5);
              c1.g = 0xff & (w1 * c1.g + w2 * c2.g + 0.5);
              c1.b = 0xff & (w1 * c1.b + w2 * c2.b + 0.5);
              c1.a = p * c1.a + (1 - p) * c2.a;
              this.rgb = c1;
            }
            return this;
          }
          interpolate(color, t) {
            if (color) {
              this._rgb = interpolate(this._rgb, color._rgb, t);
            }
            return this;
          }
          clone() {
            return new Color(this.rgb);
          }
          alpha(a) {
            this._rgb.a = n2b(a);
            return this;
          }
          clearer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 - ratio;
            return this;
          }
          greyscale() {
            const rgb = this._rgb;
            const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);
            rgb.r = rgb.g = rgb.b = val;
            return this;
          }
          opaquer(ratio) {
            const rgb = this._rgb;
            rgb.a *= 1 + ratio;
            return this;
          }
          negate() {
            const v = this._rgb;
            v.r = 255 - v.r;
            v.g = 255 - v.g;
            v.b = 255 - v.b;
            return this;
          }
          lighten(ratio) {
            modHSL(this._rgb, 2, ratio);
            return this;
          }
          darken(ratio) {
            modHSL(this._rgb, 2, -ratio);
            return this;
          }
          saturate(ratio) {
            modHSL(this._rgb, 1, ratio);
            return this;
          }
          desaturate(ratio) {
            modHSL(this._rgb, 1, -ratio);
            return this;
          }
          rotate(deg) {
            rotate(this._rgb, deg);
            return this;
          }
        }

        function index_esm(input) {
          return new Color(input);
        }

        /***/
      },

    /***/ './node_modules/chart.js/dist/chart.js':
      /*!*********************************************!*\
  !*** ./node_modules/chart.js/dist/chart.js ***!
  \*********************************************/
      /***/ (
        __unused_webpack___webpack_module__,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ Animation: () => /* binding */ Animation,
          /* harmony export */ Animations: () => /* binding */ Animations,
          /* harmony export */ ArcElement: () => /* binding */ ArcElement,
          /* harmony export */ BarController: () => /* binding */ BarController,
          /* harmony export */ BarElement: () => /* binding */ BarElement,
          /* harmony export */ BasePlatform: () => /* binding */ BasePlatform,
          /* harmony export */ BasicPlatform: () => /* binding */ BasicPlatform,
          /* harmony export */ BubbleController: () =>
            /* binding */ BubbleController,
          /* harmony export */ CategoryScale: () => /* binding */ CategoryScale,
          /* harmony export */ Chart: () => /* binding */ Chart,
          /* harmony export */ Colors: () => /* binding */ plugin_colors,
          /* harmony export */ DatasetController: () =>
            /* binding */ DatasetController,
          /* harmony export */ Decimation: () =>
            /* binding */ plugin_decimation,
          /* harmony export */ DomPlatform: () => /* binding */ DomPlatform,
          /* harmony export */ DoughnutController: () =>
            /* binding */ DoughnutController,
          /* harmony export */ Element: () => /* binding */ Element,
          /* harmony export */ Filler: () => /* binding */ index,
          /* harmony export */ Interaction: () => /* binding */ Interaction,
          /* harmony export */ Legend: () => /* binding */ plugin_legend,
          /* harmony export */ LineController: () =>
            /* binding */ LineController,
          /* harmony export */ LineElement: () => /* binding */ LineElement,
          /* harmony export */ LinearScale: () => /* binding */ LinearScale,
          /* harmony export */ LogarithmicScale: () =>
            /* binding */ LogarithmicScale,
          /* harmony export */ PieController: () => /* binding */ PieController,
          /* harmony export */ PointElement: () => /* binding */ PointElement,
          /* harmony export */ PolarAreaController: () =>
            /* binding */ PolarAreaController,
          /* harmony export */ RadarController: () =>
            /* binding */ RadarController,
          /* harmony export */ RadialLinearScale: () =>
            /* binding */ RadialLinearScale,
          /* harmony export */ Scale: () => /* binding */ Scale,
          /* harmony export */ ScatterController: () =>
            /* binding */ ScatterController,
          /* harmony export */ SubTitle: () => /* binding */ plugin_subtitle,
          /* harmony export */ Ticks: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM,
          /* harmony export */ TimeScale: () => /* binding */ TimeScale,
          /* harmony export */ TimeSeriesScale: () =>
            /* binding */ TimeSeriesScale,
          /* harmony export */ Title: () => /* binding */ plugin_title,
          /* harmony export */ Tooltip: () => /* binding */ plugin_tooltip,
          /* harmony export */ _adapters: () => /* binding */ adapters,
          /* harmony export */ _detectPlatform: () =>
            /* binding */ _detectPlatform,
          /* harmony export */ animator: () => /* binding */ animator,
          /* harmony export */ controllers: () => /* binding */ controllers,
          /* harmony export */ defaults: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,
          /* harmony export */ elements: () => /* binding */ elements,
          /* harmony export */ layouts: () => /* binding */ layouts,
          /* harmony export */ plugins: () => /* binding */ plugins,
          /* harmony export */ registerables: () => /* binding */ registerables,
          /* harmony export */ registry: () => /* binding */ registry,
          /* harmony export */ scales: () => /* binding */ scales,
          /* harmony export */
        });
        /* harmony import */ var _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./chunks/helpers.dataset.js */ './node_modules/chart.js/dist/chunks/helpers.dataset.js'
          );
        /*!
         * Chart.js v4.4.9
         * https://www.chartjs.org
         * (c) 2025 Chart.js Contributors
         * Released under the MIT License
         */

        class Animator {
          constructor() {
            this._request = null;
            this._charts = new Map();
            this._running = false;
            this._lastDate = undefined;
          }
          _notify(chart, anims, date, type) {
            const callbacks = anims.listeners[type];
            const numSteps = anims.duration;
            callbacks.forEach((fn) =>
              fn({
                chart,
                initial: anims.initial,
                numSteps,
                currentStep: Math.min(date - anims.start, numSteps),
              })
            );
          }
          _refresh() {
            if (this._request) {
              return;
            }
            this._running = true;
            this._request =
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.r.call(
                window,
                () => {
                  this._update();
                  this._request = null;
                  if (this._running) {
                    this._refresh();
                  }
                }
              );
          }
          _update(date = Date.now()) {
            let remaining = 0;
            this._charts.forEach((anims, chart) => {
              if (!anims.running || !anims.items.length) {
                return;
              }
              const items = anims.items;
              let i = items.length - 1;
              let draw = false;
              let item;
              for (; i >= 0; --i) {
                item = items[i];
                if (item._active) {
                  if (item._total > anims.duration) {
                    anims.duration = item._total;
                  }
                  item.tick(date);
                  draw = true;
                } else {
                  items[i] = items[items.length - 1];
                  items.pop();
                }
              }
              if (draw) {
                chart.draw();
                this._notify(chart, anims, date, 'progress');
              }
              if (!items.length) {
                anims.running = false;
                this._notify(chart, anims, date, 'complete');
                anims.initial = false;
              }
              remaining += items.length;
            });
            this._lastDate = date;
            if (remaining === 0) {
              this._running = false;
            }
          }
          _getAnims(chart) {
            const charts = this._charts;
            let anims = charts.get(chart);
            if (!anims) {
              anims = {
                running: false,
                initial: true,
                items: [],
                listeners: {
                  complete: [],
                  progress: [],
                },
              };
              charts.set(chart, anims);
            }
            return anims;
          }
          listen(chart, event, cb) {
            this._getAnims(chart).listeners[event].push(cb);
          }
          add(chart, items) {
            if (!items || !items.length) {
              return;
            }
            this._getAnims(chart).items.push(...items);
          }
          has(chart) {
            return this._getAnims(chart).items.length > 0;
          }
          start(chart) {
            const anims = this._charts.get(chart);
            if (!anims) {
              return;
            }
            anims.running = true;
            anims.start = Date.now();
            anims.duration = anims.items.reduce(
              (acc, cur) => Math.max(acc, cur._duration),
              0
            );
            this._refresh();
          }
          running(chart) {
            if (!this._running) {
              return false;
            }
            const anims = this._charts.get(chart);
            if (!anims || !anims.running || !anims.items.length) {
              return false;
            }
            return true;
          }
          stop(chart) {
            const anims = this._charts.get(chart);
            if (!anims || !anims.items.length) {
              return;
            }
            const items = anims.items;
            let i = items.length - 1;
            for (; i >= 0; --i) {
              items[i].cancel();
            }
            anims.items = [];
            this._notify(chart, anims, Date.now(), 'complete');
          }
          remove(chart) {
            return this._charts.delete(chart);
          }
        }
        var animator = /* #__PURE__ */ new Animator();

        const transparent = 'transparent';
        const interpolators = {
          boolean(from, to, factor) {
            return factor > 0.5 ? to : from;
          },
          color(from, to, factor) {
            const c0 = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(
              from || transparent
            );
            const c1 =
              c0.valid &&
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c)(
                to || transparent
              );
            return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
          },
          number(from, to, factor) {
            return from + (to - from) * factor;
          },
        };
        class Animation {
          constructor(cfg, target, prop, to) {
            const currentValue = target[prop];
            to = (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)(
              [cfg.to, to, currentValue, cfg.from]
            );
            const from = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
              cfg.from,
              currentValue,
              to,
            ]);
            this._active = true;
            this._fn = cfg.fn || interpolators[cfg.type || typeof from];
            this._easing =
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e[
                cfg.easing
              ] ||
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e.linear;
            this._start = Math.floor(Date.now() + (cfg.delay || 0));
            this._duration = this._total = Math.floor(cfg.duration);
            this._loop = !!cfg.loop;
            this._target = target;
            this._prop = prop;
            this._from = from;
            this._to = to;
            this._promises = undefined;
          }
          active() {
            return this._active;
          }
          update(cfg, to, date) {
            if (this._active) {
              this._notify(false);
              const currentValue = this._target[this._prop];
              const elapsed = date - this._start;
              const remain = this._duration - elapsed;
              this._start = date;
              this._duration = Math.floor(Math.max(remain, cfg.duration));
              this._total += elapsed;
              this._loop = !!cfg.loop;
              this._to = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
                cfg.to,
                to,
                currentValue,
                cfg.from,
              ]);
              this._from = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
                cfg.from,
                currentValue,
                to,
              ]);
            }
          }
          cancel() {
            if (this._active) {
              this.tick(Date.now());
              this._active = false;
              this._notify(false);
            }
          }
          tick(date) {
            const elapsed = date - this._start;
            const duration = this._duration;
            const prop = this._prop;
            const from = this._from;
            const loop = this._loop;
            const to = this._to;
            let factor;
            this._active = from !== to && (loop || elapsed < duration);
            if (!this._active) {
              this._target[prop] = to;
              this._notify(true);
              return;
            }
            if (elapsed < 0) {
              this._target[prop] = from;
              return;
            }
            factor = (elapsed / duration) % 2;
            factor = loop && factor > 1 ? 2 - factor : factor;
            factor = this._easing(Math.min(1, Math.max(0, factor)));
            this._target[prop] = this._fn(from, to, factor);
          }
          wait() {
            const promises = this._promises || (this._promises = []);
            return new Promise((res, rej) => {
              promises.push({
                res,
                rej,
              });
            });
          }
          _notify(resolved) {
            const method = resolved ? 'res' : 'rej';
            const promises = this._promises || [];
            for (let i = 0; i < promises.length; i++) {
              promises[i][method]();
            }
          }
        }

        class Animations {
          constructor(chart, config) {
            this._chart = chart;
            this._properties = new Map();
            this.configure(config);
          }
          configure(config) {
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                config
              )
            ) {
              return;
            }
            const animationOptions = Object.keys(
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
                .animation
            );
            const animatedProps = this._properties;
            Object.getOwnPropertyNames(config).forEach((key) => {
              const cfg = config[key];
              if (
                !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  cfg
                )
              ) {
                return;
              }
              const resolved = {};
              for (const option of animationOptions) {
                resolved[option] = cfg[option];
              }
              (
                ((0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                  cfg.properties
                ) &&
                  cfg.properties) || [key]
              ).forEach((prop) => {
                if (prop === key || !animatedProps.has(prop)) {
                  animatedProps.set(prop, resolved);
                }
              });
            });
          }
          _animateOptions(target, values) {
            const newOptions = values.options;
            const options = resolveTargetOptions(target, newOptions);
            if (!options) {
              return [];
            }
            const animations = this._createAnimations(options, newOptions);
            if (newOptions.$shared) {
              awaitAll(target.options.$animations, newOptions).then(
                () => {
                  target.options = newOptions;
                },
                () => {}
              );
            }
            return animations;
          }
          _createAnimations(target, values) {
            const animatedProps = this._properties;
            const animations = [];
            const running = target.$animations || (target.$animations = {});
            const props = Object.keys(values);
            const date = Date.now();
            let i;
            for (i = props.length - 1; i >= 0; --i) {
              const prop = props[i];
              if (prop.charAt(0) === '$') {
                continue;
              }
              if (prop === 'options') {
                animations.push(...this._animateOptions(target, values));
                continue;
              }
              const value = values[prop];
              let animation = running[prop];
              const cfg = animatedProps.get(prop);
              if (animation) {
                if (cfg && animation.active()) {
                  animation.update(cfg, value, date);
                  continue;
                } else {
                  animation.cancel();
                }
              }
              if (!cfg || !cfg.duration) {
                target[prop] = value;
                continue;
              }
              running[prop] = animation = new Animation(
                cfg,
                target,
                prop,
                value
              );
              animations.push(animation);
            }
            return animations;
          }
          update(target, values) {
            if (this._properties.size === 0) {
              Object.assign(target, values);
              return;
            }
            const animations = this._createAnimations(target, values);
            if (animations.length) {
              animator.add(this._chart, animations);
              return true;
            }
          }
        }
        function awaitAll(animations, properties) {
          const running = [];
          const keys = Object.keys(properties);
          for (let i = 0; i < keys.length; i++) {
            const anim = animations[keys[i]];
            if (anim && anim.active()) {
              running.push(anim.wait());
            }
          }
          return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
          if (!newOptions) {
            return;
          }
          let options = target.options;
          if (!options) {
            target.options = newOptions;
            return;
          }
          if (options.$shared) {
            target.options = options = Object.assign({}, options, {
              $shared: false,
              $animations: {},
            });
          }
          return options;
        }

        function scaleClip(scale, allowedOverflow) {
          const opts = (scale && scale.options) || {};
          const reverse = opts.reverse;
          const min = opts.min === undefined ? allowedOverflow : 0;
          const max = opts.max === undefined ? allowedOverflow : 0;
          return {
            start: reverse ? max : min,
            end: reverse ? min : max,
          };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
          if (allowedOverflow === false) {
            return false;
          }
          const x = scaleClip(xScale, allowedOverflow);
          const y = scaleClip(yScale, allowedOverflow);
          return {
            top: y.end,
            right: x.end,
            bottom: y.start,
            left: x.start,
          };
        }
        function toClip(value) {
          let t, r, b, l;
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
              value
            )
          ) {
            t = value.top;
            r = value.right;
            b = value.bottom;
            l = value.left;
          } else {
            t = r = b = l = value;
          }
          return {
            top: t,
            right: r,
            bottom: b,
            left: l,
            disabled: value === false,
          };
        }
        function getSortedDatasetIndices(chart, filterVisible) {
          const keys = [];
          const metasets = chart._getSortedDatasetMetas(filterVisible);
          let i, ilen;
          for (i = 0, ilen = metasets.length; i < ilen; ++i) {
            keys.push(metasets[i].index);
          }
          return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
          const keys = stack.keys;
          const singleMode = options.mode === 'single';
          let i, ilen, datasetIndex, otherValue;
          if (value === null) {
            return;
          }
          let found = false;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            datasetIndex = +keys[i];
            if (datasetIndex === dsIndex) {
              found = true;
              if (options.all) {
                continue;
              }
              break;
            }
            otherValue = stack.values[datasetIndex];
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                otherValue
              ) &&
              (singleMode ||
                value === 0 ||
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(
                  value
                ) ===
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(
                    otherValue
                  ))
            ) {
              value += otherValue;
            }
          }
          if (!found && !options.all) {
            return 0;
          }
          return value;
        }
        function convertObjectDataToArray(data, meta) {
          const { iScale, vScale } = meta;
          const iAxisKey = iScale.axis === 'x' ? 'x' : 'y';
          const vAxisKey = vScale.axis === 'x' ? 'x' : 'y';
          const keys = Object.keys(data);
          const adata = new Array(keys.length);
          let i, ilen, key;
          for (i = 0, ilen = keys.length; i < ilen; ++i) {
            key = keys[i];
            adata[i] = {
              [iAxisKey]: key,
              [vAxisKey]: data[key],
            };
          }
          return adata;
        }
        function isStacked(scale, meta) {
          const stacked = scale && scale.options.stacked;
          return stacked || (stacked === undefined && meta.stack !== undefined);
        }
        function getStackKey(indexScale, valueScale, meta) {
          return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
          const { min, max, minDefined, maxDefined } = scale.getUserBounds();
          return {
            min: minDefined ? min : Number.NEGATIVE_INFINITY,
            max: maxDefined ? max : Number.POSITIVE_INFINITY,
          };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
          const subStack = stacks[stackKey] || (stacks[stackKey] = {});
          return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
          for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
            const value = stack[meta.index];
            if ((positive && value > 0) || (!positive && value < 0)) {
              return meta.index;
            }
          }
          return null;
        }
        function updateStacks(controller, parsed) {
          const { chart, _cachedMeta: meta } = controller;
          const stacks = chart._stacks || (chart._stacks = {});
          const { iScale, vScale, index: datasetIndex } = meta;
          const iAxis = iScale.axis;
          const vAxis = vScale.axis;
          const key = getStackKey(iScale, vScale, meta);
          const ilen = parsed.length;
          let stack;
          for (let i = 0; i < ilen; ++i) {
            const item = parsed[i];
            const { [iAxis]: index, [vAxis]: value } = item;
            const itemStacks = item._stacks || (item._stacks = {});
            stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
            stack[datasetIndex] = value;
            stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
            stack._bottom = getLastIndexInStack(
              stack,
              vScale,
              false,
              meta.type
            );
            const visualValues =
              stack._visualValues || (stack._visualValues = {});
            visualValues[datasetIndex] = value;
          }
        }
        function getFirstScaleId(chart, axis) {
          const scales = chart.scales;
          return Object.keys(scales)
            .filter((key) => scales[key].axis === axis)
            .shift();
        }
        function createDatasetContext(parent, index) {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(
            parent,
            {
              active: false,
              dataset: undefined,
              datasetIndex: index,
              index,
              mode: 'default',
              type: 'dataset',
            }
          );
        }
        function createDataContext(parent, index, element) {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(
            parent,
            {
              active: false,
              dataIndex: index,
              parsed: undefined,
              raw: undefined,
              element,
              index,
              mode: 'default',
              type: 'data',
            }
          );
        }
        function clearStacks(meta, items) {
          const datasetIndex = meta.controller.index;
          const axis = meta.vScale && meta.vScale.axis;
          if (!axis) {
            return;
          }
          items = items || meta._parsed;
          for (const parsed of items) {
            const stacks = parsed._stacks;
            if (
              !stacks ||
              stacks[axis] === undefined ||
              stacks[axis][datasetIndex] === undefined
            ) {
              return;
            }
            delete stacks[axis][datasetIndex];
            if (
              stacks[axis]._visualValues !== undefined &&
              stacks[axis]._visualValues[datasetIndex] !== undefined
            ) {
              delete stacks[axis]._visualValues[datasetIndex];
            }
          }
        }
        const isDirectUpdateMode = (mode) =>
          mode === 'reset' || mode === 'none';
        const cloneIfNotShared = (cached, shared) =>
          shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart) =>
          canStack &&
          !meta.hidden &&
          meta._stacked && {
            keys: getSortedDatasetIndices(chart, true),
            values: null,
          };
        class DatasetController {
          static defaults = {};
          static datasetElementType = null;
          static dataElementType = null;
          constructor(chart, datasetIndex) {
            this.chart = chart;
            this._ctx = chart.ctx;
            this.index = datasetIndex;
            this._cachedDataOpts = {};
            this._cachedMeta = this.getMeta();
            this._type = this._cachedMeta.type;
            this.options = undefined;
            this._parsing = false;
            this._data = undefined;
            this._objectData = undefined;
            this._sharedOptions = undefined;
            this._drawStart = undefined;
            this._drawCount = undefined;
            this.enableOptionSharing = false;
            this.supportsDecimation = false;
            this.$context = undefined;
            this._syncList = [];
            this.datasetElementType = new.target.datasetElementType;
            this.dataElementType = new.target.dataElementType;
            this.initialize();
          }
          initialize() {
            const meta = this._cachedMeta;
            this.configure();
            this.linkScales();
            meta._stacked = isStacked(meta.vScale, meta);
            this.addElements();
            if (this.options.fill && !this.chart.isPluginEnabled('filler')) {
              console.warn(
                "Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options"
              );
            }
          }
          updateIndex(datasetIndex) {
            if (this.index !== datasetIndex) {
              clearStacks(this._cachedMeta);
            }
            this.index = datasetIndex;
          }
          linkScales() {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            const chooseId = (axis, x, y, r) =>
              axis === 'x' ? x : axis === 'r' ? r : y;
            const xid = (meta.xAxisID = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              dataset.xAxisID,
              getFirstScaleId(chart, 'x')
            ));
            const yid = (meta.yAxisID = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              dataset.yAxisID,
              getFirstScaleId(chart, 'y')
            ));
            const rid = (meta.rAxisID = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              dataset.rAxisID,
              getFirstScaleId(chart, 'r')
            ));
            const indexAxis = meta.indexAxis;
            const iid = (meta.iAxisID = chooseId(indexAxis, xid, yid, rid));
            const vid = (meta.vAxisID = chooseId(indexAxis, yid, xid, rid));
            meta.xScale = this.getScaleForId(xid);
            meta.yScale = this.getScaleForId(yid);
            meta.rScale = this.getScaleForId(rid);
            meta.iScale = this.getScaleForId(iid);
            meta.vScale = this.getScaleForId(vid);
          }
          getDataset() {
            return this.chart.data.datasets[this.index];
          }
          getMeta() {
            return this.chart.getDatasetMeta(this.index);
          }
          getScaleForId(scaleID) {
            return this.chart.scales[scaleID];
          }
          _getOtherScale(scale) {
            const meta = this._cachedMeta;
            return scale === meta.iScale ? meta.vScale : meta.iScale;
          }
          reset() {
            this._update('reset');
          }
          _destroy() {
            const meta = this._cachedMeta;
            if (this._data) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(
                this._data,
                this
              );
            }
            if (meta._stacked) {
              clearStacks(meta);
            }
          }
          _dataCheck() {
            const dataset = this.getDataset();
            const data = dataset.data || (dataset.data = []);
            const _data = this._data;
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                data
              )
            ) {
              const meta = this._cachedMeta;
              this._data = convertObjectDataToArray(data, meta);
            } else if (_data !== data) {
              if (_data) {
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u)(
                  _data,
                  this
                );
                const meta = this._cachedMeta;
                clearStacks(meta);
                meta._parsed = [];
              }
              if (data && Object.isExtensible(data)) {
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.l)(
                  data,
                  this
                );
              }
              this._syncList = [];
              this._data = data;
            }
          }
          addElements() {
            const meta = this._cachedMeta;
            this._dataCheck();
            if (this.datasetElementType) {
              meta.dataset = new this.datasetElementType();
            }
          }
          buildOrUpdateElements(resetNewElements) {
            const meta = this._cachedMeta;
            const dataset = this.getDataset();
            let stackChanged = false;
            this._dataCheck();
            const oldStacked = meta._stacked;
            meta._stacked = isStacked(meta.vScale, meta);
            if (meta.stack !== dataset.stack) {
              stackChanged = true;
              clearStacks(meta);
              meta.stack = dataset.stack;
            }
            this._resyncElements(resetNewElements);
            if (stackChanged || oldStacked !== meta._stacked) {
              updateStacks(this, meta._parsed);
              meta._stacked = isStacked(meta.vScale, meta);
            }
          }
          configure() {
            const config = this.chart.config;
            const scopeKeys = config.datasetScopeKeys(this._type);
            const scopes = config.getOptionScopes(
              this.getDataset(),
              scopeKeys,
              true
            );
            this.options = config.createResolver(scopes, this.getContext());
            this._parsing = this.options.parsing;
            this._cachedDataOpts = {};
          }
          parse(start, count) {
            const { _cachedMeta: meta, _data: data } = this;
            const { iScale, _stacked } = meta;
            const iAxis = iScale.axis;
            let sorted =
              start === 0 && count === data.length ? true : meta._sorted;
            let prev = start > 0 && meta._parsed[start - 1];
            let i, cur, parsed;
            if (this._parsing === false) {
              meta._parsed = data;
              meta._sorted = true;
              parsed = data;
            } else {
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                  data[start]
                )
              ) {
                parsed = this.parseArrayData(meta, data, start, count);
              } else if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  data[start]
                )
              ) {
                parsed = this.parseObjectData(meta, data, start, count);
              } else {
                parsed = this.parsePrimitiveData(meta, data, start, count);
              }
              const isNotInOrderComparedToPrev = () =>
                cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);
              for (i = 0; i < count; ++i) {
                meta._parsed[i + start] = cur = parsed[i];
                if (sorted) {
                  if (isNotInOrderComparedToPrev()) {
                    sorted = false;
                  }
                  prev = cur;
                }
              }
              meta._sorted = sorted;
            }
            if (_stacked) {
              updateStacks(this, parsed);
            }
          }
          parsePrimitiveData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = new Array(count);
            let i, ilen, index;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index = i + start;
              parsed[i] = {
                [iAxis]: singleScale || iScale.parse(labels[index], index),
                [vAxis]: vScale.parse(data[index], index),
              };
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const parsed = new Array(count);
            let i, ilen, index, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index = i + start;
              item = data[index];
              parsed[i] = {
                x: xScale.parse(item[0], index),
                y: yScale.parse(item[1], index),
              };
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const { xScale, yScale } = meta;
            const { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
              index = i + start;
              item = data[index];
              parsed[i] = {
                x: xScale.parse(
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(
                    item,
                    xAxisKey
                  ),
                  index
                ),
                y: yScale.parse(
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(
                    item,
                    yAxisKey
                  ),
                  index
                ),
              };
            }
            return parsed;
          }
          getParsed(index) {
            return this._cachedMeta._parsed[index];
          }
          getDataElement(index) {
            return this._cachedMeta.data[index];
          }
          applyStack(scale, parsed, mode) {
            const chart = this.chart;
            const meta = this._cachedMeta;
            const value = parsed[scale.axis];
            const stack = {
              keys: getSortedDatasetIndices(chart, true),
              values: parsed._stacks[scale.axis]._visualValues,
            };
            return applyStack(stack, value, meta.index, {
              mode,
            });
          }
          updateRangeFromParsed(range, scale, parsed, stack) {
            const parsedValue = parsed[scale.axis];
            let value = parsedValue === null ? NaN : parsedValue;
            const values = stack && parsed._stacks[scale.axis];
            if (stack && values) {
              stack.values = values;
              value = applyStack(stack, parsedValue, this._cachedMeta.index);
            }
            range.min = Math.min(range.min, value);
            range.max = Math.max(range.max, value);
          }
          getMinMax(scale, canStack) {
            const meta = this._cachedMeta;
            const _parsed = meta._parsed;
            const sorted = meta._sorted && scale === meta.iScale;
            const ilen = _parsed.length;
            const otherScale = this._getOtherScale(scale);
            const stack = createStack(canStack, meta, this.chart);
            const range = {
              min: Number.POSITIVE_INFINITY,
              max: Number.NEGATIVE_INFINITY,
            };
            const { min: otherMin, max: otherMax } = getUserBounds(otherScale);
            let i, parsed;
            function _skip() {
              parsed = _parsed[i];
              const otherValue = parsed[otherScale.axis];
              return (
                !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                  parsed[scale.axis]
                ) ||
                otherMin > otherValue ||
                otherMax < otherValue
              );
            }
            for (i = 0; i < ilen; ++i) {
              if (_skip()) {
                continue;
              }
              this.updateRangeFromParsed(range, scale, parsed, stack);
              if (sorted) {
                break;
              }
            }
            if (sorted) {
              for (i = ilen - 1; i >= 0; --i) {
                if (_skip()) {
                  continue;
                }
                this.updateRangeFromParsed(range, scale, parsed, stack);
                break;
              }
            }
            return range;
          }
          getAllParsedValues(scale) {
            const parsed = this._cachedMeta._parsed;
            const values = [];
            let i, ilen, value;
            for (i = 0, ilen = parsed.length; i < ilen; ++i) {
              value = parsed[i][scale.axis];
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                  value
                )
              ) {
                values.push(value);
              }
            }
            return values;
          }
          getMaxOverflow() {
            return false;
          }
          getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const parsed = this.getParsed(index);
            return {
              label: iScale
                ? '' + iScale.getLabelForValue(parsed[iScale.axis])
                : '',
              value: vScale
                ? '' + vScale.getLabelForValue(parsed[vScale.axis])
                : '',
            };
          }
          _update(mode) {
            const meta = this._cachedMeta;
            this.update(mode || 'default');
            meta._clip = toClip(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                this.options.clip,
                defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())
              )
            );
          }
          update(mode) {}
          draw() {
            const ctx = this._ctx;
            const chart = this.chart;
            const meta = this._cachedMeta;
            const elements = meta.data || [];
            const area = chart.chartArea;
            const active = [];
            const start = this._drawStart || 0;
            const count = this._drawCount || elements.length - start;
            const drawActiveElementsOnTop =
              this.options.drawActiveElementsOnTop;
            let i;
            if (meta.dataset) {
              meta.dataset.draw(ctx, area, start, count);
            }
            for (i = start; i < start + count; ++i) {
              const element = elements[i];
              if (element.hidden) {
                continue;
              }
              if (element.active && drawActiveElementsOnTop) {
                active.push(element);
              } else {
                element.draw(ctx, area);
              }
            }
            for (i = 0; i < active.length; ++i) {
              active[i].draw(ctx, area);
            }
          }
          getStyle(index, active) {
            const mode = active ? 'active' : 'default';
            return index === undefined && this._cachedMeta.dataset
              ? this.resolveDatasetElementOptions(mode)
              : this.resolveDataElementOptions(index || 0, mode);
          }
          getContext(index, active, mode) {
            const dataset = this.getDataset();
            let context;
            if (index >= 0 && index < this._cachedMeta.data.length) {
              const element = this._cachedMeta.data[index];
              context =
                element.$context ||
                (element.$context = createDataContext(
                  this.getContext(),
                  index,
                  element
                ));
              context.parsed = this.getParsed(index);
              context.raw = dataset.data[index];
              context.index = context.dataIndex = index;
            } else {
              context =
                this.$context ||
                (this.$context = createDatasetContext(
                  this.chart.getContext(),
                  this.index
                ));
              context.dataset = dataset;
              context.index = context.datasetIndex = this.index;
            }
            context.active = !!active;
            context.mode = mode;
            return context;
          }
          resolveDatasetElementOptions(mode) {
            return this._resolveElementOptions(
              this.datasetElementType.id,
              mode
            );
          }
          resolveDataElementOptions(index, mode) {
            return this._resolveElementOptions(
              this.dataElementType.id,
              mode,
              index
            );
          }
          _resolveElementOptions(elementType, mode = 'default', index) {
            const active = mode === 'active';
            const cache = this._cachedDataOpts;
            const cacheKey = elementType + '-' + mode;
            const cached = cache[cacheKey];
            const sharing =
              this.enableOptionSharing &&
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(
                index
              );
            if (cached) {
              return cloneIfNotShared(cached, sharing);
            }
            const config = this.chart.config;
            const scopeKeys = config.datasetElementScopeKeys(
              this._type,
              elementType
            );
            const prefixes = active
              ? [`${elementType}Hover`, 'hover', elementType, '']
              : [elementType, ''];
            const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
            const names = Object.keys(
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
                .elements[elementType]
            );
            const context = () => this.getContext(index, active, mode);
            const values = config.resolveNamedOptions(
              scopes,
              names,
              context,
              prefixes
            );
            if (values.$shared) {
              values.$shared = sharing;
              cache[cacheKey] = Object.freeze(
                cloneIfNotShared(values, sharing)
              );
            }
            return values;
          }
          _resolveAnimations(index, transition, active) {
            const chart = this.chart;
            const cache = this._cachedDataOpts;
            const cacheKey = `animation-${transition}`;
            const cached = cache[cacheKey];
            if (cached) {
              return cached;
            }
            let options;
            if (chart.options.animation !== false) {
              const config = this.chart.config;
              const scopeKeys = config.datasetAnimationScopeKeys(
                this._type,
                transition
              );
              const scopes = config.getOptionScopes(
                this.getDataset(),
                scopeKeys
              );
              options = config.createResolver(
                scopes,
                this.getContext(index, active, transition)
              );
            }
            const animations = new Animations(
              chart,
              options && options.animations
            );
            if (options && options._cacheable) {
              cache[cacheKey] = Object.freeze(animations);
            }
            return animations;
          }
          getSharedOptions(options) {
            if (!options.$shared) {
              return;
            }
            return (
              this._sharedOptions ||
              (this._sharedOptions = Object.assign({}, options))
            );
          }
          includeOptions(mode, sharedOptions) {
            return (
              !sharedOptions ||
              isDirectUpdateMode(mode) ||
              this.chart._animationsDisabled
            );
          }
          _getSharedOptions(start, mode) {
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const previouslySharedOptions = this._sharedOptions;
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions =
              this.includeOptions(mode, sharedOptions) ||
              sharedOptions !== previouslySharedOptions;
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
            return {
              sharedOptions,
              includeOptions,
            };
          }
          updateElement(element, index, properties, mode) {
            if (isDirectUpdateMode(mode)) {
              Object.assign(element, properties);
            } else {
              this._resolveAnimations(index, mode).update(element, properties);
            }
          }
          updateSharedOptions(sharedOptions, mode, newOptions) {
            if (sharedOptions && !isDirectUpdateMode(mode)) {
              this._resolveAnimations(undefined, mode).update(
                sharedOptions,
                newOptions
              );
            }
          }
          _setStyle(element, index, mode, active) {
            element.active = active;
            const options = this.getStyle(index, active);
            this._resolveAnimations(index, mode, active).update(element, {
              options: (!active && this.getSharedOptions(options)) || options,
            });
          }
          removeHoverStyle(element, datasetIndex, index) {
            this._setStyle(element, index, 'active', false);
          }
          setHoverStyle(element, datasetIndex, index) {
            this._setStyle(element, index, 'active', true);
          }
          _removeDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, undefined, 'active', false);
            }
          }
          _setDatasetHoverStyle() {
            const element = this._cachedMeta.dataset;
            if (element) {
              this._setStyle(element, undefined, 'active', true);
            }
          }
          _resyncElements(resetNewElements) {
            const data = this._data;
            const elements = this._cachedMeta.data;
            for (const [method, arg1, arg2] of this._syncList) {
              this[method](arg1, arg2);
            }
            this._syncList = [];
            const numMeta = elements.length;
            const numData = data.length;
            const count = Math.min(numData, numMeta);
            if (count) {
              this.parse(0, count);
            }
            if (numData > numMeta) {
              this._insertElements(
                numMeta,
                numData - numMeta,
                resetNewElements
              );
            } else if (numData < numMeta) {
              this._removeElements(numData, numMeta - numData);
            }
          }
          _insertElements(start, count, resetNewElements = true) {
            const meta = this._cachedMeta;
            const data = meta.data;
            const end = start + count;
            let i;
            const move = (arr) => {
              arr.length += count;
              for (i = arr.length - 1; i >= end; i--) {
                arr[i] = arr[i - count];
              }
            };
            move(data);
            for (i = start; i < end; ++i) {
              data[i] = new this.dataElementType();
            }
            if (this._parsing) {
              move(meta._parsed);
            }
            this.parse(start, count);
            if (resetNewElements) {
              this.updateElements(data, start, count, 'reset');
            }
          }
          updateElements(element, start, count, mode) {}
          _removeElements(start, count) {
            const meta = this._cachedMeta;
            if (this._parsing) {
              const removed = meta._parsed.splice(start, count);
              if (meta._stacked) {
                clearStacks(meta, removed);
              }
            }
            meta.data.splice(start, count);
          }
          _sync(args) {
            if (this._parsing) {
              this._syncList.push(args);
            } else {
              const [method, arg1, arg2] = args;
              this[method](arg1, arg2);
            }
            this.chart._dataChanges.push([this.index, ...args]);
          }
          _onDataPush() {
            const count = arguments.length;
            this._sync([
              '_insertElements',
              this.getDataset().data.length - count,
              count,
            ]);
          }
          _onDataPop() {
            this._sync([
              '_removeElements',
              this._cachedMeta.data.length - 1,
              1,
            ]);
          }
          _onDataShift() {
            this._sync(['_removeElements', 0, 1]);
          }
          _onDataSplice(start, count) {
            if (count) {
              this._sync(['_removeElements', start, count]);
            }
            const newCount = arguments.length - 2;
            if (newCount) {
              this._sync(['_insertElements', start, newCount]);
            }
          }
          _onDataUnshift() {
            this._sync(['_insertElements', 0, arguments.length]);
          }
        }

        function getAllScaleValues(scale, type) {
          if (!scale._cache.$bar) {
            const visibleMetas = scale.getMatchingVisibleMetas(type);
            let values = [];
            for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {
              values = values.concat(
                visibleMetas[i].controller.getAllParsedValues(scale)
              );
            }
            scale._cache.$bar = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(
              values.sort((a, b) => a - b)
            );
          }
          return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
          const scale = meta.iScale;
          const values = getAllScaleValues(scale, meta.type);
          let min = scale._length;
          let i, ilen, curr, prev;
          const updateMinAndPrev = () => {
            if (curr === 32767 || curr === -32768) {
              return;
            }
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(
                prev
              )
            ) {
              min = Math.min(min, Math.abs(curr - prev) || min);
            }
            prev = curr;
          };
          for (i = 0, ilen = values.length; i < ilen; ++i) {
            curr = scale.getPixelForValue(values[i]);
            updateMinAndPrev();
          }
          prev = undefined;
          for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
            curr = scale.getPixelForTick(i);
            updateMinAndPrev();
          }
          return min;
        }
        function computeFitCategoryTraits(index, ruler, options, stackCount) {
          const thickness = options.barThickness;
          let size, ratio;
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
              thickness
            )
          ) {
            size = ruler.min * options.categoryPercentage;
            ratio = options.barPercentage;
          } else {
            size = thickness * stackCount;
            ratio = 1;
          }
          return {
            chunk: size / stackCount,
            ratio,
            start: ruler.pixels[index] - size / 2,
          };
        }
        function computeFlexCategoryTraits(index, ruler, options, stackCount) {
          const pixels = ruler.pixels;
          const curr = pixels[index];
          let prev = index > 0 ? pixels[index - 1] : null;
          let next = index < pixels.length - 1 ? pixels[index + 1] : null;
          const percent = options.categoryPercentage;
          if (prev === null) {
            prev =
              curr - (next === null ? ruler.end - ruler.start : next - curr);
          }
          if (next === null) {
            next = curr + curr - prev;
          }
          const start = curr - ((curr - Math.min(prev, next)) / 2) * percent;
          const size = (Math.abs(next - prev) / 2) * percent;
          return {
            chunk: size / stackCount,
            ratio: options.barPercentage,
            start,
          };
        }
        function parseFloatBar(entry, item, vScale, i) {
          const startValue = vScale.parse(entry[0], i);
          const endValue = vScale.parse(entry[1], i);
          const min = Math.min(startValue, endValue);
          const max = Math.max(startValue, endValue);
          let barStart = min;
          let barEnd = max;
          if (Math.abs(min) > Math.abs(max)) {
            barStart = max;
            barEnd = min;
          }
          item[vScale.axis] = barEnd;
          item._custom = {
            barStart,
            barEnd,
            start: startValue,
            end: endValue,
            min,
            max,
          };
        }
        function parseValue(entry, item, vScale, i) {
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
              entry
            )
          ) {
            parseFloatBar(entry, item, vScale, i);
          } else {
            item[vScale.axis] = vScale.parse(entry, i);
          }
          return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
          const iScale = meta.iScale;
          const vScale = meta.vScale;
          const labels = iScale.getLabels();
          const singleScale = iScale === vScale;
          const parsed = [];
          let i, ilen, item, entry;
          for (i = start, ilen = start + count; i < ilen; ++i) {
            entry = data[i];
            item = {};
            item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
            parsed.push(parseValue(entry, item, vScale, i));
          }
          return parsed;
        }
        function isFloatBar(custom) {
          return (
            custom &&
            custom.barStart !== undefined &&
            custom.barEnd !== undefined
          );
        }
        function barSign(size, vScale, actualBase) {
          if (size !== 0) {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(size);
          }
          return (
            (vScale.isHorizontal() ? 1 : -1) *
            (vScale.min >= actualBase ? 1 : -1)
          );
        }
        function borderProps(properties) {
          let reverse, start, end, top, bottom;
          if (properties.horizontal) {
            reverse = properties.base > properties.x;
            start = 'left';
            end = 'right';
          } else {
            reverse = properties.base < properties.y;
            start = 'bottom';
            end = 'top';
          }
          if (reverse) {
            top = 'end';
            bottom = 'start';
          } else {
            top = 'start';
            bottom = 'end';
          }
          return {
            start,
            end,
            reverse,
            top,
            bottom,
          };
        }
        function setBorderSkipped(properties, options, stack, index) {
          let edge = options.borderSkipped;
          const res = {};
          if (!edge) {
            properties.borderSkipped = res;
            return;
          }
          if (edge === true) {
            properties.borderSkipped = {
              top: true,
              right: true,
              bottom: true,
              left: true,
            };
            return;
          }
          const { start, end, reverse, top, bottom } = borderProps(properties);
          if (edge === 'middle' && stack) {
            properties.enableBorderRadius = true;
            if ((stack._top || 0) === index) {
              edge = top;
            } else if ((stack._bottom || 0) === index) {
              edge = bottom;
            } else {
              res[parseEdge(bottom, start, end, reverse)] = true;
              edge = top;
            }
          }
          res[parseEdge(edge, start, end, reverse)] = true;
          properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
          if (reverse) {
            edge = swap(edge, a, b);
            edge = startEnd(edge, b, a);
          } else {
            edge = startEnd(edge, a, b);
          }
          return edge;
        }
        function swap(orig, v1, v2) {
          return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
          return v === 'start' ? start : v === 'end' ? end : v;
        }
        function setInflateAmount(properties, { inflateAmount }, ratio) {
          properties.inflateAmount =
            inflateAmount === 'auto' ? (ratio === 1 ? 0.33 : 0) : inflateAmount;
        }
        class BarController extends DatasetController {
          static id = 'bar';
          static defaults = {
            datasetElementType: false,
            dataElementType: 'bar',
            categoryPercentage: 0.8,
            barPercentage: 0.9,
            grouped: true,
            animations: {
              numbers: {
                type: 'number',
                properties: ['x', 'y', 'base', 'width', 'height'],
              },
            },
          };
          static overrides = {
            scales: {
              _index_: {
                type: 'category',
                offset: true,
                grid: {
                  offset: true,
                },
              },
              _value_: {
                type: 'linear',
                beginAtZero: true,
              },
            },
          };
          parsePrimitiveData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseArrayData(meta, data, start, count) {
            return parseArrayOrPrimitive(meta, data, start, count);
          }
          parseObjectData(meta, data, start, count) {
            const { iScale, vScale } = meta;
            const { xAxisKey = 'x', yAxisKey = 'y' } = this._parsing;
            const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;
            const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;
            const parsed = [];
            let i, ilen, item, obj;
            for (i = start, ilen = start + count; i < ilen; ++i) {
              obj = data[i];
              item = {};
              item[iScale.axis] = iScale.parse(
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(
                  obj,
                  iAxisKey
                ),
                i
              );
              parsed.push(
                parseValue(
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(
                    obj,
                    vAxisKey
                  ),
                  item,
                  vScale,
                  i
                )
              );
            }
            return parsed;
          }
          updateRangeFromParsed(range, scale, parsed, stack) {
            super.updateRangeFromParsed(range, scale, parsed, stack);
            const custom = parsed._custom;
            if (custom && scale === this._cachedMeta.vScale) {
              range.min = Math.min(range.min, custom.min);
              range.max = Math.max(range.max, custom.max);
            }
          }
          getMaxOverflow() {
            return 0;
          }
          getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const { iScale, vScale } = meta;
            const parsed = this.getParsed(index);
            const custom = parsed._custom;
            const value = isFloatBar(custom)
              ? '[' + custom.start + ', ' + custom.end + ']'
              : '' + vScale.getLabelForValue(parsed[vScale.axis]);
            return {
              label: '' + iScale.getLabelForValue(parsed[iScale.axis]),
              value,
            };
          }
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
            const meta = this._cachedMeta;
            meta.stack = this.getDataset().stack;
          }
          update(mode) {
            const meta = this._cachedMeta;
            this.updateElements(meta.data, 0, meta.data.length, mode);
          }
          updateElements(bars, start, count, mode) {
            const reset = mode === 'reset';
            const {
              index,
              _cachedMeta: { vScale },
            } = this;
            const base = vScale.getBasePixel();
            const horizontal = vScale.isHorizontal();
            const ruler = this._getRuler();
            const { sharedOptions, includeOptions } = this._getSharedOptions(
              start,
              mode
            );
            for (let i = start; i < start + count; i++) {
              const parsed = this.getParsed(i);
              const vpixels =
                reset ||
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  parsed[vScale.axis]
                )
                  ? {
                      base,
                      head: base,
                    }
                  : this._calculateBarValuePixels(i);
              const ipixels = this._calculateBarIndexPixels(i, ruler);
              const stack = (parsed._stacks || {})[vScale.axis];
              const properties = {
                horizontal,
                base: vpixels.base,
                enableBorderRadius:
                  !stack ||
                  isFloatBar(parsed._custom) ||
                  index === stack._top ||
                  index === stack._bottom,
                x: horizontal ? vpixels.head : ipixels.center,
                y: horizontal ? ipixels.center : vpixels.head,
                height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                width: horizontal ? Math.abs(vpixels.size) : ipixels.size,
              };
              if (includeOptions) {
                properties.options =
                  sharedOptions ||
                  this.resolveDataElementOptions(
                    i,
                    bars[i].active ? 'active' : mode
                  );
              }
              const options = properties.options || bars[i].options;
              setBorderSkipped(properties, options, stack, index);
              setInflateAmount(properties, options, ruler.ratio);
              this.updateElement(bars[i], i, properties, mode);
            }
          }
          _getStacks(last, dataIndex) {
            const { iScale } = this._cachedMeta;
            const metasets = iScale
              .getMatchingVisibleMetas(this._type)
              .filter((meta) => meta.controller.options.grouped);
            const stacked = iScale.options.stacked;
            const stacks = [];
            const currentParsed =
              this._cachedMeta.controller.getParsed(dataIndex);
            const iScaleValue = currentParsed && currentParsed[iScale.axis];
            const skipNull = (meta) => {
              const parsed = meta._parsed.find(
                (item) => item[iScale.axis] === iScaleValue
              );
              const val = parsed && parsed[meta.vScale.axis];
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  val
                ) ||
                isNaN(val)
              ) {
                return true;
              }
            };
            for (const meta of metasets) {
              if (dataIndex !== undefined && skipNull(meta)) {
                continue;
              }
              if (
                stacked === false ||
                stacks.indexOf(meta.stack) === -1 ||
                (stacked === undefined && meta.stack === undefined)
              ) {
                stacks.push(meta.stack);
              }
              if (meta.index === last) {
                break;
              }
            }
            if (!stacks.length) {
              stacks.push(undefined);
            }
            return stacks;
          }
          _getStackCount(index) {
            return this._getStacks(undefined, index).length;
          }
          _getStackIndex(datasetIndex, name, dataIndex) {
            const stacks = this._getStacks(datasetIndex, dataIndex);
            const index = name !== undefined ? stacks.indexOf(name) : -1;
            return index === -1 ? stacks.length - 1 : index;
          }
          _getRuler() {
            const opts = this.options;
            const meta = this._cachedMeta;
            const iScale = meta.iScale;
            const pixels = [];
            let i, ilen;
            for (i = 0, ilen = meta.data.length; i < ilen; ++i) {
              pixels.push(
                iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i)
              );
            }
            const barThickness = opts.barThickness;
            const min = barThickness || computeMinSampleSize(meta);
            return {
              min,
              pixels,
              start: iScale._startPixel,
              end: iScale._endPixel,
              stackCount: this._getStackCount(),
              scale: iScale,
              grouped: opts.grouped,
              ratio: barThickness
                ? 1
                : opts.categoryPercentage * opts.barPercentage,
            };
          }
          _calculateBarValuePixels(index) {
            const {
              _cachedMeta: { vScale, _stacked, index: datasetIndex },
              options: { base: baseValue, minBarLength },
            } = this;
            const actualBase = baseValue || 0;
            const parsed = this.getParsed(index);
            const custom = parsed._custom;
            const floating = isFloatBar(custom);
            let value = parsed[vScale.axis];
            let start = 0;
            let length = _stacked
              ? this.applyStack(vScale, parsed, _stacked)
              : value;
            let head, size;
            if (length !== value) {
              start = length - value;
              length = value;
            }
            if (floating) {
              value = custom.barStart;
              length = custom.barEnd - custom.barStart;
              if (
                value !== 0 &&
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(
                  value
                ) !==
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(
                    custom.barEnd
                  )
              ) {
                start = 0;
              }
              start += value;
            }
            const startValue =
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                baseValue
              ) && !floating
                ? baseValue
                : start;
            let base = vScale.getPixelForValue(startValue);
            if (this.chart.getDataVisibility(index)) {
              head = vScale.getPixelForValue(start + length);
            } else {
              head = base;
            }
            size = head - base;
            if (Math.abs(size) < minBarLength) {
              size = barSign(size, vScale, actualBase) * minBarLength;
              if (value === actualBase) {
                base -= size / 2;
              }
              const startPixel = vScale.getPixelForDecimal(0);
              const endPixel = vScale.getPixelForDecimal(1);
              const min = Math.min(startPixel, endPixel);
              const max = Math.max(startPixel, endPixel);
              base = Math.max(Math.min(base, max), min);
              head = base + size;
              if (_stacked && !floating) {
                parsed._stacks[vScale.axis]._visualValues[datasetIndex] =
                  vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
              }
            }
            if (base === vScale.getPixelForValue(actualBase)) {
              const halfGrid =
                ((0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(
                  size
                ) *
                  vScale.getLineWidthForValue(actualBase)) /
                2;
              base += halfGrid;
              size -= halfGrid;
            }
            return {
              size,
              base,
              head,
              center: head + size / 2,
            };
          }
          _calculateBarIndexPixels(index, ruler) {
            const scale = ruler.scale;
            const options = this.options;
            const skipNull = options.skipNull;
            const maxBarThickness = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              options.maxBarThickness,
              Infinity
            );
            let center, size;
            if (ruler.grouped) {
              const stackCount = skipNull
                ? this._getStackCount(index)
                : ruler.stackCount;
              const range =
                options.barThickness === 'flex'
                  ? computeFlexCategoryTraits(index, ruler, options, stackCount)
                  : computeFitCategoryTraits(index, ruler, options, stackCount);
              const stackIndex = this._getStackIndex(
                this.index,
                this._cachedMeta.stack,
                skipNull ? index : undefined
              );
              center = range.start + range.chunk * stackIndex + range.chunk / 2;
              size = Math.min(maxBarThickness, range.chunk * range.ratio);
            } else {
              center = scale.getPixelForValue(
                this.getParsed(index)[scale.axis],
                index
              );
              size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
            }
            return {
              base: center - size / 2,
              head: center + size / 2,
              center,
              size,
            };
          }
          draw() {
            const meta = this._cachedMeta;
            const vScale = meta.vScale;
            const rects = meta.data;
            const ilen = rects.length;
            let i = 0;
            for (; i < ilen; ++i) {
              if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) {
                rects[i].draw(this._ctx);
              }
            }
          }
        }

        class BubbleController extends DatasetController {
          static id = 'bubble';
          static defaults = {
            datasetElementType: false,
            dataElementType: 'point',
            animations: {
              numbers: {
                type: 'number',
                properties: ['x', 'y', 'borderWidth', 'radius'],
              },
            },
          };
          static overrides = {
            scales: {
              x: {
                type: 'linear',
              },
              y: {
                type: 'linear',
              },
            },
          };
          initialize() {
            this.enableOptionSharing = true;
            super.initialize();
          }
          parsePrimitiveData(meta, data, start, count) {
            const parsed = super.parsePrimitiveData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              parsed[i]._custom = this.resolveDataElementOptions(
                i + start
              ).radius;
            }
            return parsed;
          }
          parseArrayData(meta, data, start, count) {
            const parsed = super.parseArrayData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                item[2],
                this.resolveDataElementOptions(i + start).radius
              );
            }
            return parsed;
          }
          parseObjectData(meta, data, start, count) {
            const parsed = super.parseObjectData(meta, data, start, count);
            for (let i = 0; i < parsed.length; i++) {
              const item = data[start + i];
              parsed[i]._custom = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                item && item.r && +item.r,
                this.resolveDataElementOptions(i + start).radius
              );
            }
            return parsed;
          }
          getMaxOverflow() {
            const data = this._cachedMeta.data;
            let max = 0;
            for (let i = data.length - 1; i >= 0; --i) {
              max = Math.max(
                max,
                data[i].size(this.resolveDataElementOptions(i)) / 2
              );
            }
            return max > 0 && max;
          }
          getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const labels = this.chart.data.labels || [];
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            const r = parsed._custom;
            return {
              label: labels[index] || '',
              value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')',
            };
          }
          update(mode) {
            const points = this._cachedMeta.data;
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const reset = mode === 'reset';
            const { iScale, vScale } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(
              start,
              mode
            );
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const parsed = !reset && this.getParsed(i);
              const properties = {};
              const iPixel = (properties[iAxis] = reset
                ? iScale.getPixelForDecimal(0.5)
                : iScale.getPixelForValue(parsed[iAxis]));
              const vPixel = (properties[vAxis] = reset
                ? vScale.getBasePixel()
                : vScale.getPixelForValue(parsed[vAxis]));
              properties.skip = isNaN(iPixel) || isNaN(vPixel);
              if (includeOptions) {
                properties.options =
                  sharedOptions ||
                  this.resolveDataElementOptions(
                    i,
                    point.active ? 'active' : mode
                  );
                if (reset) {
                  properties.options.radius = 0;
                }
              }
              this.updateElement(point, i, properties, mode);
            }
          }
          resolveDataElementOptions(index, mode) {
            const parsed = this.getParsed(index);
            let values = super.resolveDataElementOptions(index, mode);
            if (values.$shared) {
              values = Object.assign({}, values, {
                $shared: false,
              });
            }
            const radius = values.radius;
            if (mode !== 'active') {
              values.radius = 0;
            }
            values.radius += (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              parsed && parsed._custom,
              radius
            );
            return values;
          }
        }

        function getRatioAndOffset(rotation, circumference, cutout) {
          let ratioX = 1;
          let ratioY = 1;
          let offsetX = 0;
          let offsetY = 0;
          if (
            circumference <
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T
          ) {
            const startAngle = rotation;
            const endAngle = startAngle + circumference;
            const startX = Math.cos(startAngle);
            const startY = Math.sin(startAngle);
            const endX = Math.cos(endAngle);
            const endY = Math.sin(endAngle);
            const calcMax = (angle, a, b) =>
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(
                angle,
                startAngle,
                endAngle,
                true
              )
                ? 1
                : Math.max(a, a * cutout, b, b * cutout);
            const calcMin = (angle, a, b) =>
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(
                angle,
                startAngle,
                endAngle,
                true
              )
                ? -1
                : Math.min(a, a * cutout, b, b * cutout);
            const maxX = calcMax(0, startX, endX);
            const maxY = calcMax(
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H,
              startY,
              endY
            );
            const minX = calcMin(
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P,
              startX,
              endX
            );
            const minY = calcMin(
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P +
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H,
              startY,
              endY
            );
            ratioX = (maxX - minX) / 2;
            ratioY = (maxY - minY) / 2;
            offsetX = -(maxX + minX) / 2;
            offsetY = -(maxY + minY) / 2;
          }
          return {
            ratioX,
            ratioY,
            offsetX,
            offsetY,
          };
        }
        class DoughnutController extends DatasetController {
          static id = 'doughnut';
          static defaults = {
            datasetElementType: false,
            dataElementType: 'arc',
            animation: {
              animateRotate: true,
              animateScale: false,
            },
            animations: {
              numbers: {
                type: 'number',
                properties: [
                  'circumference',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                  'startAngle',
                  'x',
                  'y',
                  'offset',
                  'borderWidth',
                  'spacing',
                ],
              },
            },
            cutout: '50%',
            rotation: 0,
            circumference: 360,
            radius: '100%',
            spacing: 0,
            indexAxis: 'r',
          };
          static descriptors = {
            _scriptable: (name) => name !== 'spacing',
            _indexable: (name) =>
              name !== 'spacing' &&
              !name.startsWith('borderDash') &&
              !name.startsWith('hoverBorderDash'),
          };
          static overrides = {
            aspectRatio: 1,
            plugins: {
              legend: {
                labels: {
                  generateLabels(chart) {
                    const data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                      const {
                        labels: { pointStyle, color },
                      } = chart.legend.options;
                      return data.labels.map((label, i) => {
                        const meta = chart.getDatasetMeta(0);
                        const style = meta.controller.getStyle(i);
                        return {
                          text: label,
                          fillStyle: style.backgroundColor,
                          strokeStyle: style.borderColor,
                          fontColor: color,
                          lineWidth: style.borderWidth,
                          pointStyle: pointStyle,
                          hidden: !chart.getDataVisibility(i),
                          index: i,
                        };
                      });
                    }
                    return [];
                  },
                },
                onClick(e, legendItem, legend) {
                  legend.chart.toggleDataVisibility(legendItem.index);
                  legend.chart.update();
                },
              },
            },
          };
          constructor(chart, datasetIndex) {
            super(chart, datasetIndex);
            this.enableOptionSharing = true;
            this.innerRadius = undefined;
            this.outerRadius = undefined;
            this.offsetX = undefined;
            this.offsetY = undefined;
          }
          linkScales() {}
          parse(start, count) {
            const data = this.getDataset().data;
            const meta = this._cachedMeta;
            if (this._parsing === false) {
              meta._parsed = data;
            } else {
              let getter = (i) => +data[i];
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  data[start]
                )
              ) {
                const { key = 'value' } = this._parsing;
                getter = (i) =>
                  +(0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(
                    data[i],
                    key
                  );
              }
              let i, ilen;
              for (i = start, ilen = start + count; i < ilen; ++i) {
                meta._parsed[i] = getter(i);
              }
            }
          }
          _getRotation() {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.options.rotation - 90
            );
          }
          _getCircumference() {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.options.circumference
            );
          }
          _getRotationExtents() {
            let min = _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;
            let max =
              -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T;
            for (let i = 0; i < this.chart.data.datasets.length; ++i) {
              if (
                this.chart.isDatasetVisible(i) &&
                this.chart.getDatasetMeta(i).type === this._type
              ) {
                const controller = this.chart.getDatasetMeta(i).controller;
                const rotation = controller._getRotation();
                const circumference = controller._getCircumference();
                min = Math.min(min, rotation);
                max = Math.max(max, rotation + circumference);
              }
            }
            return {
              rotation: min,
              circumference: max - min,
            };
          }
          update(mode) {
            const chart = this.chart;
            const { chartArea } = chart;
            const meta = this._cachedMeta;
            const arcs = meta.data;
            const spacing =
              this.getMaxBorderWidth() +
              this.getMaxOffset(arcs) +
              this.options.spacing;
            const maxSize = Math.max(
              (Math.min(chartArea.width, chartArea.height) - spacing) / 2,
              0
            );
            const cutout = Math.min(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.m)(
                this.options.cutout,
                maxSize
              ),
              1
            );
            const chartWeight = this._getRingWeight(this.index);
            const { circumference, rotation } = this._getRotationExtents();
            const { ratioX, ratioY, offsetX, offsetY } = getRatioAndOffset(
              rotation,
              circumference,
              cutout
            );
            const maxWidth = (chartArea.width - spacing) / ratioX;
            const maxHeight = (chartArea.height - spacing) / ratioY;
            const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
            const outerRadius = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.n)(
              this.options.radius,
              maxRadius
            );
            const innerRadius = Math.max(outerRadius * cutout, 0);
            const radiusLength =
              (outerRadius - innerRadius) /
              this._getVisibleDatasetWeightTotal();
            this.offsetX = offsetX * outerRadius;
            this.offsetY = offsetY * outerRadius;
            meta.total = this.calculateTotal();
            this.outerRadius =
              outerRadius -
              radiusLength * this._getRingWeightOffset(this.index);
            this.innerRadius = Math.max(
              this.outerRadius - radiusLength * chartWeight,
              0
            );
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          _circumference(i, reset) {
            const opts = this.options;
            const meta = this._cachedMeta;
            const circumference = this._getCircumference();
            if (
              (reset && opts.animation.animateRotate) ||
              !this.chart.getDataVisibility(i) ||
              meta._parsed[i] === null ||
              meta.data[i].hidden
            ) {
              return 0;
            }
            return this.calculateCircumference(
              (meta._parsed[i] * circumference) /
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T
            );
          }
          updateElements(arcs, start, count, mode) {
            const reset = mode === 'reset';
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const centerX = (chartArea.left + chartArea.right) / 2;
            const centerY = (chartArea.top + chartArea.bottom) / 2;
            const animateScale = reset && animationOpts.animateScale;
            const innerRadius = animateScale ? 0 : this.innerRadius;
            const outerRadius = animateScale ? 0 : this.outerRadius;
            const { sharedOptions, includeOptions } = this._getSharedOptions(
              start,
              mode
            );
            let startAngle = this._getRotation();
            let i;
            for (i = 0; i < start; ++i) {
              startAngle += this._circumference(i, reset);
            }
            for (i = start; i < start + count; ++i) {
              const circumference = this._circumference(i, reset);
              const arc = arcs[i];
              const properties = {
                x: centerX + this.offsetX,
                y: centerY + this.offsetY,
                startAngle,
                endAngle: startAngle + circumference,
                circumference,
                outerRadius,
                innerRadius,
              };
              if (includeOptions) {
                properties.options =
                  sharedOptions ||
                  this.resolveDataElementOptions(
                    i,
                    arc.active ? 'active' : mode
                  );
              }
              startAngle += circumference;
              this.updateElement(arc, i, properties, mode);
            }
          }
          calculateTotal() {
            const meta = this._cachedMeta;
            const metaData = meta.data;
            let total = 0;
            let i;
            for (i = 0; i < metaData.length; i++) {
              const value = meta._parsed[i];
              if (
                value !== null &&
                !isNaN(value) &&
                this.chart.getDataVisibility(i) &&
                !metaData[i].hidden
              ) {
                total += Math.abs(value);
              }
            }
            return total;
          }
          calculateCircumference(value) {
            const total = this._cachedMeta.total;
            if (total > 0 && !isNaN(value)) {
              return (
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T *
                (Math.abs(value) / total)
              );
            }
            return 0;
          }
          getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(
              meta._parsed[index],
              chart.options.locale
            );
            return {
              label: labels[index] || '',
              value,
            };
          }
          getMaxBorderWidth(arcs) {
            let max = 0;
            const chart = this.chart;
            let i, ilen, meta, controller, options;
            if (!arcs) {
              for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                if (chart.isDatasetVisible(i)) {
                  meta = chart.getDatasetMeta(i);
                  arcs = meta.data;
                  controller = meta.controller;
                  break;
                }
              }
            }
            if (!arcs) {
              return 0;
            }
            for (i = 0, ilen = arcs.length; i < ilen; ++i) {
              options = controller.resolveDataElementOptions(i);
              if (options.borderAlign !== 'inner') {
                max = Math.max(
                  max,
                  options.borderWidth || 0,
                  options.hoverBorderWidth || 0
                );
              }
            }
            return max;
          }
          getMaxOffset(arcs) {
            let max = 0;
            for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
              const options = this.resolveDataElementOptions(i);
              max = Math.max(
                max,
                options.offset || 0,
                options.hoverOffset || 0
              );
            }
            return max;
          }
          _getRingWeightOffset(datasetIndex) {
            let ringWeightOffset = 0;
            for (let i = 0; i < datasetIndex; ++i) {
              if (this.chart.isDatasetVisible(i)) {
                ringWeightOffset += this._getRingWeight(i);
              }
            }
            return ringWeightOffset;
          }
          _getRingWeight(datasetIndex) {
            return Math.max(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                this.chart.data.datasets[datasetIndex].weight,
                1
              ),
              0
            );
          }
          _getVisibleDatasetWeightTotal() {
            return (
              this._getRingWeightOffset(this.chart.data.datasets.length) || 1
            );
          }
        }

        class LineController extends DatasetController {
          static id = 'line';
          static defaults = {
            datasetElementType: 'line',
            dataElementType: 'point',
            showLine: true,
            spanGaps: false,
          };
          static overrides = {
            scales: {
              _index_: {
                type: 'category',
              },
              _value_: {
                type: 'linear',
              },
            },
          };
          initialize() {
            this.enableOptionSharing = true;
            this.supportsDecimation = true;
            super.initialize();
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { dataset: line, data: points = [], _dataset } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(
              meta,
              points,
              animationsDisabled
            );
            this._drawStart = start;
            this._drawCount = count;
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(
                meta
              )
            ) {
              start = 0;
              count = points.length;
            }
            line._chart = this.chart;
            line._datasetIndex = this.index;
            line._decimated = !!_dataset._decimated;
            line.points = points;
            const options = this.resolveDatasetElementOptions(mode);
            if (!this.options.showLine) {
              options.borderWidth = 0;
            }
            options.segment = this.options.segment;
            this.updateElement(
              line,
              undefined,
              {
                animated: !animationsDisabled,
                options,
              },
              mode
            );
            this.updateElements(points, start, count, mode);
          }
          updateElements(points, start, count, mode) {
            const reset = mode === 'reset';
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const { sharedOptions, includeOptions } = this._getSharedOptions(
              start,
              mode
            );
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps)
              ? spanGaps
              : Number.POSITIVE_INFINITY;
            const directUpdate =
              this.chart._animationsDisabled || reset || mode === 'none';
            const end = start + count;
            const pointsCount = points.length;
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = 0; i < pointsCount; ++i) {
              const point = points[i];
              const properties = directUpdate ? point : {};
              if (i < start || i >= end) {
                properties.skip = true;
                continue;
              }
              const parsed = this.getParsed(i);
              const nullData = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                parsed[vAxis]
              );
              const iPixel = (properties[iAxis] = iScale.getPixelForValue(
                parsed[iAxis],
                i
              ));
              const vPixel = (properties[vAxis] =
                reset || nullData
                  ? vScale.getBasePixel()
                  : vScale.getPixelForValue(
                      _stacked
                        ? this.applyStack(vScale, parsed, _stacked)
                        : parsed[vAxis],
                      i
                    ));
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop =
                i > 0 &&
                Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options =
                  sharedOptions ||
                  this.resolveDataElementOptions(
                    i,
                    point.active ? 'active' : mode
                  );
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const dataset = meta.dataset;
            const border =
              (dataset.options && dataset.options.borderWidth) || 0;
            const data = meta.data || [];
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(
              this.resolveDataElementOptions(data.length - 1)
            );
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
          draw() {
            const meta = this._cachedMeta;
            meta.dataset.updateControlPoints(
              this.chart.chartArea,
              meta.iScale.axis
            );
            super.draw();
          }
        }

        class PolarAreaController extends DatasetController {
          static id = 'polarArea';
          static defaults = {
            dataElementType: 'arc',
            animation: {
              animateRotate: true,
              animateScale: true,
            },
            animations: {
              numbers: {
                type: 'number',
                properties: [
                  'x',
                  'y',
                  'startAngle',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                ],
              },
            },
            indexAxis: 'r',
            startAngle: 0,
          };
          static overrides = {
            aspectRatio: 1,
            plugins: {
              legend: {
                labels: {
                  generateLabels(chart) {
                    const data = chart.data;
                    if (data.labels.length && data.datasets.length) {
                      const {
                        labels: { pointStyle, color },
                      } = chart.legend.options;
                      return data.labels.map((label, i) => {
                        const meta = chart.getDatasetMeta(0);
                        const style = meta.controller.getStyle(i);
                        return {
                          text: label,
                          fillStyle: style.backgroundColor,
                          strokeStyle: style.borderColor,
                          fontColor: color,
                          lineWidth: style.borderWidth,
                          pointStyle: pointStyle,
                          hidden: !chart.getDataVisibility(i),
                          index: i,
                        };
                      });
                    }
                    return [];
                  },
                },
                onClick(e, legendItem, legend) {
                  legend.chart.toggleDataVisibility(legendItem.index);
                  legend.chart.update();
                },
              },
            },
            scales: {
              r: {
                type: 'radialLinear',
                angleLines: {
                  display: false,
                },
                beginAtZero: true,
                grid: {
                  circular: true,
                },
                pointLabels: {
                  display: false,
                },
                startAngle: 0,
              },
            },
          };
          constructor(chart, datasetIndex) {
            super(chart, datasetIndex);
            this.innerRadius = undefined;
            this.outerRadius = undefined;
          }
          getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const chart = this.chart;
            const labels = chart.data.labels || [];
            const value = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(
              meta._parsed[index].r,
              chart.options.locale
            );
            return {
              label: labels[index] || '',
              value,
            };
          }
          parseObjectData(meta, data, start, count) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(
              this
            )(meta, data, start, count);
          }
          update(mode) {
            const arcs = this._cachedMeta.data;
            this._updateRadius();
            this.updateElements(arcs, 0, arcs.length, mode);
          }
          getMinMax() {
            const meta = this._cachedMeta;
            const range = {
              min: Number.POSITIVE_INFINITY,
              max: Number.NEGATIVE_INFINITY,
            };
            meta.data.forEach((element, index) => {
              const parsed = this.getParsed(index).r;
              if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                if (parsed < range.min) {
                  range.min = parsed;
                }
                if (parsed > range.max) {
                  range.max = parsed;
                }
              }
            });
            return range;
          }
          _updateRadius() {
            const chart = this.chart;
            const chartArea = chart.chartArea;
            const opts = chart.options;
            const minSize = Math.min(
              chartArea.right - chartArea.left,
              chartArea.bottom - chartArea.top
            );
            const outerRadius = Math.max(minSize / 2, 0);
            const innerRadius = Math.max(
              opts.cutoutPercentage
                ? (outerRadius / 100) * opts.cutoutPercentage
                : 1,
              0
            );
            const radiusLength =
              (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
            this.outerRadius = outerRadius - radiusLength * this.index;
            this.innerRadius = this.outerRadius - radiusLength;
          }
          updateElements(arcs, start, count, mode) {
            const reset = mode === 'reset';
            const chart = this.chart;
            const opts = chart.options;
            const animationOpts = opts.animation;
            const scale = this._cachedMeta.rScale;
            const centerX = scale.xCenter;
            const centerY = scale.yCenter;
            const datasetStartAngle =
              scale.getIndexAngle(0) -
              0.5 * _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P;
            let angle = datasetStartAngle;
            let i;
            const defaultAngle = 360 / this.countVisibleElements();
            for (i = 0; i < start; ++i) {
              angle += this._computeAngle(i, mode, defaultAngle);
            }
            for (i = start; i < start + count; i++) {
              const arc = arcs[i];
              let startAngle = angle;
              let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
              let outerRadius = chart.getDataVisibility(i)
                ? scale.getDistanceFromCenterForValue(this.getParsed(i).r)
                : 0;
              angle = endAngle;
              if (reset) {
                if (animationOpts.animateScale) {
                  outerRadius = 0;
                }
                if (animationOpts.animateRotate) {
                  startAngle = endAngle = datasetStartAngle;
                }
              }
              const properties = {
                x: centerX,
                y: centerY,
                innerRadius: 0,
                outerRadius,
                startAngle,
                endAngle,
                options: this.resolveDataElementOptions(
                  i,
                  arc.active ? 'active' : mode
                ),
              };
              this.updateElement(arc, i, properties, mode);
            }
          }
          countVisibleElements() {
            const meta = this._cachedMeta;
            let count = 0;
            meta.data.forEach((element, index) => {
              if (
                !isNaN(this.getParsed(index).r) &&
                this.chart.getDataVisibility(index)
              ) {
                count++;
              }
            });
            return count;
          }
          _computeAngle(index, mode, defaultAngle) {
            return this.chart.getDataVisibility(index)
              ? (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
                  this.resolveDataElementOptions(index, mode).angle ||
                    defaultAngle
                )
              : 0;
          }
        }

        class PieController extends DoughnutController {
          static id = 'pie';
          static defaults = {
            cutout: 0,
            rotation: 0,
            circumference: 360,
            radius: '100%',
          };
        }

        class RadarController extends DatasetController {
          static id = 'radar';
          static defaults = {
            datasetElementType: 'line',
            dataElementType: 'point',
            indexAxis: 'r',
            showLine: true,
            elements: {
              line: {
                fill: 'start',
              },
            },
          };
          static overrides = {
            aspectRatio: 1,
            scales: {
              r: {
                type: 'radialLinear',
              },
            },
          };
          getLabelAndValue(index) {
            const vScale = this._cachedMeta.vScale;
            const parsed = this.getParsed(index);
            return {
              label: vScale.getLabels()[index],
              value: '' + vScale.getLabelForValue(parsed[vScale.axis]),
            };
          }
          parseObjectData(meta, data, start, count) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y.bind(
              this
            )(meta, data, start, count);
          }
          update(mode) {
            const meta = this._cachedMeta;
            const line = meta.dataset;
            const points = meta.data || [];
            const labels = meta.iScale.getLabels();
            line.points = points;
            if (mode !== 'resize') {
              const options = this.resolveDatasetElementOptions(mode);
              if (!this.options.showLine) {
                options.borderWidth = 0;
              }
              const properties = {
                _loop: true,
                _fullLoop: labels.length === points.length,
                options,
              };
              this.updateElement(line, undefined, properties, mode);
            }
            this.updateElements(points, 0, points.length, mode);
          }
          updateElements(points, start, count, mode) {
            const scale = this._cachedMeta.rScale;
            const reset = mode === 'reset';
            for (let i = start; i < start + count; i++) {
              const point = points[i];
              const options = this.resolveDataElementOptions(
                i,
                point.active ? 'active' : mode
              );
              const pointPosition = scale.getPointPositionForValue(
                i,
                this.getParsed(i).r
              );
              const x = reset ? scale.xCenter : pointPosition.x;
              const y = reset ? scale.yCenter : pointPosition.y;
              const properties = {
                x,
                y,
                angle: pointPosition.angle,
                skip: isNaN(x) || isNaN(y),
                options,
              };
              this.updateElement(point, i, properties, mode);
            }
          }
        }

        class ScatterController extends DatasetController {
          static id = 'scatter';
          static defaults = {
            datasetElementType: false,
            dataElementType: 'point',
            showLine: false,
            fill: false,
          };
          static overrides = {
            interaction: {
              mode: 'point',
            },
            scales: {
              x: {
                type: 'linear',
              },
              y: {
                type: 'linear',
              },
            },
          };
          getLabelAndValue(index) {
            const meta = this._cachedMeta;
            const labels = this.chart.data.labels || [];
            const { xScale, yScale } = meta;
            const parsed = this.getParsed(index);
            const x = xScale.getLabelForValue(parsed.x);
            const y = yScale.getLabelForValue(parsed.y);
            return {
              label: labels[index] || '',
              value: '(' + x + ', ' + y + ')',
            };
          }
          update(mode) {
            const meta = this._cachedMeta;
            const { data: points = [] } = meta;
            const animationsDisabled = this.chart._animationsDisabled;
            let { start, count } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q)(
              meta,
              points,
              animationsDisabled
            );
            this._drawStart = start;
            this._drawCount = count;
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w)(
                meta
              )
            ) {
              start = 0;
              count = points.length;
            }
            if (this.options.showLine) {
              if (!this.datasetElementType) {
                this.addElements();
              }
              const { dataset: line, _dataset } = meta;
              line._chart = this.chart;
              line._datasetIndex = this.index;
              line._decimated = !!_dataset._decimated;
              line.points = points;
              const options = this.resolveDatasetElementOptions(mode);
              options.segment = this.options.segment;
              this.updateElement(
                line,
                undefined,
                {
                  animated: !animationsDisabled,
                  options,
                },
                mode
              );
            } else if (this.datasetElementType) {
              delete meta.dataset;
              this.datasetElementType = false;
            }
            this.updateElements(points, start, count, mode);
          }
          addElements() {
            const { showLine } = this.options;
            if (!this.datasetElementType && showLine) {
              this.datasetElementType = this.chart.registry.getElement('line');
            }
            super.addElements();
          }
          updateElements(points, start, count, mode) {
            const reset = mode === 'reset';
            const { iScale, vScale, _stacked, _dataset } = this._cachedMeta;
            const firstOpts = this.resolveDataElementOptions(start, mode);
            const sharedOptions = this.getSharedOptions(firstOpts);
            const includeOptions = this.includeOptions(mode, sharedOptions);
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const { spanGaps, segment } = this.options;
            const maxGapLength = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(spanGaps)
              ? spanGaps
              : Number.POSITIVE_INFINITY;
            const directUpdate =
              this.chart._animationsDisabled || reset || mode === 'none';
            let prevParsed = start > 0 && this.getParsed(start - 1);
            for (let i = start; i < start + count; ++i) {
              const point = points[i];
              const parsed = this.getParsed(i);
              const properties = directUpdate ? point : {};
              const nullData = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                parsed[vAxis]
              );
              const iPixel = (properties[iAxis] = iScale.getPixelForValue(
                parsed[iAxis],
                i
              ));
              const vPixel = (properties[vAxis] =
                reset || nullData
                  ? vScale.getBasePixel()
                  : vScale.getPixelForValue(
                      _stacked
                        ? this.applyStack(vScale, parsed, _stacked)
                        : parsed[vAxis],
                      i
                    ));
              properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
              properties.stop =
                i > 0 &&
                Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
              if (segment) {
                properties.parsed = parsed;
                properties.raw = _dataset.data[i];
              }
              if (includeOptions) {
                properties.options =
                  sharedOptions ||
                  this.resolveDataElementOptions(
                    i,
                    point.active ? 'active' : mode
                  );
              }
              if (!directUpdate) {
                this.updateElement(point, i, properties, mode);
              }
              prevParsed = parsed;
            }
            this.updateSharedOptions(sharedOptions, mode, firstOpts);
          }
          getMaxOverflow() {
            const meta = this._cachedMeta;
            const data = meta.data || [];
            if (!this.options.showLine) {
              let max = 0;
              for (let i = data.length - 1; i >= 0; --i) {
                max = Math.max(
                  max,
                  data[i].size(this.resolveDataElementOptions(i)) / 2
                );
              }
              return max > 0 && max;
            }
            const dataset = meta.dataset;
            const border =
              (dataset.options && dataset.options.borderWidth) || 0;
            if (!data.length) {
              return border;
            }
            const firstPoint = data[0].size(this.resolveDataElementOptions(0));
            const lastPoint = data[data.length - 1].size(
              this.resolveDataElementOptions(data.length - 1)
            );
            return Math.max(border, firstPoint, lastPoint) / 2;
          }
        }

        var controllers = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          BarController: BarController,
          BubbleController: BubbleController,
          DoughnutController: DoughnutController,
          LineController: LineController,
          PieController: PieController,
          PolarAreaController: PolarAreaController,
          RadarController: RadarController,
          ScatterController: ScatterController,
        });

        /**
         * @namespace Chart._adapters
         * @since 2.8.0
         * @private
         */ function abstract() {
          throw new Error(
            'This method is not implemented: Check that a complete date adapter is provided.'
          );
        }
        /**
         * Date adapter (current used by the time scale)
         * @namespace Chart._adapters._date
         * @memberof Chart._adapters
         * @private
         */ class DateAdapterBase {
          /**
           * Override default date adapter methods.
           * Accepts type parameter to define options type.
           * @example
           * Chart._adapters._date.override<{myAdapterOption: string}>({
           *   init() {
           *     console.log(this.options.myAdapterOption);
           *   }
           * })
           */ static override(members) {
            Object.assign(DateAdapterBase.prototype, members);
          }
          options;
          constructor(options) {
            this.options = options || {};
          }
          // eslint-disable-next-line @typescript-eslint/no-empty-function
          init() {}
          formats() {
            return abstract();
          }
          parse() {
            return abstract();
          }
          format() {
            return abstract();
          }
          add() {
            return abstract();
          }
          diff() {
            return abstract();
          }
          startOf() {
            return abstract();
          }
          endOf() {
            return abstract();
          }
        }
        var adapters = {
          _date: DateAdapterBase,
        };

        function binarySearch(metaset, axis, value, intersect) {
          const { controller, data, _sorted } = metaset;
          const iScale = controller._cachedMeta.iScale;
          const spanGaps = metaset.dataset
            ? metaset.dataset.options
              ? metaset.dataset.options.spanGaps
              : null
            : null;
          if (
            iScale &&
            axis === iScale.axis &&
            axis !== 'r' &&
            _sorted &&
            data.length
          ) {
            const lookupMethod = iScale._reversePixels
              ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.A
              : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B;
            if (!intersect) {
              const result = lookupMethod(data, axis, value);
              if (spanGaps) {
                const { vScale } = controller._cachedMeta;
                const { _parsed } = metaset;
                const distanceToDefinedLo = _parsed
                  .slice(0, result.lo + 1)
                  .reverse()
                  .findIndex(
                    (point) =>
                      !(0,
                      _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                        point[vScale.axis]
                      )
                  );
                result.lo -= Math.max(0, distanceToDefinedLo);
                const distanceToDefinedHi = _parsed
                  .slice(result.hi)
                  .findIndex(
                    (point) =>
                      !(0,
                      _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                        point[vScale.axis]
                      )
                  );
                result.hi += Math.max(0, distanceToDefinedHi);
              }
              return result;
            } else if (controller._sharedOptions) {
              const el = data[0];
              const range =
                typeof el.getRange === 'function' && el.getRange(axis);
              if (range) {
                const start = lookupMethod(data, axis, value - range);
                const end = lookupMethod(data, axis, value + range);
                return {
                  lo: start.lo,
                  hi: end.hi,
                };
              }
            }
          }
          return {
            lo: 0,
            hi: data.length - 1,
          };
        }
        function evaluateInteractionItems(
          chart,
          axis,
          position,
          handler,
          intersect
        ) {
          const metasets = chart.getSortedVisibleDatasetMetas();
          const value = position[axis];
          for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
            const { index, data } = metasets[i];
            const { lo, hi } = binarySearch(
              metasets[i],
              axis,
              value,
              intersect
            );
            for (let j = lo; j <= hi; ++j) {
              const element = data[j];
              if (!element.skip) {
                handler(element, index, j);
              }
            }
          }
        }
        function getDistanceMetricForAxis(axis) {
          const useX = axis.indexOf('x') !== -1;
          const useY = axis.indexOf('y') !== -1;
          return function (pt1, pt2) {
            const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
            const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
            return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
          };
        }
        function getIntersectItems(
          chart,
          position,
          axis,
          useFinalPosition,
          includeInvisible
        ) {
          const items = [];
          if (!includeInvisible && !chart.isPointInArea(position)) {
            return items;
          }
          const evaluationFunc = function (element, datasetIndex, index) {
            if (
              !includeInvisible &&
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
                element,
                chart.chartArea,
                0
              )
            ) {
              return;
            }
            if (element.inRange(position.x, position.y, useFinalPosition)) {
              items.push({
                element,
                datasetIndex,
                index,
              });
            }
          };
          evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
          return items;
        }
        function getNearestRadialItems(
          chart,
          position,
          axis,
          useFinalPosition
        ) {
          let items = [];
          function evaluationFunc(element, datasetIndex, index) {
            const { startAngle, endAngle } = element.getProps(
              ['startAngle', 'endAngle'],
              useFinalPosition
            );
            const { angle } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(
              element,
              {
                x: position.x,
                y: position.y,
              }
            );
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(
                angle,
                startAngle,
                endAngle
              )
            ) {
              items.push({
                element,
                datasetIndex,
                index,
              });
            }
          }
          evaluateInteractionItems(chart, axis, position, evaluationFunc);
          return items;
        }
        function getNearestCartesianItems(
          chart,
          position,
          axis,
          intersect,
          useFinalPosition,
          includeInvisible
        ) {
          let items = [];
          const distanceMetric = getDistanceMetricForAxis(axis);
          let minDistance = Number.POSITIVE_INFINITY;
          function evaluationFunc(element, datasetIndex, index) {
            const inRange = element.inRange(
              position.x,
              position.y,
              useFinalPosition
            );
            if (intersect && !inRange) {
              return;
            }
            const center = element.getCenterPoint(useFinalPosition);
            const pointInArea =
              !!includeInvisible || chart.isPointInArea(center);
            if (!pointInArea && !inRange) {
              return;
            }
            const distance = distanceMetric(position, center);
            if (distance < minDistance) {
              items = [
                {
                  element,
                  datasetIndex,
                  index,
                },
              ];
              minDistance = distance;
            } else if (distance === minDistance) {
              items.push({
                element,
                datasetIndex,
                index,
              });
            }
          }
          evaluateInteractionItems(chart, axis, position, evaluationFunc);
          return items;
        }
        function getNearestItems(
          chart,
          position,
          axis,
          intersect,
          useFinalPosition,
          includeInvisible
        ) {
          if (!includeInvisible && !chart.isPointInArea(position)) {
            return [];
          }
          return axis === 'r' && !intersect
            ? getNearestRadialItems(chart, position, axis, useFinalPosition)
            : getNearestCartesianItems(
                chart,
                position,
                axis,
                intersect,
                useFinalPosition,
                includeInvisible
              );
        }
        function getAxisItems(
          chart,
          position,
          axis,
          intersect,
          useFinalPosition
        ) {
          const items = [];
          const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';
          let intersectsItem = false;
          evaluateInteractionItems(
            chart,
            axis,
            position,
            (element, datasetIndex, index) => {
              if (
                element[rangeMethod] &&
                element[rangeMethod](position[axis], useFinalPosition)
              ) {
                items.push({
                  element,
                  datasetIndex,
                  index,
                });
                intersectsItem =
                  intersectsItem ||
                  element.inRange(position.x, position.y, useFinalPosition);
              }
            }
          );
          if (intersect && !intersectsItem) {
            return [];
          }
          return items;
        }
        var Interaction = {
          evaluateInteractionItems,
          modes: {
            index(chart, e, options, useFinalPosition) {
              const position = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
                e,
                chart
              );
              const axis = options.axis || 'x';
              const includeInvisible = options.includeInvisible || false;
              const items = options.intersect
                ? getIntersectItems(
                    chart,
                    position,
                    axis,
                    useFinalPosition,
                    includeInvisible
                  )
                : getNearestItems(
                    chart,
                    position,
                    axis,
                    false,
                    useFinalPosition,
                    includeInvisible
                  );
              const elements = [];
              if (!items.length) {
                return [];
              }
              chart.getSortedVisibleDatasetMetas().forEach((meta) => {
                const index = items[0].index;
                const element = meta.data[index];
                if (element && !element.skip) {
                  elements.push({
                    element,
                    datasetIndex: meta.index,
                    index,
                  });
                }
              });
              return elements;
            },
            dataset(chart, e, options, useFinalPosition) {
              const position = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
                e,
                chart
              );
              const axis = options.axis || 'xy';
              const includeInvisible = options.includeInvisible || false;
              let items = options.intersect
                ? getIntersectItems(
                    chart,
                    position,
                    axis,
                    useFinalPosition,
                    includeInvisible
                  )
                : getNearestItems(
                    chart,
                    position,
                    axis,
                    false,
                    useFinalPosition,
                    includeInvisible
                  );
              if (items.length > 0) {
                const datasetIndex = items[0].datasetIndex;
                const data = chart.getDatasetMeta(datasetIndex).data;
                items = [];
                for (let i = 0; i < data.length; ++i) {
                  items.push({
                    element: data[i],
                    datasetIndex,
                    index: i,
                  });
                }
              }
              return items;
            },
            point(chart, e, options, useFinalPosition) {
              const position = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
                e,
                chart
              );
              const axis = options.axis || 'xy';
              const includeInvisible = options.includeInvisible || false;
              return getIntersectItems(
                chart,
                position,
                axis,
                useFinalPosition,
                includeInvisible
              );
            },
            nearest(chart, e, options, useFinalPosition) {
              const position = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
                e,
                chart
              );
              const axis = options.axis || 'xy';
              const includeInvisible = options.includeInvisible || false;
              return getNearestItems(
                chart,
                position,
                axis,
                options.intersect,
                useFinalPosition,
                includeInvisible
              );
            },
            x(chart, e, options, useFinalPosition) {
              const position = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
                e,
                chart
              );
              return getAxisItems(
                chart,
                position,
                'x',
                options.intersect,
                useFinalPosition
              );
            },
            y(chart, e, options, useFinalPosition) {
              const position = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
                e,
                chart
              );
              return getAxisItems(
                chart,
                position,
                'y',
                options.intersect,
                useFinalPosition
              );
            },
          },
        };

        const STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];
        function filterByPosition(array, position) {
          return array.filter((v) => v.pos === position);
        }
        function filterDynamicPositionByAxis(array, axis) {
          return array.filter(
            (v) => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis
          );
        }
        function sortByWeight(array, reverse) {
          return array.sort((a, b) => {
            const v0 = reverse ? b : a;
            const v1 = reverse ? a : b;
            return v0.weight === v1.weight
              ? v0.index - v1.index
              : v0.weight - v1.weight;
          });
        }
        function wrapBoxes(boxes) {
          const layoutBoxes = [];
          let i, ilen, box, pos, stack, stackWeight;
          for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
            box = boxes[i];
            ({
              position: pos,
              options: { stack, stackWeight = 1 },
            } = box);
            layoutBoxes.push({
              index: i,
              box,
              pos,
              horizontal: box.isHorizontal(),
              weight: box.weight,
              stack: stack && pos + stack,
              stackWeight,
            });
          }
          return layoutBoxes;
        }
        function buildStacks(layouts) {
          const stacks = {};
          for (const wrap of layouts) {
            const { stack, pos, stackWeight } = wrap;
            if (!stack || !STATIC_POSITIONS.includes(pos)) {
              continue;
            }
            const _stack =
              stacks[stack] ||
              (stacks[stack] = {
                count: 0,
                placed: 0,
                weight: 0,
                size: 0,
              });
            _stack.count++;
            _stack.weight += stackWeight;
          }
          return stacks;
        }
        function setLayoutDims(layouts, params) {
          const stacks = buildStacks(layouts);
          const { vBoxMaxWidth, hBoxMaxHeight } = params;
          let i, ilen, layout;
          for (i = 0, ilen = layouts.length; i < ilen; ++i) {
            layout = layouts[i];
            const { fullSize } = layout.box;
            const stack = stacks[layout.stack];
            const factor = stack && layout.stackWeight / stack.weight;
            if (layout.horizontal) {
              layout.width = factor
                ? factor * vBoxMaxWidth
                : fullSize && params.availableWidth;
              layout.height = hBoxMaxHeight;
            } else {
              layout.width = vBoxMaxWidth;
              layout.height = factor
                ? factor * hBoxMaxHeight
                : fullSize && params.availableHeight;
            }
          }
          return stacks;
        }
        function buildLayoutBoxes(boxes) {
          const layoutBoxes = wrapBoxes(boxes);
          const fullSize = sortByWeight(
            layoutBoxes.filter((wrap) => wrap.box.fullSize),
            true
          );
          const left = sortByWeight(
            filterByPosition(layoutBoxes, 'left'),
            true
          );
          const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
          const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
          const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));
          const centerHorizontal = filterDynamicPositionByAxis(
            layoutBoxes,
            'x'
          );
          const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');
          return {
            fullSize,
            leftAndTop: left.concat(top),
            rightAndBottom: right
              .concat(centerVertical)
              .concat(bottom)
              .concat(centerHorizontal),
            chartArea: filterByPosition(layoutBoxes, 'chartArea'),
            vertical: left.concat(right).concat(centerVertical),
            horizontal: top.concat(bottom).concat(centerHorizontal),
          };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
          return (
            Math.max(maxPadding[a], chartArea[a]) +
            Math.max(maxPadding[b], chartArea[b])
          );
        }
        function updateMaxPadding(maxPadding, boxPadding) {
          maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
          maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
          maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
          maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
          const { pos, box } = layout;
          const maxPadding = chartArea.maxPadding;
          if (
            !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(pos)
          ) {
            if (layout.size) {
              chartArea[pos] -= layout.size;
            }
            const stack = stacks[layout.stack] || {
              size: 0,
              count: 1,
            };
            stack.size = Math.max(
              stack.size,
              layout.horizontal ? box.height : box.width
            );
            layout.size = stack.size / stack.count;
            chartArea[pos] += layout.size;
          }
          if (box.getPadding) {
            updateMaxPadding(maxPadding, box.getPadding());
          }
          const newWidth = Math.max(
            0,
            params.outerWidth -
              getCombinedMax(maxPadding, chartArea, 'left', 'right')
          );
          const newHeight = Math.max(
            0,
            params.outerHeight -
              getCombinedMax(maxPadding, chartArea, 'top', 'bottom')
          );
          const widthChanged = newWidth !== chartArea.w;
          const heightChanged = newHeight !== chartArea.h;
          chartArea.w = newWidth;
          chartArea.h = newHeight;
          return layout.horizontal
            ? {
                same: widthChanged,
                other: heightChanged,
              }
            : {
                same: heightChanged,
                other: widthChanged,
              };
        }
        function handleMaxPadding(chartArea) {
          const maxPadding = chartArea.maxPadding;
          function updatePos(pos) {
            const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
            chartArea[pos] += change;
            return change;
          }
          chartArea.y += updatePos('top');
          chartArea.x += updatePos('left');
          updatePos('right');
          updatePos('bottom');
        }
        function getMargins(horizontal, chartArea) {
          const maxPadding = chartArea.maxPadding;
          function marginForPositions(positions) {
            const margin = {
              left: 0,
              top: 0,
              right: 0,
              bottom: 0,
            };
            positions.forEach((pos) => {
              margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
            });
            return margin;
          }
          return horizontal
            ? marginForPositions(['left', 'right'])
            : marginForPositions(['top', 'bottom']);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
          const refitBoxes = [];
          let i, ilen, layout, box, refit, changed;
          for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
            layout = boxes[i];
            box = layout.box;
            box.update(
              layout.width || chartArea.w,
              layout.height || chartArea.h,
              getMargins(layout.horizontal, chartArea)
            );
            const { same, other } = updateDims(
              chartArea,
              params,
              layout,
              stacks
            );
            refit |= same && refitBoxes.length;
            changed = changed || other;
            if (!box.fullSize) {
              refitBoxes.push(layout);
            }
          }
          return (
            (refit && fitBoxes(refitBoxes, chartArea, params, stacks)) ||
            changed
          );
        }
        function setBoxDims(box, left, top, width, height) {
          box.top = top;
          box.left = left;
          box.right = left + width;
          box.bottom = top + height;
          box.width = width;
          box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
          const userPadding = params.padding;
          let { x, y } = chartArea;
          for (const layout of boxes) {
            const box = layout.box;
            const stack = stacks[layout.stack] || {
              count: 1,
              placed: 0,
              weight: 1,
            };
            const weight = layout.stackWeight / stack.weight || 1;
            if (layout.horizontal) {
              const width = chartArea.w * weight;
              const height = stack.size || box.height;
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(
                  stack.start
                )
              ) {
                y = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(
                  box,
                  userPadding.left,
                  y,
                  params.outerWidth - userPadding.right - userPadding.left,
                  height
                );
              } else {
                setBoxDims(
                  box,
                  chartArea.left + stack.placed,
                  y,
                  width,
                  height
                );
              }
              stack.start = y;
              stack.placed += width;
              y = box.bottom;
            } else {
              const height = chartArea.h * weight;
              const width = stack.size || box.width;
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(
                  stack.start
                )
              ) {
                x = stack.start;
              }
              if (box.fullSize) {
                setBoxDims(
                  box,
                  x,
                  userPadding.top,
                  width,
                  params.outerHeight - userPadding.bottom - userPadding.top
                );
              } else {
                setBoxDims(box, x, chartArea.top + stack.placed, width, height);
              }
              stack.start = x;
              stack.placed += height;
              x = box.right;
            }
          }
          chartArea.x = x;
          chartArea.y = y;
        }
        var layouts = {
          addBox(chart, item) {
            if (!chart.boxes) {
              chart.boxes = [];
            }
            item.fullSize = item.fullSize || false;
            item.position = item.position || 'top';
            item.weight = item.weight || 0;
            item._layers =
              item._layers ||
              function () {
                return [
                  {
                    z: 0,
                    draw(chartArea) {
                      item.draw(chartArea);
                    },
                  },
                ];
              };
            chart.boxes.push(item);
          },
          removeBox(chart, layoutItem) {
            const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
            if (index !== -1) {
              chart.boxes.splice(index, 1);
            }
          },
          configure(chart, item, options) {
            item.fullSize = options.fullSize;
            item.position = options.position;
            item.weight = options.weight;
          },
          update(chart, width, height, minPadding) {
            if (!chart) {
              return;
            }
            const padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              chart.options.layout.padding
            );
            const availableWidth = Math.max(width - padding.width, 0);
            const availableHeight = Math.max(height - padding.height, 0);
            const boxes = buildLayoutBoxes(chart.boxes);
            const verticalBoxes = boxes.vertical;
            const horizontalBoxes = boxes.horizontal;
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              chart.boxes,
              (box) => {
                if (typeof box.beforeLayout === 'function') {
                  box.beforeLayout();
                }
              }
            );
            const visibleVerticalBoxCount =
              verticalBoxes.reduce(
                (total, wrap) =>
                  wrap.box.options && wrap.box.options.display === false
                    ? total
                    : total + 1,
                0
              ) || 1;
            const params = Object.freeze({
              outerWidth: width,
              outerHeight: height,
              padding,
              availableWidth,
              availableHeight,
              vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
              hBoxMaxHeight: availableHeight / 2,
            });
            const maxPadding = Object.assign({}, padding);
            updateMaxPadding(
              maxPadding,
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
                minPadding
              )
            );
            const chartArea = Object.assign(
              {
                maxPadding,
                w: availableWidth,
                h: availableHeight,
                x: padding.left,
                y: padding.top,
              },
              padding
            );
            const stacks = setLayoutDims(
              verticalBoxes.concat(horizontalBoxes),
              params
            );
            fitBoxes(boxes.fullSize, chartArea, params, stacks);
            fitBoxes(verticalBoxes, chartArea, params, stacks);
            if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {
              fitBoxes(verticalBoxes, chartArea, params, stacks);
            }
            handleMaxPadding(chartArea);
            placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
            chartArea.x += chartArea.w;
            chartArea.y += chartArea.h;
            placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
            chart.chartArea = {
              left: chartArea.left,
              top: chartArea.top,
              right: chartArea.left + chartArea.w,
              bottom: chartArea.top + chartArea.h,
              height: chartArea.h,
              width: chartArea.w,
            };
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              boxes.chartArea,
              (layout) => {
                const box = layout.box;
                Object.assign(box, chart.chartArea);
                box.update(chartArea.w, chartArea.h, {
                  left: 0,
                  top: 0,
                  right: 0,
                  bottom: 0,
                });
              }
            );
          },
        };

        class BasePlatform {
          acquireContext(canvas, aspectRatio) {}
          releaseContext(context) {
            return false;
          }
          addEventListener(chart, type, listener) {}
          removeEventListener(chart, type, listener) {}
          getDevicePixelRatio() {
            return 1;
          }
          getMaximumSize(element, width, height, aspectRatio) {
            width = Math.max(0, width || element.width);
            height = height || element.height;
            return {
              width,
              height: Math.max(
                0,
                aspectRatio ? Math.floor(width / aspectRatio) : height
              ),
            };
          }
          isAttached(canvas) {
            return true;
          }
          updateConfig(config) {}
        }

        class BasicPlatform extends BasePlatform {
          acquireContext(item) {
            return (item && item.getContext && item.getContext('2d')) || null;
          }
          updateConfig(config) {
            config.options.animation = false;
          }
        }

        const EXPANDO_KEY = '$chartjs';
        const EVENT_TYPES = {
          touchstart: 'mousedown',
          touchmove: 'mousemove',
          touchend: 'mouseup',
          pointerenter: 'mouseenter',
          pointerdown: 'mousedown',
          pointermove: 'mousemove',
          pointerup: 'mouseup',
          pointerleave: 'mouseout',
          pointerout: 'mouseout',
        };
        const isNullOrEmpty = (value) => value === null || value === '';
        function initCanvas(canvas, aspectRatio) {
          const style = canvas.style;
          const renderHeight = canvas.getAttribute('height');
          const renderWidth = canvas.getAttribute('width');
          canvas[EXPANDO_KEY] = {
            initial: {
              height: renderHeight,
              width: renderWidth,
              style: {
                display: style.display,
                height: style.height,
                width: style.width,
              },
            },
          };
          style.display = style.display || 'block';
          style.boxSizing = style.boxSizing || 'border-box';
          if (isNullOrEmpty(renderWidth)) {
            const displayWidth = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(
              canvas,
              'width'
            );
            if (displayWidth !== undefined) {
              canvas.width = displayWidth;
            }
          }
          if (isNullOrEmpty(renderHeight)) {
            if (canvas.style.height === '') {
              canvas.height = canvas.width / (aspectRatio || 2);
            } else {
              const displayHeight = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J)(
                canvas,
                'height'
              );
              if (displayHeight !== undefined) {
                canvas.height = displayHeight;
              }
            }
          }
          return canvas;
        }
        const eventListenerOptions =
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.K
            ? {
                passive: true,
              }
            : false;
        function addListener(node, type, listener) {
          if (node) {
            node.addEventListener(type, listener, eventListenerOptions);
          }
        }
        function removeListener(chart, type, listener) {
          if (chart && chart.canvas) {
            chart.canvas.removeEventListener(
              type,
              listener,
              eventListenerOptions
            );
          }
        }
        function fromNativeEvent(event, chart) {
          const type = EVENT_TYPES[event.type] || event.type;
          const { x, y } = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z)(
            event,
            chart
          );
          return {
            type,
            chart,
            native: event,
            x: x !== undefined ? x : null,
            y: y !== undefined ? y : null,
          };
        }
        function nodeListContains(nodeList, canvas) {
          for (const node of nodeList) {
            if (node === canvas || node.contains(canvas)) {
              return true;
            }
          }
        }
        function createAttachObserver(chart, type, listener) {
          const canvas = chart.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.addedNodes, canvas);
              trigger =
                trigger && !nodeListContains(entry.removedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, {
            childList: true,
            subtree: true,
          });
          return observer;
        }
        function createDetachObserver(chart, type, listener) {
          const canvas = chart.canvas;
          const observer = new MutationObserver((entries) => {
            let trigger = false;
            for (const entry of entries) {
              trigger = trigger || nodeListContains(entry.removedNodes, canvas);
              trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
            }
            if (trigger) {
              listener();
            }
          });
          observer.observe(document, {
            childList: true,
            subtree: true,
          });
          return observer;
        }
        const drpListeningCharts = new Map();
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
          const dpr = window.devicePixelRatio;
          if (dpr === oldDevicePixelRatio) {
            return;
          }
          oldDevicePixelRatio = dpr;
          drpListeningCharts.forEach((resize, chart) => {
            if (chart.currentDevicePixelRatio !== dpr) {
              resize();
            }
          });
        }
        function listenDevicePixelRatioChanges(chart, resize) {
          if (!drpListeningCharts.size) {
            window.addEventListener('resize', onWindowResize);
          }
          drpListeningCharts.set(chart, resize);
        }
        function unlistenDevicePixelRatioChanges(chart) {
          drpListeningCharts.delete(chart);
          if (!drpListeningCharts.size) {
            window.removeEventListener('resize', onWindowResize);
          }
        }
        function createResizeObserver(chart, type, listener) {
          const canvas = chart.canvas;
          const container =
            canvas &&
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(
              canvas
            );
          if (!container) {
            return;
          }
          const resize = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)(
            (width, height) => {
              const w = container.clientWidth;
              listener(width, height);
              if (w < container.clientWidth) {
                listener();
              }
            },
            window
          );
          const observer = new ResizeObserver((entries) => {
            const entry = entries[0];
            const width = entry.contentRect.width;
            const height = entry.contentRect.height;
            if (width === 0 && height === 0) {
              return;
            }
            resize(width, height);
          });
          observer.observe(container);
          listenDevicePixelRatioChanges(chart, resize);
          return observer;
        }
        function releaseObserver(chart, type, observer) {
          if (observer) {
            observer.disconnect();
          }
          if (type === 'resize') {
            unlistenDevicePixelRatioChanges(chart);
          }
        }
        function createProxyAndListen(chart, type, listener) {
          const canvas = chart.canvas;
          const proxy = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L)(
            (event) => {
              if (chart.ctx !== null) {
                listener(fromNativeEvent(event, chart));
              }
            },
            chart
          );
          addListener(canvas, type, proxy);
          return proxy;
        }
        class DomPlatform extends BasePlatform {
          acquireContext(canvas, aspectRatio) {
            const context =
              canvas && canvas.getContext && canvas.getContext('2d');
            if (context && context.canvas === canvas) {
              initCanvas(canvas, aspectRatio);
              return context;
            }
            return null;
          }
          releaseContext(context) {
            const canvas = context.canvas;
            if (!canvas[EXPANDO_KEY]) {
              return false;
            }
            const initial = canvas[EXPANDO_KEY].initial;
            ['height', 'width'].forEach((prop) => {
              const value = initial[prop];
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  value
                )
              ) {
                canvas.removeAttribute(prop);
              } else {
                canvas.setAttribute(prop, value);
              }
            });
            const style = initial.style || {};
            Object.keys(style).forEach((key) => {
              canvas.style[key] = style[key];
            });
            canvas.width = canvas.width;
            delete canvas[EXPANDO_KEY];
            return true;
          }
          addEventListener(chart, type, listener) {
            this.removeEventListener(chart, type);
            const proxies = chart.$proxies || (chart.$proxies = {});
            const handlers = {
              attach: createAttachObserver,
              detach: createDetachObserver,
              resize: createResizeObserver,
            };
            const handler = handlers[type] || createProxyAndListen;
            proxies[type] = handler(chart, type, listener);
          }
          removeEventListener(chart, type) {
            const proxies = chart.$proxies || (chart.$proxies = {});
            const proxy = proxies[type];
            if (!proxy) {
              return;
            }
            const handlers = {
              attach: releaseObserver,
              detach: releaseObserver,
              resize: releaseObserver,
            };
            const handler = handlers[type] || removeListener;
            handler(chart, type, proxy);
            proxies[type] = undefined;
          }
          getDevicePixelRatio() {
            return window.devicePixelRatio;
          }
          getMaximumSize(canvas, width, height, aspectRatio) {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.G)(
              canvas,
              width,
              height,
              aspectRatio
            );
          }
          isAttached(canvas) {
            const container =
              canvas &&
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I)(
                canvas
              );
            return !!(container && container.isConnected);
          }
        }

        function _detectPlatform(canvas) {
          if (
            !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() ||
            (typeof OffscreenCanvas !== 'undefined' &&
              canvas instanceof OffscreenCanvas)
          ) {
            return BasicPlatform;
          }
          return DomPlatform;
        }

        class Element {
          static defaults = {};
          static defaultRoutes = undefined;
          x;
          y;
          active = false;
          options;
          $animations;
          tooltipPosition(useFinalPosition) {
            const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
            return {
              x,
              y,
            };
          }
          hasValue() {
            return (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(
                this.x
              ) &&
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(
                this.y
              )
            );
          }
          getProps(props, final) {
            const anims = this.$animations;
            if (!final || !anims) {
              // let's not create an object, if not needed
              return this;
            }
            const ret = {};
            props.forEach((prop) => {
              ret[prop] =
                anims[prop] && anims[prop].active()
                  ? anims[prop]._to
                  : this[prop];
            });
            return ret;
          }
        }

        function autoSkip(scale, ticks) {
          const tickOpts = scale.options.ticks;
          const determinedMaxTicks = determineMaxTicks(scale);
          const ticksLimit = Math.min(
            tickOpts.maxTicksLimit || determinedMaxTicks,
            determinedMaxTicks
          );
          const majorIndices = tickOpts.major.enabled
            ? getMajorIndices(ticks)
            : [];
          const numMajorIndices = majorIndices.length;
          const first = majorIndices[0];
          const last = majorIndices[numMajorIndices - 1];
          const newTicks = [];
          if (numMajorIndices > ticksLimit) {
            skipMajors(
              ticks,
              newTicks,
              majorIndices,
              numMajorIndices / ticksLimit
            );
            return newTicks;
          }
          const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
          if (numMajorIndices > 0) {
            let i, ilen;
            const avgMajorSpacing =
              numMajorIndices > 1
                ? Math.round((last - first) / (numMajorIndices - 1))
                : null;
            skip(
              ticks,
              newTicks,
              spacing,
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                avgMajorSpacing
              )
                ? 0
                : first - avgMajorSpacing,
              first
            );
            for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
              skip(
                ticks,
                newTicks,
                spacing,
                majorIndices[i],
                majorIndices[i + 1]
              );
            }
            skip(
              ticks,
              newTicks,
              spacing,
              last,
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                avgMajorSpacing
              )
                ? ticks.length
                : last + avgMajorSpacing
            );
            return newTicks;
          }
          skip(ticks, newTicks, spacing);
          return newTicks;
        }
        function determineMaxTicks(scale) {
          const offset = scale.options.offset;
          const tickLength = scale._tickSize();
          const maxScale = scale._length / tickLength + (offset ? 0 : 1);
          const maxChart = scale._maxLength / tickLength;
          return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
          const evenMajorSpacing = getEvenSpacing(majorIndices);
          const spacing = ticks.length / ticksLimit;
          if (!evenMajorSpacing) {
            return Math.max(spacing, 1);
          }
          const factors = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.N)(
            evenMajorSpacing
          );
          for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
            const factor = factors[i];
            if (factor > spacing) {
              return factor;
            }
          }
          return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
          const result = [];
          let i, ilen;
          for (i = 0, ilen = ticks.length; i < ilen; i++) {
            if (ticks[i].major) {
              result.push(i);
            }
          }
          return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
          let count = 0;
          let next = majorIndices[0];
          let i;
          spacing = Math.ceil(spacing);
          for (i = 0; i < ticks.length; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = majorIndices[count * spacing];
            }
          }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
          const start = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            majorStart,
            0
          );
          const end = Math.min(
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              majorEnd,
              ticks.length
            ),
            ticks.length
          );
          let count = 0;
          let length, i, next;
          spacing = Math.ceil(spacing);
          if (majorEnd) {
            length = majorEnd - majorStart;
            spacing = length / Math.floor(length / spacing);
          }
          next = start;
          while (next < 0) {
            count++;
            next = Math.round(start + count * spacing);
          }
          for (i = Math.max(start, 0); i < end; i++) {
            if (i === next) {
              newTicks.push(ticks[i]);
              count++;
              next = Math.round(start + count * spacing);
            }
          }
        }
        function getEvenSpacing(arr) {
          const len = arr.length;
          let i, diff;
          if (len < 2) {
            return false;
          }
          for (diff = arr[0], i = 1; i < len; ++i) {
            if (arr[i] - arr[i - 1] !== diff) {
              return false;
            }
          }
          return diff;
        }

        const reverseAlign = (align) =>
          align === 'left' ? 'right' : align === 'right' ? 'left' : align;
        const offsetFromEdge = (scale, edge, offset) =>
          edge === 'top' || edge === 'left'
            ? scale[edge] + offset
            : scale[edge] - offset;
        const getTicksLimit = (ticksLength, maxTicksLimit) =>
          Math.min(maxTicksLimit || ticksLength, ticksLength);
        function sample(arr, numItems) {
          const result = [];
          const increment = arr.length / numItems;
          const len = arr.length;
          let i = 0;
          for (; i < len; i += increment) {
            result.push(arr[Math.floor(i)]);
          }
          return result;
        }
        function getPixelForGridLine(scale, index, offsetGridLines) {
          const length = scale.ticks.length;
          const validIndex = Math.min(index, length - 1);
          const start = scale._startPixel;
          const end = scale._endPixel;
          const epsilon = 1e-6;
          let lineValue = scale.getPixelForTick(validIndex);
          let offset;
          if (offsetGridLines) {
            if (length === 1) {
              offset = Math.max(lineValue - start, end - lineValue);
            } else if (index === 0) {
              offset = (scale.getPixelForTick(1) - lineValue) / 2;
            } else {
              offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
            }
            lineValue += validIndex < index ? offset : -offset;
            if (lineValue < start - epsilon || lineValue > end + epsilon) {
              return;
            }
          }
          return lineValue;
        }
        function garbageCollect(caches, length) {
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
            caches,
            (cache) => {
              const gc = cache.gc;
              const gcLen = gc.length / 2;
              let i;
              if (gcLen > length) {
                for (i = 0; i < gcLen; ++i) {
                  delete cache.data[gc[i]];
                }
                gc.splice(0, gcLen);
              }
            }
          );
        }
        function getTickMarkLength(options) {
          return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
          if (!options.display) {
            return 0;
          }
          const font = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
            options.font,
            fallback
          );
          const padding = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
            options.padding
          );
          const lines = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
            options.text
          )
            ? options.text.length
            : 1;
          return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(
            parent,
            {
              scale,
              type: 'scale',
            }
          );
        }
        function createTickContext(parent, index, tick) {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(
            parent,
            {
              tick,
              index,
              type: 'tick',
            }
          );
        }
        function titleAlign(align, position, reverse) {
          let ret = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(align);
          if (
            (reverse && position !== 'right') ||
            (!reverse && position === 'right')
          ) {
            ret = reverseAlign(ret);
          }
          return ret;
        }
        function titleArgs(scale, offset, position, align) {
          const { top, left, bottom, right, chart } = scale;
          const { chartArea, scales } = chart;
          let rotation = 0;
          let maxWidth, titleX, titleY;
          const height = bottom - top;
          const width = right - left;
          if (scale.isHorizontal()) {
            titleX = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
              align,
              left,
              right
            );
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                position
              )
            ) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleY =
                scales[positionAxisID].getPixelForValue(value) +
                height -
                offset;
            } else if (position === 'center') {
              titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;
            } else {
              titleY = offsetFromEdge(scale, position, offset);
            }
            maxWidth = right - left;
          } else {
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                position
              )
            ) {
              const positionAxisID = Object.keys(position)[0];
              const value = position[positionAxisID];
              titleX =
                scales[positionAxisID].getPixelForValue(value) - width + offset;
            } else if (position === 'center') {
              titleX = (chartArea.left + chartArea.right) / 2 - width + offset;
            } else {
              titleX = offsetFromEdge(scale, position, offset);
            }
            titleY = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
              align,
              bottom,
              top
            );
            rotation =
              position === 'left'
                ? -_chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H
                : _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H;
          }
          return {
            titleX,
            titleY,
            maxWidth,
            rotation,
          };
        }
        class Scale extends Element {
          constructor(cfg) {
            super();
            this.id = cfg.id;
            this.type = cfg.type;
            this.options = undefined;
            this.ctx = cfg.ctx;
            this.chart = cfg.chart;
            this.top = undefined;
            this.bottom = undefined;
            this.left = undefined;
            this.right = undefined;
            this.width = undefined;
            this.height = undefined;
            this._margins = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
            };
            this.maxWidth = undefined;
            this.maxHeight = undefined;
            this.paddingTop = undefined;
            this.paddingBottom = undefined;
            this.paddingLeft = undefined;
            this.paddingRight = undefined;
            this.axis = undefined;
            this.labelRotation = undefined;
            this.min = undefined;
            this.max = undefined;
            this._range = undefined;
            this.ticks = [];
            this._gridLineItems = null;
            this._labelItems = null;
            this._labelSizes = null;
            this._length = 0;
            this._maxLength = 0;
            this._longestTextCache = {};
            this._startPixel = undefined;
            this._endPixel = undefined;
            this._reversePixels = false;
            this._userMax = undefined;
            this._userMin = undefined;
            this._suggestedMax = undefined;
            this._suggestedMin = undefined;
            this._ticksLength = 0;
            this._borderValue = 0;
            this._cache = {};
            this._dataLimitsCached = false;
            this.$context = undefined;
          }
          init(options) {
            this.options = options.setContext(this.getContext());
            this.axis = options.axis;
            this._userMin = this.parse(options.min);
            this._userMax = this.parse(options.max);
            this._suggestedMin = this.parse(options.suggestedMin);
            this._suggestedMax = this.parse(options.suggestedMax);
          }
          parse(raw, index) {
            return raw;
          }
          getUserBounds() {
            let { _userMin, _userMax, _suggestedMin, _suggestedMax } = this;
            _userMin = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
              _userMin,
              Number.POSITIVE_INFINITY
            );
            _userMax = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
              _userMax,
              Number.NEGATIVE_INFINITY
            );
            _suggestedMin = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
              _suggestedMin,
              Number.POSITIVE_INFINITY
            );
            _suggestedMax = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
              _suggestedMax,
              Number.NEGATIVE_INFINITY
            );
            return {
              min: (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
                _userMin,
                _suggestedMin
              ),
              max: (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
                _userMax,
                _suggestedMax
              ),
              minDefined: (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                _userMin
              ),
              maxDefined: (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                _userMax
              ),
            };
          }
          getMinMax(canStack) {
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            let range;
            if (minDefined && maxDefined) {
              return {
                min,
                max,
              };
            }
            const metas = this.getMatchingVisibleMetas();
            for (let i = 0, ilen = metas.length; i < ilen; ++i) {
              range = metas[i].controller.getMinMax(this, canStack);
              if (!minDefined) {
                min = Math.min(min, range.min);
              }
              if (!maxDefined) {
                max = Math.max(max, range.max);
              }
            }
            min = maxDefined && min > max ? max : min;
            max = minDefined && min > max ? min : max;
            return {
              min: (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
                min,
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
                  max,
                  min
                )
              ),
              max: (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
                max,
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
                  min,
                  max
                )
              ),
            };
          }
          getPadding() {
            return {
              left: this.paddingLeft || 0,
              top: this.paddingTop || 0,
              right: this.paddingRight || 0,
              bottom: this.paddingBottom || 0,
            };
          }
          getTicks() {
            return this.ticks;
          }
          getLabels() {
            const data = this.chart.data;
            return (
              this.options.labels ||
              (this.isHorizontal() ? data.xLabels : data.yLabels) ||
              data.labels ||
              []
            );
          }
          getLabelItems(chartArea = this.chart.chartArea) {
            const items =
              this._labelItems ||
              (this._labelItems = this._computeLabelItems(chartArea));
            return items;
          }
          beforeLayout() {
            this._cache = {};
            this._dataLimitsCached = false;
          }
          beforeUpdate() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.beforeUpdate,
              [this]
            );
          }
          update(maxWidth, maxHeight, margins) {
            const { beginAtZero, grace, ticks: tickOpts } = this.options;
            const sampleSize = tickOpts.sampleSize;
            this.beforeUpdate();
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins = Object.assign(
              {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0,
              },
              margins
            );
            this.ticks = null;
            this._labelSizes = null;
            this._gridLineItems = null;
            this._labelItems = null;
            this.beforeSetDimensions();
            this.setDimensions();
            this.afterSetDimensions();
            this._maxLength = this.isHorizontal()
              ? this.width + margins.left + margins.right
              : this.height + margins.top + margins.bottom;
            if (!this._dataLimitsCached) {
              this.beforeDataLimits();
              this.determineDataLimits();
              this.afterDataLimits();
              this._range = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.R)(
                this,
                grace,
                beginAtZero
              );
              this._dataLimitsCached = true;
            }
            this.beforeBuildTicks();
            this.ticks = this.buildTicks() || [];
            this.afterBuildTicks();
            const samplingEnabled = sampleSize < this.ticks.length;
            this._convertTicksToLabels(
              samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks
            );
            this.configure();
            this.beforeCalculateLabelRotation();
            this.calculateLabelRotation();
            this.afterCalculateLabelRotation();
            if (
              tickOpts.display &&
              (tickOpts.autoSkip || tickOpts.source === 'auto')
            ) {
              this.ticks = autoSkip(this, this.ticks);
              this._labelSizes = null;
              this.afterAutoSkip();
            }
            if (samplingEnabled) {
              this._convertTicksToLabels(this.ticks);
            }
            this.beforeFit();
            this.fit();
            this.afterFit();
            this.afterUpdate();
          }
          configure() {
            let reversePixels = this.options.reverse;
            let startPixel, endPixel;
            if (this.isHorizontal()) {
              startPixel = this.left;
              endPixel = this.right;
            } else {
              startPixel = this.top;
              endPixel = this.bottom;
              reversePixels = !reversePixels;
            }
            this._startPixel = startPixel;
            this._endPixel = endPixel;
            this._reversePixels = reversePixels;
            this._length = endPixel - startPixel;
            this._alignToPixels = this.options.alignToPixels;
          }
          afterUpdate() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.afterUpdate,
              [this]
            );
          }
          beforeSetDimensions() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.beforeSetDimensions,
              [this]
            );
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = 0;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = 0;
              this.bottom = this.height;
            }
            this.paddingLeft = 0;
            this.paddingTop = 0;
            this.paddingRight = 0;
            this.paddingBottom = 0;
          }
          afterSetDimensions() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.afterSetDimensions,
              [this]
            );
          }
          _callHooks(name) {
            this.chart.notifyPlugins(name, this.getContext());
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options[name],
              [this]
            );
          }
          beforeDataLimits() {
            this._callHooks('beforeDataLimits');
          }
          determineDataLimits() {}
          afterDataLimits() {
            this._callHooks('afterDataLimits');
          }
          beforeBuildTicks() {
            this._callHooks('beforeBuildTicks');
          }
          buildTicks() {
            return [];
          }
          afterBuildTicks() {
            this._callHooks('afterBuildTicks');
          }
          beforeTickToLabelConversion() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.beforeTickToLabelConversion,
              [this]
            );
          }
          generateTickLabels(ticks) {
            const tickOpts = this.options.ticks;
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              tick = ticks[i];
              tick.label = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                tickOpts.callback,
                [tick.value, i, ticks],
                this
              );
            }
          }
          afterTickToLabelConversion() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.afterTickToLabelConversion,
              [this]
            );
          }
          beforeCalculateLabelRotation() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.beforeCalculateLabelRotation,
              [this]
            );
          }
          calculateLabelRotation() {
            const options = this.options;
            const tickOpts = options.ticks;
            const numTicks = getTicksLimit(
              this.ticks.length,
              options.ticks.maxTicksLimit
            );
            const minRotation = tickOpts.minRotation || 0;
            const maxRotation = tickOpts.maxRotation;
            let labelRotation = minRotation;
            let tickWidth, maxHeight, maxLabelDiagonal;
            if (
              !this._isVisible() ||
              !tickOpts.display ||
              minRotation >= maxRotation ||
              numTicks <= 1 ||
              !this.isHorizontal()
            ) {
              this.labelRotation = minRotation;
              return;
            }
            const labelSizes = this._getLabelSizes();
            const maxLabelWidth = labelSizes.widest.width;
            const maxLabelHeight = labelSizes.highest.height;
            const maxWidth = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              this.chart.width - maxLabelWidth,
              0,
              this.maxWidth
            );
            tickWidth = options.offset
              ? this.maxWidth / numTicks
              : maxWidth / (numTicks - 1);
            if (maxLabelWidth + 6 > tickWidth) {
              tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
              maxHeight =
                this.maxHeight -
                getTickMarkLength(options.grid) -
                tickOpts.padding -
                getTitleHeight(options.title, this.chart.options.font);
              maxLabelDiagonal = Math.sqrt(
                maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight
              );
              labelRotation = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(
                Math.min(
                  Math.asin(
                    (0,
                    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
                      (labelSizes.highest.height + 6) / tickWidth,
                      -1,
                      1
                    )
                  ),
                  Math.asin(
                    (0,
                    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
                      maxHeight / maxLabelDiagonal,
                      -1,
                      1
                    )
                  ) -
                    Math.asin(
                      (0,
                      _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
                        maxLabelHeight / maxLabelDiagonal,
                        -1,
                        1
                      )
                    )
                )
              );
              labelRotation = Math.max(
                minRotation,
                Math.min(maxRotation, labelRotation)
              );
            }
            this.labelRotation = labelRotation;
          }
          afterCalculateLabelRotation() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.afterCalculateLabelRotation,
              [this]
            );
          }
          afterAutoSkip() {}
          beforeFit() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.beforeFit,
              [this]
            );
          }
          fit() {
            const minSize = {
              width: 0,
              height: 0,
            };
            const {
              chart,
              options: { ticks: tickOpts, title: titleOpts, grid: gridOpts },
            } = this;
            const display = this._isVisible();
            const isHorizontal = this.isHorizontal();
            if (display) {
              const titleHeight = getTitleHeight(titleOpts, chart.options.font);
              if (isHorizontal) {
                minSize.width = this.maxWidth;
                minSize.height = getTickMarkLength(gridOpts) + titleHeight;
              } else {
                minSize.height = this.maxHeight;
                minSize.width = getTickMarkLength(gridOpts) + titleHeight;
              }
              if (tickOpts.display && this.ticks.length) {
                const { first, last, widest, highest } = this._getLabelSizes();
                const tickPadding = tickOpts.padding * 2;
                const angleRadians = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
                  this.labelRotation
                );
                const cos = Math.cos(angleRadians);
                const sin = Math.sin(angleRadians);
                if (isHorizontal) {
                  const labelHeight = tickOpts.mirror
                    ? 0
                    : sin * widest.width + cos * highest.height;
                  minSize.height = Math.min(
                    this.maxHeight,
                    minSize.height + labelHeight + tickPadding
                  );
                } else {
                  const labelWidth = tickOpts.mirror
                    ? 0
                    : cos * widest.width + sin * highest.height;
                  minSize.width = Math.min(
                    this.maxWidth,
                    minSize.width + labelWidth + tickPadding
                  );
                }
                this._calculatePadding(first, last, sin, cos);
              }
            }
            this._handleMargins();
            if (isHorizontal) {
              this.width = this._length =
                chart.width - this._margins.left - this._margins.right;
              this.height = minSize.height;
            } else {
              this.width = minSize.width;
              this.height = this._length =
                chart.height - this._margins.top - this._margins.bottom;
            }
          }
          _calculatePadding(first, last, sin, cos) {
            const {
              ticks: { align, padding },
              position,
            } = this.options;
            const isRotated = this.labelRotation !== 0;
            const labelsBelowTicks = position !== 'top' && this.axis === 'x';
            if (this.isHorizontal()) {
              const offsetLeft = this.getPixelForTick(0) - this.left;
              const offsetRight =
                this.right - this.getPixelForTick(this.ticks.length - 1);
              let paddingLeft = 0;
              let paddingRight = 0;
              if (isRotated) {
                if (labelsBelowTicks) {
                  paddingLeft = cos * first.width;
                  paddingRight = sin * last.height;
                } else {
                  paddingLeft = sin * first.height;
                  paddingRight = cos * last.width;
                }
              } else if (align === 'start') {
                paddingRight = last.width;
              } else if (align === 'end') {
                paddingLeft = first.width;
              } else if (align !== 'inner') {
                paddingLeft = first.width / 2;
                paddingRight = last.width / 2;
              }
              this.paddingLeft = Math.max(
                ((paddingLeft - offsetLeft + padding) * this.width) /
                  (this.width - offsetLeft),
                0
              );
              this.paddingRight = Math.max(
                ((paddingRight - offsetRight + padding) * this.width) /
                  (this.width - offsetRight),
                0
              );
            } else {
              let paddingTop = last.height / 2;
              let paddingBottom = first.height / 2;
              if (align === 'start') {
                paddingTop = 0;
                paddingBottom = first.height;
              } else if (align === 'end') {
                paddingTop = last.height;
                paddingBottom = 0;
              }
              this.paddingTop = paddingTop + padding;
              this.paddingBottom = paddingBottom + padding;
            }
          }
          _handleMargins() {
            if (this._margins) {
              this._margins.left = Math.max(
                this.paddingLeft,
                this._margins.left
              );
              this._margins.top = Math.max(this.paddingTop, this._margins.top);
              this._margins.right = Math.max(
                this.paddingRight,
                this._margins.right
              );
              this._margins.bottom = Math.max(
                this.paddingBottom,
                this._margins.bottom
              );
            }
          }
          afterFit() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              this.options.afterFit,
              [this]
            );
          }
          isHorizontal() {
            const { axis, position } = this.options;
            return position === 'top' || position === 'bottom' || axis === 'x';
          }
          isFullSize() {
            return this.options.fullSize;
          }
          _convertTicksToLabels(ticks) {
            this.beforeTickToLabelConversion();
            this.generateTickLabels(ticks);
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) {
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  ticks[i].label
                )
              ) {
                ticks.splice(i, 1);
                ilen--;
                i--;
              }
            }
            this.afterTickToLabelConversion();
          }
          _getLabelSizes() {
            let labelSizes = this._labelSizes;
            if (!labelSizes) {
              const sampleSize = this.options.ticks.sampleSize;
              let ticks = this.ticks;
              if (sampleSize < ticks.length) {
                ticks = sample(ticks, sampleSize);
              }
              this._labelSizes = labelSizes = this._computeLabelSizes(
                ticks,
                ticks.length,
                this.options.ticks.maxTicksLimit
              );
            }
            return labelSizes;
          }
          _computeLabelSizes(ticks, length, maxTicksLimit) {
            const { ctx, _longestTextCache: caches } = this;
            const widths = [];
            const heights = [];
            const increment = Math.floor(
              length / getTicksLimit(length, maxTicksLimit)
            );
            let widestLabelSize = 0;
            let highestLabelSize = 0;
            let i,
              j,
              jlen,
              label,
              tickFont,
              fontString,
              cache,
              lineHeight,
              width,
              height,
              nestedLabel;
            for (i = 0; i < length; i += increment) {
              label = ticks[i].label;
              tickFont = this._resolveTickFontOptions(i);
              ctx.font = fontString = tickFont.string;
              cache = caches[fontString] = caches[fontString] || {
                data: {},
                gc: [],
              };
              lineHeight = tickFont.lineHeight;
              width = height = 0;
              if (
                !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  label
                ) &&
                !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                  label
                )
              ) {
                width = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(
                  ctx,
                  cache.data,
                  cache.gc,
                  width,
                  label
                );
                height = lineHeight;
              } else if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                  label
                )
              ) {
                for (j = 0, jlen = label.length; j < jlen; ++j) {
                  nestedLabel = label[j];
                  if (
                    !(0,
                    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                      nestedLabel
                    ) &&
                    !(0,
                    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                      nestedLabel
                    )
                  ) {
                    width = (0,
                    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V)(
                      ctx,
                      cache.data,
                      cache.gc,
                      width,
                      nestedLabel
                    );
                    height += lineHeight;
                  }
                }
              }
              widths.push(width);
              heights.push(height);
              widestLabelSize = Math.max(width, widestLabelSize);
              highestLabelSize = Math.max(height, highestLabelSize);
            }
            garbageCollect(caches, length);
            const widest = widths.indexOf(widestLabelSize);
            const highest = heights.indexOf(highestLabelSize);
            const valueAt = (idx) => ({
              width: widths[idx] || 0,
              height: heights[idx] || 0,
            });
            return {
              first: valueAt(0),
              last: valueAt(length - 1),
              widest: valueAt(widest),
              highest: valueAt(highest),
              widths,
              heights,
            };
          }
          getLabelForValue(value) {
            return value;
          }
          getPixelForValue(value, index) {
            return NaN;
          }
          getValueForPixel(pixel) {}
          getPixelForTick(index) {
            const ticks = this.ticks;
            if (index < 0 || index > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index].value);
          }
          getPixelForDecimal(decimal) {
            if (this._reversePixels) {
              decimal = 1 - decimal;
            }
            const pixel = this._startPixel + decimal * this._length;
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.W)(
              this._alignToPixels
                ? (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                    this.chart,
                    pixel,
                    0
                  )
                : pixel
            );
          }
          getDecimalForPixel(pixel) {
            const decimal = (pixel - this._startPixel) / this._length;
            return this._reversePixels ? 1 - decimal : decimal;
          }
          getBasePixel() {
            return this.getPixelForValue(this.getBaseValue());
          }
          getBaseValue() {
            const { min, max } = this;
            return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
          }
          getContext(index) {
            const ticks = this.ticks || [];
            if (index >= 0 && index < ticks.length) {
              const tick = ticks[index];
              return (
                tick.$context ||
                (tick.$context = createTickContext(
                  this.getContext(),
                  index,
                  tick
                ))
              );
            }
            return (
              this.$context ||
              (this.$context = createScaleContext(
                this.chart.getContext(),
                this
              ))
            );
          }
          _tickSize() {
            const optionTicks = this.options.ticks;
            const rot = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.labelRotation
            );
            const cos = Math.abs(Math.cos(rot));
            const sin = Math.abs(Math.sin(rot));
            const labelSizes = this._getLabelSizes();
            const padding = optionTicks.autoSkipPadding || 0;
            const w = labelSizes ? labelSizes.widest.width + padding : 0;
            const h = labelSizes ? labelSizes.highest.height + padding : 0;
            return this.isHorizontal()
              ? h * cos > w * sin
                ? w / cos
                : h / sin
              : h * sin < w * cos
              ? h / cos
              : w / sin;
          }
          _isVisible() {
            const display = this.options.display;
            if (display !== 'auto') {
              return !!display;
            }
            return this.getMatchingVisibleMetas().length > 0;
          }
          _computeGridLineItems(chartArea) {
            const axis = this.axis;
            const chart = this.chart;
            const options = this.options;
            const { grid, position, border } = options;
            const offset = grid.offset;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const ticksLength = ticks.length + (offset ? 1 : 0);
            const tl = getTickMarkLength(grid);
            const items = [];
            const borderOpts = border.setContext(this.getContext());
            const axisWidth = borderOpts.display ? borderOpts.width : 0;
            const axisHalfWidth = axisWidth / 2;
            const alignBorderValue = function (pixel) {
              return (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                chart,
                pixel,
                axisWidth
              );
            };
            let borderValue, i, lineValue, alignedLineValue;
            let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
            if (position === 'top') {
              borderValue = alignBorderValue(this.bottom);
              ty1 = this.bottom - tl;
              ty2 = borderValue - axisHalfWidth;
              y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
              y2 = chartArea.bottom;
            } else if (position === 'bottom') {
              borderValue = alignBorderValue(this.top);
              y1 = chartArea.top;
              y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
              ty1 = borderValue + axisHalfWidth;
              ty2 = this.top + tl;
            } else if (position === 'left') {
              borderValue = alignBorderValue(this.right);
              tx1 = this.right - tl;
              tx2 = borderValue - axisHalfWidth;
              x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
              x2 = chartArea.right;
            } else if (position === 'right') {
              borderValue = alignBorderValue(this.left);
              x1 = chartArea.left;
              x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
              tx1 = borderValue + axisHalfWidth;
              tx2 = this.left + tl;
            } else if (axis === 'x') {
              if (position === 'center') {
                borderValue = alignBorderValue(
                  (chartArea.top + chartArea.bottom) / 2 + 0.5
                );
              } else if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  position
                )
              ) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(
                  this.chart.scales[positionAxisID].getPixelForValue(value)
                );
              }
              y1 = chartArea.top;
              y2 = chartArea.bottom;
              ty1 = borderValue + axisHalfWidth;
              ty2 = ty1 + tl;
            } else if (axis === 'y') {
              if (position === 'center') {
                borderValue = alignBorderValue(
                  (chartArea.left + chartArea.right) / 2
                );
              } else if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  position
                )
              ) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                borderValue = alignBorderValue(
                  this.chart.scales[positionAxisID].getPixelForValue(value)
                );
              }
              tx1 = borderValue - axisHalfWidth;
              tx2 = tx1 - tl;
              x1 = chartArea.left;
              x2 = chartArea.right;
            }
            const limit = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              options.ticks.maxTicksLimit,
              ticksLength
            );
            const step = Math.max(1, Math.ceil(ticksLength / limit));
            for (i = 0; i < ticksLength; i += step) {
              const context = this.getContext(i);
              const optsAtIndex = grid.setContext(context);
              const optsAtIndexBorder = border.setContext(context);
              const lineWidth = optsAtIndex.lineWidth;
              const lineColor = optsAtIndex.color;
              const borderDash = optsAtIndexBorder.dash || [];
              const borderDashOffset = optsAtIndexBorder.dashOffset;
              const tickWidth = optsAtIndex.tickWidth;
              const tickColor = optsAtIndex.tickColor;
              const tickBorderDash = optsAtIndex.tickBorderDash || [];
              const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
              lineValue = getPixelForGridLine(this, i, offset);
              if (lineValue === undefined) {
                continue;
              }
              alignedLineValue = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                chart,
                lineValue,
                lineWidth
              );
              if (isHorizontal) {
                tx1 = tx2 = x1 = x2 = alignedLineValue;
              } else {
                ty1 = ty2 = y1 = y2 = alignedLineValue;
              }
              items.push({
                tx1,
                ty1,
                tx2,
                ty2,
                x1,
                y1,
                x2,
                y2,
                width: lineWidth,
                color: lineColor,
                borderDash,
                borderDashOffset,
                tickWidth,
                tickColor,
                tickBorderDash,
                tickBorderDashOffset,
              });
            }
            this._ticksLength = ticksLength;
            this._borderValue = borderValue;
            return items;
          }
          _computeLabelItems(chartArea) {
            const axis = this.axis;
            const options = this.options;
            const { position, ticks: optionTicks } = options;
            const isHorizontal = this.isHorizontal();
            const ticks = this.ticks;
            const { align, crossAlign, padding, mirror } = optionTicks;
            const tl = getTickMarkLength(options.grid);
            const tickAndPadding = tl + padding;
            const hTickAndPadding = mirror ? -padding : tickAndPadding;
            const rotation = -(0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.labelRotation
            );
            const items = [];
            let i,
              ilen,
              tick,
              label,
              x,
              y,
              textAlign,
              pixel,
              font,
              lineHeight,
              lineCount,
              textOffset;
            let textBaseline = 'middle';
            if (position === 'top') {
              y = this.bottom - hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === 'bottom') {
              y = this.top + hTickAndPadding;
              textAlign = this._getXAxisLabelAlignment();
            } else if (position === 'left') {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (position === 'right') {
              const ret = this._getYAxisLabelAlignment(tl);
              textAlign = ret.textAlign;
              x = ret.x;
            } else if (axis === 'x') {
              if (position === 'center') {
                y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding;
              } else if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  position
                )
              ) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                y =
                  this.chart.scales[positionAxisID].getPixelForValue(value) +
                  tickAndPadding;
              }
              textAlign = this._getXAxisLabelAlignment();
            } else if (axis === 'y') {
              if (position === 'center') {
                x = (chartArea.left + chartArea.right) / 2 - tickAndPadding;
              } else if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                  position
                )
              ) {
                const positionAxisID = Object.keys(position)[0];
                const value = position[positionAxisID];
                x = this.chart.scales[positionAxisID].getPixelForValue(value);
              }
              textAlign = this._getYAxisLabelAlignment(tl).textAlign;
            }
            if (axis === 'y') {
              if (align === 'start') {
                textBaseline = 'top';
              } else if (align === 'end') {
                textBaseline = 'bottom';
              }
            }
            const labelSizes = this._getLabelSizes();
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              label = tick.label;
              const optsAtIndex = optionTicks.setContext(this.getContext(i));
              pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
              font = this._resolveTickFontOptions(i);
              lineHeight = font.lineHeight;
              lineCount = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)
                ? label.length
                : 1;
              const halfCount = lineCount / 2;
              const color = optsAtIndex.color;
              const strokeColor = optsAtIndex.textStrokeColor;
              const strokeWidth = optsAtIndex.textStrokeWidth;
              let tickTextAlign = textAlign;
              if (isHorizontal) {
                x = pixel;
                if (textAlign === 'inner') {
                  if (i === ilen - 1) {
                    tickTextAlign = !this.options.reverse ? 'right' : 'left';
                  } else if (i === 0) {
                    tickTextAlign = !this.options.reverse ? 'left' : 'right';
                  } else {
                    tickTextAlign = 'center';
                  }
                }
                if (position === 'top') {
                  if (crossAlign === 'near' || rotation !== 0) {
                    textOffset = -lineCount * lineHeight + lineHeight / 2;
                  } else if (crossAlign === 'center') {
                    textOffset =
                      -labelSizes.highest.height / 2 -
                      halfCount * lineHeight +
                      lineHeight;
                  } else {
                    textOffset = -labelSizes.highest.height + lineHeight / 2;
                  }
                } else {
                  if (crossAlign === 'near' || rotation !== 0) {
                    textOffset = lineHeight / 2;
                  } else if (crossAlign === 'center') {
                    textOffset =
                      labelSizes.highest.height / 2 - halfCount * lineHeight;
                  } else {
                    textOffset =
                      labelSizes.highest.height - lineCount * lineHeight;
                  }
                }
                if (mirror) {
                  textOffset *= -1;
                }
                if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {
                  x += (lineHeight / 2) * Math.sin(rotation);
                }
              } else {
                y = pixel;
                textOffset = ((1 - lineCount) * lineHeight) / 2;
              }
              let backdrop;
              if (optsAtIndex.showLabelBackdrop) {
                const labelPadding = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
                  optsAtIndex.backdropPadding
                );
                const height = labelSizes.heights[i];
                const width = labelSizes.widths[i];
                let top = textOffset - labelPadding.top;
                let left = 0 - labelPadding.left;
                switch (textBaseline) {
                  case 'middle':
                    top -= height / 2;
                    break;
                  case 'bottom':
                    top -= height;
                    break;
                }
                switch (textAlign) {
                  case 'center':
                    left -= width / 2;
                    break;
                  case 'right':
                    left -= width;
                    break;
                  case 'inner':
                    if (i === ilen - 1) {
                      left -= width;
                    } else if (i > 0) {
                      left -= width / 2;
                    }
                    break;
                }
                backdrop = {
                  left,
                  top,
                  width: width + labelPadding.width,
                  height: height + labelPadding.height,
                  color: optsAtIndex.backdropColor,
                };
              }
              items.push({
                label,
                font,
                textOffset,
                options: {
                  rotation,
                  color,
                  strokeColor,
                  strokeWidth,
                  textAlign: tickTextAlign,
                  textBaseline,
                  translation: [x, y],
                  backdrop,
                },
              });
            }
            return items;
          }
          _getXAxisLabelAlignment() {
            const { position, ticks } = this.options;
            const rotation = -(0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.labelRotation
            );
            if (rotation) {
              return position === 'top' ? 'left' : 'right';
            }
            let align = 'center';
            if (ticks.align === 'start') {
              align = 'left';
            } else if (ticks.align === 'end') {
              align = 'right';
            } else if (ticks.align === 'inner') {
              align = 'inner';
            }
            return align;
          }
          _getYAxisLabelAlignment(tl) {
            const {
              position,
              ticks: { crossAlign, mirror, padding },
            } = this.options;
            const labelSizes = this._getLabelSizes();
            const tickAndPadding = tl + padding;
            const widest = labelSizes.widest.width;
            let textAlign;
            let x;
            if (position === 'left') {
              if (mirror) {
                x = this.right + padding;
                if (crossAlign === 'near') {
                  textAlign = 'left';
                } else if (crossAlign === 'center') {
                  textAlign = 'center';
                  x += widest / 2;
                } else {
                  textAlign = 'right';
                  x += widest;
                }
              } else {
                x = this.right - tickAndPadding;
                if (crossAlign === 'near') {
                  textAlign = 'right';
                } else if (crossAlign === 'center') {
                  textAlign = 'center';
                  x -= widest / 2;
                } else {
                  textAlign = 'left';
                  x = this.left;
                }
              }
            } else if (position === 'right') {
              if (mirror) {
                x = this.left + padding;
                if (crossAlign === 'near') {
                  textAlign = 'right';
                } else if (crossAlign === 'center') {
                  textAlign = 'center';
                  x -= widest / 2;
                } else {
                  textAlign = 'left';
                  x -= widest;
                }
              } else {
                x = this.left + tickAndPadding;
                if (crossAlign === 'near') {
                  textAlign = 'left';
                } else if (crossAlign === 'center') {
                  textAlign = 'center';
                  x += widest / 2;
                } else {
                  textAlign = 'right';
                  x = this.right;
                }
              }
            } else {
              textAlign = 'right';
            }
            return {
              textAlign,
              x,
            };
          }
          _computeLabelArea() {
            if (this.options.ticks.mirror) {
              return;
            }
            const chart = this.chart;
            const position = this.options.position;
            if (position === 'left' || position === 'right') {
              return {
                top: 0,
                left: this.left,
                bottom: chart.height,
                right: this.right,
              };
            }
            if (position === 'top' || position === 'bottom') {
              return {
                top: this.top,
                left: 0,
                bottom: this.bottom,
                right: chart.width,
              };
            }
          }
          drawBackground() {
            const {
              ctx,
              options: { backgroundColor },
              left,
              top,
              width,
              height,
            } = this;
            if (backgroundColor) {
              ctx.save();
              ctx.fillStyle = backgroundColor;
              ctx.fillRect(left, top, width, height);
              ctx.restore();
            }
          }
          getLineWidthForValue(value) {
            const grid = this.options.grid;
            if (!this._isVisible() || !grid.display) {
              return 0;
            }
            const ticks = this.ticks;
            const index = ticks.findIndex((t) => t.value === value);
            if (index >= 0) {
              const opts = grid.setContext(this.getContext(index));
              return opts.lineWidth;
            }
            return 0;
          }
          drawGrid(chartArea) {
            const grid = this.options.grid;
            const ctx = this.ctx;
            const items =
              this._gridLineItems ||
              (this._gridLineItems = this._computeGridLineItems(chartArea));
            let i, ilen;
            const drawLine = (p1, p2, style) => {
              if (!style.width || !style.color) {
                return;
              }
              ctx.save();
              ctx.lineWidth = style.width;
              ctx.strokeStyle = style.color;
              ctx.setLineDash(style.borderDash || []);
              ctx.lineDashOffset = style.borderDashOffset;
              ctx.beginPath();
              ctx.moveTo(p1.x, p1.y);
              ctx.lineTo(p2.x, p2.y);
              ctx.stroke();
              ctx.restore();
            };
            if (grid.display) {
              for (i = 0, ilen = items.length; i < ilen; ++i) {
                const item = items[i];
                if (grid.drawOnChartArea) {
                  drawLine(
                    {
                      x: item.x1,
                      y: item.y1,
                    },
                    {
                      x: item.x2,
                      y: item.y2,
                    },
                    item
                  );
                }
                if (grid.drawTicks) {
                  drawLine(
                    {
                      x: item.tx1,
                      y: item.ty1,
                    },
                    {
                      x: item.tx2,
                      y: item.ty2,
                    },
                    {
                      color: item.tickColor,
                      width: item.tickWidth,
                      borderDash: item.tickBorderDash,
                      borderDashOffset: item.tickBorderDashOffset,
                    }
                  );
                }
              }
            }
          }
          drawBorder() {
            const {
              chart,
              ctx,
              options: { border, grid },
            } = this;
            const borderOpts = border.setContext(this.getContext());
            const axisWidth = border.display ? borderOpts.width : 0;
            if (!axisWidth) {
              return;
            }
            const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
            const borderValue = this._borderValue;
            let x1, x2, y1, y2;
            if (this.isHorizontal()) {
              x1 =
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                  chart,
                  this.left,
                  axisWidth
                ) -
                axisWidth / 2;
              x2 =
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                  chart,
                  this.right,
                  lastLineWidth
                ) +
                lastLineWidth / 2;
              y1 = y2 = borderValue;
            } else {
              y1 =
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                  chart,
                  this.top,
                  axisWidth
                ) -
                axisWidth / 2;
              y2 =
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X)(
                  chart,
                  this.bottom,
                  lastLineWidth
                ) +
                lastLineWidth / 2;
              x1 = x2 = borderValue;
            }
            ctx.save();
            ctx.lineWidth = borderOpts.width;
            ctx.strokeStyle = borderOpts.color;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            ctx.restore();
          }
          drawLabels(chartArea) {
            const optionTicks = this.options.ticks;
            if (!optionTicks.display) {
              return;
            }
            const ctx = this.ctx;
            const area = this._computeLabelArea();
            if (area) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(
                ctx,
                area
              );
            }
            const items = this.getLabelItems(chartArea);
            for (const item of items) {
              const renderTextOptions = item.options;
              const tickFont = item.font;
              const label = item.label;
              const y = item.textOffset;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
                ctx,
                label,
                0,
                y,
                tickFont,
                renderTextOptions
              );
            }
            if (area) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(
                ctx
              );
            }
          }
          drawTitle() {
            const {
              ctx,
              options: { position, title, reverse },
            } = this;
            if (!title.display) {
              return;
            }
            const font = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              title.font
            );
            const padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              title.padding
            );
            const align = title.align;
            let offset = font.lineHeight / 2;
            if (
              position === 'bottom' ||
              position === 'center' ||
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                position
              )
            ) {
              offset += padding.bottom;
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                  title.text
                )
              ) {
                offset += font.lineHeight * (title.text.length - 1);
              }
            } else {
              offset += padding.top;
            }
            const { titleX, titleY, maxWidth, rotation } = titleArgs(
              this,
              offset,
              position,
              align
            );
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
              ctx,
              title.text,
              0,
              0,
              font,
              {
                color: title.color,
                maxWidth,
                rotation,
                textAlign: titleAlign(align, position, reverse),
                textBaseline: 'middle',
                translation: [titleX, titleY],
              }
            );
          }
          draw(chartArea) {
            if (!this._isVisible()) {
              return;
            }
            this.drawBackground();
            this.drawGrid(chartArea);
            this.drawBorder();
            this.drawTitle();
            this.drawLabels(chartArea);
          }
          _layers() {
            const opts = this.options;
            const tz = (opts.ticks && opts.ticks.z) || 0;
            const gz = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              opts.grid && opts.grid.z,
              -1
            );
            const bz = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              opts.border && opts.border.z,
              0
            );
            if (!this._isVisible() || this.draw !== Scale.prototype.draw) {
              return [
                {
                  z: tz,
                  draw: (chartArea) => {
                    this.draw(chartArea);
                  },
                },
              ];
            }
            return [
              {
                z: gz,
                draw: (chartArea) => {
                  this.drawBackground();
                  this.drawGrid(chartArea);
                  this.drawTitle();
                },
              },
              {
                z: bz,
                draw: () => {
                  this.drawBorder();
                },
              },
              {
                z: tz,
                draw: (chartArea) => {
                  this.drawLabels(chartArea);
                },
              },
            ];
          }
          getMatchingVisibleMetas(type) {
            const metas = this.chart.getSortedVisibleDatasetMetas();
            const axisID = this.axis + 'AxisID';
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              const meta = metas[i];
              if (meta[axisID] === this.id && (!type || meta.type === type)) {
                result.push(meta);
              }
            }
            return result;
          }
          _resolveTickFontOptions(index) {
            const opts = this.options.ticks.setContext(this.getContext(index));
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              opts.font
            );
          }
          _maxDigits() {
            const fontSize = this._resolveTickFontOptions(0).lineHeight;
            return (this.isHorizontal() ? this.width : this.height) / fontSize;
          }
        }

        class TypedRegistry {
          constructor(type, scope, override) {
            this.type = type;
            this.scope = scope;
            this.override = override;
            this.items = Object.create(null);
          }
          isForType(type) {
            return Object.prototype.isPrototypeOf.call(
              this.type.prototype,
              type.prototype
            );
          }
          register(item) {
            const proto = Object.getPrototypeOf(item);
            let parentScope;
            if (isIChartComponent(proto)) {
              parentScope = this.register(proto);
            }
            const items = this.items;
            const id = item.id;
            const scope = this.scope + '.' + id;
            if (!id) {
              throw new Error('class does not have id: ' + item);
            }
            if (id in items) {
              return scope;
            }
            items[id] = item;
            registerDefaults(item, scope, parentScope);
            if (this.override) {
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.override(
                item.id,
                item.overrides
              );
            }
            return scope;
          }
          get(id) {
            return this.items[id];
          }
          unregister(item) {
            const items = this.items;
            const id = item.id;
            const scope = this.scope;
            if (id in items) {
              delete items[id];
            }
            if (
              scope &&
              id in
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[scope]
            ) {
              delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d[
                scope
              ][id];
              if (this.override) {
                delete _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__
                  .a3[id];
              }
            }
          }
        }
        function registerDefaults(item, scope, parentScope) {
          const itemDefaults = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a4)(
            Object.create(null),
            [
              parentScope
                ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(
                    parentScope
                  )
                : {},
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.get(
                scope
              ),
              item.defaults,
            ]
          );
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.set(
            scope,
            itemDefaults
          );
          if (item.defaultRoutes) {
            routeDefaults(scope, item.defaultRoutes);
          }
          if (item.descriptors) {
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.describe(
              scope,
              item.descriptors
            );
          }
        }
        function routeDefaults(scope, routes) {
          Object.keys(routes).forEach((property) => {
            const propertyParts = property.split('.');
            const sourceName = propertyParts.pop();
            const sourceScope = [scope].concat(propertyParts).join('.');
            const parts = routes[property].split('.');
            const targetName = parts.pop();
            const targetScope = parts.join('.');
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.route(
              sourceScope,
              sourceName,
              targetScope,
              targetName
            );
          });
        }
        function isIChartComponent(proto) {
          return 'id' in proto && 'defaults' in proto;
        }

        class Registry {
          constructor() {
            this.controllers = new TypedRegistry(
              DatasetController,
              'datasets',
              true
            );
            this.elements = new TypedRegistry(Element, 'elements');
            this.plugins = new TypedRegistry(Object, 'plugins');
            this.scales = new TypedRegistry(Scale, 'scales');
            this._typedRegistries = [
              this.controllers,
              this.scales,
              this.elements,
            ];
          }
          add(...args) {
            this._each('register', args);
          }
          remove(...args) {
            this._each('unregister', args);
          }
          addControllers(...args) {
            this._each('register', args, this.controllers);
          }
          addElements(...args) {
            this._each('register', args, this.elements);
          }
          addPlugins(...args) {
            this._each('register', args, this.plugins);
          }
          addScales(...args) {
            this._each('register', args, this.scales);
          }
          getController(id) {
            return this._get(id, this.controllers, 'controller');
          }
          getElement(id) {
            return this._get(id, this.elements, 'element');
          }
          getPlugin(id) {
            return this._get(id, this.plugins, 'plugin');
          }
          getScale(id) {
            return this._get(id, this.scales, 'scale');
          }
          removeControllers(...args) {
            this._each('unregister', args, this.controllers);
          }
          removeElements(...args) {
            this._each('unregister', args, this.elements);
          }
          removePlugins(...args) {
            this._each('unregister', args, this.plugins);
          }
          removeScales(...args) {
            this._each('unregister', args, this.scales);
          }
          _each(method, args, typedRegistry) {
            [...args].forEach((arg) => {
              const reg = typedRegistry || this._getRegistryForType(arg);
              if (
                typedRegistry ||
                reg.isForType(arg) ||
                (reg === this.plugins && arg.id)
              ) {
                this._exec(method, reg, arg);
              } else {
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                  arg,
                  (item) => {
                    const itemReg =
                      typedRegistry || this._getRegistryForType(item);
                    this._exec(method, itemReg, item);
                  }
                );
              }
            });
          }
          _exec(method, registry, component) {
            const camelMethod = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a5)(method);
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              component['before' + camelMethod],
              [],
              component
            );
            registry[method](component);
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              component['after' + camelMethod],
              [],
              component
            );
          }
          _getRegistryForType(type) {
            for (let i = 0; i < this._typedRegistries.length; i++) {
              const reg = this._typedRegistries[i];
              if (reg.isForType(type)) {
                return reg;
              }
            }
            return this.plugins;
          }
          _get(id, typedRegistry, type) {
            const item = typedRegistry.get(id);
            if (item === undefined) {
              throw new Error('"' + id + '" is not a registered ' + type + '.');
            }
            return item;
          }
        }
        var registry = /* #__PURE__ */ new Registry();

        class PluginService {
          constructor() {
            this._init = [];
          }
          notify(chart, hook, args, filter) {
            if (hook === 'beforeInit') {
              this._init = this._createDescriptors(chart, true);
              this._notify(this._init, chart, 'install');
            }
            const descriptors = filter
              ? this._descriptors(chart).filter(filter)
              : this._descriptors(chart);
            const result = this._notify(descriptors, chart, hook, args);
            if (hook === 'afterDestroy') {
              this._notify(descriptors, chart, 'stop');
              this._notify(this._init, chart, 'uninstall');
            }
            return result;
          }
          _notify(descriptors, chart, hook, args) {
            args = args || {};
            for (const descriptor of descriptors) {
              const plugin = descriptor.plugin;
              const method = plugin[hook];
              const params = [chart, args, descriptor.options];
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                  method,
                  params,
                  plugin
                ) === false &&
                args.cancelable
              ) {
                return false;
              }
            }
            return true;
          }
          invalidate() {
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                this._cache
              )
            ) {
              this._oldCache = this._cache;
              this._cache = undefined;
            }
          }
          _descriptors(chart) {
            if (this._cache) {
              return this._cache;
            }
            const descriptors = (this._cache = this._createDescriptors(chart));
            this._notifyStateChanges(chart);
            return descriptors;
          }
          _createDescriptors(chart, all) {
            const config = chart && chart.config;
            const options = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              config.options && config.options.plugins,
              {}
            );
            const plugins = allPlugins(config);
            return options === false && !all
              ? []
              : createDescriptors(chart, plugins, options, all);
          }
          _notifyStateChanges(chart) {
            const previousDescriptors = this._oldCache || [];
            const descriptors = this._cache;
            const diff = (a, b) =>
              a.filter((x) => !b.some((y) => x.plugin.id === y.plugin.id));
            this._notify(diff(previousDescriptors, descriptors), chart, 'stop');
            this._notify(
              diff(descriptors, previousDescriptors),
              chart,
              'start'
            );
          }
        }
        function allPlugins(config) {
          const localIds = {};
          const plugins = [];
          const keys = Object.keys(registry.plugins.items);
          for (let i = 0; i < keys.length; i++) {
            plugins.push(registry.getPlugin(keys[i]));
          }
          const local = config.plugins || [];
          for (let i = 0; i < local.length; i++) {
            const plugin = local[i];
            if (plugins.indexOf(plugin) === -1) {
              plugins.push(plugin);
              localIds[plugin.id] = true;
            }
          }
          return {
            plugins,
            localIds,
          };
        }
        function getOpts(options, all) {
          if (!all && options === false) {
            return null;
          }
          if (options === true) {
            return {};
          }
          return options;
        }
        function createDescriptors(chart, { plugins, localIds }, options, all) {
          const result = [];
          const context = chart.getContext();
          for (const plugin of plugins) {
            const id = plugin.id;
            const opts = getOpts(options[id], all);
            if (opts === null) {
              continue;
            }
            result.push({
              plugin,
              options: pluginOpts(
                chart.config,
                {
                  plugin,
                  local: localIds[id],
                },
                opts,
                context
              ),
            });
          }
          return result;
        }
        function pluginOpts(config, { plugin, local }, opts, context) {
          const keys = config.pluginScopeKeys(plugin);
          const scopes = config.getOptionScopes(opts, keys);
          if (local && plugin.defaults) {
            scopes.push(plugin.defaults);
          }
          return config.createResolver(scopes, context, [''], {
            scriptable: false,
            indexable: false,
            allKeys: true,
          });
        }

        function getIndexAxis(type, options) {
          const datasetDefaults =
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.datasets[
              type
            ] || {};
          const datasetOptions = (options.datasets || {})[type] || {};
          return (
            datasetOptions.indexAxis ||
            options.indexAxis ||
            datasetDefaults.indexAxis ||
            'x'
          );
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
          let axis = id;
          if (id === '_index_') {
            axis = indexAxis;
          } else if (id === '_value_') {
            axis = indexAxis === 'x' ? 'y' : 'x';
          }
          return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
          return axis === indexAxis ? '_index_' : '_value_';
        }
        function idMatchesAxis(id) {
          if (id === 'x' || id === 'y' || id === 'r') {
            return id;
          }
        }
        function axisFromPosition(position) {
          if (position === 'top' || position === 'bottom') {
            return 'x';
          }
          if (position === 'left' || position === 'right') {
            return 'y';
          }
        }
        function determineAxis(id, ...scaleOptions) {
          if (idMatchesAxis(id)) {
            return id;
          }
          for (const opts of scaleOptions) {
            const axis =
              opts.axis ||
              axisFromPosition(opts.position) ||
              (id.length > 1 && idMatchesAxis(id[0].toLowerCase()));
            if (axis) {
              return axis;
            }
          }
          throw new Error(
            `Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`
          );
        }
        function getAxisFromDataset(id, axis, dataset) {
          if (dataset[axis + 'AxisID'] === id) {
            return {
              axis,
            };
          }
        }
        function retrieveAxisFromDatasets(id, config) {
          if (config.data && config.data.datasets) {
            const boundDs = config.data.datasets.filter(
              (d) => d.xAxisID === id || d.yAxisID === id
            );
            if (boundDs.length) {
              return (
                getAxisFromDataset(id, 'x', boundDs[0]) ||
                getAxisFromDataset(id, 'y', boundDs[0])
              );
            }
          }
          return {};
        }
        function mergeScaleConfig(config, options) {
          const chartDefaults =
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[
              config.type
            ] || {
              scales: {},
            };
          const configScales = options.scales || {};
          const chartIndexAxis = getIndexAxis(config.type, options);
          const scales = Object.create(null);
          Object.keys(configScales).forEach((id) => {
            const scaleConf = configScales[id];
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                scaleConf
              )
            ) {
              return console.error(
                `Invalid scale configuration for scale: ${id}`
              );
            }
            if (scaleConf._proxy) {
              return console.warn(
                `Ignoring resolver passed as options for scale: ${id}`
              );
            }
            const axis = determineAxis(
              id,
              scaleConf,
              retrieveAxisFromDatasets(id, config),
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scales[
                scaleConf.type
              ]
            );
            const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
            const defaultScaleOptions = chartDefaults.scales || {};
            scales[id] = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(
              Object.create(null),
              [
                {
                  axis,
                },
                scaleConf,
                defaultScaleOptions[axis],
                defaultScaleOptions[defaultId],
              ]
            );
          });
          config.data.datasets.forEach((dataset) => {
            const type = dataset.type || config.type;
            const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
            const datasetDefaults =
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[
                type
              ] || {};
            const defaultScaleOptions = datasetDefaults.scales || {};
            Object.keys(defaultScaleOptions).forEach((defaultID) => {
              const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
              const id = dataset[axis + 'AxisID'] || axis;
              scales[id] = scales[id] || Object.create(null);
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(
                scales[id],
                [
                  {
                    axis,
                  },
                  configScales[id],
                  defaultScaleOptions[defaultID],
                ]
              );
            });
          });
          Object.keys(scales).forEach((key) => {
            const scale = scales[key];
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(
              scale,
              [
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
                  .scales[scale.type],
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.scale,
              ]
            );
          });
          return scales;
        }
        function initOptions(config) {
          const options = config.options || (config.options = {});
          options.plugins = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            options.plugins,
            {}
          );
          options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
          data = data || {};
          data.datasets = data.datasets || [];
          data.labels = data.labels || [];
          return data;
        }
        function initConfig(config) {
          config = config || {};
          config.data = initData(config.data);
          initOptions(config);
          return config;
        }
        const keyCache = new Map();
        const keysCached = new Set();
        function cachedKeys(cacheKey, generate) {
          let keys = keyCache.get(cacheKey);
          if (!keys) {
            keys = generate();
            keyCache.set(cacheKey, keys);
            keysCached.add(keys);
          }
          return keys;
        }
        const addIfFound = (set, obj, key) => {
          const opts = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f)(obj, key);
          if (opts !== undefined) {
            set.add(opts);
          }
        };
        class Config {
          constructor(config) {
            this._config = initConfig(config);
            this._scopeCache = new Map();
            this._resolverCache = new Map();
          }
          get platform() {
            return this._config.platform;
          }
          get type() {
            return this._config.type;
          }
          set type(type) {
            this._config.type = type;
          }
          get data() {
            return this._config.data;
          }
          set data(data) {
            this._config.data = initData(data);
          }
          get options() {
            return this._config.options;
          }
          set options(options) {
            this._config.options = options;
          }
          get plugins() {
            return this._config.plugins;
          }
          update() {
            const config = this._config;
            this.clearCache();
            initOptions(config);
          }
          clearCache() {
            this._scopeCache.clear();
            this._resolverCache.clear();
          }
          datasetScopeKeys(datasetType) {
            return cachedKeys(datasetType, () => [
              [`datasets.${datasetType}`, ''],
            ]);
          }
          datasetAnimationScopeKeys(datasetType, transition) {
            return cachedKeys(`${datasetType}.transition.${transition}`, () => [
              [
                `datasets.${datasetType}.transitions.${transition}`,
                `transitions.${transition}`,
              ],
              [`datasets.${datasetType}`, ''],
            ]);
          }
          datasetElementScopeKeys(datasetType, elementType) {
            return cachedKeys(`${datasetType}-${elementType}`, () => [
              [
                `datasets.${datasetType}.elements.${elementType}`,
                `datasets.${datasetType}`,
                `elements.${elementType}`,
                '',
              ],
            ]);
          }
          pluginScopeKeys(plugin) {
            const id = plugin.id;
            const type = this.type;
            return cachedKeys(`${type}-plugin-${id}`, () => [
              [`plugins.${id}`, ...(plugin.additionalOptionScopes || [])],
            ]);
          }
          _cachedScopes(mainScope, resetCache) {
            const _scopeCache = this._scopeCache;
            let cache = _scopeCache.get(mainScope);
            if (!cache || resetCache) {
              cache = new Map();
              _scopeCache.set(mainScope, cache);
            }
            return cache;
          }
          getOptionScopes(mainScope, keyLists, resetCache) {
            const { options, type } = this;
            const cache = this._cachedScopes(mainScope, resetCache);
            const cached = cache.get(keyLists);
            if (cached) {
              return cached;
            }
            const scopes = new Set();
            keyLists.forEach((keys) => {
              if (mainScope) {
                scopes.add(mainScope);
                keys.forEach((key) => addIfFound(scopes, mainScope, key));
              }
              keys.forEach((key) => addIfFound(scopes, options, key));
              keys.forEach((key) =>
                addIfFound(
                  scopes,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[
                    type
                  ] || {},
                  key
                )
              );
              keys.forEach((key) =>
                addIfFound(
                  scopes,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,
                  key
                )
              );
              keys.forEach((key) =>
                addIfFound(
                  scopes,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6,
                  key
                )
              );
            });
            const array = Array.from(scopes);
            if (array.length === 0) {
              array.push(Object.create(null));
            }
            if (keysCached.has(keyLists)) {
              cache.set(keyLists, array);
            }
            return array;
          }
          chartOptionScopes() {
            const { options, type } = this;
            return [
              options,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3[
                type
              ] || {},
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
                .datasets[type] || {},
              {
                type,
              },
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a6,
            ];
          }
          resolveNamedOptions(scopes, names, context, prefixes = ['']) {
            const result = {
              $shared: true,
            };
            const { resolver, subPrefixes } = getResolver(
              this._resolverCache,
              scopes,
              prefixes
            );
            let options = resolver;
            if (needContext(resolver, names)) {
              result.$shared = false;
              context = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(
                context
              )
                ? context()
                : context;
              const subResolver = this.createResolver(
                scopes,
                context,
                subPrefixes
              );
              options = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(
                resolver,
                context,
                subResolver
              );
            }
            for (const prop of names) {
              result[prop] = options[prop];
            }
            return result;
          }
          createResolver(scopes, context, prefixes = [''], descriptorDefaults) {
            const { resolver } = getResolver(
              this._resolverCache,
              scopes,
              prefixes
            );
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(context)
              ? (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8)(
                  resolver,
                  context,
                  undefined,
                  descriptorDefaults
                )
              : resolver;
          }
        }
        function getResolver(resolverCache, scopes, prefixes) {
          let cache = resolverCache.get(scopes);
          if (!cache) {
            cache = new Map();
            resolverCache.set(scopes, cache);
          }
          const cacheKey = prefixes.join();
          let cached = cache.get(cacheKey);
          if (!cached) {
            const resolver = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a9)(
              scopes,
              prefixes
            );
            cached = {
              resolver,
              subPrefixes: prefixes.filter(
                (p) => !p.toLowerCase().includes('hover')
              ),
            };
            cache.set(cacheKey, cached);
          }
          return cached;
        }
        const hasFunction = (value) =>
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
            value
          ) &&
          Object.getOwnPropertyNames(value).some((key) =>
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(
              value[key]
            )
          );
        function needContext(proxy, names) {
          const { isScriptable, isIndexable } = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aa)(proxy);
          for (const prop of names) {
            const scriptable = isScriptable(prop);
            const indexable = isIndexable(prop);
            const value = (indexable || scriptable) && proxy[prop];
            if (
              (scriptable &&
                ((0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(
                  value
                ) ||
                  hasFunction(value))) ||
              (indexable &&
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                  value
                ))
            ) {
              return true;
            }
          }
          return false;
        }

        var version = '4.4.9';

        const KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];
        function positionIsHorizontal(position, axis) {
          return (
            position === 'top' ||
            position === 'bottom' ||
            (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x')
          );
        }
        function compare2Level(l1, l2) {
          return function (a, b) {
            return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
          };
        }
        function onAnimationsComplete(context) {
          const chart = context.chart;
          const animationOptions = chart.options.animation;
          chart.notifyPlugins('afterRender');
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
            animationOptions && animationOptions.onComplete,
            [context],
            chart
          );
        }
        function onAnimationProgress(context) {
          const chart = context.chart;
          const animationOptions = chart.options.animation;
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
            animationOptions && animationOptions.onProgress,
            [context],
            chart
          );
        }
        function getCanvas(item) {
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M)() &&
            typeof item === 'string'
          ) {
            item = document.getElementById(item);
          } else if (item && item.length) {
            item = item[0];
          }
          if (item && item.canvas) {
            item = item.canvas;
          }
          return item;
        }
        const instances = {};
        const getChart = (key) => {
          const canvas = getCanvas(key);
          return Object.values(instances)
            .filter((c) => c.canvas === canvas)
            .pop();
        };
        function moveNumericKeys(obj, start, move) {
          const keys = Object.keys(obj);
          for (const key of keys) {
            const intKey = +key;
            if (intKey >= start) {
              const value = obj[key];
              delete obj[key];
              if (move > 0 || intKey > start) {
                obj[intKey + move] = value;
              }
            }
          }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
          if (!inChartArea || e.type === 'mouseout') {
            return null;
          }
          if (isClick) {
            return lastEvent;
          }
          return e;
        }
        class Chart {
          static defaults =
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d;
          static instances = instances;
          static overrides =
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a3;
          static registry = registry;
          static version = version;
          static getChart = getChart;
          static register(...items) {
            registry.add(...items);
            invalidatePlugins();
          }
          static unregister(...items) {
            registry.remove(...items);
            invalidatePlugins();
          }
          constructor(item, userConfig) {
            const config = (this.config = new Config(userConfig));
            const initialCanvas = getCanvas(item);
            const existingChart = getChart(initialCanvas);
            if (existingChart) {
              throw new Error(
                "Canvas is already in use. Chart with ID '" +
                  existingChart.id +
                  "'" +
                  " must be destroyed before the canvas with ID '" +
                  existingChart.canvas.id +
                  "' can be reused."
              );
            }
            const options = config.createResolver(
              config.chartOptionScopes(),
              this.getContext()
            );
            this.platform = new (config.platform ||
              _detectPlatform(initialCanvas))();
            this.platform.updateConfig(config);
            const context = this.platform.acquireContext(
              initialCanvas,
              options.aspectRatio
            );
            const canvas = context && context.canvas;
            const height = canvas && canvas.height;
            const width = canvas && canvas.width;
            this.id = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ac)();
            this.ctx = context;
            this.canvas = canvas;
            this.width = width;
            this.height = height;
            this._options = options;
            this._aspectRatio = this.aspectRatio;
            this._layers = [];
            this._metasets = [];
            this._stacks = undefined;
            this.boxes = [];
            this.currentDevicePixelRatio = undefined;
            this.chartArea = undefined;
            this._active = [];
            this._lastEvent = undefined;
            this._listeners = {};
            this._responsiveListeners = undefined;
            this._sortedMetasets = [];
            this.scales = {};
            this._plugins = new PluginService();
            this.$proxies = {};
            this._hiddenIndices = {};
            this.attached = false;
            this._animationsDisabled = undefined;
            this.$context = undefined;
            this._doResize = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ad)(
              (mode) => this.update(mode),
              options.resizeDelay || 0
            );
            this._dataChanges = [];
            instances[this.id] = this;
            if (!context || !canvas) {
              console.error(
                "Failed to create chart: can't acquire context from the given item"
              );
              return;
            }
            animator.listen(this, 'complete', onAnimationsComplete);
            animator.listen(this, 'progress', onAnimationProgress);
            this._initialize();
            if (this.attached) {
              this.update();
            }
          }
          get aspectRatio() {
            const {
              options: { aspectRatio, maintainAspectRatio },
              width,
              height,
              _aspectRatio,
            } = this;
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                aspectRatio
              )
            ) {
              return aspectRatio;
            }
            if (maintainAspectRatio && _aspectRatio) {
              return _aspectRatio;
            }
            return height ? width / height : null;
          }
          get data() {
            return this.config.data;
          }
          set data(data) {
            this.config.data = data;
          }
          get options() {
            return this._options;
          }
          set options(options) {
            this.config.options = options;
          }
          get registry() {
            return registry;
          }
          _initialize() {
            this.notifyPlugins('beforeInit');
            if (this.options.responsive) {
              this.resize();
            } else {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(
                this,
                this.options.devicePixelRatio
              );
            }
            this.bindEvents();
            this.notifyPlugins('afterInit');
            return this;
          }
          clear() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(
              this.canvas,
              this.ctx
            );
            return this;
          }
          stop() {
            animator.stop(this);
            return this;
          }
          resize(width, height) {
            if (!animator.running(this)) {
              this._resize(width, height);
            } else {
              this._resizeBeforeDraw = {
                width,
                height,
              };
            }
          }
          _resize(width, height) {
            const options = this.options;
            const canvas = this.canvas;
            const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
            const newSize = this.platform.getMaximumSize(
              canvas,
              width,
              height,
              aspectRatio
            );
            const newRatio =
              options.devicePixelRatio || this.platform.getDevicePixelRatio();
            const mode = this.width ? 'resize' : 'attach';
            this.width = newSize.width;
            this.height = newSize.height;
            this._aspectRatio = this.aspectRatio;
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae)(
                this,
                newRatio,
                true
              )
            ) {
              return;
            }
            this.notifyPlugins('resize', {
              size: newSize,
            });
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
              options.onResize,
              [this, newSize],
              this
            );
            if (this.attached) {
              if (this._doResize(mode)) {
                this.render();
              }
            }
          }
          ensureScalesHaveIDs() {
            const options = this.options;
            const scalesOptions = options.scales || {};
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              scalesOptions,
              (axisOptions, axisID) => {
                axisOptions.id = axisID;
              }
            );
          }
          buildOrUpdateScales() {
            const options = this.options;
            const scaleOpts = options.scales;
            const scales = this.scales;
            const updated = Object.keys(scales).reduce((obj, id) => {
              obj[id] = false;
              return obj;
            }, {});
            let items = [];
            if (scaleOpts) {
              items = items.concat(
                Object.keys(scaleOpts).map((id) => {
                  const scaleOptions = scaleOpts[id];
                  const axis = determineAxis(id, scaleOptions);
                  const isRadial = axis === 'r';
                  const isHorizontal = axis === 'x';
                  return {
                    options: scaleOptions,
                    dposition: isRadial
                      ? 'chartArea'
                      : isHorizontal
                      ? 'bottom'
                      : 'left',
                    dtype: isRadial
                      ? 'radialLinear'
                      : isHorizontal
                      ? 'category'
                      : 'linear',
                  };
                })
              );
            }
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              items,
              (item) => {
                const scaleOptions = item.options;
                const id = scaleOptions.id;
                const axis = determineAxis(id, scaleOptions);
                const scaleType = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                  scaleOptions.type,
                  item.dtype
                );
                if (
                  scaleOptions.position === undefined ||
                  positionIsHorizontal(scaleOptions.position, axis) !==
                    positionIsHorizontal(item.dposition)
                ) {
                  scaleOptions.position = item.dposition;
                }
                updated[id] = true;
                let scale = null;
                if (id in scales && scales[id].type === scaleType) {
                  scale = scales[id];
                } else {
                  const scaleClass = registry.getScale(scaleType);
                  scale = new scaleClass({
                    id,
                    type: scaleType,
                    ctx: this.ctx,
                    chart: this,
                  });
                  scales[scale.id] = scale;
                }
                scale.init(scaleOptions, options);
              }
            );
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              updated,
              (hasUpdated, id) => {
                if (!hasUpdated) {
                  delete scales[id];
                }
              }
            );
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              scales,
              (scale) => {
                layouts.configure(this, scale, scale.options);
                layouts.addBox(this, scale);
              }
            );
          }
          _updateMetasets() {
            const metasets = this._metasets;
            const numData = this.data.datasets.length;
            const numMeta = metasets.length;
            metasets.sort((a, b) => a.index - b.index);
            if (numMeta > numData) {
              for (let i = numData; i < numMeta; ++i) {
                this._destroyDatasetMeta(i);
              }
              metasets.splice(numData, numMeta - numData);
            }
            this._sortedMetasets = metasets
              .slice(0)
              .sort(compare2Level('order', 'index'));
          }
          _removeUnreferencedMetasets() {
            const {
              _metasets: metasets,
              data: { datasets },
            } = this;
            if (metasets.length > datasets.length) {
              delete this._stacks;
            }
            metasets.forEach((meta, index) => {
              if (datasets.filter((x) => x === meta._dataset).length === 0) {
                this._destroyDatasetMeta(index);
              }
            });
          }
          buildOrUpdateControllers() {
            const newControllers = [];
            const datasets = this.data.datasets;
            let i, ilen;
            this._removeUnreferencedMetasets();
            for (i = 0, ilen = datasets.length; i < ilen; i++) {
              const dataset = datasets[i];
              let meta = this.getDatasetMeta(i);
              const type = dataset.type || this.config.type;
              if (meta.type && meta.type !== type) {
                this._destroyDatasetMeta(i);
                meta = this.getDatasetMeta(i);
              }
              meta.type = type;
              meta.indexAxis =
                dataset.indexAxis || getIndexAxis(type, this.options);
              meta.order = dataset.order || 0;
              meta.index = i;
              meta.label = '' + dataset.label;
              meta.visible = this.isDatasetVisible(i);
              if (meta.controller) {
                meta.controller.updateIndex(i);
                meta.controller.linkScales();
              } else {
                const ControllerClass = registry.getController(type);
                const { datasetElementType, dataElementType } =
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
                    .datasets[type];
                Object.assign(ControllerClass, {
                  dataElementType: registry.getElement(dataElementType),
                  datasetElementType:
                    datasetElementType &&
                    registry.getElement(datasetElementType),
                });
                meta.controller = new ControllerClass(this, i);
                newControllers.push(meta.controller);
              }
            }
            this._updateMetasets();
            return newControllers;
          }
          _resetElements() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this.data.datasets,
              (dataset, datasetIndex) => {
                this.getDatasetMeta(datasetIndex).controller.reset();
              },
              this
            );
          }
          reset() {
            this._resetElements();
            this.notifyPlugins('reset');
          }
          update(mode) {
            const config = this.config;
            config.update();
            const options = (this._options = config.createResolver(
              config.chartOptionScopes(),
              this.getContext()
            ));
            const animsDisabled = (this._animationsDisabled =
              !options.animation);
            this._updateScales();
            this._checkEventBindings();
            this._updateHiddenIndices();
            this._plugins.invalidate();
            if (
              this.notifyPlugins('beforeUpdate', {
                mode,
                cancelable: true,
              }) === false
            ) {
              return;
            }
            const newControllers = this.buildOrUpdateControllers();
            this.notifyPlugins('beforeElementsUpdate');
            let minPadding = 0;
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
              const { controller } = this.getDatasetMeta(i);
              const reset =
                !animsDisabled && newControllers.indexOf(controller) === -1;
              controller.buildOrUpdateElements(reset);
              minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
            }
            minPadding = this._minPadding = options.layout.autoPadding
              ? minPadding
              : 0;
            this._updateLayout(minPadding);
            if (!animsDisabled) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                newControllers,
                (controller) => {
                  controller.reset();
                }
              );
            }
            this._updateDatasets(mode);
            this.notifyPlugins('afterUpdate', {
              mode,
            });
            this._layers.sort(compare2Level('z', '_idx'));
            const { _active, _lastEvent } = this;
            if (_lastEvent) {
              this._eventHandler(_lastEvent, true);
            } else if (_active.length) {
              this._updateHoverStyles(_active, _active, true);
            }
            this.render();
          }
          _updateScales() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this.scales,
              (scale) => {
                layouts.removeBox(this, scale);
              }
            );
            this.ensureScalesHaveIDs();
            this.buildOrUpdateScales();
          }
          _checkEventBindings() {
            const options = this.options;
            const existingEvents = new Set(Object.keys(this._listeners));
            const newEvents = new Set(options.events);
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(
                existingEvents,
                newEvents
              ) ||
              !!this._responsiveListeners !== options.responsive
            ) {
              this.unbindEvents();
              this.bindEvents();
            }
          }
          _updateHiddenIndices() {
            const { _hiddenIndices } = this;
            const changes = this._getUniformDataChanges() || [];
            for (const { method, start, count } of changes) {
              const move = method === '_removeElements' ? -count : count;
              moveNumericKeys(_hiddenIndices, start, move);
            }
          }
          _getUniformDataChanges() {
            const _dataChanges = this._dataChanges;
            if (!_dataChanges || !_dataChanges.length) {
              return;
            }
            this._dataChanges = [];
            const datasetCount = this.data.datasets.length;
            const makeSet = (idx) =>
              new Set(
                _dataChanges
                  .filter((c) => c[0] === idx)
                  .map((c, i) => i + ',' + c.splice(1).join(','))
              );
            const changeSet = makeSet(0);
            for (let i = 1; i < datasetCount; i++) {
              if (
                !(0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag)(
                  changeSet,
                  makeSet(i)
                )
              ) {
                return;
              }
            }
            return Array.from(changeSet)
              .map((c) => c.split(','))
              .map((a) => ({
                method: a[1],
                start: +a[2],
                count: +a[3],
              }));
          }
          _updateLayout(minPadding) {
            if (
              this.notifyPlugins('beforeLayout', {
                cancelable: true,
              }) === false
            ) {
              return;
            }
            layouts.update(this, this.width, this.height, minPadding);
            const area = this.chartArea;
            const noArea = area.width <= 0 || area.height <= 0;
            this._layers = [];
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this.boxes,
              (box) => {
                if (noArea && box.position === 'chartArea') {
                  return;
                }
                if (box.configure) {
                  box.configure();
                }
                this._layers.push(...box._layers());
              },
              this
            );
            this._layers.forEach((item, index) => {
              item._idx = index;
            });
            this.notifyPlugins('afterLayout');
          }
          _updateDatasets(mode) {
            if (
              this.notifyPlugins('beforeDatasetsUpdate', {
                mode,
                cancelable: true,
              }) === false
            ) {
              return;
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this.getDatasetMeta(i).controller.configure();
            }
            for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._updateDataset(
                i,
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7)(
                  mode
                )
                  ? mode({
                      datasetIndex: i,
                    })
                  : mode
              );
            }
            this.notifyPlugins('afterDatasetsUpdate', {
              mode,
            });
          }
          _updateDataset(index, mode) {
            const meta = this.getDatasetMeta(index);
            const args = {
              meta,
              index,
              mode,
              cancelable: true,
            };
            if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {
              return;
            }
            meta.controller._update(mode);
            args.cancelable = false;
            this.notifyPlugins('afterDatasetUpdate', args);
          }
          render() {
            if (
              this.notifyPlugins('beforeRender', {
                cancelable: true,
              }) === false
            ) {
              return;
            }
            if (animator.has(this)) {
              if (this.attached && !animator.running(this)) {
                animator.start(this);
              }
            } else {
              this.draw();
              onAnimationsComplete({
                chart: this,
              });
            }
          }
          draw() {
            let i;
            if (this._resizeBeforeDraw) {
              const { width, height } = this._resizeBeforeDraw;
              this._resizeBeforeDraw = null;
              this._resize(width, height);
            }
            this.clear();
            if (this.width <= 0 || this.height <= 0) {
              return;
            }
            if (
              this.notifyPlugins('beforeDraw', {
                cancelable: true,
              }) === false
            ) {
              return;
            }
            const layers = this._layers;
            for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
              layers[i].draw(this.chartArea);
            }
            this._drawDatasets();
            for (; i < layers.length; ++i) {
              layers[i].draw(this.chartArea);
            }
            this.notifyPlugins('afterDraw');
          }
          _getSortedDatasetMetas(filterVisible) {
            const metasets = this._sortedMetasets;
            const result = [];
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) {
              const meta = metasets[i];
              if (!filterVisible || meta.visible) {
                result.push(meta);
              }
            }
            return result;
          }
          getSortedVisibleDatasetMetas() {
            return this._getSortedDatasetMetas(true);
          }
          _drawDatasets() {
            if (
              this.notifyPlugins('beforeDatasetsDraw', {
                cancelable: true,
              }) === false
            ) {
              return;
            }
            const metasets = this.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              this._drawDataset(metasets[i]);
            }
            this.notifyPlugins('afterDatasetsDraw');
          }
          _drawDataset(meta) {
            const ctx = this.ctx;
            const args = {
              meta,
              index: meta.index,
              cancelable: true,
            };
            const clip = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(
              this,
              meta
            );
            if (this.notifyPlugins('beforeDatasetDraw', args) === false) {
              return;
            }
            if (clip) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(
                ctx,
                clip
              );
            }
            meta.controller.draw();
            if (clip) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(
                ctx
              );
            }
            args.cancelable = false;
            this.notifyPlugins('afterDatasetDraw', args);
          }
          isPointInArea(point) {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
              point,
              this.chartArea,
              this._minPadding
            );
          }
          getElementsAtEventForMode(e, mode, options, useFinalPosition) {
            const method = Interaction.modes[mode];
            if (typeof method === 'function') {
              return method(this, e, options, useFinalPosition);
            }
            return [];
          }
          getDatasetMeta(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            const metasets = this._metasets;
            let meta = metasets
              .filter((x) => x && x._dataset === dataset)
              .pop();
            if (!meta) {
              meta = {
                type: null,
                data: [],
                dataset: null,
                controller: null,
                hidden: null,
                xAxisID: null,
                yAxisID: null,
                order: (dataset && dataset.order) || 0,
                index: datasetIndex,
                _dataset: dataset,
                _parsed: [],
                _sorted: false,
              };
              metasets.push(meta);
            }
            return meta;
          }
          getContext() {
            return (
              this.$context ||
              (this.$context = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(null, {
                chart: this,
                type: 'chart',
              }))
            );
          }
          getVisibleDatasetCount() {
            return this.getSortedVisibleDatasetMetas().length;
          }
          isDatasetVisible(datasetIndex) {
            const dataset = this.data.datasets[datasetIndex];
            if (!dataset) {
              return false;
            }
            const meta = this.getDatasetMeta(datasetIndex);
            return typeof meta.hidden === 'boolean'
              ? !meta.hidden
              : !dataset.hidden;
          }
          setDatasetVisibility(datasetIndex, visible) {
            const meta = this.getDatasetMeta(datasetIndex);
            meta.hidden = !visible;
          }
          toggleDataVisibility(index) {
            this._hiddenIndices[index] = !this._hiddenIndices[index];
          }
          getDataVisibility(index) {
            return !this._hiddenIndices[index];
          }
          _updateVisibility(datasetIndex, dataIndex, visible) {
            const mode = visible ? 'show' : 'hide';
            const meta = this.getDatasetMeta(datasetIndex);
            const anims = meta.controller._resolveAnimations(undefined, mode);
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h)(
                dataIndex
              )
            ) {
              meta.data[dataIndex].hidden = !visible;
              this.update();
            } else {
              this.setDatasetVisibility(datasetIndex, visible);
              anims.update(meta, {
                visible,
              });
              this.update((ctx) =>
                ctx.datasetIndex === datasetIndex ? mode : undefined
              );
            }
          }
          hide(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, false);
          }
          show(datasetIndex, dataIndex) {
            this._updateVisibility(datasetIndex, dataIndex, true);
          }
          _destroyDatasetMeta(datasetIndex) {
            const meta = this._metasets[datasetIndex];
            if (meta && meta.controller) {
              meta.controller._destroy();
            }
            delete this._metasets[datasetIndex];
          }
          _stop() {
            let i, ilen;
            this.stop();
            animator.remove(this);
            for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
              this._destroyDatasetMeta(i);
            }
          }
          destroy() {
            this.notifyPlugins('beforeDestroy');
            const { canvas, ctx } = this;
            this._stop();
            this.config.clearCache();
            if (canvas) {
              this.unbindEvents();
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af)(
                canvas,
                ctx
              );
              this.platform.releaseContext(ctx);
              this.canvas = null;
              this.ctx = null;
            }
            delete instances[this.id];
            this.notifyPlugins('afterDestroy');
          }
          toBase64Image(...args) {
            return this.canvas.toDataURL(...args);
          }
          bindEvents() {
            this.bindUserEvents();
            if (this.options.responsive) {
              this.bindResponsiveEvents();
            } else {
              this.attached = true;
            }
          }
          bindUserEvents() {
            const listeners = this._listeners;
            const platform = this.platform;
            const _add = (type, listener) => {
              platform.addEventListener(this, type, listener);
              listeners[type] = listener;
            };
            const listener = (e, x, y) => {
              e.offsetX = x;
              e.offsetY = y;
              this._eventHandler(e);
            };
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this.options.events,
              (type) => _add(type, listener)
            );
          }
          bindResponsiveEvents() {
            if (!this._responsiveListeners) {
              this._responsiveListeners = {};
            }
            const listeners = this._responsiveListeners;
            const platform = this.platform;
            const _add = (type, listener) => {
              platform.addEventListener(this, type, listener);
              listeners[type] = listener;
            };
            const _remove = (type, listener) => {
              if (listeners[type]) {
                platform.removeEventListener(this, type, listener);
                delete listeners[type];
              }
            };
            const listener = (width, height) => {
              if (this.canvas) {
                this.resize(width, height);
              }
            };
            let detached;
            const attached = () => {
              _remove('attach', attached);
              this.attached = true;
              this.resize();
              _add('resize', listener);
              _add('detach', detached);
            };
            detached = () => {
              this.attached = false;
              _remove('resize', listener);
              this._stop();
              this._resize(0, 0);
              _add('attach', attached);
            };
            if (platform.isAttached(this.canvas)) {
              attached();
            } else {
              detached();
            }
          }
          unbindEvents() {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this._listeners,
              (listener, type) => {
                this.platform.removeEventListener(this, type, listener);
              }
            );
            this._listeners = {};
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this._responsiveListeners,
              (listener, type) => {
                this.platform.removeEventListener(this, type, listener);
              }
            );
            this._responsiveListeners = undefined;
          }
          updateHoverStyle(items, mode, enabled) {
            const prefix = enabled ? 'set' : 'remove';
            let meta, item, i, ilen;
            if (mode === 'dataset') {
              meta = this.getDatasetMeta(items[0].datasetIndex);
              meta.controller['_' + prefix + 'DatasetHoverStyle']();
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              item = items[i];
              const controller =
                item && this.getDatasetMeta(item.datasetIndex).controller;
              if (controller) {
                controller[prefix + 'HoverStyle'](
                  item.element,
                  item.datasetIndex,
                  item.index
                );
              }
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements) {
            const lastActive = this._active || [];
            const active = activeElements.map(({ datasetIndex, index }) => {
              const meta = this.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error('No dataset found at index ' + datasetIndex);
              }
              return {
                datasetIndex,
                element: meta.data[index],
                index,
              };
            });
            const changed = !(0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(
              active,
              lastActive
            );
            if (changed) {
              this._active = active;
              this._lastEvent = null;
              this._updateHoverStyles(active, lastActive);
            }
          }
          notifyPlugins(hook, args, filter) {
            return this._plugins.notify(this, hook, args, filter);
          }
          isPluginEnabled(pluginId) {
            return (
              this._plugins._cache.filter((p) => p.plugin.id === pluginId)
                .length === 1
            );
          }
          _updateHoverStyles(active, lastActive, replay) {
            const hoverOptions = this.options.hover;
            const diff = (a, b) =>
              a.filter(
                (x) =>
                  !b.some(
                    (y) =>
                      x.datasetIndex === y.datasetIndex && x.index === y.index
                  )
              );
            const deactivated = diff(lastActive, active);
            const activated = replay ? active : diff(active, lastActive);
            if (deactivated.length) {
              this.updateHoverStyle(deactivated, hoverOptions.mode, false);
            }
            if (activated.length && hoverOptions.mode) {
              this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
          }
          _eventHandler(e, replay) {
            const args = {
              event: e,
              replay,
              cancelable: true,
              inChartArea: this.isPointInArea(e),
            };
            const eventFilter = (plugin) =>
              (plugin.options.events || this.options.events).includes(
                e.native.type
              );
            if (
              this.notifyPlugins('beforeEvent', args, eventFilter) === false
            ) {
              return;
            }
            const changed = this._handleEvent(e, replay, args.inChartArea);
            args.cancelable = false;
            this.notifyPlugins('afterEvent', args, eventFilter);
            if (changed || args.changed) {
              this.render();
            }
            return this;
          }
          _handleEvent(e, replay, inChartArea) {
            const { _active: lastActive = [], options } = this;
            const useFinalPosition = replay;
            const active = this._getActiveElements(
              e,
              lastActive,
              inChartArea,
              useFinalPosition
            );
            const isClick = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aj)(e);
            const lastEvent = determineLastEvent(
              e,
              this._lastEvent,
              inChartArea,
              isClick
            );
            if (inChartArea) {
              this._lastEvent = null;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                options.onHover,
                [e, active, this],
                this
              );
              if (isClick) {
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                  options.onClick,
                  [e, active, this],
                  this
                );
              }
            }
            const changed = !(0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(
              active,
              lastActive
            );
            if (changed || replay) {
              this._active = active;
              this._updateHoverStyles(active, lastActive, replay);
            }
            this._lastEvent = lastEvent;
            return changed;
          }
          _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
            if (e.type === 'mouseout') {
              return [];
            }
            if (!inChartArea) {
              return lastActive;
            }
            const hoverOptions = this.options.hover;
            return this.getElementsAtEventForMode(
              e,
              hoverOptions.mode,
              hoverOptions,
              useFinalPosition
            );
          }
        }
        function invalidatePlugins() {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
            Chart.instances,
            (chart) => chart._plugins.invalidate()
          );
        }

        function clipArc(ctx, element, endAngle) {
          const { startAngle, pixelMargin, x, y, outerRadius, innerRadius } =
            element;
          let angleMargin = pixelMargin / outerRadius;
          // Draw an inner border by clipping the arc and drawing a double-width border
          // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
          ctx.beginPath();
          ctx.arc(
            x,
            y,
            outerRadius,
            startAngle - angleMargin,
            endAngle + angleMargin
          );
          if (innerRadius > pixelMargin) {
            angleMargin = pixelMargin / innerRadius;
            ctx.arc(
              x,
              y,
              innerRadius,
              endAngle + angleMargin,
              startAngle - angleMargin,
              true
            );
          } else {
            ctx.arc(
              x,
              y,
              pixelMargin,
              endAngle +
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H,
              startAngle -
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H
            );
          }
          ctx.closePath();
          ctx.clip();
        }
        function toRadiusCorners(value) {
          return (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al)(value, [
            'outerStart',
            'outerEnd',
            'innerStart',
            'innerEnd',
          ]);
        }
        /**
         * Parse border radius from the provided options
         */ function parseBorderRadius$1(
          arc,
          innerRadius,
          outerRadius,
          angleDelta
        ) {
          const o = toRadiusCorners(arc.options.borderRadius);
          const halfThickness = (outerRadius - innerRadius) / 2;
          const innerLimit = Math.min(
            halfThickness,
            (angleDelta * innerRadius) / 2
          );
          // Outer limits are complicated. We want to compute the available angular distance at
          // a radius of outerRadius - borderRadius because for small angular distances, this term limits.
          // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.
          //
          // If the borderRadius is large, that value can become negative.
          // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius
          // we know that the thickness term will dominate and compute the limits at that point
          const computeOuterLimit = (val) => {
            const outerArcLimit =
              ((outerRadius - Math.min(halfThickness, val)) * angleDelta) / 2;
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              val,
              0,
              Math.min(halfThickness, outerArcLimit)
            );
          };
          return {
            outerStart: computeOuterLimit(o.outerStart),
            outerEnd: computeOuterLimit(o.outerEnd),
            innerStart: (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              o.innerStart,
              0,
              innerLimit
            ),
            innerEnd: (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              o.innerEnd,
              0,
              innerLimit
            ),
          };
        }
        /**
         * Convert (r, 𝜃) to (x, y)
         */ function rThetaToXY(r, theta, x, y) {
          return {
            x: x + r * Math.cos(theta),
            y: y + r * Math.sin(theta),
          };
        }
        /**
         * Path the arc, respecting border radius by separating into left and right halves.
         *
         *   Start      End
         *
         *    1--->a--->2    Outer
         *   /           \
         *   8           3
         *   |           |
         *   |           |
         *   7           4
         *   \           /
         *    6<---b<---5    Inner
         */ function pathArc(ctx, element, offset, spacing, end, circular) {
          const {
            x,
            y,
            startAngle: start,
            pixelMargin,
            innerRadius: innerR,
          } = element;
          const outerRadius = Math.max(
            element.outerRadius + spacing + offset - pixelMargin,
            0
          );
          const innerRadius =
            innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
          let spacingOffset = 0;
          const alpha = end - start;
          if (spacing) {
            // When spacing is present, it is the same for all items
            // So we adjust the start and end angle of the arc such that
            // the distance is the same as it would be without the spacing
            const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
            const noSpacingOuterRadius =
              outerRadius > 0 ? outerRadius - spacing : 0;
            const avNogSpacingRadius =
              (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
            const adjustedAngle =
              avNogSpacingRadius !== 0
                ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing)
                : alpha;
            spacingOffset = (alpha - adjustedAngle) / 2;
          }
          const beta =
            Math.max(
              0.001,
              alpha * outerRadius -
                offset /
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P
            ) / outerRadius;
          const angleOffset = (alpha - beta) / 2;
          const startAngle = start + angleOffset + spacingOffset;
          const endAngle = end - angleOffset - spacingOffset;
          const { outerStart, outerEnd, innerStart, innerEnd } =
            parseBorderRadius$1(
              element,
              innerRadius,
              outerRadius,
              endAngle - startAngle
            );
          const outerStartAdjustedRadius = outerRadius - outerStart;
          const outerEndAdjustedRadius = outerRadius - outerEnd;
          const outerStartAdjustedAngle =
            startAngle + outerStart / outerStartAdjustedRadius;
          const outerEndAdjustedAngle =
            endAngle - outerEnd / outerEndAdjustedRadius;
          const innerStartAdjustedRadius = innerRadius + innerStart;
          const innerEndAdjustedRadius = innerRadius + innerEnd;
          const innerStartAdjustedAngle =
            startAngle + innerStart / innerStartAdjustedRadius;
          const innerEndAdjustedAngle =
            endAngle - innerEnd / innerEndAdjustedRadius;
          ctx.beginPath();
          if (circular) {
            // The first arc segments from point 1 to point a to point 2
            const outerMidAdjustedAngle =
              (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
            ctx.arc(
              x,
              y,
              outerRadius,
              outerStartAdjustedAngle,
              outerMidAdjustedAngle
            );
            ctx.arc(
              x,
              y,
              outerRadius,
              outerMidAdjustedAngle,
              outerEndAdjustedAngle
            );
            // The corner segment from point 2 to point 3
            if (outerEnd > 0) {
              const pCenter = rThetaToXY(
                outerEndAdjustedRadius,
                outerEndAdjustedAngle,
                x,
                y
              );
              ctx.arc(
                pCenter.x,
                pCenter.y,
                outerEnd,
                outerEndAdjustedAngle,
                endAngle +
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H
              );
            }
            // The line from point 3 to point 4
            const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
            ctx.lineTo(p4.x, p4.y);
            // The corner segment from point 4 to point 5
            if (innerEnd > 0) {
              const pCenter = rThetaToXY(
                innerEndAdjustedRadius,
                innerEndAdjustedAngle,
                x,
                y
              );
              ctx.arc(
                pCenter.x,
                pCenter.y,
                innerEnd,
                endAngle +
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H,
                innerEndAdjustedAngle + Math.PI
              );
            }
            // The inner arc from point 5 to point b to point 6
            const innerMidAdjustedAngle =
              (endAngle -
                innerEnd / innerRadius +
                (startAngle + innerStart / innerRadius)) /
              2;
            ctx.arc(
              x,
              y,
              innerRadius,
              endAngle - innerEnd / innerRadius,
              innerMidAdjustedAngle,
              true
            );
            ctx.arc(
              x,
              y,
              innerRadius,
              innerMidAdjustedAngle,
              startAngle + innerStart / innerRadius,
              true
            );
            // The corner segment from point 6 to point 7
            if (innerStart > 0) {
              const pCenter = rThetaToXY(
                innerStartAdjustedRadius,
                innerStartAdjustedAngle,
                x,
                y
              );
              ctx.arc(
                pCenter.x,
                pCenter.y,
                innerStart,
                innerStartAdjustedAngle + Math.PI,
                startAngle -
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H
              );
            }
            // The line from point 7 to point 8
            const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
            ctx.lineTo(p8.x, p8.y);
            // The corner segment from point 8 to point 1
            if (outerStart > 0) {
              const pCenter = rThetaToXY(
                outerStartAdjustedRadius,
                outerStartAdjustedAngle,
                x,
                y
              );
              ctx.arc(
                pCenter.x,
                pCenter.y,
                outerStart,
                startAngle -
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H,
                outerStartAdjustedAngle
              );
            }
          } else {
            ctx.moveTo(x, y);
            const outerStartX =
              Math.cos(outerStartAdjustedAngle) * outerRadius + x;
            const outerStartY =
              Math.sin(outerStartAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerStartX, outerStartY);
            const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
            const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
            ctx.lineTo(outerEndX, outerEndY);
          }
          ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
          const { fullCircles, startAngle, circumference } = element;
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.fill();
            }
            if (!isNaN(circumference)) {
              endAngle =
                startAngle +
                (circumference %
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ||
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);
            }
          }
          pathArc(ctx, element, offset, spacing, endAngle, circular);
          ctx.fill();
          return endAngle;
        }
        function drawBorder(ctx, element, offset, spacing, circular) {
          const { fullCircles, startAngle, circumference, options } = element;
          const { borderWidth, borderJoinStyle, borderDash, borderDashOffset } =
            options;
          const inner = options.borderAlign === 'inner';
          if (!borderWidth) {
            return;
          }
          ctx.setLineDash(borderDash || []);
          ctx.lineDashOffset = borderDashOffset;
          if (inner) {
            ctx.lineWidth = borderWidth * 2;
            ctx.lineJoin = borderJoinStyle || 'round';
          } else {
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = borderJoinStyle || 'bevel';
          }
          let endAngle = element.endAngle;
          if (fullCircles) {
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            for (let i = 0; i < fullCircles; ++i) {
              ctx.stroke();
            }
            if (!isNaN(circumference)) {
              endAngle =
                startAngle +
                (circumference %
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ||
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T);
            }
          }
          if (inner) {
            clipArc(ctx, element, endAngle);
          }
          if (!fullCircles) {
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            ctx.stroke();
          }
        }
        class ArcElement extends Element {
          static id = 'arc';
          static defaults = {
            borderAlign: 'center',
            borderColor: '#fff',
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: undefined,
            borderRadius: 0,
            borderWidth: 2,
            offset: 0,
            spacing: 0,
            angle: undefined,
            circular: true,
          };
          static defaultRoutes = {
            backgroundColor: 'backgroundColor',
          };
          static descriptors = {
            _scriptable: true,
            _indexable: (name) => name !== 'borderDash',
          };
          circumference;
          endAngle;
          fullCircles;
          innerRadius;
          outerRadius;
          pixelMargin;
          startAngle;
          constructor(cfg) {
            super();
            this.options = undefined;
            this.circumference = undefined;
            this.startAngle = undefined;
            this.endAngle = undefined;
            this.innerRadius = undefined;
            this.outerRadius = undefined;
            this.pixelMargin = 0;
            this.fullCircles = 0;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(chartX, chartY, useFinalPosition) {
            const point = this.getProps(['x', 'y'], useFinalPosition);
            const { angle, distance } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D)(point, {
              x: chartX,
              y: chartY,
            });
            const {
              startAngle,
              endAngle,
              innerRadius,
              outerRadius,
              circumference,
            } = this.getProps(
              [
                'startAngle',
                'endAngle',
                'innerRadius',
                'outerRadius',
                'circumference',
              ],
              useFinalPosition
            );
            const rAdjust =
              (this.options.spacing + this.options.borderWidth) / 2;
            const _circumference = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              circumference,
              endAngle - startAngle
            );
            const nonZeroBetween =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p)(
                angle,
                startAngle,
                endAngle
              ) && startAngle !== endAngle;
            const betweenAngles =
              _circumference >=
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T ||
              nonZeroBetween;
            const withinRadius = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
              distance,
              innerRadius + rAdjust,
              outerRadius + rAdjust
            );
            return betweenAngles && withinRadius;
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, startAngle, endAngle, innerRadius, outerRadius } =
              this.getProps(
                [
                  'x',
                  'y',
                  'startAngle',
                  'endAngle',
                  'innerRadius',
                  'outerRadius',
                ],
                useFinalPosition
              );
            const { offset, spacing } = this.options;
            const halfAngle = (startAngle + endAngle) / 2;
            const halfRadius =
              (innerRadius + outerRadius + spacing + offset) / 2;
            return {
              x: x + Math.cos(halfAngle) * halfRadius,
              y: y + Math.sin(halfAngle) * halfRadius,
            };
          }
          tooltipPosition(useFinalPosition) {
            return this.getCenterPoint(useFinalPosition);
          }
          draw(ctx) {
            const { options, circumference } = this;
            const offset = (options.offset || 0) / 4;
            const spacing = (options.spacing || 0) / 2;
            const circular = options.circular;
            this.pixelMargin = options.borderAlign === 'inner' ? 0.33 : 0;
            this.fullCircles =
              circumference >
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T
                ? Math.floor(
                    circumference /
                      _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T
                  )
                : 0;
            if (
              circumference === 0 ||
              this.innerRadius < 0 ||
              this.outerRadius < 0
            ) {
              return;
            }
            ctx.save();
            const halfAngle = (this.startAngle + this.endAngle) / 2;
            ctx.translate(
              Math.cos(halfAngle) * offset,
              Math.sin(halfAngle) * offset
            );
            const fix =
              1 -
              Math.sin(
                Math.min(
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P,
                  circumference || 0
                )
              );
            const radiusOffset = offset * fix;
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            drawArc(ctx, this, radiusOffset, spacing, circular);
            drawBorder(ctx, this, radiusOffset, spacing, circular);
            ctx.restore();
          }
        }

        function setStyle(ctx, options, style = options) {
          ctx.lineCap = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            style.borderCapStyle,
            options.borderCapStyle
          );
          ctx.setLineDash(
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              style.borderDash,
              options.borderDash
            )
          );
          ctx.lineDashOffset = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            style.borderDashOffset,
            options.borderDashOffset
          );
          ctx.lineJoin = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            style.borderJoinStyle,
            options.borderJoinStyle
          );
          ctx.lineWidth = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            style.borderWidth,
            options.borderWidth
          );
          ctx.strokeStyle = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            style.borderColor,
            options.borderColor
          );
        }
        function lineTo(ctx, previous, target) {
          ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
          if (options.stepped) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.as;
          }
          if (
            options.tension ||
            options.cubicInterpolationMode === 'monotone'
          ) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.at;
          }
          return lineTo;
        }
        function pathVars(points, segment, params = {}) {
          const count = points.length;
          const { start: paramsStart = 0, end: paramsEnd = count - 1 } = params;
          const { start: segmentStart, end: segmentEnd } = segment;
          const start = Math.max(paramsStart, segmentStart);
          const end = Math.min(paramsEnd, segmentEnd);
          const outside =
            (paramsStart < segmentStart && paramsEnd < segmentStart) ||
            (paramsStart > segmentEnd && paramsEnd > segmentEnd);
          return {
            count,
            start,
            loop: segment.loop,
            ilen: end < start && !outside ? count + end - start : end - start,
          };
        }
        function pathSegment(ctx, line, segment, params) {
          const { points, options } = line;
          const { count, start, loop, ilen } = pathVars(
            points,
            segment,
            params
          );
          const lineMethod = getLineMethod(options);
          let { move = true, reverse } = params || {};
          let i, point, prev;
          for (i = 0; i <= ilen; ++i) {
            point = points[(start + (reverse ? ilen - i : i)) % count];
            if (point.skip) {
              continue;
            } else if (move) {
              ctx.moveTo(point.x, point.y);
              move = false;
            } else {
              lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            prev = point;
          }
          if (loop) {
            point = points[(start + (reverse ? ilen : 0)) % count];
            lineMethod(ctx, prev, point, reverse, options.stepped);
          }
          return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
          const points = line.points;
          const { count, start, ilen } = pathVars(points, segment, params);
          const { move = true, reverse } = params || {};
          let avgX = 0;
          let countX = 0;
          let i, point, prevX, minY, maxY, lastY;
          const pointIndex = (index) =>
            (start + (reverse ? ilen - index : index)) % count;
          const drawX = () => {
            if (minY !== maxY) {
              ctx.lineTo(avgX, maxY);
              ctx.lineTo(avgX, minY);
              ctx.lineTo(avgX, lastY);
            }
          };
          if (move) {
            point = points[pointIndex(0)];
            ctx.moveTo(point.x, point.y);
          }
          for (i = 0; i <= ilen; ++i) {
            point = points[pointIndex(i)];
            if (point.skip) {
              continue;
            }
            const x = point.x;
            const y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
              } else if (y > maxY) {
                maxY = y;
              }
              avgX = (countX * avgX + x) / ++countX;
            } else {
              drawX();
              ctx.lineTo(x, y);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
            }
            lastY = y;
          }
          drawX();
        }
        function _getSegmentMethod(line) {
          const opts = line.options;
          const borderDash = opts.borderDash && opts.borderDash.length;
          const useFastPath =
            !line._decimated &&
            !line._loop &&
            !opts.tension &&
            opts.cubicInterpolationMode !== 'monotone' &&
            !opts.stepped &&
            !borderDash;
          return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
          if (options.stepped) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap;
          }
          if (
            options.tension ||
            options.cubicInterpolationMode === 'monotone'
          ) {
            return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aq;
          }
          return _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ar;
        }
        function strokePathWithCache(ctx, line, start, count) {
          let path = line._path;
          if (!path) {
            path = line._path = new Path2D();
            if (line.path(path, start, count)) {
              path.closePath();
            }
          }
          setStyle(ctx, line.options);
          ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
          const { segments, options } = line;
          const segmentMethod = _getSegmentMethod(line);
          for (const segment of segments) {
            setStyle(ctx, options, segment.style);
            ctx.beginPath();
            if (
              segmentMethod(ctx, line, segment, {
                start,
                end: start + count - 1,
              })
            ) {
              ctx.closePath();
            }
            ctx.stroke();
          }
        }
        const usePath2D = typeof Path2D === 'function';
        function draw(ctx, line, start, count) {
          if (usePath2D && !line.options.segment) {
            strokePathWithCache(ctx, line, start, count);
          } else {
            strokePathDirect(ctx, line, start, count);
          }
        }
        class LineElement extends Element {
          static id = 'line';
          static defaults = {
            borderCapStyle: 'butt',
            borderDash: [],
            borderDashOffset: 0,
            borderJoinStyle: 'miter',
            borderWidth: 3,
            capBezierPoints: true,
            cubicInterpolationMode: 'default',
            fill: false,
            spanGaps: false,
            stepped: false,
            tension: 0,
          };
          static defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor',
          };
          static descriptors = {
            _scriptable: true,
            _indexable: (name) => name !== 'borderDash' && name !== 'fill',
          };
          constructor(cfg) {
            super();
            this.animated = true;
            this.options = undefined;
            this._chart = undefined;
            this._loop = undefined;
            this._fullLoop = undefined;
            this._path = undefined;
            this._points = undefined;
            this._segments = undefined;
            this._decimated = false;
            this._pointsUpdated = false;
            this._datasetIndex = undefined;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          updateControlPoints(chartArea, indexAxis) {
            const options = this.options;
            if (
              (options.tension ||
                options.cubicInterpolationMode === 'monotone') &&
              !options.stepped &&
              !this._pointsUpdated
            ) {
              const loop = options.spanGaps ? this._loop : this._fullLoop;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.am)(
                this._points,
                options,
                chartArea,
                loop,
                indexAxis
              );
              this._pointsUpdated = true;
            }
          }
          set points(points) {
            this._points = points;
            delete this._segments;
            delete this._path;
            this._pointsUpdated = false;
          }
          get points() {
            return this._points;
          }
          get segments() {
            return (
              this._segments ||
              (this._segments = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.an)(
                this,
                this.options.segment
              ))
            );
          }
          first() {
            const segments = this.segments;
            const points = this.points;
            return segments.length && points[segments[0].start];
          }
          last() {
            const segments = this.segments;
            const points = this.points;
            const count = segments.length;
            return count && points[segments[count - 1].end];
          }
          interpolate(point, property) {
            const options = this.options;
            const value = point[property];
            const points = this.points;
            const segments = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao)(this, {
              property,
              start: value,
              end: value,
            });
            if (!segments.length) {
              return;
            }
            const result = [];
            const _interpolate = _getInterpolationMethod(options);
            let i, ilen;
            for (i = 0, ilen = segments.length; i < ilen; ++i) {
              const { start, end } = segments[i];
              const p1 = points[start];
              const p2 = points[end];
              if (p1 === p2) {
                result.push(p1);
                continue;
              }
              const t = Math.abs(
                (value - p1[property]) / (p2[property] - p1[property])
              );
              const interpolated = _interpolate(p1, p2, t, options.stepped);
              interpolated[property] = point[property];
              result.push(interpolated);
            }
            return result.length === 1 ? result[0] : result;
          }
          pathSegment(ctx, segment, params) {
            const segmentMethod = _getSegmentMethod(this);
            return segmentMethod(ctx, this, segment, params);
          }
          path(ctx, start, count) {
            const segments = this.segments;
            const segmentMethod = _getSegmentMethod(this);
            let loop = this._loop;
            start = start || 0;
            count = count || this.points.length - start;
            for (const segment of segments) {
              loop &= segmentMethod(ctx, this, segment, {
                start,
                end: start + count - 1,
              });
            }
            return !!loop;
          }
          draw(ctx, chartArea, start, count) {
            const options = this.options || {};
            const points = this.points || [];
            if (points.length && options.borderWidth) {
              ctx.save();
              draw(ctx, this, start, count);
              ctx.restore();
            }
            if (this.animated) {
              this._pointsUpdated = false;
              this._path = undefined;
            }
          }
        }

        function inRange$1(el, pos, axis, useFinalPosition) {
          const options = el.options;
          const { [axis]: value } = el.getProps([axis], useFinalPosition);
          return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends Element {
          static id = 'point';
          parsed;
          skip;
          stop;
          /**
           * @type {any}
           */ static defaults = {
            borderWidth: 1,
            hitRadius: 1,
            hoverBorderWidth: 1,
            hoverRadius: 4,
            pointStyle: 'circle',
            radius: 3,
            rotation: 0,
          };
          /**
           * @type {any}
           */ static defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor',
          };
          constructor(cfg) {
            super();
            this.options = undefined;
            this.parsed = undefined;
            this.skip = undefined;
            this.stop = undefined;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            const options = this.options;
            const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
            return (
              Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) <
              Math.pow(options.hitRadius + options.radius, 2)
            );
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange$1(this, mouseX, 'x', useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange$1(this, mouseY, 'y', useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y } = this.getProps(['x', 'y'], useFinalPosition);
            return {
              x,
              y,
            };
          }
          size(options) {
            options = options || this.options || {};
            let radius = options.radius || 0;
            radius = Math.max(radius, (radius && options.hoverRadius) || 0);
            const borderWidth = (radius && options.borderWidth) || 0;
            return (radius + borderWidth) * 2;
          }
          draw(ctx, area) {
            const options = this.options;
            if (
              this.skip ||
              options.radius < 0.1 ||
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
                this,
                area,
                this.size(options) / 2
              )
            ) {
              return;
            }
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.fillStyle = options.backgroundColor;
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au)(
              ctx,
              options,
              this.x,
              this.y
            );
          }
          getRange() {
            const options = this.options || {};
            // @ts-expect-error Fallbacks should never be hit in practice
            return options.radius + options.hitRadius;
          }
        }

        function getBarBounds(bar, useFinalPosition) {
          const { x, y, base, width, height } = bar.getProps(
            ['x', 'y', 'base', 'width', 'height'],
            useFinalPosition
          );
          let left, right, top, bottom, half;
          if (bar.horizontal) {
            half = height / 2;
            left = Math.min(x, base);
            right = Math.max(x, base);
            top = y - half;
            bottom = y + half;
          } else {
            half = width / 2;
            left = x - half;
            right = x + half;
            top = Math.min(y, base);
            bottom = Math.max(y, base);
          }
          return {
            left,
            top,
            right,
            bottom,
          };
        }
        function skipOrLimit(skip, value, min, max) {
          return skip
            ? 0
            : (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
                value,
                min,
                max
              );
        }
        function parseBorderWidth(bar, maxW, maxH) {
          const value = bar.options.borderWidth;
          const skip = bar.borderSkipped;
          const o = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw)(value);
          return {
            t: skipOrLimit(skip.top, o.top, 0, maxH),
            r: skipOrLimit(skip.right, o.right, 0, maxW),
            b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
            l: skipOrLimit(skip.left, o.left, 0, maxW),
          };
        }
        function parseBorderRadius(bar, maxW, maxH) {
          const { enableBorderRadius } = bar.getProps(['enableBorderRadius']);
          const value = bar.options.borderRadius;
          const o = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(value);
          const maxR = Math.min(maxW, maxH);
          const skip = bar.borderSkipped;
          const enableBorder =
            enableBorderRadius ||
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
              value
            );
          return {
            topLeft: skipOrLimit(
              !enableBorder || skip.top || skip.left,
              o.topLeft,
              0,
              maxR
            ),
            topRight: skipOrLimit(
              !enableBorder || skip.top || skip.right,
              o.topRight,
              0,
              maxR
            ),
            bottomLeft: skipOrLimit(
              !enableBorder || skip.bottom || skip.left,
              o.bottomLeft,
              0,
              maxR
            ),
            bottomRight: skipOrLimit(
              !enableBorder || skip.bottom || skip.right,
              o.bottomRight,
              0,
              maxR
            ),
          };
        }
        function boundingRects(bar) {
          const bounds = getBarBounds(bar);
          const width = bounds.right - bounds.left;
          const height = bounds.bottom - bounds.top;
          const border = parseBorderWidth(bar, width / 2, height / 2);
          const radius = parseBorderRadius(bar, width / 2, height / 2);
          return {
            outer: {
              x: bounds.left,
              y: bounds.top,
              w: width,
              h: height,
              radius,
            },
            inner: {
              x: bounds.left + border.l,
              y: bounds.top + border.t,
              w: width - border.l - border.r,
              h: height - border.t - border.b,
              radius: {
                topLeft: Math.max(
                  0,
                  radius.topLeft - Math.max(border.t, border.l)
                ),
                topRight: Math.max(
                  0,
                  radius.topRight - Math.max(border.t, border.r)
                ),
                bottomLeft: Math.max(
                  0,
                  radius.bottomLeft - Math.max(border.b, border.l)
                ),
                bottomRight: Math.max(
                  0,
                  radius.bottomRight - Math.max(border.b, border.r)
                ),
              },
            },
          };
        }
        function inRange(bar, x, y, useFinalPosition) {
          const skipX = x === null;
          const skipY = y === null;
          const skipBoth = skipX && skipY;
          const bounds =
            bar && !skipBoth && getBarBounds(bar, useFinalPosition);
          return (
            bounds &&
            (skipX ||
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                x,
                bounds.left,
                bounds.right
              )) &&
            (skipY ||
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                y,
                bounds.top,
                bounds.bottom
              ))
          );
        }
        function hasRadius(radius) {
          return (
            radius.topLeft ||
            radius.topRight ||
            radius.bottomLeft ||
            radius.bottomRight
          );
        }
        function addNormalRectPath(ctx, rect) {
          ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
          const x = rect.x !== refRect.x ? -amount : 0;
          const y = rect.y !== refRect.y ? -amount : 0;
          const w =
            (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
          const h =
            (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
          return {
            x: rect.x + x,
            y: rect.y + y,
            w: rect.w + w,
            h: rect.h + h,
            radius: rect.radius,
          };
        }
        class BarElement extends Element {
          static id = 'bar';
          static defaults = {
            borderSkipped: 'start',
            borderWidth: 0,
            borderRadius: 0,
            inflateAmount: 'auto',
            pointStyle: undefined,
          };
          static defaultRoutes = {
            backgroundColor: 'backgroundColor',
            borderColor: 'borderColor',
          };
          constructor(cfg) {
            super();
            this.options = undefined;
            this.horizontal = undefined;
            this.base = undefined;
            this.width = undefined;
            this.height = undefined;
            this.inflateAmount = undefined;
            if (cfg) {
              Object.assign(this, cfg);
            }
          }
          draw(ctx) {
            const {
              inflateAmount,
              options: { borderColor, backgroundColor },
            } = this;
            const { inner, outer } = boundingRects(this);
            const addRectPath = hasRadius(outer.radius)
              ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av
              : addNormalRectPath;
            ctx.save();
            if (outer.w !== inner.w || outer.h !== inner.h) {
              ctx.beginPath();
              addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
              ctx.clip();
              addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
              ctx.fillStyle = borderColor;
              ctx.fill('evenodd');
            }
            ctx.beginPath();
            addRectPath(ctx, inflateRect(inner, inflateAmount));
            ctx.fillStyle = backgroundColor;
            ctx.fill();
            ctx.restore();
          }
          inRange(mouseX, mouseY, useFinalPosition) {
            return inRange(this, mouseX, mouseY, useFinalPosition);
          }
          inXRange(mouseX, useFinalPosition) {
            return inRange(this, mouseX, null, useFinalPosition);
          }
          inYRange(mouseY, useFinalPosition) {
            return inRange(this, null, mouseY, useFinalPosition);
          }
          getCenterPoint(useFinalPosition) {
            const { x, y, base, horizontal } = this.getProps(
              ['x', 'y', 'base', 'horizontal'],
              useFinalPosition
            );
            return {
              x: horizontal ? (x + base) / 2 : x,
              y: horizontal ? y : (y + base) / 2,
            };
          }
          getRange(axis) {
            return axis === 'x' ? this.width / 2 : this.height / 2;
          }
        }

        var elements = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          ArcElement: ArcElement,
          BarElement: BarElement,
          LineElement: LineElement,
          PointElement: PointElement,
        });

        const BORDER_COLORS = [
          'rgb(54, 162, 235)',
          'rgb(255, 99, 132)',
          'rgb(255, 159, 64)',
          'rgb(255, 205, 86)',
          'rgb(75, 192, 192)',
          'rgb(153, 102, 255)',
          'rgb(201, 203, 207)', // grey
        ];
        // Border colors with 50% transparency
        const BACKGROUND_COLORS = /* #__PURE__ */ BORDER_COLORS.map((color) =>
          color.replace('rgb(', 'rgba(').replace(')', ', 0.5)')
        );
        function getBorderColor(i) {
          return BORDER_COLORS[i % BORDER_COLORS.length];
        }
        function getBackgroundColor(i) {
          return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
        }
        function colorizeDefaultDataset(dataset, i) {
          dataset.borderColor = getBorderColor(i);
          dataset.backgroundColor = getBackgroundColor(i);
          return ++i;
        }
        function colorizeDoughnutDataset(dataset, i) {
          dataset.backgroundColor = dataset.data.map(() => getBorderColor(i++));
          return i;
        }
        function colorizePolarAreaDataset(dataset, i) {
          dataset.backgroundColor = dataset.data.map(() =>
            getBackgroundColor(i++)
          );
          return i;
        }
        function getColorizer(chart) {
          let i = 0;
          return (dataset, datasetIndex) => {
            const controller = chart.getDatasetMeta(datasetIndex).controller;
            if (controller instanceof DoughnutController) {
              i = colorizeDoughnutDataset(dataset, i);
            } else if (controller instanceof PolarAreaController) {
              i = colorizePolarAreaDataset(dataset, i);
            } else if (controller) {
              i = colorizeDefaultDataset(dataset, i);
            }
          };
        }
        function containsColorsDefinitions(descriptors) {
          let k;
          for (k in descriptors) {
            if (descriptors[k].borderColor || descriptors[k].backgroundColor) {
              return true;
            }
          }
          return false;
        }
        function containsColorsDefinition(descriptor) {
          return (
            descriptor && (descriptor.borderColor || descriptor.backgroundColor)
          );
        }
        function containsDefaultColorsDefenitions() {
          return (
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
              .borderColor !== 'rgba(0,0,0,0.1)' ||
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d
              .backgroundColor !== 'rgba(0,0,0,0.1)'
          );
        }
        var plugin_colors = {
          id: 'colors',
          defaults: {
            enabled: true,
            forceOverride: false,
          },
          beforeLayout(chart, _args, options) {
            if (!options.enabled) {
              return;
            }
            const {
              data: { datasets },
              options: chartOptions,
            } = chart.config;
            const { elements } = chartOptions;
            const containsColorDefenition =
              containsColorsDefinitions(datasets) ||
              containsColorsDefinition(chartOptions) ||
              (elements && containsColorsDefinitions(elements)) ||
              containsDefaultColorsDefenitions();
            if (!options.forceOverride && containsColorDefenition) {
              return;
            }
            const colorizer = getColorizer(chart);
            datasets.forEach(colorizer);
          },
        };

        function lttbDecimation(data, start, count, availableWidth, options) {
          const samples = options.samples || availableWidth;
          if (samples >= count) {
            return data.slice(start, start + count);
          }
          const decimated = [];
          const bucketWidth = (count - 2) / (samples - 2);
          let sampledIndex = 0;
          const endIndex = start + count - 1;
          let a = start;
          let i, maxAreaPoint, maxArea, area, nextA;
          decimated[sampledIndex++] = data[a];
          for (i = 0; i < samples - 2; i++) {
            let avgX = 0;
            let avgY = 0;
            let j;
            const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
            const avgRangeEnd =
              Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
            const avgRangeLength = avgRangeEnd - avgRangeStart;
            for (j = avgRangeStart; j < avgRangeEnd; j++) {
              avgX += data[j].x;
              avgY += data[j].y;
            }
            avgX /= avgRangeLength;
            avgY /= avgRangeLength;
            const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
            const rangeTo =
              Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
            const { x: pointAx, y: pointAy } = data[a];
            maxArea = area = -1;
            for (j = rangeOffs; j < rangeTo; j++) {
              area =
                0.5 *
                Math.abs(
                  (pointAx - avgX) * (data[j].y - pointAy) -
                    (pointAx - data[j].x) * (avgY - pointAy)
                );
              if (area > maxArea) {
                maxArea = area;
                maxAreaPoint = data[j];
                nextA = j;
              }
            }
            decimated[sampledIndex++] = maxAreaPoint;
            a = nextA;
          }
          decimated[sampledIndex++] = data[endIndex];
          return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
          let avgX = 0;
          let countX = 0;
          let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
          const decimated = [];
          const endIndex = start + count - 1;
          const xMin = data[start].x;
          const xMax = data[endIndex].x;
          const dx = xMax - xMin;
          for (i = start; i < start + count; ++i) {
            point = data[i];
            x = ((point.x - xMin) / dx) * availableWidth;
            y = point.y;
            const truncX = x | 0;
            if (truncX === prevX) {
              if (y < minY) {
                minY = y;
                minIndex = i;
              } else if (y > maxY) {
                maxY = y;
                maxIndex = i;
              }
              avgX = (countX * avgX + point.x) / ++countX;
            } else {
              const lastIndex = i - 1;
              if (
                !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  minIndex
                ) &&
                !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  maxIndex
                )
              ) {
                const intermediateIndex1 = Math.min(minIndex, maxIndex);
                const intermediateIndex2 = Math.max(minIndex, maxIndex);
                if (
                  intermediateIndex1 !== startIndex &&
                  intermediateIndex1 !== lastIndex
                ) {
                  decimated.push({
                    ...data[intermediateIndex1],
                    x: avgX,
                  });
                }
                if (
                  intermediateIndex2 !== startIndex &&
                  intermediateIndex2 !== lastIndex
                ) {
                  decimated.push({
                    ...data[intermediateIndex2],
                    x: avgX,
                  });
                }
              }
              if (i > 0 && lastIndex !== startIndex) {
                decimated.push(data[lastIndex]);
              }
              decimated.push(point);
              prevX = truncX;
              countX = 0;
              minY = maxY = y;
              minIndex = maxIndex = startIndex = i;
            }
          }
          return decimated;
        }
        function cleanDecimatedDataset(dataset) {
          if (dataset._decimated) {
            const data = dataset._data;
            delete dataset._decimated;
            delete dataset._data;
            Object.defineProperty(dataset, 'data', {
              configurable: true,
              enumerable: true,
              writable: true,
              value: data,
            });
          }
        }
        function cleanDecimatedData(chart) {
          chart.data.datasets.forEach((dataset) => {
            cleanDecimatedDataset(dataset);
          });
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
          const pointCount = points.length;
          let start = 0;
          let count;
          const { iScale } = meta;
          const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
          if (minDefined) {
            start = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(
                points,
                iScale.axis,
                min
              ).lo,
              0,
              pointCount - 1
            );
          }
          if (maxDefined) {
            count =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(
                  points,
                  iScale.axis,
                  max
                ).hi + 1,
                start,
                pointCount
              ) - start;
          } else {
            count = pointCount - start;
          }
          return {
            start,
            count,
          };
        }
        var plugin_decimation = {
          id: 'decimation',
          defaults: {
            algorithm: 'min-max',
            enabled: false,
          },
          beforeElementsUpdate: (chart, args, options) => {
            if (!options.enabled) {
              cleanDecimatedData(chart);
              return;
            }
            const availableWidth = chart.width;
            chart.data.datasets.forEach((dataset, datasetIndex) => {
              const { _data, indexAxis } = dataset;
              const meta = chart.getDatasetMeta(datasetIndex);
              const data = _data || dataset.data;
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a)([
                  indexAxis,
                  chart.options.indexAxis,
                ]) === 'y'
              ) {
                return;
              }
              if (!meta.controller.supportsDecimation) {
                return;
              }
              const xAxis = chart.scales[meta.xAxisID];
              if (xAxis.type !== 'linear' && xAxis.type !== 'time') {
                return;
              }
              if (chart.options.parsing) {
                return;
              }
              let { start, count } = getStartAndCountOfVisiblePointsSimplified(
                meta,
                data
              );
              const threshold = options.threshold || 4 * availableWidth;
              if (count <= threshold) {
                cleanDecimatedDataset(dataset);
                return;
              }
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                  _data
                )
              ) {
                dataset._data = data;
                delete dataset.data;
                Object.defineProperty(dataset, 'data', {
                  configurable: true,
                  enumerable: true,
                  get: function () {
                    return this._decimated;
                  },
                  set: function (d) {
                    this._data = d;
                  },
                });
              }
              let decimated;
              switch (options.algorithm) {
                case 'lttb':
                  decimated = lttbDecimation(
                    data,
                    start,
                    count,
                    availableWidth,
                    options
                  );
                  break;
                case 'min-max':
                  decimated = minMaxDecimation(
                    data,
                    start,
                    count,
                    availableWidth
                  );
                  break;
                default:
                  throw new Error(
                    `Unsupported decimation algorithm '${options.algorithm}'`
                  );
              }
              dataset._decimated = decimated;
            });
          },
          destroy(chart) {
            cleanDecimatedData(chart);
          },
        };

        function _segments(line, target, property) {
          const segments = line.segments;
          const points = line.points;
          const tpoints = target.points;
          const parts = [];
          for (const segment of segments) {
            let { start, end } = segment;
            end = _findSegmentEnd(start, end, points);
            const bounds = _getBounds(
              property,
              points[start],
              points[end],
              segment.loop
            );
            if (!target.segments) {
              parts.push({
                source: segment,
                target: bounds,
                start: points[start],
                end: points[end],
              });
              continue;
            }
            const targetSegments = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao)(
              target,
              bounds
            );
            for (const tgt of targetSegments) {
              const subBounds = _getBounds(
                property,
                tpoints[tgt.start],
                tpoints[tgt.end],
                tgt.loop
              );
              const fillSources = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay)(
                segment,
                points,
                subBounds
              );
              for (const fillSource of fillSources) {
                parts.push({
                  source: fillSource,
                  target: tgt,
                  start: {
                    [property]: _getEdge(bounds, subBounds, 'start', Math.max),
                  },
                  end: {
                    [property]: _getEdge(bounds, subBounds, 'end', Math.min),
                  },
                });
              }
            }
          }
          return parts;
        }
        function _getBounds(property, first, last, loop) {
          if (loop) {
            return;
          }
          let start = first[property];
          let end = last[property];
          if (property === 'angle') {
            start = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(start);
            end = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(end);
          }
          return {
            property,
            start,
            end,
          };
        }
        function _pointsFromSegments(boundary, line) {
          const { x = null, y = null } = boundary || {};
          const linePoints = line.points;
          const points = [];
          line.segments.forEach(({ start, end }) => {
            end = _findSegmentEnd(start, end, linePoints);
            const first = linePoints[start];
            const last = linePoints[end];
            if (y !== null) {
              points.push({
                x: first.x,
                y,
              });
              points.push({
                x: last.x,
                y,
              });
            } else if (x !== null) {
              points.push({
                x,
                y: first.y,
              });
              points.push({
                x,
                y: last.y,
              });
            }
          });
          return points;
        }
        function _findSegmentEnd(start, end, points) {
          for (; end > start; end--) {
            const point = points[end];
            if (!isNaN(point.x) && !isNaN(point.y)) {
              break;
            }
          }
          return end;
        }
        function _getEdge(a, b, prop, fn) {
          if (a && b) {
            return fn(a[prop], b[prop]);
          }
          return a ? a[prop] : b ? b[prop] : 0;
        }

        function _createBoundaryLine(boundary, line) {
          let points = [];
          let _loop = false;
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
              boundary
            )
          ) {
            _loop = true;
            points = boundary;
          } else {
            points = _pointsFromSegments(boundary, line);
          }
          return points.length
            ? new LineElement({
                points,
                options: {
                  tension: 0,
                },
                _loop,
                _fullLoop: _loop,
              })
            : null;
        }
        function _shouldApplyFill(source) {
          return source && source.fill !== false;
        }

        function _resolveTarget(sources, index, propagate) {
          const source = sources[index];
          let fill = source.fill;
          const visited = [index];
          let target;
          if (!propagate) {
            return fill;
          }
          while (fill !== false && visited.indexOf(fill) === -1) {
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                fill
              )
            ) {
              return fill;
            }
            target = sources[fill];
            if (!target) {
              return false;
            }
            if (target.visible) {
              return fill;
            }
            visited.push(fill);
            fill = target.fill;
          }
          return false;
        }
        function _decodeFill(line, index, count) {
          const fill = parseFillOption(line);
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)
          ) {
            return isNaN(fill.value) ? false : fill;
          }
          let target = parseFloat(fill);
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
              target
            ) &&
            Math.floor(target) === target
          ) {
            return decodeTargetIndex(fill[0], index, target, count);
          }
          return (
            ['origin', 'start', 'end', 'stack', 'shape'].indexOf(fill) >= 0 &&
            fill
          );
        }
        function decodeTargetIndex(firstCh, index, target, count) {
          if (firstCh === '-' || firstCh === '+') {
            target = index + target;
          }
          if (target === index || target < 0 || target >= count) {
            return false;
          }
          return target;
        }
        function _getTargetPixel(fill, scale) {
          let pixel = null;
          if (fill === 'start') {
            pixel = scale.bottom;
          } else if (fill === 'end') {
            pixel = scale.top;
          } else if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)
          ) {
            pixel = scale.getPixelForValue(fill.value);
          } else if (scale.getBasePixel) {
            pixel = scale.getBasePixel();
          }
          return pixel;
        }
        function _getTargetValue(fill, scale, startValue) {
          let value;
          if (fill === 'start') {
            value = startValue;
          } else if (fill === 'end') {
            value = scale.options.reverse ? scale.min : scale.max;
          } else if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(fill)
          ) {
            value = fill.value;
          } else {
            value = scale.getBaseValue();
          }
          return value;
        }
        function parseFillOption(line) {
          const options = line.options;
          const fillOption = options.fill;
          let fill = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
            fillOption && fillOption.target,
            fillOption
          );
          if (fill === undefined) {
            fill = !!options.backgroundColor;
          }
          if (fill === false || fill === null) {
            return false;
          }
          if (fill === true) {
            return 'origin';
          }
          return fill;
        }

        function _buildStackLine(source) {
          const { scale, index, line } = source;
          const points = [];
          const segments = line.segments;
          const sourcePoints = line.points;
          const linesBelow = getLinesBelow(scale, index);
          linesBelow.push(
            _createBoundaryLine(
              {
                x: null,
                y: scale.bottom,
              },
              line
            )
          );
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            for (let j = segment.start; j <= segment.end; j++) {
              addPointsBelow(points, sourcePoints[j], linesBelow);
            }
          }
          return new LineElement({
            points,
            options: {},
          });
        }
        function getLinesBelow(scale, index) {
          const below = [];
          const metas = scale.getMatchingVisibleMetas('line');
          for (let i = 0; i < metas.length; i++) {
            const meta = metas[i];
            if (meta.index === index) {
              break;
            }
            if (!meta.hidden) {
              below.unshift(meta.dataset);
            }
          }
          return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
          const postponed = [];
          for (let j = 0; j < linesBelow.length; j++) {
            const line = linesBelow[j];
            const { first, last, point } = findPoint(line, sourcePoint, 'x');
            if (!point || (first && last)) {
              continue;
            }
            if (first) {
              postponed.unshift(point);
            } else {
              points.push(point);
              if (!last) {
                break;
              }
            }
          }
          points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
          const point = line.interpolate(sourcePoint, property);
          if (!point) {
            return {};
          }
          const pointValue = point[property];
          const segments = line.segments;
          const linePoints = line.points;
          let first = false;
          let last = false;
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const firstValue = linePoints[segment.start][property];
            const lastValue = linePoints[segment.end][property];
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                pointValue,
                firstValue,
                lastValue
              )
            ) {
              first = pointValue === firstValue;
              last = pointValue === lastValue;
              break;
            }
          }
          return {
            first,
            last,
            point,
          };
        }

        class simpleArc {
          constructor(opts) {
            this.x = opts.x;
            this.y = opts.y;
            this.radius = opts.radius;
          }
          pathSegment(ctx, bounds, opts) {
            const { x, y, radius } = this;
            bounds = bounds || {
              start: 0,
              end: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T,
            };
            ctx.arc(x, y, radius, bounds.end, bounds.start, true);
            return !opts.bounds;
          }
          interpolate(point) {
            const { x, y, radius } = this;
            const angle = point.angle;
            return {
              x: x + Math.cos(angle) * radius,
              y: y + Math.sin(angle) * radius,
              angle,
            };
          }
        }

        function _getTarget(source) {
          const { chart, fill, line } = source;
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(fill)
          ) {
            return getLineByIndex(chart, fill);
          }
          if (fill === 'stack') {
            return _buildStackLine(source);
          }
          if (fill === 'shape') {
            return true;
          }
          const boundary = computeBoundary(source);
          if (boundary instanceof simpleArc) {
            return boundary;
          }
          return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart, index) {
          const meta = chart.getDatasetMeta(index);
          const visible = meta && chart.isDatasetVisible(index);
          return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
          const scale = source.scale || {};
          if (scale.getPointPositionForValue) {
            return computeCircularBoundary(source);
          }
          return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
          const { scale = {}, fill } = source;
          const pixel = _getTargetPixel(fill, scale);
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
              pixel
            )
          ) {
            const horizontal = scale.isHorizontal();
            return {
              x: horizontal ? pixel : null,
              y: horizontal ? null : pixel,
            };
          }
          return null;
        }
        function computeCircularBoundary(source) {
          const { scale, fill } = source;
          const options = scale.options;
          const length = scale.getLabels().length;
          const start = options.reverse ? scale.max : scale.min;
          const value = _getTargetValue(fill, scale, start);
          const target = [];
          if (options.grid.circular) {
            const center = scale.getPointPositionForValue(0, start);
            return new simpleArc({
              x: center.x,
              y: center.y,
              radius: scale.getDistanceFromCenterForValue(value),
            });
          }
          for (let i = 0; i < length; ++i) {
            target.push(scale.getPointPositionForValue(i, value));
          }
          return target;
        }

        function _drawfill(ctx, source, area) {
          const target = _getTarget(source);
          const { chart, index, line, scale, axis } = source;
          const lineOpts = line.options;
          const fillOption = lineOpts.fill;
          const color = lineOpts.backgroundColor;
          const { above = color, below = color } = fillOption || {};
          const meta = chart.getDatasetMeta(index);
          const clip = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah)(
            chart,
            meta
          );
          if (target && line.points.length) {
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(
              ctx,
              area
            );
            doFill(ctx, {
              line,
              target,
              above,
              below,
              area,
              scale,
              axis,
              clip,
            });
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(ctx);
          }
        }
        function doFill(ctx, cfg) {
          const { line, target, above, below, area, scale, clip } = cfg;
          const property = line._loop ? 'angle' : cfg.axis;
          ctx.save();
          if (property === 'x' && below !== above) {
            clipVertical(ctx, target, area.top);
            fill(ctx, {
              line,
              target,
              color: above,
              scale,
              property,
              clip,
            });
            ctx.restore();
            ctx.save();
            clipVertical(ctx, target, area.bottom);
          }
          fill(ctx, {
            line,
            target,
            color: below,
            scale,
            property,
            clip,
          });
          ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
          const { segments, points } = target;
          let first = true;
          let lineLoop = false;
          ctx.beginPath();
          for (const segment of segments) {
            const { start, end } = segment;
            const firstPoint = points[start];
            const lastPoint = points[_findSegmentEnd(start, end, points)];
            if (first) {
              ctx.moveTo(firstPoint.x, firstPoint.y);
              first = false;
            } else {
              ctx.lineTo(firstPoint.x, clipY);
              ctx.lineTo(firstPoint.x, firstPoint.y);
            }
            lineLoop = !!target.pathSegment(ctx, segment, {
              move: lineLoop,
            });
            if (lineLoop) {
              ctx.closePath();
            } else {
              ctx.lineTo(lastPoint.x, clipY);
            }
          }
          ctx.lineTo(target.first().x, clipY);
          ctx.closePath();
          ctx.clip();
        }
        function fill(ctx, cfg) {
          const { line, target, property, color, scale, clip } = cfg;
          const segments = _segments(line, target, property);
          for (const { source: src, target: tgt, start, end } of segments) {
            const { style: { backgroundColor = color } = {} } = src;
            const notShape = target !== true;
            ctx.save();
            ctx.fillStyle = backgroundColor;
            clipBounds(
              ctx,
              scale,
              clip,
              notShape && _getBounds(property, start, end)
            );
            ctx.beginPath();
            const lineLoop = !!line.pathSegment(ctx, src);
            let loop;
            if (notShape) {
              if (lineLoop) {
                ctx.closePath();
              } else {
                interpolatedLineTo(ctx, target, end, property);
              }
              const targetLoop = !!target.pathSegment(ctx, tgt, {
                move: lineLoop,
                reverse: true,
              });
              loop = lineLoop && targetLoop;
              if (!loop) {
                interpolatedLineTo(ctx, target, start, property);
              }
            }
            ctx.closePath();
            ctx.fill(loop ? 'evenodd' : 'nonzero');
            ctx.restore();
          }
        }
        function clipBounds(ctx, scale, clip, bounds) {
          const chartArea = scale.chart.chartArea;
          const { property, start, end } = bounds || {};
          if (property === 'x' || property === 'y') {
            let left, top, right, bottom;
            if (property === 'x') {
              left = start;
              top = chartArea.top;
              right = end;
              bottom = chartArea.bottom;
            } else {
              left = chartArea.left;
              top = start;
              right = chartArea.right;
              bottom = end;
            }
            ctx.beginPath();
            if (clip) {
              left = Math.max(left, clip.left);
              right = Math.min(right, clip.right);
              top = Math.max(top, clip.top);
              bottom = Math.min(bottom, clip.bottom);
            }
            ctx.rect(left, top, right - left, bottom - top);
            ctx.clip();
          }
        }
        function interpolatedLineTo(ctx, target, point, property) {
          const interpolatedPoint = target.interpolate(point, property);
          if (interpolatedPoint) {
            ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
          }
        }

        var index = {
          id: 'filler',
          afterDatasetsUpdate(chart, _args, options) {
            const count = (chart.data.datasets || []).length;
            const sources = [];
            let meta, i, line, source;
            for (i = 0; i < count; ++i) {
              meta = chart.getDatasetMeta(i);
              line = meta.dataset;
              source = null;
              if (line && line.options && line instanceof LineElement) {
                source = {
                  visible: chart.isDatasetVisible(i),
                  index: i,
                  fill: _decodeFill(line, i, count),
                  chart,
                  axis: meta.controller.options.indexAxis,
                  scale: meta.vScale,
                  line,
                };
              }
              meta.$filler = source;
              sources.push(source);
            }
            for (i = 0; i < count; ++i) {
              source = sources[i];
              if (!source || source.fill === false) {
                continue;
              }
              source.fill = _resolveTarget(sources, i, options.propagate);
            }
          },
          beforeDraw(chart, _args, options) {
            const draw = options.drawTime === 'beforeDraw';
            const metasets = chart.getSortedVisibleDatasetMetas();
            const area = chart.chartArea;
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (!source) {
                continue;
              }
              source.line.updateControlPoints(area, source.axis);
              if (draw && source.fill) {
                _drawfill(chart.ctx, source, area);
              }
            }
          },
          beforeDatasetsDraw(chart, _args, options) {
            if (options.drawTime !== 'beforeDatasetsDraw') {
              return;
            }
            const metasets = chart.getSortedVisibleDatasetMetas();
            for (let i = metasets.length - 1; i >= 0; --i) {
              const source = metasets[i].$filler;
              if (_shouldApplyFill(source)) {
                _drawfill(chart.ctx, source, chart.chartArea);
              }
            }
          },
          beforeDatasetDraw(chart, args, options) {
            const source = args.meta.$filler;
            if (
              !_shouldApplyFill(source) ||
              options.drawTime !== 'beforeDatasetDraw'
            ) {
              return;
            }
            _drawfill(chart.ctx, source, chart.chartArea);
          },
          defaults: {
            propagate: true,
            drawTime: 'beforeDatasetDraw',
          },
        };

        const getBoxSize = (labelOpts, fontSize) => {
          let { boxHeight = fontSize, boxWidth = fontSize } = labelOpts;
          if (labelOpts.usePointStyle) {
            boxHeight = Math.min(boxHeight, fontSize);
            boxWidth =
              labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
          }
          return {
            boxWidth,
            boxHeight,
            itemHeight: Math.max(fontSize, boxHeight),
          };
        };
        const itemsEqual = (a, b) =>
          a !== null &&
          b !== null &&
          a.datasetIndex === b.datasetIndex &&
          a.index === b.index;
        class Legend extends Element {
          constructor(config) {
            super();
            this._added = false;
            this.legendHitBoxes = [];
            this._hoveredItem = null;
            this.doughnutMode = false;
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this.legendItems = undefined;
            this.columnSizes = undefined;
            this.lineWidths = undefined;
            this.maxHeight = undefined;
            this.maxWidth = undefined;
            this.top = undefined;
            this.bottom = undefined;
            this.left = undefined;
            this.right = undefined;
            this.height = undefined;
            this.width = undefined;
            this._margins = undefined;
            this.position = undefined;
            this.weight = undefined;
            this.fullSize = undefined;
          }
          update(maxWidth, maxHeight, margins) {
            this.maxWidth = maxWidth;
            this.maxHeight = maxHeight;
            this._margins = margins;
            this.setDimensions();
            this.buildLabels();
            this.fit();
          }
          setDimensions() {
            if (this.isHorizontal()) {
              this.width = this.maxWidth;
              this.left = this._margins.left;
              this.right = this.width;
            } else {
              this.height = this.maxHeight;
              this.top = this._margins.top;
              this.bottom = this.height;
            }
          }
          buildLabels() {
            const labelOpts = this.options.labels || {};
            let legendItems =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                labelOpts.generateLabels,
                [this.chart],
                this
              ) || [];
            if (labelOpts.filter) {
              legendItems = legendItems.filter((item) =>
                labelOpts.filter(item, this.chart.data)
              );
            }
            if (labelOpts.sort) {
              legendItems = legendItems.sort((a, b) =>
                labelOpts.sort(a, b, this.chart.data)
              );
            }
            if (this.options.reverse) {
              legendItems.reverse();
            }
            this.legendItems = legendItems;
          }
          fit() {
            const { options, ctx } = this;
            if (!options.display) {
              this.width = this.height = 0;
              return;
            }
            const labelOpts = options.labels;
            const labelFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              labelOpts.font
            );
            const fontSize = labelFont.size;
            const titleHeight = this._computeTitleHeight();
            const { boxWidth, itemHeight } = getBoxSize(labelOpts, fontSize);
            let width, height;
            ctx.font = labelFont.string;
            if (this.isHorizontal()) {
              width = this.maxWidth;
              height =
                this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
            } else {
              height = this.maxHeight;
              width =
                this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) +
                10;
            }
            this.width = Math.min(width, options.maxWidth || this.maxWidth);
            this.height = Math.min(height, options.maxHeight || this.maxHeight);
          }
          _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
            const {
              ctx,
              maxWidth,
              options: {
                labels: { padding },
              },
            } = this;
            const hitboxes = (this.legendHitBoxes = []);
            const lineWidths = (this.lineWidths = [0]);
            const lineHeight = itemHeight + padding;
            let totalHeight = titleHeight;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            let row = -1;
            let top = -lineHeight;
            this.legendItems.forEach((legendItem, i) => {
              const itemWidth =
                boxWidth +
                fontSize / 2 +
                ctx.measureText(legendItem.text).width;
              if (
                i === 0 ||
                lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding >
                  maxWidth
              ) {
                totalHeight += lineHeight;
                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                top += lineHeight;
                row++;
              }
              hitboxes[i] = {
                left: 0,
                top,
                row,
                width: itemWidth,
                height: itemHeight,
              };
              lineWidths[lineWidths.length - 1] += itemWidth + padding;
            });
            return totalHeight;
          }
          _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
            const {
              ctx,
              maxHeight,
              options: {
                labels: { padding },
              },
            } = this;
            const hitboxes = (this.legendHitBoxes = []);
            const columnSizes = (this.columnSizes = []);
            const heightLimit = maxHeight - titleHeight;
            let totalWidth = padding;
            let currentColWidth = 0;
            let currentColHeight = 0;
            let left = 0;
            let col = 0;
            this.legendItems.forEach((legendItem, i) => {
              const { itemWidth, itemHeight } = calculateItemSize(
                boxWidth,
                labelFont,
                ctx,
                legendItem,
                _itemHeight
              );
              if (
                i > 0 &&
                currentColHeight + itemHeight + 2 * padding > heightLimit
              ) {
                totalWidth += currentColWidth + padding;
                columnSizes.push({
                  width: currentColWidth,
                  height: currentColHeight,
                });
                left += currentColWidth + padding;
                col++;
                currentColWidth = currentColHeight = 0;
              }
              hitboxes[i] = {
                left,
                top: currentColHeight,
                col,
                width: itemWidth,
                height: itemHeight,
              };
              currentColWidth = Math.max(currentColWidth, itemWidth);
              currentColHeight += itemHeight + padding;
            });
            totalWidth += currentColWidth;
            columnSizes.push({
              width: currentColWidth,
              height: currentColHeight,
            });
            return totalWidth;
          }
          adjustHitBoxes() {
            if (!this.options.display) {
              return;
            }
            const titleHeight = this._computeTitleHeight();
            const {
              legendHitBoxes: hitboxes,
              options: {
                align,
                labels: { padding },
                rtl,
              },
            } = this;
            const rtlHelper = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(
              rtl,
              this.left,
              this.width
            );
            if (this.isHorizontal()) {
              let row = 0;
              let left = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                align,
                this.left + padding,
                this.right - this.lineWidths[row]
              );
              for (const hitbox of hitboxes) {
                if (row !== hitbox.row) {
                  row = hitbox.row;
                  left = (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                    align,
                    this.left + padding,
                    this.right - this.lineWidths[row]
                  );
                }
                hitbox.top += this.top + titleHeight + padding;
                hitbox.left = rtlHelper.leftForLtr(
                  rtlHelper.x(left),
                  hitbox.width
                );
                left += hitbox.width + padding;
              }
            } else {
              let col = 0;
              let top = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                align,
                this.top + titleHeight + padding,
                this.bottom - this.columnSizes[col].height
              );
              for (const hitbox of hitboxes) {
                if (hitbox.col !== col) {
                  col = hitbox.col;
                  top = (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                    align,
                    this.top + titleHeight + padding,
                    this.bottom - this.columnSizes[col].height
                  );
                }
                hitbox.top = top;
                hitbox.left += this.left + padding;
                hitbox.left = rtlHelper.leftForLtr(
                  rtlHelper.x(hitbox.left),
                  hitbox.width
                );
                top += hitbox.height + padding;
              }
            }
          }
          isHorizontal() {
            return (
              this.options.position === 'top' ||
              this.options.position === 'bottom'
            );
          }
          draw() {
            if (this.options.display) {
              const ctx = this.ctx;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y)(
                ctx,
                this
              );
              this._draw();
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$)(
                ctx
              );
            }
          }
          _draw() {
            const { options: opts, columnSizes, lineWidths, ctx } = this;
            const { align, labels: labelOpts } = opts;
            const defaultColor =
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.color;
            const rtlHelper = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(
              opts.rtl,
              this.left,
              this.width
            );
            const labelFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              labelOpts.font
            );
            const { padding } = labelOpts;
            const fontSize = labelFont.size;
            const halfFontSize = fontSize / 2;
            let cursor;
            this.drawTitle();
            ctx.textAlign = rtlHelper.textAlign('left');
            ctx.textBaseline = 'middle';
            ctx.lineWidth = 0.5;
            ctx.font = labelFont.string;
            const { boxWidth, boxHeight, itemHeight } = getBoxSize(
              labelOpts,
              fontSize
            );
            const drawLegendBox = function (x, y, legendItem) {
              if (
                isNaN(boxWidth) ||
                boxWidth <= 0 ||
                isNaN(boxHeight) ||
                boxHeight < 0
              ) {
                return;
              }
              ctx.save();
              const lineWidth = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                legendItem.lineWidth,
                1
              );
              ctx.fillStyle = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                legendItem.fillStyle,
                defaultColor
              );
              ctx.lineCap = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                legendItem.lineCap,
                'butt'
              );
              ctx.lineDashOffset = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                legendItem.lineDashOffset,
                0
              );
              ctx.lineJoin = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                legendItem.lineJoin,
                'miter'
              );
              ctx.lineWidth = lineWidth;
              ctx.strokeStyle = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                legendItem.strokeStyle,
                defaultColor
              );
              ctx.setLineDash(
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                  legendItem.lineDash,
                  []
                )
              );
              if (labelOpts.usePointStyle) {
                const drawOptions = {
                  radius: (boxHeight * Math.SQRT2) / 2,
                  pointStyle: legendItem.pointStyle,
                  rotation: legendItem.rotation,
                  borderWidth: lineWidth,
                };
                const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                const centerY = y + halfFontSize;
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aE)(
                  ctx,
                  drawOptions,
                  centerX,
                  centerY,
                  labelOpts.pointStyleWidth && boxWidth
                );
              } else {
                const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                const borderRadius = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(
                  legendItem.borderRadius
                );
                ctx.beginPath();
                if (Object.values(borderRadius).some((v) => v !== 0)) {
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(
                    ctx,
                    {
                      x: xBoxLeft,
                      y: yBoxTop,
                      w: boxWidth,
                      h: boxHeight,
                      radius: borderRadius,
                    }
                  );
                } else {
                  ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                }
                ctx.fill();
                if (lineWidth !== 0) {
                  ctx.stroke();
                }
              }
              ctx.restore();
            };
            const fillText = function (x, y, legendItem) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
                ctx,
                legendItem.text,
                x,
                y + itemHeight / 2,
                labelFont,
                {
                  strikethrough: legendItem.hidden,
                  textAlign: rtlHelper.textAlign(legendItem.textAlign),
                }
              );
            };
            const isHorizontal = this.isHorizontal();
            const titleHeight = this._computeTitleHeight();
            if (isHorizontal) {
              cursor = {
                x: (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                  align,
                  this.left + padding,
                  this.right - lineWidths[0]
                ),
                y: this.top + padding + titleHeight,
                line: 0,
              };
            } else {
              cursor = {
                x: this.left + padding,
                y: (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                  align,
                  this.top + titleHeight + padding,
                  this.bottom - columnSizes[0].height
                ),
                line: 0,
              };
            }
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(
              this.ctx,
              opts.textDirection
            );
            const lineHeight = itemHeight + padding;
            this.legendItems.forEach((legendItem, i) => {
              ctx.strokeStyle = legendItem.fontColor;
              ctx.fillStyle = legendItem.fontColor;
              const textWidth = ctx.measureText(legendItem.text).width;
              const textAlign = rtlHelper.textAlign(
                legendItem.textAlign ||
                  (legendItem.textAlign = labelOpts.textAlign)
              );
              const width = boxWidth + halfFontSize + textWidth;
              let x = cursor.x;
              let y = cursor.y;
              rtlHelper.setWidth(this.width);
              if (isHorizontal) {
                if (i > 0 && x + width + padding > this.right) {
                  y = cursor.y += lineHeight;
                  cursor.line++;
                  x = cursor.x = (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                    align,
                    this.left + padding,
                    this.right - lineWidths[cursor.line]
                  );
                }
              } else if (i > 0 && y + lineHeight > this.bottom) {
                x = cursor.x = x + columnSizes[cursor.line].width + padding;
                cursor.line++;
                y = cursor.y = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                  align,
                  this.top + titleHeight + padding,
                  this.bottom - columnSizes[cursor.line].height
                );
              }
              const realX = rtlHelper.x(x);
              drawLegendBox(realX, y, legendItem);
              x = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aC)(
                textAlign,
                x + boxWidth + halfFontSize,
                isHorizontal ? x + width : this.right,
                opts.rtl
              );
              fillText(rtlHelper.x(x), y, legendItem);
              if (isHorizontal) {
                cursor.x += width + padding;
              } else if (typeof legendItem.text !== 'string') {
                const fontLineHeight = labelFont.lineHeight;
                cursor.y +=
                  calculateLegendItemHeight(legendItem, fontLineHeight) +
                  padding;
              } else {
                cursor.y += lineHeight;
              }
            });
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(
              this.ctx,
              opts.textDirection
            );
          }
          drawTitle() {
            const opts = this.options;
            const titleOpts = opts.title;
            const titleFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              titleOpts.font
            );
            const titlePadding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              titleOpts.padding
            );
            if (!titleOpts.display) {
              return;
            }
            const rtlHelper = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(
              opts.rtl,
              this.left,
              this.width
            );
            const ctx = this.ctx;
            const position = titleOpts.position;
            const halfFontSize = titleFont.size / 2;
            const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
            let y;
            let left = this.left;
            let maxWidth = this.width;
            if (this.isHorizontal()) {
              maxWidth = Math.max(...this.lineWidths);
              y = this.top + topPaddingPlusHalfFontSize;
              left = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                opts.align,
                left,
                this.right - maxWidth
              );
            } else {
              const maxHeight = this.columnSizes.reduce(
                (acc, size) => Math.max(acc, size.height),
                0
              );
              y =
                topPaddingPlusHalfFontSize +
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                  opts.align,
                  this.top,
                  this.bottom -
                    maxHeight -
                    opts.labels.padding -
                    this._computeTitleHeight()
                );
            }
            const x = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
              position,
              left,
              left + maxWidth
            );
            ctx.textAlign = rtlHelper.textAlign(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(
                position
              )
            );
            ctx.textBaseline = 'middle';
            ctx.strokeStyle = titleOpts.color;
            ctx.fillStyle = titleOpts.color;
            ctx.font = titleFont.string;
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
              ctx,
              titleOpts.text,
              x,
              y,
              titleFont
            );
          }
          _computeTitleHeight() {
            const titleOpts = this.options.title;
            const titleFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              titleOpts.font
            );
            const titlePadding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              titleOpts.padding
            );
            return titleOpts.display
              ? titleFont.lineHeight + titlePadding.height
              : 0;
          }
          _getLegendItemAt(x, y) {
            let i, hitBox, lh;
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                x,
                this.left,
                this.right
              ) &&
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                y,
                this.top,
                this.bottom
              )
            ) {
              lh = this.legendHitBoxes;
              for (i = 0; i < lh.length; ++i) {
                hitBox = lh[i];
                if (
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                    x,
                    hitBox.left,
                    hitBox.left + hitBox.width
                  ) &&
                  (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak)(
                    y,
                    hitBox.top,
                    hitBox.top + hitBox.height
                  )
                ) {
                  return this.legendItems[i];
                }
              }
            }
            return null;
          }
          handleEvent(e) {
            const opts = this.options;
            if (!isListened(e.type, opts)) {
              return;
            }
            const hoveredItem = this._getLegendItemAt(e.x, e.y);
            if (e.type === 'mousemove' || e.type === 'mouseout') {
              const previous = this._hoveredItem;
              const sameItem = itemsEqual(previous, hoveredItem);
              if (previous && !sameItem) {
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                  opts.onLeave,
                  [e, previous, this],
                  this
                );
              }
              this._hoveredItem = hoveredItem;
              if (hoveredItem && !sameItem) {
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                  opts.onHover,
                  [e, hoveredItem, this],
                  this
                );
              }
            } else if (hoveredItem) {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                opts.onClick,
                [e, hoveredItem, this],
                this
              );
            }
          }
        }
        function calculateItemSize(
          boxWidth,
          labelFont,
          ctx,
          legendItem,
          _itemHeight
        ) {
          const itemWidth = calculateItemWidth(
            legendItem,
            boxWidth,
            labelFont,
            ctx
          );
          const itemHeight = calculateItemHeight(
            _itemHeight,
            legendItem,
            labelFont.lineHeight
          );
          return {
            itemWidth,
            itemHeight,
          };
        }
        function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
          let legendItemText = legendItem.text;
          if (legendItemText && typeof legendItemText !== 'string') {
            legendItemText = legendItemText.reduce((a, b) =>
              a.length > b.length ? a : b
            );
          }
          return (
            boxWidth +
            labelFont.size / 2 +
            ctx.measureText(legendItemText).width
          );
        }
        function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
          let itemHeight = _itemHeight;
          if (typeof legendItem.text !== 'string') {
            itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
          }
          return itemHeight;
        }
        function calculateLegendItemHeight(legendItem, fontLineHeight) {
          const labelHeight = legendItem.text ? legendItem.text.length : 0;
          return fontLineHeight * labelHeight;
        }
        function isListened(type, opts) {
          if (
            (type === 'mousemove' || type === 'mouseout') &&
            (opts.onHover || opts.onLeave)
          ) {
            return true;
          }
          if (opts.onClick && (type === 'click' || type === 'mouseup')) {
            return true;
          }
          return false;
        }
        var plugin_legend = {
          id: 'legend',
          _element: Legend,
          start(chart, _args, options) {
            const legend = (chart.legend = new Legend({
              ctx: chart.ctx,
              options,
              chart,
            }));
            layouts.configure(chart, legend, options);
            layouts.addBox(chart, legend);
          },
          stop(chart) {
            layouts.removeBox(chart, chart.legend);
            delete chart.legend;
          },
          beforeUpdate(chart, _args, options) {
            const legend = chart.legend;
            layouts.configure(chart, legend, options);
            legend.options = options;
          },
          afterUpdate(chart) {
            const legend = chart.legend;
            legend.buildLabels();
            legend.adjustHitBoxes();
          },
          afterEvent(chart, args) {
            if (!args.replay) {
              chart.legend.handleEvent(args.event);
            }
          },
          defaults: {
            display: true,
            position: 'top',
            align: 'center',
            fullSize: true,
            reverse: false,
            weight: 1000,
            onClick(e, legendItem, legend) {
              const index = legendItem.datasetIndex;
              const ci = legend.chart;
              if (ci.isDatasetVisible(index)) {
                ci.hide(index);
                legendItem.hidden = true;
              } else {
                ci.show(index);
                legendItem.hidden = false;
              }
            },
            onHover: null,
            onLeave: null,
            labels: {
              color: (ctx) => ctx.chart.options.color,
              boxWidth: 40,
              padding: 10,
              generateLabels(chart) {
                const datasets = chart.data.datasets;
                const {
                  labels: {
                    usePointStyle,
                    pointStyle,
                    textAlign,
                    color,
                    useBorderRadius,
                    borderRadius,
                  },
                } = chart.legend.options;
                return chart._getSortedDatasetMetas().map((meta) => {
                  const style = meta.controller.getStyle(
                    usePointStyle ? 0 : undefined
                  );
                  const borderWidth = (0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
                    style.borderWidth
                  );
                  return {
                    text: datasets[meta.index].label,
                    fillStyle: style.backgroundColor,
                    fontColor: color,
                    hidden: !meta.visible,
                    lineCap: style.borderCapStyle,
                    lineDash: style.borderDash,
                    lineDashOffset: style.borderDashOffset,
                    lineJoin: style.borderJoinStyle,
                    lineWidth: (borderWidth.width + borderWidth.height) / 4,
                    strokeStyle: style.borderColor,
                    pointStyle: pointStyle || style.pointStyle,
                    rotation: style.rotation,
                    textAlign: textAlign || style.textAlign,
                    borderRadius:
                      useBorderRadius && (borderRadius || style.borderRadius),
                    datasetIndex: meta.index,
                  };
                }, this);
              },
            },
            title: {
              color: (ctx) => ctx.chart.options.color,
              display: false,
              position: 'center',
              text: '',
            },
          },
          descriptors: {
            _scriptable: (name) => !name.startsWith('on'),
            labels: {
              _scriptable: (name) =>
                !['generateLabels', 'filter', 'sort'].includes(name),
            },
          },
        };

        class Title extends Element {
          constructor(config) {
            super();
            this.chart = config.chart;
            this.options = config.options;
            this.ctx = config.ctx;
            this._padding = undefined;
            this.top = undefined;
            this.bottom = undefined;
            this.left = undefined;
            this.right = undefined;
            this.width = undefined;
            this.height = undefined;
            this.position = undefined;
            this.weight = undefined;
            this.fullSize = undefined;
          }
          update(maxWidth, maxHeight) {
            const opts = this.options;
            this.left = 0;
            this.top = 0;
            if (!opts.display) {
              this.width = this.height = this.right = this.bottom = 0;
              return;
            }
            this.width = this.right = maxWidth;
            this.height = this.bottom = maxHeight;
            const lineCount = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
              opts.text
            )
              ? opts.text.length
              : 1;
            this._padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              opts.padding
            );
            const textSize =
              lineCount *
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
                  opts.font
                ).lineHeight +
              this._padding.height;
            if (this.isHorizontal()) {
              this.height = textSize;
            } else {
              this.width = textSize;
            }
          }
          isHorizontal() {
            const pos = this.options.position;
            return pos === 'top' || pos === 'bottom';
          }
          _drawArgs(offset) {
            const { top, left, bottom, right, options } = this;
            const align = options.align;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            if (this.isHorizontal()) {
              titleX = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                align,
                left,
                right
              );
              titleY = top + offset;
              maxWidth = right - left;
            } else {
              if (options.position === 'left') {
                titleX = left + offset;
                titleY = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                  align,
                  bottom,
                  top
                );
                rotation =
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P *
                  -0.5;
              } else {
                titleX = right - offset;
                titleY = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2)(
                  align,
                  top,
                  bottom
                );
                rotation =
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P *
                  0.5;
              }
              maxWidth = bottom - top;
            }
            return {
              titleX,
              titleY,
              maxWidth,
              rotation,
            };
          }
          draw() {
            const ctx = this.ctx;
            const opts = this.options;
            if (!opts.display) {
              return;
            }
            const fontOpts = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              opts.font
            );
            const lineHeight = fontOpts.lineHeight;
            const offset = lineHeight / 2 + this._padding.top;
            const { titleX, titleY, maxWidth, rotation } =
              this._drawArgs(offset);
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
              ctx,
              opts.text,
              0,
              0,
              fontOpts,
              {
                color: opts.color,
                maxWidth,
                rotation,
                textAlign: (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1)(
                  opts.align
                ),
                textBaseline: 'middle',
                translation: [titleX, titleY],
              }
            );
          }
        }
        function createTitle(chart, titleOpts) {
          const title = new Title({
            ctx: chart.ctx,
            options: titleOpts,
            chart,
          });
          layouts.configure(chart, title, titleOpts);
          layouts.addBox(chart, title);
          chart.titleBlock = title;
        }
        var plugin_title = {
          id: 'title',
          _element: Title,
          start(chart, _args, options) {
            createTitle(chart, options);
          },
          stop(chart) {
            const titleBlock = chart.titleBlock;
            layouts.removeBox(chart, titleBlock);
            delete chart.titleBlock;
          },
          beforeUpdate(chart, _args, options) {
            const title = chart.titleBlock;
            layouts.configure(chart, title, options);
            title.options = options;
          },
          defaults: {
            align: 'center',
            display: false,
            font: {
              weight: 'bold',
            },
            fullSize: true,
            padding: 10,
            position: 'top',
            text: '',
            weight: 2000,
          },
          defaultRoutes: {
            color: 'color',
          },
          descriptors: {
            _scriptable: true,
            _indexable: false,
          },
        };

        const map = new WeakMap();
        var plugin_subtitle = {
          id: 'subtitle',
          start(chart, _args, options) {
            const title = new Title({
              ctx: chart.ctx,
              options,
              chart,
            });
            layouts.configure(chart, title, options);
            layouts.addBox(chart, title);
            map.set(chart, title);
          },
          stop(chart) {
            layouts.removeBox(chart, map.get(chart));
            map.delete(chart);
          },
          beforeUpdate(chart, _args, options) {
            const title = map.get(chart);
            layouts.configure(chart, title, options);
            title.options = options;
          },
          defaults: {
            align: 'center',
            display: false,
            font: {
              weight: 'normal',
            },
            fullSize: true,
            padding: 0,
            position: 'top',
            text: '',
            weight: 1500,
          },
          defaultRoutes: {
            color: 'color',
          },
          descriptors: {
            _scriptable: true,
            _indexable: false,
          },
        };

        const positioners = {
          average(items) {
            if (!items.length) {
              return false;
            }
            let i, len;
            let xSet = new Set();
            let y = 0;
            let count = 0;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const pos = el.tooltipPosition();
                xSet.add(pos.x);
                y += pos.y;
                ++count;
              }
            }
            if (count === 0 || xSet.size === 0) {
              return false;
            }
            const xAverage = [...xSet].reduce((a, b) => a + b) / xSet.size;
            return {
              x: xAverage,
              y: y / count,
            };
          },
          nearest(items, eventPosition) {
            if (!items.length) {
              return false;
            }
            let x = eventPosition.x;
            let y = eventPosition.y;
            let minDistance = Number.POSITIVE_INFINITY;
            let i, len, nearestElement;
            for (i = 0, len = items.length; i < len; ++i) {
              const el = items[i].element;
              if (el && el.hasValue()) {
                const center = el.getCenterPoint();
                const d = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aF)(
                  eventPosition,
                  center
                );
                if (d < minDistance) {
                  minDistance = d;
                  nearestElement = el;
                }
              }
            }
            if (nearestElement) {
              const tp = nearestElement.tooltipPosition();
              x = tp.x;
              y = tp.y;
            }
            return {
              x,
              y,
            };
          },
        };
        function pushOrConcat(base, toPush) {
          if (toPush) {
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(
                toPush
              )
            ) {
              Array.prototype.push.apply(base, toPush);
            } else {
              base.push(toPush);
            }
          }
          return base;
        }
        function splitNewlines(str) {
          if (
            (typeof str === 'string' || str instanceof String) &&
            str.indexOf('\n') > -1
          ) {
            return str.split('\n');
          }
          return str;
        }
        function createTooltipItem(chart, item) {
          const { element, datasetIndex, index } = item;
          const controller = chart.getDatasetMeta(datasetIndex).controller;
          const { label, value } = controller.getLabelAndValue(index);
          return {
            chart,
            label,
            parsed: controller.getParsed(index),
            raw: chart.data.datasets[datasetIndex].data[index],
            formattedValue: value,
            dataset: controller.getDataset(),
            dataIndex: index,
            datasetIndex,
            element,
          };
        }
        function getTooltipSize(tooltip, options) {
          const ctx = tooltip.chart.ctx;
          const { body, footer, title } = tooltip;
          const { boxWidth, boxHeight } = options;
          const bodyFont = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
            options.bodyFont
          );
          const titleFont = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
            options.titleFont
          );
          const footerFont = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
            options.footerFont
          );
          const titleLineCount = title.length;
          const footerLineCount = footer.length;
          const bodyLineItemCount = body.length;
          const padding = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
            options.padding
          );
          let height = padding.height;
          let width = 0;
          let combinedBodyLength = body.reduce(
            (count, bodyItem) =>
              count +
              bodyItem.before.length +
              bodyItem.lines.length +
              bodyItem.after.length,
            0
          );
          combinedBodyLength +=
            tooltip.beforeBody.length + tooltip.afterBody.length;
          if (titleLineCount) {
            height +=
              titleLineCount * titleFont.lineHeight +
              (titleLineCount - 1) * options.titleSpacing +
              options.titleMarginBottom;
          }
          if (combinedBodyLength) {
            const bodyLineHeight = options.displayColors
              ? Math.max(boxHeight, bodyFont.lineHeight)
              : bodyFont.lineHeight;
            height +=
              bodyLineItemCount * bodyLineHeight +
              (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight +
              (combinedBodyLength - 1) * options.bodySpacing;
          }
          if (footerLineCount) {
            height +=
              options.footerMarginTop +
              footerLineCount * footerFont.lineHeight +
              (footerLineCount - 1) * options.footerSpacing;
          }
          let widthPadding = 0;
          const maxLineWidth = function (line) {
            width = Math.max(width, ctx.measureText(line).width + widthPadding);
          };
          ctx.save();
          ctx.font = titleFont.string;
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
            tooltip.title,
            maxLineWidth
          );
          ctx.font = bodyFont.string;
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
            tooltip.beforeBody.concat(tooltip.afterBody),
            maxLineWidth
          );
          widthPadding = options.displayColors
            ? boxWidth + 2 + options.boxPadding
            : 0;
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
            body,
            (bodyItem) => {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                bodyItem.before,
                maxLineWidth
              );
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                bodyItem.lines,
                maxLineWidth
              );
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                bodyItem.after,
                maxLineWidth
              );
            }
          );
          widthPadding = 0;
          ctx.font = footerFont.string;
          (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
            tooltip.footer,
            maxLineWidth
          );
          ctx.restore();
          width += padding.width;
          return {
            width,
            height,
          };
        }
        function determineYAlign(chart, size) {
          const { y, height } = size;
          if (y < height / 2) {
            return 'top';
          } else if (y > chart.height - height / 2) {
            return 'bottom';
          }
          return 'center';
        }
        function doesNotFitWithAlign(xAlign, chart, options, size) {
          const { x, width } = size;
          const caret = options.caretSize + options.caretPadding;
          if (xAlign === 'left' && x + width + caret > chart.width) {
            return true;
          }
          if (xAlign === 'right' && x - width - caret < 0) {
            return true;
          }
        }
        function determineXAlign(chart, options, size, yAlign) {
          const { x, width } = size;
          const {
            width: chartWidth,
            chartArea: { left, right },
          } = chart;
          let xAlign = 'center';
          if (yAlign === 'center') {
            xAlign = x <= (left + right) / 2 ? 'left' : 'right';
          } else if (x <= width / 2) {
            xAlign = 'left';
          } else if (x >= chartWidth - width / 2) {
            xAlign = 'right';
          }
          if (doesNotFitWithAlign(xAlign, chart, options, size)) {
            xAlign = 'center';
          }
          return xAlign;
        }
        function determineAlignment(chart, options, size) {
          const yAlign =
            size.yAlign || options.yAlign || determineYAlign(chart, size);
          return {
            xAlign:
              size.xAlign ||
              options.xAlign ||
              determineXAlign(chart, options, size, yAlign),
            yAlign,
          };
        }
        function alignX(size, xAlign) {
          let { x, width } = size;
          if (xAlign === 'right') {
            x -= width;
          } else if (xAlign === 'center') {
            x -= width / 2;
          }
          return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
          let { y, height } = size;
          if (yAlign === 'top') {
            y += paddingAndSize;
          } else if (yAlign === 'bottom') {
            y -= height + paddingAndSize;
          } else {
            y -= height / 2;
          }
          return y;
        }
        function getBackgroundPoint(options, size, alignment, chart) {
          const { caretSize, caretPadding, cornerRadius } = options;
          const { xAlign, yAlign } = alignment;
          const paddingAndSize = caretSize + caretPadding;
          const { topLeft, topRight, bottomLeft, bottomRight } = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(
            cornerRadius
          );
          let x = alignX(size, xAlign);
          const y = alignY(size, yAlign, paddingAndSize);
          if (yAlign === 'center') {
            if (xAlign === 'left') {
              x += paddingAndSize;
            } else if (xAlign === 'right') {
              x -= paddingAndSize;
            }
          } else if (xAlign === 'left') {
            x -= Math.max(topLeft, bottomLeft) + caretSize;
          } else if (xAlign === 'right') {
            x += Math.max(topRight, bottomRight) + caretSize;
          }
          return {
            x: (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              x,
              0,
              chart.width - size.width
            ),
            y: (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              y,
              0,
              chart.height - size.height
            ),
          };
        }
        function getAlignedX(tooltip, align, options) {
          const padding = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
            options.padding
          );
          return align === 'center'
            ? tooltip.x + tooltip.width / 2
            : align === 'right'
            ? tooltip.x + tooltip.width - padding.right
            : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback) {
          return pushOrConcat([], splitNewlines(callback));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(
            parent,
            {
              tooltip,
              tooltipItems,
              type: 'tooltip',
            }
          );
        }
        function overrideCallbacks(callbacks, context) {
          const override =
            context &&
            context.dataset &&
            context.dataset.tooltip &&
            context.dataset.tooltip.callbacks;
          return override ? callbacks.override(override) : callbacks;
        }
        const defaultCallbacks = {
          beforeTitle:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          title(tooltipItems) {
            if (tooltipItems.length > 0) {
              const item = tooltipItems[0];
              const labels = item.chart.data.labels;
              const labelCount = labels ? labels.length : 0;
              if (this && this.options && this.options.mode === 'dataset') {
                return item.dataset.label || '';
              } else if (item.label) {
                return item.label;
              } else if (labelCount > 0 && item.dataIndex < labelCount) {
                return labels[item.dataIndex];
              }
            }
            return '';
          },
          afterTitle:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          beforeBody:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          beforeLabel:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          label(tooltipItem) {
            if (this && this.options && this.options.mode === 'dataset') {
              return (
                tooltipItem.label + ': ' + tooltipItem.formattedValue ||
                tooltipItem.formattedValue
              );
            }
            let label = tooltipItem.dataset.label || '';
            if (label) {
              label += ': ';
            }
            const value = tooltipItem.formattedValue;
            if (
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                value
              )
            ) {
              label += value;
            }
            return label;
          },
          labelColor(tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(
              tooltipItem.datasetIndex
            );
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
              borderColor: options.borderColor,
              backgroundColor: options.backgroundColor,
              borderWidth: options.borderWidth,
              borderDash: options.borderDash,
              borderDashOffset: options.borderDashOffset,
              borderRadius: 0,
            };
          },
          labelTextColor() {
            return this.options.bodyColor;
          },
          labelPointStyle(tooltipItem) {
            const meta = tooltipItem.chart.getDatasetMeta(
              tooltipItem.datasetIndex
            );
            const options = meta.controller.getStyle(tooltipItem.dataIndex);
            return {
              pointStyle: options.pointStyle,
              rotation: options.rotation,
            };
          },
          afterLabel:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          afterBody: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          beforeFooter:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          footer: _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          afterFooter:
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
        };
        function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
          const result = callbacks[name].call(ctx, arg);
          if (typeof result === 'undefined') {
            return defaultCallbacks[name].call(ctx, arg);
          }
          return result;
        }
        class Tooltip extends Element {
          static positioners = positioners;
          constructor(config) {
            super();
            this.opacity = 0;
            this._active = [];
            this._eventPosition = undefined;
            this._size = undefined;
            this._cachedAnimations = undefined;
            this._tooltipItems = [];
            this.$animations = undefined;
            this.$context = undefined;
            this.chart = config.chart;
            this.options = config.options;
            this.dataPoints = undefined;
            this.title = undefined;
            this.beforeBody = undefined;
            this.body = undefined;
            this.afterBody = undefined;
            this.footer = undefined;
            this.xAlign = undefined;
            this.yAlign = undefined;
            this.x = undefined;
            this.y = undefined;
            this.height = undefined;
            this.width = undefined;
            this.caretX = undefined;
            this.caretY = undefined;
            this.labelColors = undefined;
            this.labelPointStyles = undefined;
            this.labelTextColors = undefined;
          }
          initialize(options) {
            this.options = options;
            this._cachedAnimations = undefined;
            this.$context = undefined;
          }
          _resolveAnimations() {
            const cached = this._cachedAnimations;
            if (cached) {
              return cached;
            }
            const chart = this.chart;
            const options = this.options.setContext(this.getContext());
            const opts =
              options.enabled && chart.options.animation && options.animations;
            const animations = new Animations(this.chart, opts);
            if (opts._cacheable) {
              this._cachedAnimations = Object.freeze(animations);
            }
            return animations;
          }
          getContext() {
            return (
              this.$context ||
              (this.$context = createTooltipContext(
                this.chart.getContext(),
                this,
                this._tooltipItems
              ))
            );
          }
          getTitle(context, options) {
            const { callbacks } = options;
            const beforeTitle = invokeCallbackWithFallback(
              callbacks,
              'beforeTitle',
              this,
              context
            );
            const title = invokeCallbackWithFallback(
              callbacks,
              'title',
              this,
              context
            );
            const afterTitle = invokeCallbackWithFallback(
              callbacks,
              'afterTitle',
              this,
              context
            );
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeTitle));
            lines = pushOrConcat(lines, splitNewlines(title));
            lines = pushOrConcat(lines, splitNewlines(afterTitle));
            return lines;
          }
          getBeforeBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(
              invokeCallbackWithFallback(
                options.callbacks,
                'beforeBody',
                this,
                tooltipItems
              )
            );
          }
          getBody(tooltipItems, options) {
            const { callbacks } = options;
            const bodyItems = [];
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              tooltipItems,
              (context) => {
                const bodyItem = {
                  before: [],
                  lines: [],
                  after: [],
                };
                const scoped = overrideCallbacks(callbacks, context);
                pushOrConcat(
                  bodyItem.before,
                  splitNewlines(
                    invokeCallbackWithFallback(
                      scoped,
                      'beforeLabel',
                      this,
                      context
                    )
                  )
                );
                pushOrConcat(
                  bodyItem.lines,
                  invokeCallbackWithFallback(scoped, 'label', this, context)
                );
                pushOrConcat(
                  bodyItem.after,
                  splitNewlines(
                    invokeCallbackWithFallback(
                      scoped,
                      'afterLabel',
                      this,
                      context
                    )
                  )
                );
                bodyItems.push(bodyItem);
              }
            );
            return bodyItems;
          }
          getAfterBody(tooltipItems, options) {
            return getBeforeAfterBodyLines(
              invokeCallbackWithFallback(
                options.callbacks,
                'afterBody',
                this,
                tooltipItems
              )
            );
          }
          getFooter(tooltipItems, options) {
            const { callbacks } = options;
            const beforeFooter = invokeCallbackWithFallback(
              callbacks,
              'beforeFooter',
              this,
              tooltipItems
            );
            const footer = invokeCallbackWithFallback(
              callbacks,
              'footer',
              this,
              tooltipItems
            );
            const afterFooter = invokeCallbackWithFallback(
              callbacks,
              'afterFooter',
              this,
              tooltipItems
            );
            let lines = [];
            lines = pushOrConcat(lines, splitNewlines(beforeFooter));
            lines = pushOrConcat(lines, splitNewlines(footer));
            lines = pushOrConcat(lines, splitNewlines(afterFooter));
            return lines;
          }
          _createItems(options) {
            const active = this._active;
            const data = this.chart.data;
            const labelColors = [];
            const labelPointStyles = [];
            const labelTextColors = [];
            let tooltipItems = [];
            let i, len;
            for (i = 0, len = active.length; i < len; ++i) {
              tooltipItems.push(createTooltipItem(this.chart, active[i]));
            }
            if (options.filter) {
              tooltipItems = tooltipItems.filter((element, index, array) =>
                options.filter(element, index, array, data)
              );
            }
            if (options.itemSort) {
              tooltipItems = tooltipItems.sort((a, b) =>
                options.itemSort(a, b, data)
              );
            }
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              tooltipItems,
              (context) => {
                const scoped = overrideCallbacks(options.callbacks, context);
                labelColors.push(
                  invokeCallbackWithFallback(
                    scoped,
                    'labelColor',
                    this,
                    context
                  )
                );
                labelPointStyles.push(
                  invokeCallbackWithFallback(
                    scoped,
                    'labelPointStyle',
                    this,
                    context
                  )
                );
                labelTextColors.push(
                  invokeCallbackWithFallback(
                    scoped,
                    'labelTextColor',
                    this,
                    context
                  )
                );
              }
            );
            this.labelColors = labelColors;
            this.labelPointStyles = labelPointStyles;
            this.labelTextColors = labelTextColors;
            this.dataPoints = tooltipItems;
            return tooltipItems;
          }
          update(changed, replay) {
            const options = this.options.setContext(this.getContext());
            const active = this._active;
            let properties;
            let tooltipItems = [];
            if (!active.length) {
              if (this.opacity !== 0) {
                properties = {
                  opacity: 0,
                };
              }
            } else {
              const position = positioners[options.position].call(
                this,
                active,
                this._eventPosition
              );
              tooltipItems = this._createItems(options);
              this.title = this.getTitle(tooltipItems, options);
              this.beforeBody = this.getBeforeBody(tooltipItems, options);
              this.body = this.getBody(tooltipItems, options);
              this.afterBody = this.getAfterBody(tooltipItems, options);
              this.footer = this.getFooter(tooltipItems, options);
              const size = (this._size = getTooltipSize(this, options));
              const positionAndSize = Object.assign({}, position, size);
              const alignment = determineAlignment(
                this.chart,
                options,
                positionAndSize
              );
              const backgroundPoint = getBackgroundPoint(
                options,
                positionAndSize,
                alignment,
                this.chart
              );
              this.xAlign = alignment.xAlign;
              this.yAlign = alignment.yAlign;
              properties = {
                opacity: 1,
                x: backgroundPoint.x,
                y: backgroundPoint.y,
                width: size.width,
                height: size.height,
                caretX: position.x,
                caretY: position.y,
              };
            }
            this._tooltipItems = tooltipItems;
            this.$context = undefined;
            if (properties) {
              this._resolveAnimations().update(this, properties);
            }
            if (changed && options.external) {
              options.external.call(this, {
                chart: this.chart,
                tooltip: this,
                replay,
              });
            }
          }
          drawCaret(tooltipPoint, ctx, size, options) {
            const caretPosition = this.getCaretPosition(
              tooltipPoint,
              size,
              options
            );
            ctx.lineTo(caretPosition.x1, caretPosition.y1);
            ctx.lineTo(caretPosition.x2, caretPosition.y2);
            ctx.lineTo(caretPosition.x3, caretPosition.y3);
          }
          getCaretPosition(tooltipPoint, size, options) {
            const { xAlign, yAlign } = this;
            const { caretSize, cornerRadius } = options;
            const { topLeft, topRight, bottomLeft, bottomRight } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(
              cornerRadius
            );
            const { x: ptX, y: ptY } = tooltipPoint;
            const { width, height } = size;
            let x1, x2, x3, y1, y2, y3;
            if (yAlign === 'center') {
              y2 = ptY + height / 2;
              if (xAlign === 'left') {
                x1 = ptX;
                x2 = x1 - caretSize;
                y1 = y2 + caretSize;
                y3 = y2 - caretSize;
              } else {
                x1 = ptX + width;
                x2 = x1 + caretSize;
                y1 = y2 - caretSize;
                y3 = y2 + caretSize;
              }
              x3 = x1;
            } else {
              if (xAlign === 'left') {
                x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize;
              } else if (xAlign === 'right') {
                x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;
              } else {
                x2 = this.caretX;
              }
              if (yAlign === 'top') {
                y1 = ptY;
                y2 = y1 - caretSize;
                x1 = x2 - caretSize;
                x3 = x2 + caretSize;
              } else {
                y1 = ptY + height;
                y2 = y1 + caretSize;
                x1 = x2 + caretSize;
                x3 = x2 - caretSize;
              }
              y3 = y1;
            }
            return {
              x1,
              x2,
              x3,
              y1,
              y2,
              y3,
            };
          }
          drawTitle(pt, ctx, options) {
            const title = this.title;
            const length = title.length;
            let titleFont, titleSpacing, i;
            if (length) {
              const rtlHelper = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(
                options.rtl,
                this.x,
                this.width
              );
              pt.x = getAlignedX(this, options.titleAlign, options);
              ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
              ctx.textBaseline = 'middle';
              titleFont = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
                options.titleFont
              );
              titleSpacing = options.titleSpacing;
              ctx.fillStyle = options.titleColor;
              ctx.font = titleFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(
                  title[i],
                  rtlHelper.x(pt.x),
                  pt.y + titleFont.lineHeight / 2
                );
                pt.y += titleFont.lineHeight + titleSpacing;
                if (i + 1 === length) {
                  pt.y += options.titleMarginBottom - titleSpacing;
                }
              }
            }
          }
          _drawColorBox(ctx, pt, i, rtlHelper, options) {
            const labelColor = this.labelColors[i];
            const labelPointStyle = this.labelPointStyles[i];
            const { boxHeight, boxWidth } = options;
            const bodyFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              options.bodyFont
            );
            const colorX = getAlignedX(this, 'left', options);
            const rtlColorX = rtlHelper.x(colorX);
            const yOffSet =
              boxHeight < bodyFont.lineHeight
                ? (bodyFont.lineHeight - boxHeight) / 2
                : 0;
            const colorY = pt.y + yOffSet;
            if (options.usePointStyle) {
              const drawOptions = {
                radius: Math.min(boxWidth, boxHeight) / 2,
                pointStyle: labelPointStyle.pointStyle,
                rotation: labelPointStyle.rotation,
                borderWidth: 1,
              };
              const centerX =
                rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
              const centerY = colorY + boxHeight / 2;
              ctx.strokeStyle = options.multiKeyBackground;
              ctx.fillStyle = options.multiKeyBackground;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au)(
                ctx,
                drawOptions,
                centerX,
                centerY
              );
              ctx.strokeStyle = labelColor.borderColor;
              ctx.fillStyle = labelColor.backgroundColor;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au)(
                ctx,
                drawOptions,
                centerX,
                centerY
              );
            } else {
              ctx.lineWidth = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i)(
                labelColor.borderWidth
              )
                ? Math.max(...Object.values(labelColor.borderWidth))
                : labelColor.borderWidth || 1;
              ctx.strokeStyle = labelColor.borderColor;
              ctx.setLineDash(labelColor.borderDash || []);
              ctx.lineDashOffset = labelColor.borderDashOffset || 0;
              const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
              const innerX = rtlHelper.leftForLtr(
                rtlHelper.xPlus(rtlColorX, 1),
                boxWidth - 2
              );
              const borderRadius = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(
                labelColor.borderRadius
              );
              if (Object.values(borderRadius).some((v) => v !== 0)) {
                ctx.beginPath();
                ctx.fillStyle = options.multiKeyBackground;
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(
                  ctx,
                  {
                    x: outerX,
                    y: colorY,
                    w: boxWidth,
                    h: boxHeight,
                    radius: borderRadius,
                  }
                );
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.beginPath();
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(
                  ctx,
                  {
                    x: innerX,
                    y: colorY + 1,
                    w: boxWidth - 2,
                    h: boxHeight - 2,
                    radius: borderRadius,
                  }
                );
                ctx.fill();
              } else {
                ctx.fillStyle = options.multiKeyBackground;
                ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                ctx.fillStyle = labelColor.backgroundColor;
                ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
              }
            }
            ctx.fillStyle = this.labelTextColors[i];
          }
          drawBody(pt, ctx, options) {
            const { body } = this;
            const {
              bodySpacing,
              bodyAlign,
              displayColors,
              boxHeight,
              boxWidth,
              boxPadding,
            } = options;
            const bodyFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              options.bodyFont
            );
            let bodyLineHeight = bodyFont.lineHeight;
            let xLinePadding = 0;
            const rtlHelper = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(
              options.rtl,
              this.x,
              this.width
            );
            const fillLineOfText = function (line) {
              ctx.fillText(
                line,
                rtlHelper.x(pt.x + xLinePadding),
                pt.y + bodyLineHeight / 2
              );
              pt.y += bodyLineHeight + bodySpacing;
            };
            const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
            let bodyItem, textColor, lines, i, j, ilen, jlen;
            ctx.textAlign = bodyAlign;
            ctx.textBaseline = 'middle';
            ctx.font = bodyFont.string;
            pt.x = getAlignedX(this, bodyAlignForCalculation, options);
            ctx.fillStyle = options.bodyColor;
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this.beforeBody,
              fillLineOfText
            );
            xLinePadding =
              displayColors && bodyAlignForCalculation !== 'right'
                ? bodyAlign === 'center'
                  ? boxWidth / 2 + boxPadding
                  : boxWidth + 2 + boxPadding
                : 0;
            for (i = 0, ilen = body.length; i < ilen; ++i) {
              bodyItem = body[i];
              textColor = this.labelTextColors[i];
              ctx.fillStyle = textColor;
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                bodyItem.before,
                fillLineOfText
              );
              lines = bodyItem.lines;
              if (displayColors && lines.length) {
                this._drawColorBox(ctx, pt, i, rtlHelper, options);
                bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
              }
              for (j = 0, jlen = lines.length; j < jlen; ++j) {
                fillLineOfText(lines[j]);
                bodyLineHeight = bodyFont.lineHeight;
              }
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
                bodyItem.after,
                fillLineOfText
              );
            }
            xLinePadding = 0;
            bodyLineHeight = bodyFont.lineHeight;
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F)(
              this.afterBody,
              fillLineOfText
            );
            pt.y -= bodySpacing;
          }
          drawFooter(pt, ctx, options) {
            const footer = this.footer;
            const length = footer.length;
            let footerFont, i;
            if (length) {
              const rtlHelper = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA)(
                options.rtl,
                this.x,
                this.width
              );
              pt.x = getAlignedX(this, options.footerAlign, options);
              pt.y += options.footerMarginTop;
              ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
              ctx.textBaseline = 'middle';
              footerFont = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
                options.footerFont
              );
              ctx.fillStyle = options.footerColor;
              ctx.font = footerFont.string;
              for (i = 0; i < length; ++i) {
                ctx.fillText(
                  footer[i],
                  rtlHelper.x(pt.x),
                  pt.y + footerFont.lineHeight / 2
                );
                pt.y += footerFont.lineHeight + options.footerSpacing;
              }
            }
          }
          drawBackground(pt, ctx, tooltipSize, options) {
            const { xAlign, yAlign } = this;
            const { x, y } = pt;
            const { width, height } = tooltipSize;
            const { topLeft, topRight, bottomLeft, bottomRight } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(
              options.cornerRadius
            );
            ctx.fillStyle = options.backgroundColor;
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.beginPath();
            ctx.moveTo(x + topLeft, y);
            if (yAlign === 'top') {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width - topRight, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
            if (yAlign === 'center' && xAlign === 'right') {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + width, y + height - bottomRight);
            ctx.quadraticCurveTo(
              x + width,
              y + height,
              x + width - bottomRight,
              y + height
            );
            if (yAlign === 'bottom') {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x + bottomLeft, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
            if (yAlign === 'center' && xAlign === 'left') {
              this.drawCaret(pt, ctx, tooltipSize, options);
            }
            ctx.lineTo(x, y + topLeft);
            ctx.quadraticCurveTo(x, y, x + topLeft, y);
            ctx.closePath();
            ctx.fill();
            if (options.borderWidth > 0) {
              ctx.stroke();
            }
          }
          _updateAnimationTarget(options) {
            const chart = this.chart;
            const anims = this.$animations;
            const animX = anims && anims.x;
            const animY = anims && anims.y;
            if (animX || animY) {
              const position = positioners[options.position].call(
                this,
                this._active,
                this._eventPosition
              );
              if (!position) {
                return;
              }
              const size = (this._size = getTooltipSize(this, options));
              const positionAndSize = Object.assign({}, position, this._size);
              const alignment = determineAlignment(
                chart,
                options,
                positionAndSize
              );
              const point = getBackgroundPoint(
                options,
                positionAndSize,
                alignment,
                chart
              );
              if (animX._to !== point.x || animY._to !== point.y) {
                this.xAlign = alignment.xAlign;
                this.yAlign = alignment.yAlign;
                this.width = size.width;
                this.height = size.height;
                this.caretX = position.x;
                this.caretY = position.y;
                this._resolveAnimations().update(this, point);
              }
            }
          }
          _willRender() {
            return !!this.opacity;
          }
          draw(ctx) {
            const options = this.options.setContext(this.getContext());
            let opacity = this.opacity;
            if (!opacity) {
              return;
            }
            this._updateAnimationTarget(options);
            const tooltipSize = {
              width: this.width,
              height: this.height,
            };
            const pt = {
              x: this.x,
              y: this.y,
            };
            opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;
            const padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              options.padding
            );
            const hasTooltipContent =
              this.title.length ||
              this.beforeBody.length ||
              this.body.length ||
              this.afterBody.length ||
              this.footer.length;
            if (options.enabled && hasTooltipContent) {
              ctx.save();
              ctx.globalAlpha = opacity;
              this.drawBackground(pt, ctx, tooltipSize, options);
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB)(
                ctx,
                options.textDirection
              );
              pt.y += padding.top;
              this.drawTitle(pt, ctx, options);
              this.drawBody(pt, ctx, options);
              this.drawFooter(pt, ctx, options);
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD)(
                ctx,
                options.textDirection
              );
              ctx.restore();
            }
          }
          getActiveElements() {
            return this._active || [];
          }
          setActiveElements(activeElements, eventPosition) {
            const lastActive = this._active;
            const active = activeElements.map(({ datasetIndex, index }) => {
              const meta = this.chart.getDatasetMeta(datasetIndex);
              if (!meta) {
                throw new Error(
                  'Cannot find a dataset at index ' + datasetIndex
                );
              }
              return {
                datasetIndex,
                element: meta.data[index],
                index,
              };
            });
            const changed = !(0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(
              lastActive,
              active
            );
            const positionChanged = this._positionChanged(
              active,
              eventPosition
            );
            if (changed || positionChanged) {
              this._active = active;
              this._eventPosition = eventPosition;
              this._ignoreReplayEvents = true;
              this.update(true);
            }
          }
          handleEvent(e, replay, inChartArea = true) {
            if (replay && this._ignoreReplayEvents) {
              return false;
            }
            this._ignoreReplayEvents = false;
            const options = this.options;
            const lastActive = this._active || [];
            const active = this._getActiveElements(
              e,
              lastActive,
              replay,
              inChartArea
            );
            const positionChanged = this._positionChanged(active, e);
            const changed =
              replay ||
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai)(
                active,
                lastActive
              ) ||
              positionChanged;
            if (changed) {
              this._active = active;
              if (options.enabled || options.external) {
                this._eventPosition = {
                  x: e.x,
                  y: e.y,
                };
                this.update(true, replay);
              }
            }
            return changed;
          }
          _getActiveElements(e, lastActive, replay, inChartArea) {
            const options = this.options;
            if (e.type === 'mouseout') {
              return [];
            }
            if (!inChartArea) {
              return lastActive.filter(
                (i) =>
                  this.chart.data.datasets[i.datasetIndex] &&
                  this.chart
                    .getDatasetMeta(i.datasetIndex)
                    .controller.getParsed(i.index) !== undefined
              );
            }
            const active = this.chart.getElementsAtEventForMode(
              e,
              options.mode,
              options,
              replay
            );
            if (options.reverse) {
              active.reverse();
            }
            return active;
          }
          _positionChanged(active, e) {
            const { caretX, caretY, options } = this;
            const position = positioners[options.position].call(
              this,
              active,
              e
            );
            return (
              position !== false &&
              (caretX !== position.x || caretY !== position.y)
            );
          }
        }
        var plugin_tooltip = {
          id: 'tooltip',
          _element: Tooltip,
          positioners,
          afterInit(chart, _args, options) {
            if (options) {
              chart.tooltip = new Tooltip({
                chart,
                options,
              });
            }
          },
          beforeUpdate(chart, _args, options) {
            if (chart.tooltip) {
              chart.tooltip.initialize(options);
            }
          },
          reset(chart, _args, options) {
            if (chart.tooltip) {
              chart.tooltip.initialize(options);
            }
          },
          afterDraw(chart) {
            const tooltip = chart.tooltip;
            if (tooltip && tooltip._willRender()) {
              const args = {
                tooltip,
              };
              if (
                chart.notifyPlugins('beforeTooltipDraw', {
                  ...args,
                  cancelable: true,
                }) === false
              ) {
                return;
              }
              tooltip.draw(chart.ctx);
              chart.notifyPlugins('afterTooltipDraw', args);
            }
          },
          afterEvent(chart, args) {
            if (chart.tooltip) {
              const useFinalPosition = args.replay;
              if (
                chart.tooltip.handleEvent(
                  args.event,
                  useFinalPosition,
                  args.inChartArea
                )
              ) {
                args.changed = true;
              }
            }
          },
          defaults: {
            enabled: true,
            external: null,
            position: 'average',
            backgroundColor: 'rgba(0,0,0,0.8)',
            titleColor: '#fff',
            titleFont: {
              weight: 'bold',
            },
            titleSpacing: 2,
            titleMarginBottom: 6,
            titleAlign: 'left',
            bodyColor: '#fff',
            bodySpacing: 2,
            bodyFont: {},
            bodyAlign: 'left',
            footerColor: '#fff',
            footerSpacing: 2,
            footerMarginTop: 6,
            footerFont: {
              weight: 'bold',
            },
            footerAlign: 'left',
            padding: 6,
            caretPadding: 2,
            caretSize: 5,
            cornerRadius: 6,
            boxHeight: (ctx, opts) => opts.bodyFont.size,
            boxWidth: (ctx, opts) => opts.bodyFont.size,
            multiKeyBackground: '#fff',
            displayColors: true,
            boxPadding: 0,
            borderColor: 'rgba(0,0,0,0)',
            borderWidth: 0,
            animation: {
              duration: 400,
              easing: 'easeOutQuart',
            },
            animations: {
              numbers: {
                type: 'number',
                properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],
              },
              opacity: {
                easing: 'linear',
                duration: 200,
              },
            },
            callbacks: defaultCallbacks,
          },
          defaultRoutes: {
            bodyFont: 'font',
            footerFont: 'font',
            titleFont: 'font',
          },
          descriptors: {
            _scriptable: (name) =>
              name !== 'filter' && name !== 'itemSort' && name !== 'external',
            _indexable: false,
            callbacks: {
              _scriptable: false,
              _indexable: false,
            },
            animation: {
              _fallback: false,
            },
            animations: {
              _fallback: 'animation',
            },
          },
          additionalOptionScopes: ['interaction'],
        };

        var plugins = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          Colors: plugin_colors,
          Decimation: plugin_decimation,
          Filler: index,
          Legend: plugin_legend,
          SubTitle: plugin_subtitle,
          Title: plugin_title,
          Tooltip: plugin_tooltip,
        });

        const addIfString = (labels, raw, index, addedLabels) => {
          if (typeof raw === 'string') {
            index = labels.push(raw) - 1;
            addedLabels.unshift({
              index,
              label: raw,
            });
          } else if (isNaN(raw)) {
            index = null;
          }
          return index;
        };
        function findOrAddLabel(labels, raw, index, addedLabels) {
          const first = labels.indexOf(raw);
          if (first === -1) {
            return addIfString(labels, raw, index, addedLabels);
          }
          const last = labels.lastIndexOf(raw);
          return first !== last ? index : first;
        }
        const validIndex = (index, max) =>
          index === null
            ? null
            : (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
                Math.round(index),
                0,
                max
              );
        function _getLabelForValue(value) {
          const labels = this.getLabels();
          if (value >= 0 && value < labels.length) {
            return labels[value];
          }
          return value;
        }
        class CategoryScale extends Scale {
          static id = 'category';
          static defaults = {
            ticks: {
              callback: _getLabelForValue,
            },
          };
          constructor(cfg) {
            super(cfg);
            this._startValue = undefined;
            this._valueRange = 0;
            this._addedLabels = [];
          }
          init(scaleOptions) {
            const added = this._addedLabels;
            if (added.length) {
              const labels = this.getLabels();
              for (const { index, label } of added) {
                if (labels[index] === label) {
                  labels.splice(index, 1);
                }
              }
              this._addedLabels = [];
            }
            super.init(scaleOptions);
          }
          parse(raw, index) {
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                raw
              )
            ) {
              return null;
            }
            const labels = this.getLabels();
            index =
              isFinite(index) && labels[index] === raw
                ? index
                : findOrAddLabel(
                    labels,
                    raw,
                    (0,
                    _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                      index,
                      raw
                    ),
                    this._addedLabels
                  );
            return validIndex(index, labels.length - 1);
          }
          determineDataLimits() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this.getMinMax(true);
            if (this.options.bounds === 'ticks') {
              if (!minDefined) {
                min = 0;
              }
              if (!maxDefined) {
                max = this.getLabels().length - 1;
              }
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const min = this.min;
            const max = this.max;
            const offset = this.options.offset;
            const ticks = [];
            let labels = this.getLabels();
            labels =
              min === 0 && max === labels.length - 1
                ? labels
                : labels.slice(min, max + 1);
            this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
            this._startValue = this.min - (offset ? 0.5 : 0);
            for (let value = min; value <= max; value++) {
              ticks.push({
                value,
              });
            }
            return ticks;
          }
          getLabelForValue(value) {
            return _getLabelForValue.call(this, value);
          }
          configure() {
            super.configure();
            if (!this.isHorizontal()) {
              this._reversePixels = !this._reversePixels;
            }
          }
          getPixelForValue(value) {
            if (typeof value !== 'number') {
              value = this.parse(value);
            }
            return value === null
              ? NaN
              : this.getPixelForDecimal(
                  (value - this._startValue) / this._valueRange
                );
          }
          getPixelForTick(index) {
            const ticks = this.ticks;
            if (index < 0 || index > ticks.length - 1) {
              return null;
            }
            return this.getPixelForValue(ticks[index].value);
          }
          getValueForPixel(pixel) {
            return Math.round(
              this._startValue +
                this.getDecimalForPixel(pixel) * this._valueRange
            );
          }
          getBasePixel() {
            return this.bottom;
          }
        }

        function generateTicks$1(generationOptions, dataRange) {
          const ticks = [];
          const MIN_SPACING = 1e-14;
          const {
            bounds,
            step,
            min,
            max,
            precision,
            count,
            maxTicks,
            maxDigits,
            includeBounds,
          } = generationOptions;
          const unit = step || 1;
          const maxSpaces = maxTicks - 1;
          const { min: rmin, max: rmax } = dataRange;
          const minDefined = !(0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(min);
          const maxDefined = !(0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(max);
          const countDefined = !(0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(count);
          const minSpacing = (rmax - rmin) / (maxDigits + 1);
          let spacing =
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)(
              (rmax - rmin) / maxSpaces / unit
            ) * unit;
          let factor, niceMin, niceMax, numSpaces;
          if (spacing < MIN_SPACING && !minDefined && !maxDefined) {
            return [
              {
                value: rmin,
              },
              {
                value: rmax,
              },
            ];
          }
          numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
          if (numSpaces > maxSpaces) {
            spacing =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI)(
                (numSpaces * spacing) / maxSpaces / unit
              ) * unit;
          }
          if (
            !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
              precision
            )
          ) {
            factor = Math.pow(10, precision);
            spacing = Math.ceil(spacing * factor) / factor;
          }
          if (bounds === 'ticks') {
            niceMin = Math.floor(rmin / spacing) * spacing;
            niceMax = Math.ceil(rmax / spacing) * spacing;
          } else {
            niceMin = rmin;
            niceMax = rmax;
          }
          if (
            minDefined &&
            maxDefined &&
            step &&
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aJ)(
              (max - min) / step,
              spacing / 1000
            )
          ) {
            numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
            spacing = (max - min) / numSpaces;
            niceMin = min;
            niceMax = max;
          } else if (countDefined) {
            niceMin = minDefined ? min : niceMin;
            niceMax = maxDefined ? max : niceMax;
            numSpaces = count - 1;
            spacing = (niceMax - niceMin) / numSpaces;
          } else {
            numSpaces = (niceMax - niceMin) / spacing;
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(
                numSpaces,
                Math.round(numSpaces),
                spacing / 1000
              )
            ) {
              numSpaces = Math.round(numSpaces);
            } else {
              numSpaces = Math.ceil(numSpaces);
            }
          }
          const decimalPlaces = Math.max(
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(
              spacing
            ),
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL)(
              niceMin
            )
          );
          factor = Math.pow(
            10,
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
              precision
            )
              ? decimalPlaces
              : precision
          );
          niceMin = Math.round(niceMin * factor) / factor;
          niceMax = Math.round(niceMax * factor) / factor;
          let j = 0;
          if (minDefined) {
            if (includeBounds && niceMin !== min) {
              ticks.push({
                value: min,
              });
              if (niceMin < min) {
                j++;
              }
              if (
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(
                  Math.round((niceMin + j * spacing) * factor) / factor,
                  min,
                  relativeLabelSize(min, minSpacing, generationOptions)
                )
              ) {
                j++;
              }
            } else if (niceMin < min) {
              j++;
            }
          }
          for (; j < numSpaces; ++j) {
            const tickValue =
              Math.round((niceMin + j * spacing) * factor) / factor;
            if (maxDefined && tickValue > max) {
              break;
            }
            ticks.push({
              value: tickValue,
            });
          }
          if (maxDefined && includeBounds && niceMax !== max) {
            if (
              ticks.length &&
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK)(
                ticks[ticks.length - 1].value,
                max,
                relativeLabelSize(max, minSpacing, generationOptions)
              )
            ) {
              ticks[ticks.length - 1].value = max;
            } else {
              ticks.push({
                value: max,
              });
            }
          } else if (!maxDefined || niceMax === max) {
            ticks.push({
              value: niceMax,
            });
          }
          return ticks;
        }
        function relativeLabelSize(
          value,
          minSpacing,
          { horizontal, minRotation }
        ) {
          const rad = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
            minRotation
          );
          const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;
          const length = 0.75 * minSpacing * ('' + value).length;
          return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
          constructor(cfg) {
            super(cfg);
            this.start = undefined;
            this.end = undefined;
            this._startValue = undefined;
            this._endValue = undefined;
            this._valueRange = 0;
          }
          parse(raw, index) {
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                raw
              )
            ) {
              return null;
            }
            if (
              (typeof raw === 'number' || raw instanceof Number) &&
              !isFinite(+raw)
            ) {
              return null;
            }
            return +raw;
          }
          handleTickRangeOptions() {
            const { beginAtZero } = this.options;
            const { minDefined, maxDefined } = this.getUserBounds();
            let { min, max } = this;
            const setMin = (v) => (min = minDefined ? min : v);
            const setMax = (v) => (max = maxDefined ? max : v);
            if (beginAtZero) {
              const minSign = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(min);
              const maxSign = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s)(max);
              if (minSign < 0 && maxSign < 0) {
                setMax(0);
              } else if (minSign > 0 && maxSign > 0) {
                setMin(0);
              }
            }
            if (min === max) {
              let offset = max === 0 ? 1 : Math.abs(max * 0.05);
              setMax(max + offset);
              if (!beginAtZero) {
                setMin(min - offset);
              }
            }
            this.min = min;
            this.max = max;
          }
          getTickLimit() {
            const tickOpts = this.options.ticks;
            let { maxTicksLimit, stepSize } = tickOpts;
            let maxTicks;
            if (stepSize) {
              maxTicks =
                Math.ceil(this.max / stepSize) -
                Math.floor(this.min / stepSize) +
                1;
              if (maxTicks > 1000) {
                console.warn(
                  `scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`
                );
                maxTicks = 1000;
              }
            } else {
              maxTicks = this.computeTickLimit();
              maxTicksLimit = maxTicksLimit || 11;
            }
            if (maxTicksLimit) {
              maxTicks = Math.min(maxTicksLimit, maxTicks);
            }
            return maxTicks;
          }
          computeTickLimit() {
            return Number.POSITIVE_INFINITY;
          }
          buildTicks() {
            const opts = this.options;
            const tickOpts = opts.ticks;
            let maxTicks = this.getTickLimit();
            maxTicks = Math.max(2, maxTicks);
            const numericGeneratorOptions = {
              maxTicks,
              bounds: opts.bounds,
              min: opts.min,
              max: opts.max,
              precision: tickOpts.precision,
              step: tickOpts.stepSize,
              count: tickOpts.count,
              maxDigits: this._maxDigits(),
              horizontal: this.isHorizontal(),
              minRotation: tickOpts.minRotation || 0,
              includeBounds: tickOpts.includeBounds !== false,
            };
            const dataRange = this._range || this;
            const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
            if (opts.bounds === 'ticks') {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(
                ticks,
                this,
                'value'
              );
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          configure() {
            const ticks = this.ticks;
            let start = this.min;
            let end = this.max;
            super.configure();
            if (this.options.offset && ticks.length) {
              const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
              start -= offset;
              end += offset;
            }
            this._startValue = start;
            this._endValue = end;
            this._valueRange = end - start;
          }
          getLabelForValue(value) {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(
              value,
              this.chart.options.locale,
              this.options.ticks.format
            );
          }
        }

        class LinearScale extends LinearScaleBase {
          static id = 'linear';
          static defaults = {
            ticks: {
              callback:
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM
                  .formatters.numeric,
            },
          };
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min)
              ? min
              : 0;
            this.max = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max)
              ? max
              : 1;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            const horizontal = this.isHorizontal();
            const length = horizontal ? this.width : this.height;
            const minRotation = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.options.ticks.minRotation
            );
            const ratio =
              (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) ||
              0.001;
            const tickFont = this._resolveTickFontOptions(0);
            return Math.ceil(
              length / Math.min(40, tickFont.lineHeight / ratio)
            );
          }
          getPixelForValue(value) {
            return value === null
              ? NaN
              : this.getPixelForDecimal(
                  (value - this._startValue) / this._valueRange
                );
          }
          getValueForPixel(pixel) {
            return (
              this._startValue +
              this.getDecimalForPixel(pixel) * this._valueRange
            );
          }
        }

        const log10Floor = (v) =>
          Math.floor(
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(v)
          );
        const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
        function isMajor(tickVal) {
          const remain = tickVal / Math.pow(10, log10Floor(tickVal));
          return remain === 1;
        }
        function steps(min, max, rangeExp) {
          const rangeStep = Math.pow(10, rangeExp);
          const start = Math.floor(min / rangeStep);
          const end = Math.ceil(max / rangeStep);
          return end - start;
        }
        function startExp(min, max) {
          const range = max - min;
          let rangeExp = log10Floor(range);
          while (steps(min, max, rangeExp) > 10) {
            rangeExp++;
          }
          while (steps(min, max, rangeExp) < 10) {
            rangeExp--;
          }
          return Math.min(rangeExp, log10Floor(min));
        }
        function generateTicks(generationOptions, { min, max }) {
          min = (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
            generationOptions.min,
            min
          );
          const ticks = [];
          const minExp = log10Floor(min);
          let exp = startExp(min, max);
          let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
          const stepSize = Math.pow(10, exp);
          const base = minExp > exp ? Math.pow(10, minExp) : 0;
          const start = Math.round((min - base) * precision) / precision;
          const offset =
            Math.floor((min - base) / stepSize / 10) * stepSize * 10;
          let significand = Math.floor((start - offset) / Math.pow(10, exp));
          let value = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
            generationOptions.min,
            Math.round(
              (base + offset + significand * Math.pow(10, exp)) * precision
            ) / precision
          );
          while (value < max) {
            ticks.push({
              value,
              major: isMajor(value),
              significand,
            });
            if (significand >= 10) {
              significand = significand < 15 ? 15 : 20;
            } else {
              significand++;
            }
            if (significand >= 20) {
              exp++;
              significand = 2;
              precision = exp >= 0 ? 1 : precision;
            }
            value =
              Math.round(
                (base + offset + significand * Math.pow(10, exp)) * precision
              ) / precision;
          }
          const lastTick = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O)(
            generationOptions.max,
            value
          );
          ticks.push({
            value: lastTick,
            major: isMajor(lastTick),
            significand,
          });
          return ticks;
        }
        class LogarithmicScale extends Scale {
          static id = 'logarithmic';
          static defaults = {
            ticks: {
              callback:
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM
                  .formatters.logarithmic,
              major: {
                enabled: true,
              },
            },
          };
          constructor(cfg) {
            super(cfg);
            this.start = undefined;
            this.end = undefined;
            this._startValue = undefined;
            this._valueRange = 0;
          }
          parse(raw, index) {
            const value = LinearScaleBase.prototype.parse.apply(this, [
              raw,
              index,
            ]);
            if (value === 0) {
              this._zero = true;
              return undefined;
            }
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(value) &&
              value > 0
              ? value
              : null;
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(true);
            this.min = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(min)
              ? Math.max(0, min)
              : null;
            this.max = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(max)
              ? Math.max(0, max)
              : null;
            if (this.options.beginAtZero) {
              this._zero = true;
            }
            if (
              this._zero &&
              this.min !== this._suggestedMin &&
              !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                this._userMin
              )
            ) {
              this.min =
                min === changeExponent(this.min, 0)
                  ? changeExponent(this.min, -1)
                  : changeExponent(this.min, 0);
            }
            this.handleTickRangeOptions();
          }
          handleTickRangeOptions() {
            const { minDefined, maxDefined } = this.getUserBounds();
            let min = this.min;
            let max = this.max;
            const setMin = (v) => (min = minDefined ? min : v);
            const setMax = (v) => (max = maxDefined ? max : v);
            if (min === max) {
              if (min <= 0) {
                setMin(1);
                setMax(10);
              } else {
                setMin(changeExponent(min, -1));
                setMax(changeExponent(max, +1));
              }
            }
            if (min <= 0) {
              setMin(changeExponent(max, -1));
            }
            if (max <= 0) {
              setMax(changeExponent(min, +1));
            }
            this.min = min;
            this.max = max;
          }
          buildTicks() {
            const opts = this.options;
            const generationOptions = {
              min: this._userMin,
              max: this._userMax,
            };
            const ticks = generateTicks(generationOptions, this);
            if (opts.bounds === 'ticks') {
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH)(
                ticks,
                this,
                'value'
              );
            }
            if (opts.reverse) {
              ticks.reverse();
              this.start = this.max;
              this.end = this.min;
            } else {
              this.start = this.min;
              this.end = this.max;
            }
            return ticks;
          }
          getLabelForValue(value) {
            return value === undefined
              ? '0'
              : (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o)(
                  value,
                  this.chart.options.locale,
                  this.options.ticks.format
                );
          }
          configure() {
            const start = this.min;
            super.configure();
            this._startValue = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(start);
            this._valueRange =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(
                this.max
              ) -
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(
                start
              );
          }
          getPixelForValue(value) {
            if (value === undefined || value === 0) {
              value = this.min;
            }
            if (value === null || isNaN(value)) {
              return NaN;
            }
            return this.getPixelForDecimal(
              value === this.min
                ? 0
                : ((0,
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN)(
                    value
                  ) -
                    this._startValue) /
                    this._valueRange
            );
          }
          getValueForPixel(pixel) {
            const decimal = this.getDecimalForPixel(pixel);
            return Math.pow(10, this._startValue + decimal * this._valueRange);
          }
        }

        function getTickBackdropHeight(opts) {
          const tickOpts = opts.ticks;
          if (tickOpts.display && opts.display) {
            const padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              tickOpts.backdropPadding
            );
            return (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
                tickOpts.font && tickOpts.font.size,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.d.font
                  .size
              ) + padding.height
            );
          }
          return 0;
        }
        function measureLabelSize(ctx, font, label) {
          label = (0,
          _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b)(label)
            ? label
            : [label];
          return {
            w: (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aO)(
              ctx,
              font.string,
              label
            ),
            h: label.length * font.lineHeight,
          };
        }
        function determineLimits(angle, pos, size, min, max) {
          if (angle === min || angle === max) {
            return {
              start: pos - size / 2,
              end: pos + size / 2,
            };
          } else if (angle < min || angle > max) {
            return {
              start: pos - size,
              end: pos,
            };
          }
          return {
            start: pos,
            end: pos + size,
          };
        }
        function fitWithPointLabels(scale) {
          const orig = {
            l: scale.left + scale._padding.left,
            r: scale.right - scale._padding.right,
            t: scale.top + scale._padding.top,
            b: scale.bottom - scale._padding.bottom,
          };
          const limits = Object.assign({}, orig);
          const labelSizes = [];
          const padding = [];
          const valueCount = scale._pointLabels.length;
          const pointLabelOpts = scale.options.pointLabels;
          const additionalAngle = pointLabelOpts.centerPointLabels
            ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P /
              valueCount
            : 0;
          for (let i = 0; i < valueCount; i++) {
            const opts = pointLabelOpts.setContext(
              scale.getPointLabelContext(i)
            );
            padding[i] = opts.padding;
            const pointPosition = scale.getPointPosition(
              i,
              scale.drawingArea + padding[i],
              additionalAngle
            );
            const plFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              opts.font
            );
            const textSize = measureLabelSize(
              scale.ctx,
              plFont,
              scale._pointLabels[i]
            );
            labelSizes[i] = textSize;
            const angleRadians = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(
              scale.getIndexAngle(i) + additionalAngle
            );
            const angle = Math.round(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(
                angleRadians
              )
            );
            const hLimits = determineLimits(
              angle,
              pointPosition.x,
              textSize.w,
              0,
              180
            );
            const vLimits = determineLimits(
              angle,
              pointPosition.y,
              textSize.h,
              90,
              270
            );
            updateLimits(limits, orig, angleRadians, hLimits, vLimits);
          }
          scale.setCenterPoint(
            orig.l - limits.l,
            limits.r - orig.r,
            orig.t - limits.t,
            limits.b - orig.b
          );
          scale._pointLabelItems = buildPointLabelItems(
            scale,
            labelSizes,
            padding
          );
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
          const sin = Math.abs(Math.sin(angle));
          const cos = Math.abs(Math.cos(angle));
          let x = 0;
          let y = 0;
          if (hLimits.start < orig.l) {
            x = (orig.l - hLimits.start) / sin;
            limits.l = Math.min(limits.l, orig.l - x);
          } else if (hLimits.end > orig.r) {
            x = (hLimits.end - orig.r) / sin;
            limits.r = Math.max(limits.r, orig.r + x);
          }
          if (vLimits.start < orig.t) {
            y = (orig.t - vLimits.start) / cos;
            limits.t = Math.min(limits.t, orig.t - y);
          } else if (vLimits.end > orig.b) {
            y = (vLimits.end - orig.b) / cos;
            limits.b = Math.max(limits.b, orig.b + y);
          }
        }
        function createPointLabelItem(scale, index, itemOpts) {
          const outerDistance = scale.drawingArea;
          const { extra, additionalAngle, padding, size } = itemOpts;
          const pointLabelPosition = scale.getPointPosition(
            index,
            outerDistance + extra + padding,
            additionalAngle
          );
          const angle = Math.round(
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U)(
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(
                pointLabelPosition.angle +
                  _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H
              )
            )
          );
          const y = yForAngle(pointLabelPosition.y, size.h, angle);
          const textAlign = getTextAlignForAngle(angle);
          const left = leftForTextAlign(
            pointLabelPosition.x,
            size.w,
            textAlign
          );
          return {
            visible: true,
            x: pointLabelPosition.x,
            y,
            textAlign,
            left,
            top: y,
            right: left + size.w,
            bottom: y + size.h,
          };
        }
        function isNotOverlapped(item, area) {
          if (!area) {
            return true;
          }
          const { left, top, right, bottom } = item;
          const apexesInArea =
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
              {
                x: left,
                y: top,
              },
              area
            ) ||
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
              {
                x: left,
                y: bottom,
              },
              area
            ) ||
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
              {
                x: right,
                y: top,
              },
              area
            ) ||
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C)(
              {
                x: right,
                y: bottom,
              },
              area
            );
          return !apexesInArea;
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
          const items = [];
          const valueCount = scale._pointLabels.length;
          const opts = scale.options;
          const { centerPointLabels, display } = opts.pointLabels;
          const itemOpts = {
            extra: getTickBackdropHeight(opts) / 2,
            additionalAngle: centerPointLabels
              ? _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P /
                valueCount
              : 0,
          };
          let area;
          for (let i = 0; i < valueCount; i++) {
            itemOpts.padding = padding[i];
            itemOpts.size = labelSizes[i];
            const item = createPointLabelItem(scale, i, itemOpts);
            items.push(item);
            if (display === 'auto') {
              item.visible = isNotOverlapped(item, area);
              if (item.visible) {
                area = item;
              }
            }
          }
          return items;
        }
        function getTextAlignForAngle(angle) {
          if (angle === 0 || angle === 180) {
            return 'center';
          } else if (angle < 180) {
            return 'left';
          }
          return 'right';
        }
        function leftForTextAlign(x, w, align) {
          if (align === 'right') {
            x -= w;
          } else if (align === 'center') {
            x -= w / 2;
          }
          return x;
        }
        function yForAngle(y, h, angle) {
          if (angle === 90 || angle === 270) {
            y -= h / 2;
          } else if (angle > 270 || angle < 90) {
            y -= h;
          }
          return y;
        }
        function drawPointLabelBox(ctx, opts, item) {
          const { left, top, right, bottom } = item;
          const { backdropColor } = opts;
          if (
            !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
              backdropColor
            )
          ) {
            const borderRadius = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax)(
              opts.borderRadius
            );
            const padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              opts.backdropPadding
            );
            ctx.fillStyle = backdropColor;
            const backdropLeft = left - padding.left;
            const backdropTop = top - padding.top;
            const backdropWidth = right - left + padding.width;
            const backdropHeight = bottom - top + padding.height;
            if (Object.values(borderRadius).some((v) => v !== 0)) {
              ctx.beginPath();
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av)(
                ctx,
                {
                  x: backdropLeft,
                  y: backdropTop,
                  w: backdropWidth,
                  h: backdropHeight,
                  radius: borderRadius,
                }
              );
              ctx.fill();
            } else {
              ctx.fillRect(
                backdropLeft,
                backdropTop,
                backdropWidth,
                backdropHeight
              );
            }
          }
        }
        function drawPointLabels(scale, labelCount) {
          const {
            ctx,
            options: { pointLabels },
          } = scale;
          for (let i = labelCount - 1; i >= 0; i--) {
            const item = scale._pointLabelItems[i];
            if (!item.visible) {
              continue;
            }
            const optsAtIndex = pointLabels.setContext(
              scale.getPointLabelContext(i)
            );
            drawPointLabelBox(ctx, optsAtIndex, item);
            const plFont = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
              optsAtIndex.font
            );
            const { x, y, textAlign } = item;
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
              ctx,
              scale._pointLabels[i],
              x,
              y + plFont.lineHeight / 2,
              plFont,
              {
                color: optsAtIndex.color,
                textAlign: textAlign,
                textBaseline: 'middle',
              }
            );
          }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
          const { ctx } = scale;
          if (circular) {
            ctx.arc(
              scale.xCenter,
              scale.yCenter,
              radius,
              0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T
            );
          } else {
            let pointPosition = scale.getPointPosition(0, radius);
            ctx.moveTo(pointPosition.x, pointPosition.y);
            for (let i = 1; i < labelCount; i++) {
              pointPosition = scale.getPointPosition(i, radius);
              ctx.lineTo(pointPosition.x, pointPosition.y);
            }
          }
        }
        function drawRadiusLine(
          scale,
          gridLineOpts,
          radius,
          labelCount,
          borderOpts
        ) {
          const ctx = scale.ctx;
          const circular = gridLineOpts.circular;
          const { color, lineWidth } = gridLineOpts;
          if (
            (!circular && !labelCount) ||
            !color ||
            !lineWidth ||
            radius < 0
          ) {
            return;
          }
          ctx.save();
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.setLineDash(borderOpts.dash || []);
          ctx.lineDashOffset = borderOpts.dashOffset;
          ctx.beginPath();
          pathRadiusLine(scale, radius, circular, labelCount);
          ctx.closePath();
          ctx.stroke();
          ctx.restore();
        }
        function createPointLabelContext(parent, index, label) {
          return (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j)(
            parent,
            {
              label,
              index,
              type: 'pointLabel',
            }
          );
        }
        class RadialLinearScale extends LinearScaleBase {
          static id = 'radialLinear';
          static defaults = {
            display: true,
            animate: true,
            position: 'chartArea',
            angleLines: {
              display: true,
              lineWidth: 1,
              borderDash: [],
              borderDashOffset: 0.0,
            },
            grid: {
              circular: false,
            },
            startAngle: 0,
            ticks: {
              showLabelBackdrop: true,
              callback:
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aM
                  .formatters.numeric,
            },
            pointLabels: {
              backdropColor: undefined,
              backdropPadding: 2,
              display: true,
              font: {
                size: 10,
              },
              callback(label) {
                return label;
              },
              padding: 5,
              centerPointLabels: false,
            },
          };
          static defaultRoutes = {
            'angleLines.color': 'borderColor',
            'pointLabels.color': 'color',
            'ticks.color': 'color',
          };
          static descriptors = {
            angleLines: {
              _fallback: 'grid',
            },
          };
          constructor(cfg) {
            super(cfg);
            this.xCenter = undefined;
            this.yCenter = undefined;
            this.drawingArea = undefined;
            this._pointLabels = [];
            this._pointLabelItems = [];
          }
          setDimensions() {
            const padding = (this._padding = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
              getTickBackdropHeight(this.options) / 2
            ));
            const w = (this.width = this.maxWidth - padding.width);
            const h = (this.height = this.maxHeight - padding.height);
            this.xCenter = Math.floor(this.left + w / 2 + padding.left);
            this.yCenter = Math.floor(this.top + h / 2 + padding.top);
            this.drawingArea = Math.floor(Math.min(w, h) / 2);
          }
          determineDataLimits() {
            const { min, max } = this.getMinMax(false);
            this.min =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                min
              ) && !isNaN(min)
                ? min
                : 0;
            this.max =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                max
              ) && !isNaN(max)
                ? max
                : 0;
            this.handleTickRangeOptions();
          }
          computeTickLimit() {
            return Math.ceil(
              this.drawingArea / getTickBackdropHeight(this.options)
            );
          }
          generateTickLabels(ticks) {
            LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
            this._pointLabels = this.getLabels()
              .map((value, index) => {
                const label = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                  this.options.pointLabels.callback,
                  [value, index],
                  this
                );
                return label || label === 0 ? label : '';
              })
              .filter((v, i) => this.chart.getDataVisibility(i));
          }
          fit() {
            const opts = this.options;
            if (opts.display && opts.pointLabels.display) {
              fitWithPointLabels(this);
            } else {
              this.setCenterPoint(0, 0, 0, 0);
            }
          }
          setCenterPoint(
            leftMovement,
            rightMovement,
            topMovement,
            bottomMovement
          ) {
            this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
            this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
            this.drawingArea -= Math.min(
              this.drawingArea / 2,
              Math.max(leftMovement, rightMovement, topMovement, bottomMovement)
            );
          }
          getIndexAngle(index) {
            const angleMultiplier =
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T /
              (this._pointLabels.length || 1);
            const startAngle = this.options.startAngle || 0;
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az)(
              index * angleMultiplier +
                (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
                  startAngle
                )
            );
          }
          getDistanceFromCenterForValue(value) {
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                value
              )
            ) {
              return NaN;
            }
            const scalingFactor = this.drawingArea / (this.max - this.min);
            if (this.options.reverse) {
              return (this.max - value) * scalingFactor;
            }
            return (value - this.min) * scalingFactor;
          }
          getValueForDistanceFromCenter(distance) {
            if (
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
                distance
              )
            ) {
              return NaN;
            }
            const scaledDistance =
              distance / (this.drawingArea / (this.max - this.min));
            return this.options.reverse
              ? this.max - scaledDistance
              : this.min + scaledDistance;
          }
          getPointLabelContext(index) {
            const pointLabels = this._pointLabels || [];
            if (index >= 0 && index < pointLabels.length) {
              const pointLabel = pointLabels[index];
              return createPointLabelContext(
                this.getContext(),
                index,
                pointLabel
              );
            }
          }
          getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
            const angle =
              this.getIndexAngle(index) -
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H +
              additionalAngle;
            return {
              x: Math.cos(angle) * distanceFromCenter + this.xCenter,
              y: Math.sin(angle) * distanceFromCenter + this.yCenter,
              angle,
            };
          }
          getPointPositionForValue(index, value) {
            return this.getPointPosition(
              index,
              this.getDistanceFromCenterForValue(value)
            );
          }
          getBasePosition(index) {
            return this.getPointPositionForValue(
              index || 0,
              this.getBaseValue()
            );
          }
          getPointLabelPosition(index) {
            const { left, top, right, bottom } = this._pointLabelItems[index];
            return {
              left,
              top,
              right,
              bottom,
            };
          }
          drawBackground() {
            const {
              backgroundColor,
              grid: { circular },
            } = this.options;
            if (backgroundColor) {
              const ctx = this.ctx;
              ctx.save();
              ctx.beginPath();
              pathRadiusLine(
                this,
                this.getDistanceFromCenterForValue(this._endValue),
                circular,
                this._pointLabels.length
              );
              ctx.closePath();
              ctx.fillStyle = backgroundColor;
              ctx.fill();
              ctx.restore();
            }
          }
          drawGrid() {
            const ctx = this.ctx;
            const opts = this.options;
            const { angleLines, grid, border } = opts;
            const labelCount = this._pointLabels.length;
            let i, offset, position;
            if (opts.pointLabels.display) {
              drawPointLabels(this, labelCount);
            }
            if (grid.display) {
              this.ticks.forEach((tick, index) => {
                if (index !== 0 || (index === 0 && this.min < 0)) {
                  offset = this.getDistanceFromCenterForValue(tick.value);
                  const context = this.getContext(index);
                  const optsAtIndex = grid.setContext(context);
                  const optsAtIndexBorder = border.setContext(context);
                  drawRadiusLine(
                    this,
                    optsAtIndex,
                    offset,
                    labelCount,
                    optsAtIndexBorder
                  );
                }
              });
            }
            if (angleLines.display) {
              ctx.save();
              for (i = labelCount - 1; i >= 0; i--) {
                const optsAtIndex = angleLines.setContext(
                  this.getPointLabelContext(i)
                );
                const { color, lineWidth } = optsAtIndex;
                if (!lineWidth || !color) {
                  continue;
                }
                ctx.lineWidth = lineWidth;
                ctx.strokeStyle = color;
                ctx.setLineDash(optsAtIndex.borderDash);
                ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                offset = this.getDistanceFromCenterForValue(
                  opts.reverse ? this.min : this.max
                );
                position = this.getPointPosition(i, offset);
                ctx.beginPath();
                ctx.moveTo(this.xCenter, this.yCenter);
                ctx.lineTo(position.x, position.y);
                ctx.stroke();
              }
              ctx.restore();
            }
          }
          drawBorder() {}
          drawLabels() {
            const ctx = this.ctx;
            const opts = this.options;
            const tickOpts = opts.ticks;
            if (!tickOpts.display) {
              return;
            }
            const startAngle = this.getIndexAngle(0);
            let offset, width;
            ctx.save();
            ctx.translate(this.xCenter, this.yCenter);
            ctx.rotate(startAngle);
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            this.ticks.forEach((tick, index) => {
              if (index === 0 && this.min >= 0 && !opts.reverse) {
                return;
              }
              const optsAtIndex = tickOpts.setContext(this.getContext(index));
              const tickFont = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0)(
                optsAtIndex.font
              );
              offset = this.getDistanceFromCenterForValue(
                this.ticks[index].value
              );
              if (optsAtIndex.showLabelBackdrop) {
                ctx.font = tickFont.string;
                width = ctx.measureText(tick.label).width;
                ctx.fillStyle = optsAtIndex.backdropColor;
                const padding = (0,
                _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E)(
                  optsAtIndex.backdropPadding
                );
                ctx.fillRect(
                  -width / 2 - padding.left,
                  -offset - tickFont.size / 2 - padding.top,
                  width + padding.width,
                  tickFont.size + padding.height
                );
              }
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z)(
                ctx,
                tick.label,
                0,
                -offset,
                tickFont,
                {
                  color: optsAtIndex.color,
                  strokeColor: optsAtIndex.textStrokeColor,
                  strokeWidth: optsAtIndex.textStrokeWidth,
                }
              );
            });
            ctx.restore();
          }
          drawTitle() {}
        }

        const INTERVALS = {
          millisecond: {
            common: true,
            size: 1,
            steps: 1000,
          },
          second: {
            common: true,
            size: 1000,
            steps: 60,
          },
          minute: {
            common: true,
            size: 60000,
            steps: 60,
          },
          hour: {
            common: true,
            size: 3600000,
            steps: 24,
          },
          day: {
            common: true,
            size: 86400000,
            steps: 30,
          },
          week: {
            common: false,
            size: 604800000,
            steps: 4,
          },
          month: {
            common: true,
            size: 2.628e9,
            steps: 12,
          },
          quarter: {
            common: false,
            size: 7.884e9,
            steps: 4,
          },
          year: {
            common: true,
            size: 3.154e10,
          },
        };
        const UNITS = /* #__PURE__ */ Object.keys(INTERVALS);
        function sorter(a, b) {
          return a - b;
        }
        function parse(scale, input) {
          if (
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k)(
              input
            )
          ) {
            return null;
          }
          const adapter = scale._adapter;
          const { parser, round, isoWeekday } = scale._parseOpts;
          let value = input;
          if (typeof parser === 'function') {
            value = parser(value);
          }
          if (
            !(0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
              value
            )
          ) {
            value =
              typeof parser === 'string'
                ? adapter.parse(value, parser)
                : adapter.parse(value);
          }
          if (value === null) {
            return null;
          }
          if (round) {
            value =
              round === 'week' &&
              ((0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(
                isoWeekday
              ) ||
                isoWeekday === true)
                ? adapter.startOf(value, 'isoWeek', isoWeekday)
                : adapter.startOf(value, round);
          }
          return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
          const ilen = UNITS.length;
          for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
            const interval = INTERVALS[UNITS[i]];
            const factor = interval.steps
              ? interval.steps
              : Number.MAX_SAFE_INTEGER;
            if (
              interval.common &&
              Math.ceil((max - min) / (factor * interval.size)) <= capacity
            ) {
              return UNITS[i];
            }
          }
          return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(
          scale,
          numTicks,
          minUnit,
          min,
          max
        ) {
          for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
            const unit = UNITS[i];
            if (
              INTERVALS[unit].common &&
              scale._adapter.diff(max, min, unit) >= numTicks - 1
            ) {
              return unit;
            }
          }
          return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
          for (
            let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length;
            i < ilen;
            ++i
          ) {
            if (INTERVALS[UNITS[i]].common) {
              return UNITS[i];
            }
          }
        }
        function addTick(ticks, time, timestamps) {
          if (!timestamps) {
            ticks[time] = true;
          } else if (timestamps.length) {
            const { lo, hi } = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aQ)(
              timestamps,
              time
            );
            const timestamp =
              timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
            ticks[timestamp] = true;
          }
        }
        function setMajorTicks(scale, ticks, map, majorUnit) {
          const adapter = scale._adapter;
          const first = +adapter.startOf(ticks[0].value, majorUnit);
          const last = ticks[ticks.length - 1].value;
          let major, index;
          for (
            major = first;
            major <= last;
            major = +adapter.add(major, 1, majorUnit)
          ) {
            index = map[major];
            if (index >= 0) {
              ticks[index].major = true;
            }
          }
          return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
          const ticks = [];
          const map = {};
          const ilen = values.length;
          let i, value;
          for (i = 0; i < ilen; ++i) {
            value = values[i];
            map[value] = i;
            ticks.push({
              value,
              major: false,
            });
          }
          return ilen === 0 || !majorUnit
            ? ticks
            : setMajorTicks(scale, ticks, map, majorUnit);
        }
        class TimeScale extends Scale {
          static id = 'time';
          static defaults = {
            bounds: 'data',
            adapters: {},
            time: {
              parser: false,
              unit: false,
              round: false,
              isoWeekday: false,
              minUnit: 'millisecond',
              displayFormats: {},
            },
            ticks: {
              source: 'auto',
              callback: false,
              major: {
                enabled: false,
              },
            },
          };
          constructor(props) {
            super(props);
            this._cache = {
              data: [],
              labels: [],
              all: [],
            };
            this._unit = 'day';
            this._majorUnit = undefined;
            this._offsets = {};
            this._normalized = false;
            this._parseOpts = undefined;
          }
          init(scaleOpts, opts = {}) {
            const time = scaleOpts.time || (scaleOpts.time = {});
            const adapter = (this._adapter = new adapters._date(
              scaleOpts.adapters.date
            ));
            adapter.init(opts);
            (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab)(
              time.displayFormats,
              adapter.formats()
            );
            this._parseOpts = {
              parser: time.parser,
              round: time.round,
              isoWeekday: time.isoWeekday,
            };
            super.init(scaleOpts);
            this._normalized = opts.normalized;
          }
          parse(raw, index) {
            if (raw === undefined) {
              return null;
            }
            return parse(this, raw);
          }
          beforeLayout() {
            super.beforeLayout();
            this._cache = {
              data: [],
              labels: [],
              all: [],
            };
          }
          determineDataLimits() {
            const options = this.options;
            const adapter = this._adapter;
            const unit = options.time.unit || 'day';
            let { min, max, minDefined, maxDefined } = this.getUserBounds();
            function _applyBounds(bounds) {
              if (!minDefined && !isNaN(bounds.min)) {
                min = Math.min(min, bounds.min);
              }
              if (!maxDefined && !isNaN(bounds.max)) {
                max = Math.max(max, bounds.max);
              }
            }
            if (!minDefined || !maxDefined) {
              _applyBounds(this._getLabelBounds());
              if (
                options.bounds !== 'ticks' ||
                options.ticks.source !== 'labels'
              ) {
                _applyBounds(this.getMinMax(false));
              }
            }
            min =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                min
              ) && !isNaN(min)
                ? min
                : +adapter.startOf(Date.now(), unit);
            max =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g)(
                max
              ) && !isNaN(max)
                ? max
                : +adapter.endOf(Date.now(), unit) + 1;
            this.min = Math.min(min, max - 1);
            this.max = Math.max(min + 1, max);
          }
          _getLabelBounds() {
            const arr = this.getLabelTimestamps();
            let min = Number.POSITIVE_INFINITY;
            let max = Number.NEGATIVE_INFINITY;
            if (arr.length) {
              min = arr[0];
              max = arr[arr.length - 1];
            }
            return {
              min,
              max,
            };
          }
          buildTicks() {
            const options = this.options;
            const timeOpts = options.time;
            const tickOpts = options.ticks;
            const timestamps =
              tickOpts.source === 'labels'
                ? this.getLabelTimestamps()
                : this._generate();
            if (options.bounds === 'ticks' && timestamps.length) {
              this.min = this._userMin || timestamps[0];
              this.max = this._userMax || timestamps[timestamps.length - 1];
            }
            const min = this.min;
            const max = this.max;
            const ticks = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aP)(
              timestamps,
              min,
              max
            );
            this._unit =
              timeOpts.unit ||
              (tickOpts.autoSkip
                ? determineUnitForAutoTicks(
                    timeOpts.minUnit,
                    this.min,
                    this.max,
                    this._getLabelCapacity(min)
                  )
                : determineUnitForFormatting(
                    this,
                    ticks.length,
                    timeOpts.minUnit,
                    this.min,
                    this.max
                  ));
            this._majorUnit =
              !tickOpts.major.enabled || this._unit === 'year'
                ? undefined
                : determineMajorUnit(this._unit);
            this.initOffsets(timestamps);
            if (options.reverse) {
              ticks.reverse();
            }
            return ticksFromTimestamps(this, ticks, this._majorUnit);
          }
          afterAutoSkip() {
            if (this.options.offsetAfterAutoskip) {
              this.initOffsets(this.ticks.map((tick) => +tick.value));
            }
          }
          initOffsets(timestamps = []) {
            let start = 0;
            let end = 0;
            let first, last;
            if (this.options.offset && timestamps.length) {
              first = this.getDecimalForValue(timestamps[0]);
              if (timestamps.length === 1) {
                start = 1 - first;
              } else {
                start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
              }
              last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
              if (timestamps.length === 1) {
                end = last;
              } else {
                end =
                  (last -
                    this.getDecimalForValue(
                      timestamps[timestamps.length - 2]
                    )) /
                  2;
              }
            }
            const limit = timestamps.length < 3 ? 0.5 : 0.25;
            start = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              start,
              0,
              limit
            );
            end = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S)(
              end,
              0,
              limit
            );
            this._offsets = {
              start,
              end,
              factor: 1 / (start + 1 + end),
            };
          }
          _generate() {
            const adapter = this._adapter;
            const min = this.min;
            const max = this.max;
            const options = this.options;
            const timeOpts = options.time;
            const minor =
              timeOpts.unit ||
              determineUnitForAutoTicks(
                timeOpts.minUnit,
                min,
                max,
                this._getLabelCapacity(min)
              );
            const stepSize = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v)(
              options.ticks.stepSize,
              1
            );
            const weekday = minor === 'week' ? timeOpts.isoWeekday : false;
            const hasWeekday =
              (0, _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x)(
                weekday
              ) || weekday === true;
            const ticks = {};
            let first = min;
            let time, count;
            if (hasWeekday) {
              first = +adapter.startOf(first, 'isoWeek', weekday);
            }
            first = +adapter.startOf(first, hasWeekday ? 'day' : minor);
            if (adapter.diff(max, min, minor) > 100000 * stepSize) {
              throw new Error(
                min +
                  ' and ' +
                  max +
                  ' are too far apart with stepSize of ' +
                  stepSize +
                  ' ' +
                  minor
              );
            }
            const timestamps =
              options.ticks.source === 'data' && this.getDataTimestamps();
            for (
              time = first, count = 0;
              time < max;
              time = +adapter.add(time, stepSize, minor), count++
            ) {
              addTick(ticks, time, timestamps);
            }
            if (time === max || options.bounds === 'ticks' || count === 1) {
              addTick(ticks, time, timestamps);
            }
            return Object.keys(ticks)
              .sort(sorter)
              .map((x) => +x);
          }
          getLabelForValue(value) {
            const adapter = this._adapter;
            const timeOpts = this.options.time;
            if (timeOpts.tooltipFormat) {
              return adapter.format(value, timeOpts.tooltipFormat);
            }
            return adapter.format(value, timeOpts.displayFormats.datetime);
          }
          format(value, format) {
            const options = this.options;
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const fmt = format || formats[unit];
            return this._adapter.format(value, fmt);
          }
          _tickFormatFunction(time, index, ticks, format) {
            const options = this.options;
            const formatter = options.ticks.callback;
            if (formatter) {
              return (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q)(
                formatter,
                [time, index, ticks],
                this
              );
            }
            const formats = options.time.displayFormats;
            const unit = this._unit;
            const majorUnit = this._majorUnit;
            const minorFormat = unit && formats[unit];
            const majorFormat = majorUnit && formats[majorUnit];
            const tick = ticks[index];
            const major = majorUnit && majorFormat && tick && tick.major;
            return this._adapter.format(
              time,
              format || (major ? majorFormat : minorFormat)
            );
          }
          generateTickLabels(ticks) {
            let i, ilen, tick;
            for (i = 0, ilen = ticks.length; i < ilen; ++i) {
              tick = ticks[i];
              tick.label = this._tickFormatFunction(tick.value, i, ticks);
            }
          }
          getDecimalForValue(value) {
            return value === null
              ? NaN
              : (value - this.min) / (this.max - this.min);
          }
          getPixelForValue(value) {
            const offsets = this._offsets;
            const pos = this.getDecimalForValue(value);
            return this.getPixelForDecimal(
              (offsets.start + pos) * offsets.factor
            );
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const pos =
              this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return this.min + pos * (this.max - this.min);
          }
          _getLabelSize(label) {
            const ticksOpts = this.options.ticks;
            const tickLabelWidth = this.ctx.measureText(label).width;
            const angle = (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t)(
              this.isHorizontal()
                ? ticksOpts.maxRotation
                : ticksOpts.minRotation
            );
            const cosRotation = Math.cos(angle);
            const sinRotation = Math.sin(angle);
            const tickFontSize = this._resolveTickFontOptions(0).size;
            return {
              w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
              h: tickLabelWidth * sinRotation + tickFontSize * cosRotation,
            };
          }
          _getLabelCapacity(exampleTime) {
            const timeOpts = this.options.time;
            const displayFormats = timeOpts.displayFormats;
            const format =
              displayFormats[timeOpts.unit] || displayFormats.millisecond;
            const exampleLabel = this._tickFormatFunction(
              exampleTime,
              0,
              ticksFromTimestamps(this, [exampleTime], this._majorUnit),
              format
            );
            const size = this._getLabelSize(exampleLabel);
            const capacity =
              Math.floor(
                this.isHorizontal() ? this.width / size.w : this.height / size.h
              ) - 1;
            return capacity > 0 ? capacity : 1;
          }
          getDataTimestamps() {
            let timestamps = this._cache.data || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const metas = this.getMatchingVisibleMetas();
            if (this._normalized && metas.length) {
              return (this._cache.data =
                metas[0].controller.getAllParsedValues(this));
            }
            for (i = 0, ilen = metas.length; i < ilen; ++i) {
              timestamps = timestamps.concat(
                metas[i].controller.getAllParsedValues(this)
              );
            }
            return (this._cache.data = this.normalize(timestamps));
          }
          getLabelTimestamps() {
            const timestamps = this._cache.labels || [];
            let i, ilen;
            if (timestamps.length) {
              return timestamps;
            }
            const labels = this.getLabels();
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              timestamps.push(parse(this, labels[i]));
            }
            return (this._cache.labels = this._normalized
              ? timestamps
              : this.normalize(timestamps));
          }
          normalize(values) {
            return (0,
            _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._)(
              values.sort(sorter)
            );
          }
        }

        function interpolate(table, val, reverse) {
          let lo = 0;
          let hi = table.length - 1;
          let prevSource, nextSource, prevTarget, nextTarget;
          if (reverse) {
            if (val >= table[lo].pos && val <= table[hi].pos) {
              ({ lo, hi } = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(
                table,
                'pos',
                val
              ));
            }
            ({ pos: prevSource, time: prevTarget } = table[lo]);
            ({ pos: nextSource, time: nextTarget } = table[hi]);
          } else {
            if (val >= table[lo].time && val <= table[hi].time) {
              ({ lo, hi } = (0,
              _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B)(
                table,
                'time',
                val
              ));
            }
            ({ time: prevSource, pos: prevTarget } = table[lo]);
            ({ time: nextSource, pos: nextTarget } = table[hi]);
          }
          const span = nextSource - prevSource;
          return span
            ? prevTarget +
                ((nextTarget - prevTarget) * (val - prevSource)) / span
            : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
          static id = 'timeseries';
          static defaults = TimeScale.defaults;
          constructor(props) {
            super(props);
            this._table = [];
            this._minPos = undefined;
            this._tableRange = undefined;
          }
          initOffsets() {
            const timestamps = this._getTimestampsForTable();
            const table = (this._table = this.buildLookupTable(timestamps));
            this._minPos = interpolate(table, this.min);
            this._tableRange = interpolate(table, this.max) - this._minPos;
            super.initOffsets(timestamps);
          }
          buildLookupTable(timestamps) {
            const { min, max } = this;
            const items = [];
            const table = [];
            let i, ilen, prev, curr, next;
            for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
              curr = timestamps[i];
              if (curr >= min && curr <= max) {
                items.push(curr);
              }
            }
            if (items.length < 2) {
              return [
                {
                  time: min,
                  pos: 0,
                },
                {
                  time: max,
                  pos: 1,
                },
              ];
            }
            for (i = 0, ilen = items.length; i < ilen; ++i) {
              next = items[i + 1];
              prev = items[i - 1];
              curr = items[i];
              if (Math.round((next + prev) / 2) !== curr) {
                table.push({
                  time: curr,
                  pos: i / (ilen - 1),
                });
              }
            }
            return table;
          }
          _generate() {
            const min = this.min;
            const max = this.max;
            let timestamps = super.getDataTimestamps();
            if (!timestamps.includes(min) || !timestamps.length) {
              timestamps.splice(0, 0, min);
            }
            if (!timestamps.includes(max) || timestamps.length === 1) {
              timestamps.push(max);
            }
            return timestamps.sort((a, b) => a - b);
          }
          _getTimestampsForTable() {
            let timestamps = this._cache.all || [];
            if (timestamps.length) {
              return timestamps;
            }
            const data = this.getDataTimestamps();
            const label = this.getLabelTimestamps();
            if (data.length && label.length) {
              timestamps = this.normalize(data.concat(label));
            } else {
              timestamps = data.length ? data : label;
            }
            timestamps = this._cache.all = timestamps;
            return timestamps;
          }
          getDecimalForValue(value) {
            return (
              (interpolate(this._table, value) - this._minPos) /
              this._tableRange
            );
          }
          getValueForPixel(pixel) {
            const offsets = this._offsets;
            const decimal =
              this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
            return interpolate(
              this._table,
              decimal * this._tableRange + this._minPos,
              true
            );
          }
        }

        var scales = /*#__PURE__*/ Object.freeze({
          __proto__: null,
          CategoryScale: CategoryScale,
          LinearScale: LinearScale,
          LogarithmicScale: LogarithmicScale,
          RadialLinearScale: RadialLinearScale,
          TimeScale: TimeScale,
          TimeSeriesScale: TimeSeriesScale,
        });

        const registerables = [controllers, elements, plugins, scales];

        //# sourceMappingURL=chart.js.map

        /***/
      },

    /***/ './node_modules/chart.js/dist/chunks/helpers.dataset.js':
      /*!**************************************************************!*\
  !*** ./node_modules/chart.js/dist/chunks/helpers.dataset.js ***!
  \**************************************************************/
      /***/ (
        __unused_webpack___webpack_module__,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ $: () => /* binding */ unclipArea,
          /* harmony export */ A: () => /* binding */ _rlookupByKey,
          /* harmony export */ B: () => /* binding */ _lookupByKey,
          /* harmony export */ C: () => /* binding */ _isPointInArea,
          /* harmony export */ D: () => /* binding */ getAngleFromPoint,
          /* harmony export */ E: () => /* binding */ toPadding,
          /* harmony export */ F: () => /* binding */ each,
          /* harmony export */ G: () => /* binding */ getMaximumSize,
          /* harmony export */ H: () => /* binding */ HALF_PI,
          /* harmony export */ I: () => /* binding */ _getParentNode,
          /* harmony export */ J: () => /* binding */ readUsedSize,
          /* harmony export */ K: () =>
            /* binding */ supportsEventListenerOptions,
          /* harmony export */ L: () => /* binding */ throttled,
          /* harmony export */ M: () => /* binding */ _isDomSupported,
          /* harmony export */ N: () => /* binding */ _factorize,
          /* harmony export */ O: () => /* binding */ finiteOrDefault,
          /* harmony export */ P: () => /* binding */ PI,
          /* harmony export */ Q: () => /* binding */ callback,
          /* harmony export */ R: () => /* binding */ _addGrace,
          /* harmony export */ S: () => /* binding */ _limitValue,
          /* harmony export */ T: () => /* binding */ TAU,
          /* harmony export */ U: () => /* binding */ toDegrees,
          /* harmony export */ V: () => /* binding */ _measureText,
          /* harmony export */ W: () => /* binding */ _int16Range,
          /* harmony export */ X: () => /* binding */ _alignPixel,
          /* harmony export */ Y: () => /* binding */ clipArea,
          /* harmony export */ Z: () => /* binding */ renderText,
          /* harmony export */ _: () => /* binding */ _arrayUnique,
          /* harmony export */ a: () => /* binding */ resolve,
          /* harmony export */ a$: () => /* binding */ getStyle,
          /* harmony export */ a0: () => /* binding */ toFont,
          /* harmony export */ a1: () => /* binding */ _toLeftRightCenter,
          /* harmony export */ a2: () => /* binding */ _alignStartEnd,
          /* harmony export */ a3: () => /* binding */ overrides,
          /* harmony export */ a4: () => /* binding */ merge,
          /* harmony export */ a5: () => /* binding */ _capitalize,
          /* harmony export */ a6: () => /* binding */ descriptors,
          /* harmony export */ a7: () => /* binding */ isFunction,
          /* harmony export */ a8: () => /* binding */ _attachContext,
          /* harmony export */ a9: () => /* binding */ _createResolver,
          /* harmony export */ aA: () => /* binding */ getRtlAdapter,
          /* harmony export */ aB: () => /* binding */ overrideTextDirection,
          /* harmony export */ aC: () => /* binding */ _textX,
          /* harmony export */ aD: () => /* binding */ restoreTextDirection,
          /* harmony export */ aE: () => /* binding */ drawPointLegend,
          /* harmony export */ aF: () => /* binding */ distanceBetweenPoints,
          /* harmony export */ aG: () => /* binding */ noop,
          /* harmony export */ aH: () => /* binding */ _setMinAndMaxByKey,
          /* harmony export */ aI: () => /* binding */ niceNum,
          /* harmony export */ aJ: () => /* binding */ almostWhole,
          /* harmony export */ aK: () => /* binding */ almostEquals,
          /* harmony export */ aL: () => /* binding */ _decimalPlaces,
          /* harmony export */ aM: () => /* binding */ Ticks,
          /* harmony export */ aN: () => /* binding */ log10,
          /* harmony export */ aO: () => /* binding */ _longestText,
          /* harmony export */ aP: () => /* binding */ _filterBetween,
          /* harmony export */ aQ: () => /* binding */ _lookup,
          /* harmony export */ aR: () => /* binding */ isPatternOrGradient,
          /* harmony export */ aS: () => /* binding */ getHoverColor,
          /* harmony export */ aT: () => /* binding */ clone,
          /* harmony export */ aU: () => /* binding */ _merger,
          /* harmony export */ aV: () => /* binding */ _mergerIf,
          /* harmony export */ aW: () => /* binding */ _deprecated,
          /* harmony export */ aX: () => /* binding */ _splitKey,
          /* harmony export */ aY: () => /* binding */ toFontString,
          /* harmony export */ aZ: () => /* binding */ splineCurve,
          /* harmony export */ a_: () => /* binding */ splineCurveMonotone,
          /* harmony export */ aa: () => /* binding */ _descriptors,
          /* harmony export */ ab: () => /* binding */ mergeIf,
          /* harmony export */ ac: () => /* binding */ uid,
          /* harmony export */ ad: () => /* binding */ debounce,
          /* harmony export */ ae: () => /* binding */ retinaScale,
          /* harmony export */ af: () => /* binding */ clearCanvas,
          /* harmony export */ ag: () => /* binding */ setsEqual,
          /* harmony export */ ah: () => /* binding */ getDatasetClipArea,
          /* harmony export */ ai: () => /* binding */ _elementsEqual,
          /* harmony export */ aj: () => /* binding */ _isClickEvent,
          /* harmony export */ ak: () => /* binding */ _isBetween,
          /* harmony export */ al: () => /* binding */ _readValueToProps,
          /* harmony export */ am: () =>
            /* binding */ _updateBezierControlPoints,
          /* harmony export */ an: () => /* binding */ _computeSegments,
          /* harmony export */ ao: () => /* binding */ _boundSegments,
          /* harmony export */ ap: () => /* binding */ _steppedInterpolation,
          /* harmony export */ aq: () => /* binding */ _bezierInterpolation,
          /* harmony export */ ar: () => /* binding */ _pointInLine,
          /* harmony export */ as: () => /* binding */ _steppedLineTo,
          /* harmony export */ at: () => /* binding */ _bezierCurveTo,
          /* harmony export */ au: () => /* binding */ drawPoint,
          /* harmony export */ av: () => /* binding */ addRoundedRectPath,
          /* harmony export */ aw: () => /* binding */ toTRBL,
          /* harmony export */ ax: () => /* binding */ toTRBLCorners,
          /* harmony export */ ay: () => /* binding */ _boundSegment,
          /* harmony export */ az: () => /* binding */ _normalizeAngle,
          /* harmony export */ b: () => /* binding */ isArray,
          /* harmony export */ b0: () => /* binding */ fontString,
          /* harmony export */ b1: () => /* binding */ toLineHeight,
          /* harmony export */ b2: () => /* binding */ PITAU,
          /* harmony export */ b3: () => /* binding */ INFINITY,
          /* harmony export */ b4: () => /* binding */ RAD_PER_DEG,
          /* harmony export */ b5: () => /* binding */ QUARTER_PI,
          /* harmony export */ b6: () => /* binding */ TWO_THIRDS_PI,
          /* harmony export */ b7: () => /* binding */ _angleDiff,
          /* harmony export */ c: () => /* binding */ color,
          /* harmony export */ d: () => /* binding */ defaults,
          /* harmony export */ e: () => /* binding */ effects,
          /* harmony export */ f: () => /* binding */ resolveObjectKey,
          /* harmony export */ g: () => /* binding */ isNumberFinite,
          /* harmony export */ h: () => /* binding */ defined,
          /* harmony export */ i: () => /* binding */ isObject,
          /* harmony export */ j: () => /* binding */ createContext,
          /* harmony export */ k: () => /* binding */ isNullOrUndef,
          /* harmony export */ l: () => /* binding */ listenArrayEvents,
          /* harmony export */ m: () => /* binding */ toPercentage,
          /* harmony export */ n: () => /* binding */ toDimension,
          /* harmony export */ o: () => /* binding */ formatNumber,
          /* harmony export */ p: () => /* binding */ _angleBetween,
          /* harmony export */ q: () =>
            /* binding */ _getStartAndCountOfVisiblePoints,
          /* harmony export */ r: () => /* binding */ requestAnimFrame,
          /* harmony export */ s: () => /* binding */ sign,
          /* harmony export */ t: () => /* binding */ toRadians,
          /* harmony export */ u: () => /* binding */ unlistenArrayEvents,
          /* harmony export */ v: () => /* binding */ valueOrDefault,
          /* harmony export */ w: () => /* binding */ _scaleRangesChanged,
          /* harmony export */ x: () => /* binding */ isNumber,
          /* harmony export */ y: () =>
            /* binding */ _parseObjectDataRadialScale,
          /* harmony export */ z: () => /* binding */ getRelativePosition,
          /* harmony export */
        });
        /* harmony import */ var _kurkle_color__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! @kurkle/color */ './node_modules/@kurkle/color/dist/color.esm.js'
          );
        /*!
         * Chart.js v4.4.9
         * https://www.chartjs.org
         * (c) 2025 Chart.js Contributors
         * Released under the MIT License
         */

        /**
         * @namespace Chart.helpers
         */ /**
         * An empty function that can be used, for example, for optional callback.
         */ function noop() {
          /* noop */
        }
        /**
         * Returns a unique id, sequentially generated from a global variable.
         */ const uid = (() => {
          let id = 0;
          return () => id++;
        })();
        /**
         * Returns true if `value` is neither null nor undefined, else returns false.
         * @param value - The value to test.
         * @since 2.7.0
         */ function isNullOrUndef(value) {
          return value === null || value === undefined;
        }
        /**
         * Returns true if `value` is an array (including typed arrays), else returns false.
         * @param value - The value to test.
         * @function
         */ function isArray(value) {
          if (Array.isArray && Array.isArray(value)) {
            return true;
          }
          const type = Object.prototype.toString.call(value);
          if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {
            return true;
          }
          return false;
        }
        /**
         * Returns true if `value` is an object (excluding null), else returns false.
         * @param value - The value to test.
         * @since 2.7.0
         */ function isObject(value) {
          return (
            value !== null &&
            Object.prototype.toString.call(value) === '[object Object]'
          );
        }
        /**
         * Returns true if `value` is a finite number, else returns false
         * @param value  - The value to test.
         */ function isNumberFinite(value) {
          return (
            (typeof value === 'number' || value instanceof Number) &&
            isFinite(+value)
          );
        }
        /**
         * Returns `value` if finite, else returns `defaultValue`.
         * @param value - The value to return if defined.
         * @param defaultValue - The value to return if `value` is not finite.
         */ function finiteOrDefault(value, defaultValue) {
          return isNumberFinite(value) ? value : defaultValue;
        }
        /**
         * Returns `value` if defined, else returns `defaultValue`.
         * @param value - The value to return if defined.
         * @param defaultValue - The value to return if `value` is undefined.
         */ function valueOrDefault(value, defaultValue) {
          return typeof value === 'undefined' ? defaultValue : value;
        }
        const toPercentage = (value, dimension) =>
          typeof value === 'string' && value.endsWith('%')
            ? parseFloat(value) / 100
            : +value / dimension;
        const toDimension = (value, dimension) =>
          typeof value === 'string' && value.endsWith('%')
            ? (parseFloat(value) / 100) * dimension
            : +value;
        /**
         * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
         * value returned by `fn`. If `fn` is not a function, this method returns undefined.
         * @param fn - The function to call.
         * @param args - The arguments with which `fn` should be called.
         * @param [thisArg] - The value of `this` provided for the call to `fn`.
         */ function callback(fn, args, thisArg) {
          if (fn && typeof fn.call === 'function') {
            return fn.apply(thisArg, args);
          }
        }
        function each(loopable, fn, thisArg, reverse) {
          let i, len, keys;
          if (isArray(loopable)) {
            len = loopable.length;
            if (reverse) {
              for (i = len - 1; i >= 0; i--) {
                fn.call(thisArg, loopable[i], i);
              }
            } else {
              for (i = 0; i < len; i++) {
                fn.call(thisArg, loopable[i], i);
              }
            }
          } else if (isObject(loopable)) {
            keys = Object.keys(loopable);
            len = keys.length;
            for (i = 0; i < len; i++) {
              fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
          }
        }
        /**
         * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
         * @param a0 - The array to compare
         * @param a1 - The array to compare
         * @private
         */ function _elementsEqual(a0, a1) {
          let i, ilen, v0, v1;
          if (!a0 || !a1 || a0.length !== a1.length) {
            return false;
          }
          for (i = 0, ilen = a0.length; i < ilen; ++i) {
            v0 = a0[i];
            v1 = a1[i];
            if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {
              return false;
            }
          }
          return true;
        }
        /**
         * Returns a deep copy of `source` without keeping references on objects and arrays.
         * @param source - The value to clone.
         */ function clone(source) {
          if (isArray(source)) {
            return source.map(clone);
          }
          if (isObject(source)) {
            const target = Object.create(null);
            const keys = Object.keys(source);
            const klen = keys.length;
            let k = 0;
            for (; k < klen; ++k) {
              target[keys[k]] = clone(source[keys[k]]);
            }
            return target;
          }
          return source;
        }
        function isValidKey(key) {
          return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;
        }
        /**
         * The default merger when Chart.helpers.merge is called without merger option.
         * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
         * @private
         */ function _merger(key, target, source, options) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject(tval) && isObject(sval)) {
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            merge(tval, sval, options);
          } else {
            target[key] = clone(sval);
          }
        }
        function merge(target, source, options) {
          const sources = isArray(source) ? source : [source];
          const ilen = sources.length;
          if (!isObject(target)) {
            return target;
          }
          options = options || {};
          const merger = options.merger || _merger;
          let current;
          for (let i = 0; i < ilen; ++i) {
            current = sources[i];
            if (!isObject(current)) {
              continue;
            }
            const keys = Object.keys(current);
            for (let k = 0, klen = keys.length; k < klen; ++k) {
              merger(keys[k], target, current, options);
            }
          }
          return target;
        }
        function mergeIf(target, source) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          return merge(target, source, {
            merger: _mergerIf,
          });
        }
        /**
         * Merges source[key] in target[key] only if target[key] is undefined.
         * @private
         */ function _mergerIf(key, target, source) {
          if (!isValidKey(key)) {
            return;
          }
          const tval = target[key];
          const sval = source[key];
          if (isObject(tval) && isObject(sval)) {
            mergeIf(tval, sval);
          } else if (!Object.prototype.hasOwnProperty.call(target, key)) {
            target[key] = clone(sval);
          }
        }
        /**
         * @private
         */ function _deprecated(scope, value, previous, current) {
          if (value !== undefined) {
            console.warn(
              scope +
                ': "' +
                previous +
                '" is deprecated. Please use "' +
                current +
                '" instead'
            );
          }
        }
        // resolveObjectKey resolver cache
        const keyResolvers = {
          // Chart.helpers.core resolveObjectKey should resolve empty key to root object
          '': (v) => v,
          // default resolvers
          x: (o) => o.x,
          y: (o) => o.y,
        };
        /**
         * @private
         */ function _splitKey(key) {
          const parts = key.split('.');
          const keys = [];
          let tmp = '';
          for (const part of parts) {
            tmp += part;
            if (tmp.endsWith('\\')) {
              tmp = tmp.slice(0, -1) + '.';
            } else {
              keys.push(tmp);
              tmp = '';
            }
          }
          return keys;
        }
        function _getKeyResolver(key) {
          const keys = _splitKey(key);
          return (obj) => {
            for (const k of keys) {
              if (k === '') {
                break;
              }
              obj = obj && obj[k];
            }
            return obj;
          };
        }
        function resolveObjectKey(obj, key) {
          const resolver =
            keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
          return resolver(obj);
        }
        /**
         * @private
         */ function _capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = (value) => typeof value !== 'undefined';
        const isFunction = (value) => typeof value === 'function';
        // Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384
        const setsEqual = (a, b) => {
          if (a.size !== b.size) {
            return false;
          }
          for (const item of a) {
            if (!b.has(item)) {
              return false;
            }
          }
          return true;
        };
        /**
         * @param e - The event
         * @private
         */ function _isClickEvent(e) {
          return (
            e.type === 'mouseup' ||
            e.type === 'click' ||
            e.type === 'contextmenu'
          );
        }

        /**
         * @alias Chart.helpers.math
         * @namespace
         */ const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = (PI * 2) / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function almostEquals(x, y, epsilon) {
          return Math.abs(x - y) < epsilon;
        }
        /**
         * Implementation of the nice number algorithm used in determining where axis labels will go
         */ function niceNum(range) {
          const roundedRange = Math.round(range);
          range = almostEquals(range, roundedRange, range / 1000)
            ? roundedRange
            : range;
          const niceRange = Math.pow(10, Math.floor(log10(range)));
          const fraction = range / niceRange;
          const niceFraction =
            fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
          return niceFraction * niceRange;
        }
        /**
         * Returns an array of factors sorted from 1 to sqrt(value)
         * @private
         */ function _factorize(value) {
          const result = [];
          const sqrt = Math.sqrt(value);
          let i;
          for (i = 1; i < sqrt; i++) {
            if (value % i === 0) {
              result.push(i);
              result.push(value / i);
            }
          }
          if (sqrt === (sqrt | 0)) {
            result.push(sqrt);
          }
          result.sort((a, b) => a - b).pop();
          return result;
        }
        /**
         * Verifies that attempting to coerce n to string or number won't throw a TypeError.
         */ function isNonPrimitive(n) {
          return (
            typeof n === 'symbol' ||
            (typeof n === 'object' &&
              n !== null &&
              !(Symbol.toPrimitive in n || 'toString' in n || 'valueOf' in n))
          );
        }
        function isNumber(n) {
          return !isNonPrimitive(n) && !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostWhole(x, epsilon) {
          const rounded = Math.round(x);
          return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        /**
         * @private
         */ function _setMinAndMaxByKey(array, target, property) {
          let i, ilen, value;
          for (i = 0, ilen = array.length; i < ilen; i++) {
            value = array[i][property];
            if (!isNaN(value)) {
              target.min = Math.min(target.min, value);
              target.max = Math.max(target.max, value);
            }
          }
        }
        function toRadians(degrees) {
          return degrees * (PI / 180);
        }
        function toDegrees(radians) {
          return radians * (180 / PI);
        }
        /**
         * Returns the number of decimal places
         * i.e. the number of digits after the decimal point, of the value of this Number.
         * @param x - A number.
         * @returns The number of decimal places.
         * @private
         */ function _decimalPlaces(x) {
          if (!isNumberFinite(x)) {
            return;
          }
          let e = 1;
          let p = 0;
          while (Math.round(x * e) / e !== x) {
            e *= 10;
            p++;
          }
          return p;
        }
        // Gets the angle from vertical upright to the point about a centre.
        function getAngleFromPoint(centrePoint, anglePoint) {
          const distanceFromXCenter = anglePoint.x - centrePoint.x;
          const distanceFromYCenter = anglePoint.y - centrePoint.y;
          const radialDistanceFromCenter = Math.sqrt(
            distanceFromXCenter * distanceFromXCenter +
              distanceFromYCenter * distanceFromYCenter
          );
          let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
          if (angle < -0.5 * PI) {
            angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
          }
          return {
            angle,
            distance: radialDistanceFromCenter,
          };
        }
        function distanceBetweenPoints(pt1, pt2) {
          return Math.sqrt(
            Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2)
          );
        }
        /**
         * Shortest distance between angles, in either direction.
         * @private
         */ function _angleDiff(a, b) {
          return ((a - b + PITAU) % TAU) - PI;
        }
        /**
         * Normalize angle to be between 0 and 2*PI
         * @private
         */ function _normalizeAngle(a) {
          return ((a % TAU) + TAU) % TAU;
        }
        /**
         * @private
         */ function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
          const a = _normalizeAngle(angle);
          const s = _normalizeAngle(start);
          const e = _normalizeAngle(end);
          const angleToStart = _normalizeAngle(s - a);
          const angleToEnd = _normalizeAngle(e - a);
          const startToAngle = _normalizeAngle(a - s);
          const endToAngle = _normalizeAngle(a - e);
          return (
            a === s ||
            a === e ||
            (sameAngleIsFullCircle && s === e) ||
            (angleToStart > angleToEnd && startToAngle < endToAngle)
          );
        }
        /**
         * Limit `value` between `min` and `max`
         * @param value
         * @param min
         * @param max
         * @private
         */ function _limitValue(value, min, max) {
          return Math.max(min, Math.min(max, value));
        }
        /**
         * @param {number} value
         * @private
         */ function _int16Range(value) {
          return _limitValue(value, -32768, 32767);
        }
        /**
         * @param value
         * @param start
         * @param end
         * @param [epsilon]
         * @private
         */ function _isBetween(value, start, end, epsilon = 1e-6) {
          return (
            value >= Math.min(start, end) - epsilon &&
            value <= Math.max(start, end) + epsilon
          );
        }

        function _lookup(table, value, cmp) {
          cmp = cmp || ((index) => table[index] < value);
          let hi = table.length - 1;
          let lo = 0;
          let mid;
          while (hi - lo > 1) {
            mid = (lo + hi) >> 1;
            if (cmp(mid)) {
              lo = mid;
            } else {
              hi = mid;
            }
          }
          return {
            lo,
            hi,
          };
        }
        /**
         * Binary search
         * @param table - the table search. must be sorted!
         * @param key - property name for the value in each entry
         * @param value - value to find
         * @param last - lookup last index
         * @private
         */ const _lookupByKey = (table, key, value, last) =>
          _lookup(
            table,
            value,
            last
              ? (index) => {
                  const ti = table[index][key];
                  return (
                    ti < value ||
                    (ti === value && table[index + 1][key] === value)
                  );
                }
              : (index) => table[index][key] < value
          );
        /**
         * Reverse binary search
         * @param table - the table search. must be sorted!
         * @param key - property name for the value in each entry
         * @param value - value to find
         * @private
         */ const _rlookupByKey = (table, key, value) =>
          _lookup(table, value, (index) => table[index][key] >= value);
        /**
         * Return subset of `values` between `min` and `max` inclusive.
         * Values are assumed to be in sorted order.
         * @param values - sorted array of values
         * @param min - min value
         * @param max - max value
         */ function _filterBetween(values, min, max) {
          let start = 0;
          let end = values.length;
          while (start < end && values[start] < min) {
            start++;
          }
          while (end > start && values[end - 1] > max) {
            end--;
          }
          return start > 0 || end < values.length
            ? values.slice(start, end)
            : values;
        }
        const arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];
        function listenArrayEvents(array, listener) {
          if (array._chartjs) {
            array._chartjs.listeners.push(listener);
            return;
          }
          Object.defineProperty(array, '_chartjs', {
            configurable: true,
            enumerable: false,
            value: {
              listeners: [listener],
            },
          });
          arrayEvents.forEach((key) => {
            const method = '_onData' + _capitalize(key);
            const base = array[key];
            Object.defineProperty(array, key, {
              configurable: true,
              enumerable: false,
              value(...args) {
                const res = base.apply(this, args);
                array._chartjs.listeners.forEach((object) => {
                  if (typeof object[method] === 'function') {
                    object[method](...args);
                  }
                });
                return res;
              },
            });
          });
        }
        function unlistenArrayEvents(array, listener) {
          const stub = array._chartjs;
          if (!stub) {
            return;
          }
          const listeners = stub.listeners;
          const index = listeners.indexOf(listener);
          if (index !== -1) {
            listeners.splice(index, 1);
          }
          if (listeners.length > 0) {
            return;
          }
          arrayEvents.forEach((key) => {
            delete array[key];
          });
          delete array._chartjs;
        }
        /**
         * @param items
         */ function _arrayUnique(items) {
          const set = new Set(items);
          if (set.size === items.length) {
            return items;
          }
          return Array.from(set);
        }

        function fontString(pixelSize, fontStyle, fontFamily) {
          return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
        }
        /**
         * Request animation polyfill
         */ const requestAnimFrame = (function () {
          if (typeof window === 'undefined') {
            return function (callback) {
              return callback();
            };
          }
          return window.requestAnimationFrame;
        })();
        /**
         * Throttles calling `fn` once per animation frame
         * Latest arguments are used on the actual call
         */ function throttled(fn, thisArg) {
          let argsToUse = [];
          let ticking = false;
          return function (...args) {
            // Save the args for use later
            argsToUse = args;
            if (!ticking) {
              ticking = true;
              requestAnimFrame.call(window, () => {
                ticking = false;
                fn.apply(thisArg, argsToUse);
              });
            }
          };
        }
        /**
         * Debounces calling `fn` for `delay` ms
         */ function debounce(fn, delay) {
          let timeout;
          return function (...args) {
            if (delay) {
              clearTimeout(timeout);
              timeout = setTimeout(fn, delay, args);
            } else {
              fn.apply(this, args);
            }
            return delay;
          };
        }
        /**
         * Converts 'start' to 'left', 'end' to 'right' and others to 'center'
         * @private
         */ const _toLeftRightCenter = (align) =>
          align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';
        /**
         * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`
         * @private
         */ const _alignStartEnd = (align, start, end) =>
          align === 'start' ? start : align === 'end' ? end : (start + end) / 2;
        /**
         * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`
         * @private
         */ const _textX = (align, left, right, rtl) => {
          const check = rtl ? 'left' : 'right';
          return align === check
            ? right
            : align === 'center'
            ? (left + right) / 2
            : left;
        };
        /**
         * Return start and count of visible points.
         * @private
         */ function _getStartAndCountOfVisiblePoints(
          meta,
          points,
          animationsDisabled
        ) {
          const pointCount = points.length;
          let start = 0;
          let count = pointCount;
          if (meta._sorted) {
            const { iScale, vScale, _parsed } = meta;
            const spanGaps = meta.dataset
              ? meta.dataset.options
                ? meta.dataset.options.spanGaps
                : null
              : null;
            const axis = iScale.axis;
            const { min, max, minDefined, maxDefined } = iScale.getUserBounds();
            if (minDefined) {
              start = Math.min(
                // @ts-expect-error Need to type _parsed
                _lookupByKey(_parsed, axis, min).lo, // @ts-expect-error Need to fix types on _lookupByKey
                animationsDisabled
                  ? pointCount
                  : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo
              );
              if (spanGaps) {
                const distanceToDefinedLo = _parsed
                  .slice(0, start + 1)
                  .reverse()
                  .findIndex((point) => !isNullOrUndef(point[vScale.axis]));
                start -= Math.max(0, distanceToDefinedLo);
              }
              start = _limitValue(start, 0, pointCount - 1);
            }
            if (maxDefined) {
              let end = Math.max(
                // @ts-expect-error Need to type _parsed
                _lookupByKey(_parsed, iScale.axis, max, true).hi + 1, // @ts-expect-error Need to fix types on _lookupByKey
                animationsDisabled
                  ? 0
                  : _lookupByKey(
                      points,
                      axis,
                      iScale.getPixelForValue(max),
                      true
                    ).hi + 1
              );
              if (spanGaps) {
                const distanceToDefinedHi = _parsed
                  .slice(end - 1)
                  .findIndex((point) => !isNullOrUndef(point[vScale.axis]));
                end += Math.max(0, distanceToDefinedHi);
              }
              count = _limitValue(end, start, pointCount) - start;
            } else {
              count = pointCount - start;
            }
          }
          return {
            start,
            count,
          };
        }
        /**
         * Checks if the scale ranges have changed.
         * @param {object} meta - dataset meta.
         * @returns {boolean}
         * @private
         */ function _scaleRangesChanged(meta) {
          const { xScale, yScale, _scaleRanges } = meta;
          const newRanges = {
            xmin: xScale.min,
            xmax: xScale.max,
            ymin: yScale.min,
            ymax: yScale.max,
          };
          if (!_scaleRanges) {
            meta._scaleRanges = newRanges;
            return true;
          }
          const changed =
            _scaleRanges.xmin !== xScale.min ||
            _scaleRanges.xmax !== xScale.max ||
            _scaleRanges.ymin !== yScale.min ||
            _scaleRanges.ymax !== yScale.max;
          Object.assign(_scaleRanges, newRanges);
          return changed;
        }

        const atEdge = (t) => t === 0 || t === 1;
        const elasticIn = (t, s, p) =>
          -(Math.pow(2, 10 * (t -= 1)) * Math.sin(((t - s) * TAU) / p));
        const elasticOut = (t, s, p) =>
          Math.pow(2, -10 * t) * Math.sin(((t - s) * TAU) / p) + 1;
        /**
         * Easing functions adapted from Robert Penner's easing equations.
         * @namespace Chart.helpers.easing.effects
         * @see http://www.robertpenner.com/easing/
         */ const effects = {
          linear: (t) => t,
          easeInQuad: (t) => t * t,
          easeOutQuad: (t) => -t * (t - 2),
          easeInOutQuad: (t) =>
            (t /= 0.5) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1),
          easeInCubic: (t) => t * t * t,
          easeOutCubic: (t) => (t -= 1) * t * t + 1,
          easeInOutCubic: (t) =>
            (t /= 0.5) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2),
          easeInQuart: (t) => t * t * t * t,
          easeOutQuart: (t) => -((t -= 1) * t * t * t - 1),
          easeInOutQuart: (t) =>
            (t /= 0.5) < 1
              ? 0.5 * t * t * t * t
              : -0.5 * ((t -= 2) * t * t * t - 2),
          easeInQuint: (t) => t * t * t * t * t,
          easeOutQuint: (t) => (t -= 1) * t * t * t * t + 1,
          easeInOutQuint: (t) =>
            (t /= 0.5) < 1
              ? 0.5 * t * t * t * t * t
              : 0.5 * ((t -= 2) * t * t * t * t + 2),
          easeInSine: (t) => -Math.cos(t * HALF_PI) + 1,
          easeOutSine: (t) => Math.sin(t * HALF_PI),
          easeInOutSine: (t) => -0.5 * (Math.cos(PI * t) - 1),
          easeInExpo: (t) => (t === 0 ? 0 : Math.pow(2, 10 * (t - 1))),
          easeOutExpo: (t) => (t === 1 ? 1 : -Math.pow(2, -10 * t) + 1),
          easeInOutExpo: (t) =>
            atEdge(t)
              ? t
              : t < 0.5
              ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))
              : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
          easeInCirc: (t) => (t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1)),
          easeOutCirc: (t) => Math.sqrt(1 - (t -= 1) * t),
          easeInOutCirc: (t) =>
            (t /= 0.5) < 1
              ? -0.5 * (Math.sqrt(1 - t * t) - 1)
              : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
          easeInElastic: (t) => (atEdge(t) ? t : elasticIn(t, 0.075, 0.3)),
          easeOutElastic: (t) => (atEdge(t) ? t : elasticOut(t, 0.075, 0.3)),
          easeInOutElastic(t) {
            const s = 0.1125;
            const p = 0.45;
            return atEdge(t)
              ? t
              : t < 0.5
              ? 0.5 * elasticIn(t * 2, s, p)
              : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);
          },
          easeInBack(t) {
            const s = 1.70158;
            return t * t * ((s + 1) * t - s);
          },
          easeOutBack(t) {
            const s = 1.70158;
            return (t -= 1) * t * ((s + 1) * t + s) + 1;
          },
          easeInOutBack(t) {
            let s = 1.70158;
            if ((t /= 0.5) < 1) {
              return 0.5 * (t * t * (((s *= 1.525) + 1) * t - s));
            }
            return 0.5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
          },
          easeInBounce: (t) => 1 - effects.easeOutBounce(1 - t),
          easeOutBounce(t) {
            const m = 7.5625;
            const d = 2.75;
            if (t < 1 / d) {
              return m * t * t;
            }
            if (t < 2 / d) {
              return m * (t -= 1.5 / d) * t + 0.75;
            }
            if (t < 2.5 / d) {
              return m * (t -= 2.25 / d) * t + 0.9375;
            }
            return m * (t -= 2.625 / d) * t + 0.984375;
          },
          easeInOutBounce: (t) =>
            t < 0.5
              ? effects.easeInBounce(t * 2) * 0.5
              : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,
        };

        function isPatternOrGradient(value) {
          if (value && typeof value === 'object') {
            const type = value.toString();
            return (
              type === '[object CanvasPattern]' ||
              type === '[object CanvasGradient]'
            );
          }
          return false;
        }
        function color(value) {
          return isPatternOrGradient(value)
            ? value
            : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value);
        }
        function getHoverColor(value) {
          return isPatternOrGradient(value)
            ? value
            : new _kurkle_color__WEBPACK_IMPORTED_MODULE_0__.Color(value)
                .saturate(0.5)
                .darken(0.1)
                .hexString();
        }

        const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];
        const colors = ['color', 'borderColor', 'backgroundColor'];
        function applyAnimationsDefaults(defaults) {
          defaults.set('animation', {
            delay: undefined,
            duration: 1000,
            easing: 'easeOutQuart',
            fn: undefined,
            from: undefined,
            loop: undefined,
            to: undefined,
            type: undefined,
          });
          defaults.describe('animation', {
            _fallback: false,
            _indexable: false,
            _scriptable: (name) =>
              name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',
          });
          defaults.set('animations', {
            colors: {
              type: 'color',
              properties: colors,
            },
            numbers: {
              type: 'number',
              properties: numbers,
            },
          });
          defaults.describe('animations', {
            _fallback: 'animation',
          });
          defaults.set('transitions', {
            active: {
              animation: {
                duration: 400,
              },
            },
            resize: {
              animation: {
                duration: 0,
              },
            },
            show: {
              animations: {
                colors: {
                  from: 'transparent',
                },
                visible: {
                  type: 'boolean',
                  duration: 0,
                },
              },
            },
            hide: {
              animations: {
                colors: {
                  to: 'transparent',
                },
                visible: {
                  type: 'boolean',
                  easing: 'linear',
                  fn: (v) => v | 0,
                },
              },
            },
          });
        }

        function applyLayoutsDefaults(defaults) {
          defaults.set('layout', {
            autoPadding: true,
            padding: {
              top: 0,
              right: 0,
              bottom: 0,
              left: 0,
            },
          });
        }

        const intlCache = new Map();
        function getNumberFormat(locale, options) {
          options = options || {};
          const cacheKey = locale + JSON.stringify(options);
          let formatter = intlCache.get(cacheKey);
          if (!formatter) {
            formatter = new Intl.NumberFormat(locale, options);
            intlCache.set(cacheKey, formatter);
          }
          return formatter;
        }
        function formatNumber(num, locale, options) {
          return getNumberFormat(locale, options).format(num);
        }

        const formatters = {
          values(value) {
            return isArray(value) ? value : '' + value;
          },
          numeric(tickValue, index, ticks) {
            if (tickValue === 0) {
              return '0';
            }
            const locale = this.chart.options.locale;
            let notation;
            let delta = tickValue;
            if (ticks.length > 1) {
              const maxTick = Math.max(
                Math.abs(ticks[0].value),
                Math.abs(ticks[ticks.length - 1].value)
              );
              if (maxTick < 1e-4 || maxTick > 1e15) {
                notation = 'scientific';
              }
              delta = calculateDelta(tickValue, ticks);
            }
            const logDelta = log10(Math.abs(delta));
            const numDecimal = isNaN(logDelta)
              ? 1
              : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
            const options = {
              notation,
              minimumFractionDigits: numDecimal,
              maximumFractionDigits: numDecimal,
            };
            Object.assign(options, this.options.ticks.format);
            return formatNumber(tickValue, locale, options);
          },
          logarithmic(tickValue, index, ticks) {
            if (tickValue === 0) {
              return '0';
            }
            const remain =
              ticks[index].significand ||
              tickValue / Math.pow(10, Math.floor(log10(tickValue)));
            if (
              [1, 2, 3, 5, 10, 15].includes(remain) ||
              index > 0.8 * ticks.length
            ) {
              return formatters.numeric.call(this, tickValue, index, ticks);
            }
            return '';
          },
        };
        function calculateDelta(tickValue, ticks) {
          let delta =
            ticks.length > 3
              ? ticks[2].value - ticks[1].value
              : ticks[1].value - ticks[0].value;
          if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {
            delta = tickValue - Math.floor(tickValue);
          }
          return delta;
        }
        var Ticks = {
          formatters,
        };

        function applyScaleDefaults(defaults) {
          defaults.set('scale', {
            display: true,
            offset: false,
            reverse: false,
            beginAtZero: false,
            bounds: 'ticks',
            clip: true,
            grace: 0,
            grid: {
              display: true,
              lineWidth: 1,
              drawOnChartArea: true,
              drawTicks: true,
              tickLength: 8,
              tickWidth: (_ctx, options) => options.lineWidth,
              tickColor: (_ctx, options) => options.color,
              offset: false,
            },
            border: {
              display: true,
              dash: [],
              dashOffset: 0.0,
              width: 1,
            },
            title: {
              display: false,
              text: '',
              padding: {
                top: 4,
                bottom: 4,
              },
            },
            ticks: {
              minRotation: 0,
              maxRotation: 50,
              mirror: false,
              textStrokeWidth: 0,
              textStrokeColor: '',
              padding: 3,
              display: true,
              autoSkip: true,
              autoSkipPadding: 3,
              labelOffset: 0,
              callback: Ticks.formatters.values,
              minor: {},
              major: {},
              align: 'center',
              crossAlign: 'near',
              showLabelBackdrop: false,
              backdropColor: 'rgba(255, 255, 255, 0.75)',
              backdropPadding: 2,
            },
          });
          defaults.route('scale.ticks', 'color', '', 'color');
          defaults.route('scale.grid', 'color', '', 'borderColor');
          defaults.route('scale.border', 'color', '', 'borderColor');
          defaults.route('scale.title', 'color', '', 'color');
          defaults.describe('scale', {
            _fallback: false,
            _scriptable: (name) =>
              !name.startsWith('before') &&
              !name.startsWith('after') &&
              name !== 'callback' &&
              name !== 'parser',
            _indexable: (name) =>
              name !== 'borderDash' &&
              name !== 'tickBorderDash' &&
              name !== 'dash',
          });
          defaults.describe('scales', {
            _fallback: 'scale',
          });
          defaults.describe('scale.ticks', {
            _scriptable: (name) =>
              name !== 'backdropPadding' && name !== 'callback',
            _indexable: (name) => name !== 'backdropPadding',
          });
        }

        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
          if (!key) {
            return node;
          }
          const keys = key.split('.');
          for (let i = 0, n = keys.length; i < n; ++i) {
            const k = keys[i];
            node = node[k] || (node[k] = Object.create(null));
          }
          return node;
        }
        function set(root, scope, values) {
          if (typeof scope === 'string') {
            return merge(getScope$1(root, scope), values);
          }
          return merge(getScope$1(root, ''), scope);
        }
        class Defaults {
          constructor(_descriptors, _appliers) {
            this.animation = undefined;
            this.backgroundColor = 'rgba(0,0,0,0.1)';
            this.borderColor = 'rgba(0,0,0,0.1)';
            this.color = '#666';
            this.datasets = {};
            this.devicePixelRatio = (context) =>
              context.chart.platform.getDevicePixelRatio();
            this.elements = {};
            this.events = [
              'mousemove',
              'mouseout',
              'click',
              'touchstart',
              'touchmove',
            ];
            this.font = {
              family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
              size: 12,
              style: 'normal',
              lineHeight: 1.2,
              weight: null,
            };
            this.hover = {};
            this.hoverBackgroundColor = (ctx, options) =>
              getHoverColor(options.backgroundColor);
            this.hoverBorderColor = (ctx, options) =>
              getHoverColor(options.borderColor);
            this.hoverColor = (ctx, options) => getHoverColor(options.color);
            this.indexAxis = 'x';
            this.interaction = {
              mode: 'nearest',
              intersect: true,
              includeInvisible: false,
            };
            this.maintainAspectRatio = true;
            this.onHover = null;
            this.onClick = null;
            this.parsing = true;
            this.plugins = {};
            this.responsive = true;
            this.scale = undefined;
            this.scales = {};
            this.showLine = true;
            this.drawActiveElementsOnTop = true;
            this.describe(_descriptors);
            this.apply(_appliers);
          }
          set(scope, values) {
            return set(this, scope, values);
          }
          get(scope) {
            return getScope$1(this, scope);
          }
          describe(scope, values) {
            return set(descriptors, scope, values);
          }
          override(scope, values) {
            return set(overrides, scope, values);
          }
          route(scope, name, targetScope, targetName) {
            const scopeObject = getScope$1(this, scope);
            const targetScopeObject = getScope$1(this, targetScope);
            const privateName = '_' + name;
            Object.defineProperties(scopeObject, {
              [privateName]: {
                value: scopeObject[name],
                writable: true,
              },
              [name]: {
                enumerable: true,
                get() {
                  const local = this[privateName];
                  const target = targetScopeObject[targetName];
                  if (isObject(local)) {
                    return Object.assign({}, target, local);
                  }
                  return valueOrDefault(local, target);
                },
                set(value) {
                  this[privateName] = value;
                },
              },
            });
          }
          apply(appliers) {
            appliers.forEach((apply) => apply(this));
          }
        }
        var defaults = /* #__PURE__ */ new Defaults(
          {
            _scriptable: (name) => !name.startsWith('on'),
            _indexable: (name) => name !== 'events',
            hover: {
              _fallback: 'interaction',
            },
            interaction: {
              _scriptable: false,
              _indexable: false,
            },
          },
          [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]
        );

        /**
         * Converts the given font object into a CSS font string.
         * @param font - A font object.
         * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
         * @private
         */ function toFontString(font) {
          if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {
            return null;
          }
          return (
            (font.style ? font.style + ' ' : '') +
            (font.weight ? font.weight + ' ' : '') +
            font.size +
            'px ' +
            font.family
          );
        }
        /**
         * @private
         */ function _measureText(ctx, data, gc, longest, string) {
          let textWidth = data[string];
          if (!textWidth) {
            textWidth = data[string] = ctx.measureText(string).width;
            gc.push(string);
          }
          if (textWidth > longest) {
            longest = textWidth;
          }
          return longest;
        }
        /**
         * @private
         */ // eslint-disable-next-line complexity
        function _longestText(ctx, font, arrayOfThings, cache) {
          cache = cache || {};
          let data = (cache.data = cache.data || {});
          let gc = (cache.garbageCollect = cache.garbageCollect || []);
          if (cache.font !== font) {
            data = cache.data = {};
            gc = cache.garbageCollect = [];
            cache.font = font;
          }
          ctx.save();
          ctx.font = font;
          let longest = 0;
          const ilen = arrayOfThings.length;
          let i, j, jlen, thing, nestedThing;
          for (i = 0; i < ilen; i++) {
            thing = arrayOfThings[i];
            // Undefined strings and arrays should not be measured
            if (thing !== undefined && thing !== null && !isArray(thing)) {
              longest = _measureText(ctx, data, gc, longest, thing);
            } else if (isArray(thing)) {
              // if it is an array lets measure each element
              // to do maybe simplify this function a bit so we can do this more recursively?
              for (j = 0, jlen = thing.length; j < jlen; j++) {
                nestedThing = thing[j];
                // Undefined strings and arrays should not be measured
                if (
                  nestedThing !== undefined &&
                  nestedThing !== null &&
                  !isArray(nestedThing)
                ) {
                  longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
              }
            }
          }
          ctx.restore();
          const gcLen = gc.length / 2;
          if (gcLen > arrayOfThings.length) {
            for (i = 0; i < gcLen; i++) {
              delete data[gc[i]];
            }
            gc.splice(0, gcLen);
          }
          return longest;
        }
        /**
         * Returns the aligned pixel value to avoid anti-aliasing blur
         * @param chart - The chart instance.
         * @param pixel - A pixel value.
         * @param width - The width of the element.
         * @returns The aligned pixel value.
         * @private
         */ function _alignPixel(chart, pixel, width) {
          const devicePixelRatio = chart.currentDevicePixelRatio;
          const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;
          return (
            Math.round((pixel - halfWidth) * devicePixelRatio) /
              devicePixelRatio +
            halfWidth
          );
        }
        /**
         * Clears the entire canvas.
         */ function clearCanvas(canvas, ctx) {
          if (!ctx && !canvas) {
            return;
          }
          ctx = ctx || canvas.getContext('2d');
          ctx.save();
          // canvas.width and canvas.height do not consider the canvas transform,
          // while clearRect does
          ctx.resetTransform();
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          drawPointLegend(ctx, options, x, y, null);
        }
        // eslint-disable-next-line complexity
        function drawPointLegend(ctx, options, x, y, w) {
          let type,
            xOffset,
            yOffset,
            size,
            cornerRadius,
            width,
            xOffsetW,
            yOffsetW;
          const style = options.pointStyle;
          const rotation = options.rotation;
          const radius = options.radius;
          let rad = (rotation || 0) * RAD_PER_DEG;
          if (style && typeof style === 'object') {
            type = style.toString();
            if (
              type === '[object HTMLImageElement]' ||
              type === '[object HTMLCanvasElement]'
            ) {
              ctx.save();
              ctx.translate(x, y);
              ctx.rotate(rad);
              ctx.drawImage(
                style,
                -style.width / 2,
                -style.height / 2,
                style.width,
                style.height
              );
              ctx.restore();
              return;
            }
          }
          if (isNaN(radius) || radius <= 0) {
            return;
          }
          ctx.beginPath();
          switch (style) {
            // Default includes circle
            default:
              if (w) {
                ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);
              } else {
                ctx.arc(x, y, radius, 0, TAU);
              }
              ctx.closePath();
              break;
            case 'triangle':
              width = w ? w / 2 : radius;
              ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
              rad += TWO_THIRDS_PI;
              ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
              ctx.closePath();
              break;
            case 'rectRounded':
              // NOTE: the rounded rect implementation changed to use `arc` instead of
              // `quadraticCurveTo` since it generates better results when rect is
              // almost a circle. 0.516 (instead of 0.5) produces results with visually
              // closer proportion to the previous impl and it is inscribed in the
              // circle with `radius`. For more details, see the following PRs:
              // https://github.com/chartjs/Chart.js/issues/5597
              // https://github.com/chartjs/Chart.js/issues/5858
              cornerRadius = radius * 0.516;
              size = radius - cornerRadius;
              xOffset = Math.cos(rad + QUARTER_PI) * size;
              xOffsetW =
                Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
              yOffset = Math.sin(rad + QUARTER_PI) * size;
              yOffsetW =
                Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
              ctx.arc(
                x - xOffsetW,
                y - yOffset,
                cornerRadius,
                rad - PI,
                rad - HALF_PI
              );
              ctx.arc(
                x + yOffsetW,
                y - xOffset,
                cornerRadius,
                rad - HALF_PI,
                rad
              );
              ctx.arc(
                x + xOffsetW,
                y + yOffset,
                cornerRadius,
                rad,
                rad + HALF_PI
              );
              ctx.arc(
                x - yOffsetW,
                y + xOffset,
                cornerRadius,
                rad + HALF_PI,
                rad + PI
              );
              ctx.closePath();
              break;
            case 'rect':
              if (!rotation) {
                size = Math.SQRT1_2 * radius;
                width = w ? w / 2 : size;
                ctx.rect(x - width, y - size, 2 * width, 2 * size);
                break;
              }
              rad += QUARTER_PI;
            /* falls through */ case 'rectRot':
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              ctx.closePath();
              break;
            case 'crossRot':
              rad += QUARTER_PI;
            /* falls through */ case 'cross':
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.moveTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              break;
            case 'star':
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.moveTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              rad += QUARTER_PI;
              xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
              xOffset = Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
              ctx.moveTo(x - xOffsetW, y - yOffset);
              ctx.lineTo(x + xOffsetW, y + yOffset);
              ctx.moveTo(x + yOffsetW, y - xOffset);
              ctx.lineTo(x - yOffsetW, y + xOffset);
              break;
            case 'line':
              xOffset = w ? w / 2 : Math.cos(rad) * radius;
              yOffset = Math.sin(rad) * radius;
              ctx.moveTo(x - xOffset, y - yOffset);
              ctx.lineTo(x + xOffset, y + yOffset);
              break;
            case 'dash':
              ctx.moveTo(x, y);
              ctx.lineTo(
                x + Math.cos(rad) * (w ? w / 2 : radius),
                y + Math.sin(rad) * radius
              );
              break;
            case false:
              ctx.closePath();
              break;
          }
          ctx.fill();
          if (options.borderWidth > 0) {
            ctx.stroke();
          }
        }
        /**
         * Returns true if the point is inside the rectangle
         * @param point - The point to test
         * @param area - The rectangle
         * @param margin - allowed margin
         * @private
         */ function _isPointInArea(point, area, margin) {
          margin = margin || 0.5; // margin - default is to match rounded decimals
          return (
            !area ||
            (point &&
              point.x > area.left - margin &&
              point.x < area.right + margin &&
              point.y > area.top - margin &&
              point.y < area.bottom + margin)
          );
        }
        function clipArea(ctx, area) {
          ctx.save();
          ctx.beginPath();
          ctx.rect(
            area.left,
            area.top,
            area.right - area.left,
            area.bottom - area.top
          );
          ctx.clip();
        }
        function unclipArea(ctx) {
          ctx.restore();
        }
        /**
         * @private
         */ function _steppedLineTo(ctx, previous, target, flip, mode) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          if (mode === 'middle') {
            const midpoint = (previous.x + target.x) / 2.0;
            ctx.lineTo(midpoint, previous.y);
            ctx.lineTo(midpoint, target.y);
          } else if ((mode === 'after') !== !!flip) {
            ctx.lineTo(previous.x, target.y);
          } else {
            ctx.lineTo(target.x, previous.y);
          }
          ctx.lineTo(target.x, target.y);
        }
        /**
         * @private
         */ function _bezierCurveTo(ctx, previous, target, flip) {
          if (!previous) {
            return ctx.lineTo(target.x, target.y);
          }
          ctx.bezierCurveTo(
            flip ? previous.cp1x : previous.cp2x,
            flip ? previous.cp1y : previous.cp2y,
            flip ? target.cp2x : target.cp1x,
            flip ? target.cp2y : target.cp1y,
            target.x,
            target.y
          );
        }
        function setRenderOpts(ctx, opts) {
          if (opts.translation) {
            ctx.translate(opts.translation[0], opts.translation[1]);
          }
          if (!isNullOrUndef(opts.rotation)) {
            ctx.rotate(opts.rotation);
          }
          if (opts.color) {
            ctx.fillStyle = opts.color;
          }
          if (opts.textAlign) {
            ctx.textAlign = opts.textAlign;
          }
          if (opts.textBaseline) {
            ctx.textBaseline = opts.textBaseline;
          }
        }
        function decorateText(ctx, x, y, line, opts) {
          if (opts.strikethrough || opts.underline) {
            /**
             * Now that IE11 support has been dropped, we can use more
             * of the TextMetrics object. The actual bounding boxes
             * are unflagged in Chrome, Firefox, Edge, and Safari so they
             * can be safely used.
             * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility
             */ const metrics = ctx.measureText(line);
            const left = x - metrics.actualBoundingBoxLeft;
            const right = x + metrics.actualBoundingBoxRight;
            const top = y - metrics.actualBoundingBoxAscent;
            const bottom = y + metrics.actualBoundingBoxDescent;
            const yDecoration = opts.strikethrough
              ? (top + bottom) / 2
              : bottom;
            ctx.strokeStyle = ctx.fillStyle;
            ctx.beginPath();
            ctx.lineWidth = opts.decorationWidth || 2;
            ctx.moveTo(left, yDecoration);
            ctx.lineTo(right, yDecoration);
            ctx.stroke();
          }
        }
        function drawBackdrop(ctx, opts) {
          const oldColor = ctx.fillStyle;
          ctx.fillStyle = opts.color;
          ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
          ctx.fillStyle = oldColor;
        }
        /**
         * Render text onto the canvas
         */ function renderText(ctx, text, x, y, font, opts = {}) {
          const lines = isArray(text) ? text : [text];
          const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';
          let i, line;
          ctx.save();
          ctx.font = font.string;
          setRenderOpts(ctx, opts);
          for (i = 0; i < lines.length; ++i) {
            line = lines[i];
            if (opts.backdrop) {
              drawBackdrop(ctx, opts.backdrop);
            }
            if (stroke) {
              if (opts.strokeColor) {
                ctx.strokeStyle = opts.strokeColor;
              }
              if (!isNullOrUndef(opts.strokeWidth)) {
                ctx.lineWidth = opts.strokeWidth;
              }
              ctx.strokeText(line, x, y, opts.maxWidth);
            }
            ctx.fillText(line, x, y, opts.maxWidth);
            decorateText(ctx, x, y, line, opts);
            y += Number(font.lineHeight);
          }
          ctx.restore();
        }
        /**
         * Add a path of a rectangle with rounded corners to the current sub-path
         * @param ctx - Context
         * @param rect - Bounding rect
         */ function addRoundedRectPath(ctx, rect) {
          const { x, y, w, h, radius } = rect;
          // top left arc
          ctx.arc(
            x + radius.topLeft,
            y + radius.topLeft,
            radius.topLeft,
            1.5 * PI,
            PI,
            true
          );
          // line from top left to bottom left
          ctx.lineTo(x, y + h - radius.bottomLeft);
          // bottom left arc
          ctx.arc(
            x + radius.bottomLeft,
            y + h - radius.bottomLeft,
            radius.bottomLeft,
            PI,
            HALF_PI,
            true
          );
          // line from bottom left to bottom right
          ctx.lineTo(x + w - radius.bottomRight, y + h);
          // bottom right arc
          ctx.arc(
            x + w - radius.bottomRight,
            y + h - radius.bottomRight,
            radius.bottomRight,
            HALF_PI,
            0,
            true
          );
          // line from bottom right to top right
          ctx.lineTo(x + w, y + radius.topRight);
          // top right arc
          ctx.arc(
            x + w - radius.topRight,
            y + radius.topRight,
            radius.topRight,
            0,
            -HALF_PI,
            true
          );
          // line from top right to top left
          ctx.lineTo(x + radius.topLeft, y);
        }

        const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
        const FONT_STYLE =
          /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
        /**
         * @alias Chart.helpers.options
         * @namespace
         */ /**
         * Converts the given line height `value` in pixels for a specific font `size`.
         * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
         * @param size - The font size (in pixels) used to resolve relative `value`.
         * @returns The effective line height in pixels (size * 1.2 if value is invalid).
         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
         * @since 2.7.0
         */ function toLineHeight(value, size) {
          const matches = ('' + value).match(LINE_HEIGHT);
          if (!matches || matches[1] === 'normal') {
            return size * 1.2;
          }
          value = +matches[2];
          switch (matches[3]) {
            case 'px':
              return value;
            case '%':
              value /= 100;
              break;
          }
          return size * value;
        }
        const numberOrZero = (v) => +v || 0;
        function _readValueToProps(value, props) {
          const ret = {};
          const objProps = isObject(props);
          const keys = objProps ? Object.keys(props) : props;
          const read = isObject(value)
            ? objProps
              ? (prop) => valueOrDefault(value[prop], value[props[prop]])
              : (prop) => value[prop]
            : () => value;
          for (const prop of keys) {
            ret[prop] = numberOrZero(read(prop));
          }
          return ret;
        }
        /**
         * Converts the given value into a TRBL object.
         * @param value - If a number, set the value to all TRBL component,
         *  else, if an object, use defined properties and sets undefined ones to 0.
         *  x / y are shorthands for same value for left/right and top/bottom.
         * @returns The padding values (top, right, bottom, left)
         * @since 3.0.0
         */ function toTRBL(value) {
          return _readValueToProps(value, {
            top: 'y',
            right: 'x',
            bottom: 'y',
            left: 'x',
          });
        }
        /**
         * Converts the given value into a TRBL corners object (similar with css border-radius).
         * @param value - If a number, set the value to all TRBL corner components,
         *  else, if an object, use defined properties and sets undefined ones to 0.
         * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)
         * @since 3.0.0
         */ function toTRBLCorners(value) {
          return _readValueToProps(value, [
            'topLeft',
            'topRight',
            'bottomLeft',
            'bottomRight',
          ]);
        }
        /**
         * Converts the given value into a padding object with pre-computed width/height.
         * @param value - If a number, set the value to all TRBL component,
         *  else, if an object, use defined properties and sets undefined ones to 0.
         *  x / y are shorthands for same value for left/right and top/bottom.
         * @returns The padding values (top, right, bottom, left, width, height)
         * @since 2.7.0
         */ function toPadding(value) {
          const obj = toTRBL(value);
          obj.width = obj.left + obj.right;
          obj.height = obj.top + obj.bottom;
          return obj;
        }
        /**
         * Parses font options and returns the font object.
         * @param options - A object that contains font options to be parsed.
         * @param fallback - A object that contains fallback font options.
         * @return The font object.
         * @private
         */ function toFont(options, fallback) {
          options = options || {};
          fallback = fallback || defaults.font;
          let size = valueOrDefault(options.size, fallback.size);
          if (typeof size === 'string') {
            size = parseInt(size, 10);
          }
          let style = valueOrDefault(options.style, fallback.style);
          if (style && !('' + style).match(FONT_STYLE)) {
            console.warn('Invalid font style specified: "' + style + '"');
            style = undefined;
          }
          const font = {
            family: valueOrDefault(options.family, fallback.family),
            lineHeight: toLineHeight(
              valueOrDefault(options.lineHeight, fallback.lineHeight),
              size
            ),
            size,
            style,
            weight: valueOrDefault(options.weight, fallback.weight),
            string: '',
          };
          font.string = toFontString(font);
          return font;
        }
        /**
         * Evaluates the given `inputs` sequentially and returns the first defined value.
         * @param inputs - An array of values, falling back to the last value.
         * @param context - If defined and the current value is a function, the value
         * is called with `context` as first argument and the result becomes the new input.
         * @param index - If defined and the current value is an array, the value
         * at `index` become the new input.
         * @param info - object to return information about resolution in
         * @param info.cacheable - Will be set to `false` if option is not cacheable.
         * @since 2.7.0
         */ function resolve(inputs, context, index, info) {
          let cacheable = true;
          let i, ilen, value;
          for (i = 0, ilen = inputs.length; i < ilen; ++i) {
            value = inputs[i];
            if (value === undefined) {
              continue;
            }
            if (context !== undefined && typeof value === 'function') {
              value = value(context);
              cacheable = false;
            }
            if (index !== undefined && isArray(value)) {
              value = value[index % value.length];
              cacheable = false;
            }
            if (value !== undefined) {
              if (info && !cacheable) {
                info.cacheable = false;
              }
              return value;
            }
          }
        }
        /**
         * @param minmax
         * @param grace
         * @param beginAtZero
         * @private
         */ function _addGrace(minmax, grace, beginAtZero) {
          const { min, max } = minmax;
          const change = toDimension(grace, (max - min) / 2);
          const keepZero = (value, add) =>
            beginAtZero && value === 0 ? 0 : value + add;
          return {
            min: keepZero(min, -Math.abs(change)),
            max: keepZero(max, change),
          };
        }
        function createContext(parentContext, context) {
          return Object.assign(Object.create(parentContext), context);
        }

        /**
         * Creates a Proxy for resolving raw values for options.
         * @param scopes - The option scopes to look for values, in resolution order
         * @param prefixes - The prefixes for values, in resolution order.
         * @param rootScopes - The root option scopes
         * @param fallback - Parent scopes fallback
         * @param getTarget - callback for getting the target for changed values
         * @returns Proxy
         * @private
         */ function _createResolver(
          scopes,
          prefixes = [''],
          rootScopes,
          fallback,
          getTarget = () => scopes[0]
        ) {
          const finalRootScopes = rootScopes || scopes;
          if (typeof fallback === 'undefined') {
            fallback = _resolve('_fallback', scopes);
          }
          const cache = {
            [Symbol.toStringTag]: 'Object',
            _cacheable: true,
            _scopes: scopes,
            _rootScopes: finalRootScopes,
            _fallback: fallback,
            _getTarget: getTarget,
            override: (scope) =>
              _createResolver(
                [scope, ...scopes],
                prefixes,
                finalRootScopes,
                fallback
              ),
          };
          return new Proxy(cache, {
            /**
             * A trap for the delete operator.
             */ deleteProperty(target, prop) {
              delete target[prop]; // remove from cache
              delete target._keys; // remove cached keys
              delete scopes[0][prop]; // remove from top level scope
              return true;
            },
            /**
             * A trap for getting property values.
             */ get(target, prop) {
              return _cached(target, prop, () =>
                _resolveWithPrefixes(prop, prefixes, scopes, target)
              );
            },
            /**
             * A trap for Object.getOwnPropertyDescriptor.
             * Also used by Object.hasOwnProperty.
             */ getOwnPropertyDescriptor(target, prop) {
              return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
            },
            /**
             * A trap for Object.getPrototypeOf.
             */ getPrototypeOf() {
              return Reflect.getPrototypeOf(scopes[0]);
            },
            /**
             * A trap for the in operator.
             */ has(target, prop) {
              return getKeysFromAllScopes(target).includes(prop);
            },
            /**
             * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
             */ ownKeys(target) {
              return getKeysFromAllScopes(target);
            },
            /**
             * A trap for setting property values.
             */ set(target, prop, value) {
              const storage =
                target._storage || (target._storage = getTarget());
              target[prop] = storage[prop] = value; // set to top level scope + cache
              delete target._keys; // remove cached keys
              return true;
            },
          });
        }
        /**
         * Returns an Proxy for resolving option values with context.
         * @param proxy - The Proxy returned by `_createResolver`
         * @param context - Context object for scriptable/indexable options
         * @param subProxy - The proxy provided for scriptable options
         * @param descriptorDefaults - Defaults for descriptors
         * @private
         */ function _attachContext(
          proxy,
          context,
          subProxy,
          descriptorDefaults
        ) {
          const cache = {
            _cacheable: false,
            _proxy: proxy,
            _context: context,
            _subProxy: subProxy,
            _stack: new Set(),
            _descriptors: _descriptors(proxy, descriptorDefaults),
            setContext: (ctx) =>
              _attachContext(proxy, ctx, subProxy, descriptorDefaults),
            override: (scope) =>
              _attachContext(
                proxy.override(scope),
                context,
                subProxy,
                descriptorDefaults
              ),
          };
          return new Proxy(cache, {
            /**
             * A trap for the delete operator.
             */ deleteProperty(target, prop) {
              delete target[prop]; // remove from cache
              delete proxy[prop]; // remove from proxy
              return true;
            },
            /**
             * A trap for getting property values.
             */ get(target, prop, receiver) {
              return _cached(target, prop, () =>
                _resolveWithContext(target, prop, receiver)
              );
            },
            /**
             * A trap for Object.getOwnPropertyDescriptor.
             * Also used by Object.hasOwnProperty.
             */ getOwnPropertyDescriptor(target, prop) {
              return target._descriptors.allKeys
                ? Reflect.has(proxy, prop)
                  ? {
                      enumerable: true,
                      configurable: true,
                    }
                  : undefined
                : Reflect.getOwnPropertyDescriptor(proxy, prop);
            },
            /**
             * A trap for Object.getPrototypeOf.
             */ getPrototypeOf() {
              return Reflect.getPrototypeOf(proxy);
            },
            /**
             * A trap for the in operator.
             */ has(target, prop) {
              return Reflect.has(proxy, prop);
            },
            /**
             * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
             */ ownKeys() {
              return Reflect.ownKeys(proxy);
            },
            /**
             * A trap for setting property values.
             */ set(target, prop, value) {
              proxy[prop] = value; // set to proxy
              delete target[prop]; // remove from cache
              return true;
            },
          });
        }
        /**
         * @private
         */ function _descriptors(
          proxy,
          defaults = {
            scriptable: true,
            indexable: true,
          }
        ) {
          const {
            _scriptable = defaults.scriptable,
            _indexable = defaults.indexable,
            _allKeys = defaults.allKeys,
          } = proxy;
          return {
            allKeys: _allKeys,
            scriptable: _scriptable,
            indexable: _indexable,
            isScriptable: isFunction(_scriptable)
              ? _scriptable
              : () => _scriptable,
            isIndexable: isFunction(_indexable) ? _indexable : () => _indexable,
          };
        }
        const readKey = (prefix, name) =>
          prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) =>
          isObject(value) &&
          prop !== 'adapters' &&
          (Object.getPrototypeOf(value) === null ||
            value.constructor === Object);
        function _cached(target, prop, resolve) {
          if (
            Object.prototype.hasOwnProperty.call(target, prop) ||
            prop === 'constructor'
          ) {
            return target[prop];
          }
          const value = resolve();
          // cache the resolved value
          target[prop] = value;
          return value;
        }
        function _resolveWithContext(target, prop, receiver) {
          const {
            _proxy,
            _context,
            _subProxy,
            _descriptors: descriptors,
          } = target;
          let value = _proxy[prop]; // resolve from proxy
          // resolve with context
          if (isFunction(value) && descriptors.isScriptable(prop)) {
            value = _resolveScriptable(prop, value, target, receiver);
          }
          if (isArray(value) && value.length) {
            value = _resolveArray(prop, value, target, descriptors.isIndexable);
          }
          if (needsSubResolver(prop, value)) {
            // if the resolved value is an object, create a sub resolver for it
            value = _attachContext(
              value,
              _context,
              _subProxy && _subProxy[prop],
              descriptors
            );
          }
          return value;
        }
        function _resolveScriptable(prop, getValue, target, receiver) {
          const { _proxy, _context, _subProxy, _stack } = target;
          if (_stack.has(prop)) {
            throw new Error(
              'Recursion detected: ' +
                Array.from(_stack).join('->') +
                '->' +
                prop
            );
          }
          _stack.add(prop);
          let value = getValue(_context, _subProxy || receiver);
          _stack.delete(prop);
          if (needsSubResolver(prop, value)) {
            // When scriptable option returns an object, create a resolver on that.
            value = createSubResolver(_proxy._scopes, _proxy, prop, value);
          }
          return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
          const {
            _proxy,
            _context,
            _subProxy,
            _descriptors: descriptors,
          } = target;
          if (typeof _context.index !== 'undefined' && isIndexable(prop)) {
            return value[_context.index % value.length];
          } else if (isObject(value[0])) {
            // Array of objects, return array or resolvers
            const arr = value;
            const scopes = _proxy._scopes.filter((s) => s !== arr);
            value = [];
            for (const item of arr) {
              const resolver = createSubResolver(scopes, _proxy, prop, item);
              value.push(
                _attachContext(
                  resolver,
                  _context,
                  _subProxy && _subProxy[prop],
                  descriptors
                )
              );
            }
          }
          return value;
        }
        function resolveFallback(fallback, prop, value) {
          return isFunction(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) =>
          key === true
            ? parent
            : typeof key === 'string'
            ? resolveObjectKey(parent, key)
            : undefined;
        function addScopes(set, parentScopes, key, parentFallback, value) {
          for (const parent of parentScopes) {
            const scope = getScope(key, parent);
            if (scope) {
              set.add(scope);
              const fallback = resolveFallback(scope._fallback, key, value);
              if (
                typeof fallback !== 'undefined' &&
                fallback !== key &&
                fallback !== parentFallback
              ) {
                // When we reach the descriptor that defines a new _fallback, return that.
                // The fallback will resume to that new scope.
                return fallback;
              }
            } else if (
              scope === false &&
              typeof parentFallback !== 'undefined' &&
              key !== parentFallback
            ) {
              // Fallback to `false` results to `false`, when falling back to different key.
              // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`
              return null;
            }
          }
          return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
          const rootScopes = resolver._rootScopes;
          const fallback = resolveFallback(resolver._fallback, prop, value);
          const allScopes = [...parentScopes, ...rootScopes];
          const set = new Set();
          set.add(value);
          let key = addScopesFromKey(
            set,
            allScopes,
            prop,
            fallback || prop,
            value
          );
          if (key === null) {
            return false;
          }
          if (typeof fallback !== 'undefined' && fallback !== prop) {
            key = addScopesFromKey(set, allScopes, fallback, key, value);
            if (key === null) {
              return false;
            }
          }
          return _createResolver(
            Array.from(set),
            [''],
            rootScopes,
            fallback,
            () => subGetTarget(resolver, prop, value)
          );
        }
        function addScopesFromKey(set, allScopes, key, fallback, item) {
          while (key) {
            key = addScopes(set, allScopes, key, fallback, item);
          }
          return key;
        }
        function subGetTarget(resolver, prop, value) {
          const parent = resolver._getTarget();
          if (!(prop in parent)) {
            parent[prop] = {};
          }
          const target = parent[prop];
          if (isArray(target) && isObject(value)) {
            // For array of objects, the object is used to store updated values
            return value;
          }
          return target || {};
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
          let value;
          for (const prefix of prefixes) {
            value = _resolve(readKey(prefix, prop), scopes);
            if (typeof value !== 'undefined') {
              return needsSubResolver(prop, value)
                ? createSubResolver(scopes, proxy, prop, value)
                : value;
            }
          }
        }
        function _resolve(key, scopes) {
          for (const scope of scopes) {
            if (!scope) {
              continue;
            }
            const value = scope[key];
            if (typeof value !== 'undefined') {
              return value;
            }
          }
        }
        function getKeysFromAllScopes(target) {
          let keys = target._keys;
          if (!keys) {
            keys = target._keys = resolveKeysFromAllScopes(target._scopes);
          }
          return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
          const set = new Set();
          for (const scope of scopes) {
            for (const key of Object.keys(scope).filter(
              (k) => !k.startsWith('_')
            )) {
              set.add(key);
            }
          }
          return Array.from(set);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
          const { iScale } = meta;
          const { key = 'r' } = this._parsing;
          const parsed = new Array(count);
          let i, ilen, index, item;
          for (i = 0, ilen = count; i < ilen; ++i) {
            index = i + start;
            item = data[index];
            parsed[i] = {
              r: iScale.parse(resolveObjectKey(item, key), index),
            };
          }
          return parsed;
        }

        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) =>
          i < points.length && !points[i].skip && points[i];
        const getValueAxis = (indexAxis) => (indexAxis === 'x' ? 'y' : 'x');
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
          // Props to Rob Spencer at scaled innovation for his post on splining between points
          // http://scaledinnovation.com/analytics/splines/aboutSplines.html
          // This function must also respect "skipped" points
          const previous = firstPoint.skip ? middlePoint : firstPoint;
          const current = middlePoint;
          const next = afterPoint.skip ? middlePoint : afterPoint;
          const d01 = distanceBetweenPoints(current, previous);
          const d12 = distanceBetweenPoints(next, current);
          let s01 = d01 / (d01 + d12);
          let s12 = d12 / (d01 + d12);
          // If all points are the same, s01 & s02 will be inf
          s01 = isNaN(s01) ? 0 : s01;
          s12 = isNaN(s12) ? 0 : s12;
          const fa = t * s01; // scaling factor for triangle Ta
          const fb = t * s12;
          return {
            previous: {
              x: current.x - fa * (next.x - previous.x),
              y: current.y - fa * (next.y - previous.y),
            },
            next: {
              x: current.x + fb * (next.x - previous.x),
              y: current.y + fb * (next.y - previous.y),
            },
          };
        }
        /**
         * Adjust tangents to ensure monotonic properties
         */ function monotoneAdjust(points, deltaK, mK) {
          const pointsLen = points.length;
          let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen - 1; ++i) {
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent || !pointAfter) {
              continue;
            }
            if (almostEquals(deltaK[i], 0, EPSILON)) {
              mK[i] = mK[i + 1] = 0;
              continue;
            }
            alphaK = mK[i] / deltaK[i];
            betaK = mK[i + 1] / deltaK[i];
            squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
            if (squaredMagnitude <= 9) {
              continue;
            }
            tauK = 3 / Math.sqrt(squaredMagnitude);
            mK[i] = alphaK * tauK * deltaK[i];
            mK[i + 1] = betaK * tauK * deltaK[i];
          }
        }
        function monotoneCompute(points, mK, indexAxis = 'x') {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          let delta, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (let i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            const iPixel = pointCurrent[indexAxis];
            const vPixel = pointCurrent[valueAxis];
            if (pointBefore) {
              delta = (iPixel - pointBefore[indexAxis]) / 3;
              pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
              pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
            }
            if (pointAfter) {
              delta = (pointAfter[indexAxis] - iPixel) / 3;
              pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
              pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
            }
          }
        }
        /**
         * This function calculates Bézier control points in a similar way than |splineCurve|,
         * but preserves monotonicity of the provided data and ensures no local extremums are added
         * between the dataset discrete points due to the interpolation.
         * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation
         */ function splineCurveMonotone(points, indexAxis = 'x') {
          const valueAxis = getValueAxis(indexAxis);
          const pointsLen = points.length;
          const deltaK = Array(pointsLen).fill(0);
          const mK = Array(pointsLen);
          // Calculate slopes (deltaK) and initialize tangents (mK)
          let i, pointBefore, pointCurrent;
          let pointAfter = getPoint(points, 0);
          for (i = 0; i < pointsLen; ++i) {
            pointBefore = pointCurrent;
            pointCurrent = pointAfter;
            pointAfter = getPoint(points, i + 1);
            if (!pointCurrent) {
              continue;
            }
            if (pointAfter) {
              const slopeDelta =
                pointAfter[indexAxis] - pointCurrent[indexAxis];
              // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
              deltaK[i] =
                slopeDelta !== 0
                  ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) /
                    slopeDelta
                  : 0;
            }
            mK[i] = !pointBefore
              ? deltaK[i]
              : !pointAfter
              ? deltaK[i - 1]
              : sign(deltaK[i - 1]) !== sign(deltaK[i])
              ? 0
              : (deltaK[i - 1] + deltaK[i]) / 2;
          }
          monotoneAdjust(points, deltaK, mK);
          monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
          return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
          let i, ilen, point, inArea, inAreaPrev;
          let inAreaNext = _isPointInArea(points[0], area);
          for (i = 0, ilen = points.length; i < ilen; ++i) {
            inAreaPrev = inArea;
            inArea = inAreaNext;
            inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
            if (!inArea) {
              continue;
            }
            point = points[i];
            if (inAreaPrev) {
              point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
              point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
            }
            if (inAreaNext) {
              point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
              point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
            }
          }
        }
        /**
         * @private
         */ function _updateBezierControlPoints(
          points,
          options,
          area,
          loop,
          indexAxis
        ) {
          let i, ilen, point, controlPoints;
          // Only consider points that are drawn in case the spanGaps option is used
          if (options.spanGaps) {
            points = points.filter((pt) => !pt.skip);
          }
          if (options.cubicInterpolationMode === 'monotone') {
            splineCurveMonotone(points, indexAxis);
          } else {
            let prev = loop ? points[points.length - 1] : points[0];
            for (i = 0, ilen = points.length; i < ilen; ++i) {
              point = points[i];
              controlPoints = splineCurve(
                prev,
                point,
                points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],
                options.tension
              );
              point.cp1x = controlPoints.previous.x;
              point.cp1y = controlPoints.previous.y;
              point.cp2x = controlPoints.next.x;
              point.cp2y = controlPoints.next.y;
              prev = point;
            }
          }
          if (options.capBezierPoints) {
            capBezierPoints(points, area);
          }
        }

        /**
         * @private
         */ function _isDomSupported() {
          return (
            typeof window !== 'undefined' && typeof document !== 'undefined'
          );
        }
        /**
         * @private
         */ function _getParentNode(domNode) {
          let parent = domNode.parentNode;
          if (parent && parent.toString() === '[object ShadowRoot]') {
            parent = parent.host;
          }
          return parent;
        }
        /**
         * convert max-width/max-height values that may be percentages into a number
         * @private
         */ function parseMaxStyle(styleValue, node, parentProperty) {
          let valueInPixels;
          if (typeof styleValue === 'string') {
            valueInPixels = parseInt(styleValue, 10);
            if (styleValue.indexOf('%') !== -1) {
              // percentage * size in dimension
              valueInPixels =
                (valueInPixels / 100) * node.parentNode[parentProperty];
            }
          } else {
            valueInPixels = styleValue;
          }
          return valueInPixels;
        }
        const getComputedStyle = (element) =>
          element.ownerDocument.defaultView.getComputedStyle(element, null);
        function getStyle(el, property) {
          return getComputedStyle(el).getPropertyValue(property);
        }
        const positions = ['top', 'right', 'bottom', 'left'];
        function getPositionedStyle(styles, style, suffix) {
          const result = {};
          suffix = suffix ? '-' + suffix : '';
          for (let i = 0; i < 4; i++) {
            const pos = positions[i];
            result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;
          }
          result.width = result.left + result.right;
          result.height = result.top + result.bottom;
          return result;
        }
        const useOffsetPos = (x, y, target) =>
          (x > 0 || y > 0) && (!target || !target.shadowRoot);
        /**
         * @param e
         * @param canvas
         * @returns Canvas position
         */ function getCanvasPosition(e, canvas) {
          const touches = e.touches;
          const source = touches && touches.length ? touches[0] : e;
          const { offsetX, offsetY } = source;
          let box = false;
          let x, y;
          if (useOffsetPos(offsetX, offsetY, e.target)) {
            x = offsetX;
            y = offsetY;
          } else {
            const rect = canvas.getBoundingClientRect();
            x = source.clientX - rect.left;
            y = source.clientY - rect.top;
            box = true;
          }
          return {
            x,
            y,
            box,
          };
        }
        /**
         * Gets an event's x, y coordinates, relative to the chart area
         * @param event
         * @param chart
         * @returns x and y coordinates of the event
         */ function getRelativePosition(event, chart) {
          if ('native' in event) {
            return event;
          }
          const { canvas, currentDevicePixelRatio } = chart;
          const style = getComputedStyle(canvas);
          const borderBox = style.boxSizing === 'border-box';
          const paddings = getPositionedStyle(style, 'padding');
          const borders = getPositionedStyle(style, 'border', 'width');
          const { x, y, box } = getCanvasPosition(event, canvas);
          const xOffset = paddings.left + (box && borders.left);
          const yOffset = paddings.top + (box && borders.top);
          let { width, height } = chart;
          if (borderBox) {
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          return {
            x: Math.round(
              (((x - xOffset) / width) * canvas.width) / currentDevicePixelRatio
            ),
            y: Math.round(
              (((y - yOffset) / height) * canvas.height) /
                currentDevicePixelRatio
            ),
          };
        }
        function getContainerSize(canvas, width, height) {
          let maxWidth, maxHeight;
          if (width === undefined || height === undefined) {
            const container = canvas && _getParentNode(canvas);
            if (!container) {
              width = canvas.clientWidth;
              height = canvas.clientHeight;
            } else {
              const rect = container.getBoundingClientRect(); // this is the border box of the container
              const containerStyle = getComputedStyle(container);
              const containerBorder = getPositionedStyle(
                containerStyle,
                'border',
                'width'
              );
              const containerPadding = getPositionedStyle(
                containerStyle,
                'padding'
              );
              width =
                rect.width - containerPadding.width - containerBorder.width;
              height =
                rect.height - containerPadding.height - containerBorder.height;
              maxWidth = parseMaxStyle(
                containerStyle.maxWidth,
                container,
                'clientWidth'
              );
              maxHeight = parseMaxStyle(
                containerStyle.maxHeight,
                container,
                'clientHeight'
              );
            }
          }
          return {
            width,
            height,
            maxWidth: maxWidth || INFINITY,
            maxHeight: maxHeight || INFINITY,
          };
        }
        const round1 = (v) => Math.round(v * 10) / 10;
        // eslint-disable-next-line complexity
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
          const style = getComputedStyle(canvas);
          const margins = getPositionedStyle(style, 'margin');
          const maxWidth =
            parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;
          const maxHeight =
            parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;
          const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
          let { width, height } = containerSize;
          if (style.boxSizing === 'content-box') {
            const borders = getPositionedStyle(style, 'border', 'width');
            const paddings = getPositionedStyle(style, 'padding');
            width -= paddings.width + borders.width;
            height -= paddings.height + borders.height;
          }
          width = Math.max(0, width - margins.width);
          height = Math.max(
            0,
            aspectRatio ? width / aspectRatio : height - margins.height
          );
          width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
          height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
          if (width && !height) {
            // https://github.com/chartjs/Chart.js/issues/4659
            // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)
            height = round1(width / 2);
          }
          const maintainHeight =
            bbWidth !== undefined || bbHeight !== undefined;
          if (
            maintainHeight &&
            aspectRatio &&
            containerSize.height &&
            height > containerSize.height
          ) {
            height = containerSize.height;
            width = round1(Math.floor(height * aspectRatio));
          }
          return {
            width,
            height,
          };
        }
        /**
         * @param chart
         * @param forceRatio
         * @param forceStyle
         * @returns True if the canvas context size or transformation has changed.
         */ function retinaScale(chart, forceRatio, forceStyle) {
          const pixelRatio = forceRatio || 1;
          const deviceHeight = Math.floor(chart.height * pixelRatio);
          const deviceWidth = Math.floor(chart.width * pixelRatio);
          chart.height = Math.floor(chart.height);
          chart.width = Math.floor(chart.width);
          const canvas = chart.canvas;
          // If no style has been set on the canvas, the render size is used as display size,
          // making the chart visually bigger, so let's enforce it to the "correct" values.
          // See https://github.com/chartjs/Chart.js/issues/3575
          if (
            canvas.style &&
            (forceStyle || (!canvas.style.height && !canvas.style.width))
          ) {
            canvas.style.height = `${chart.height}px`;
            canvas.style.width = `${chart.width}px`;
          }
          if (
            chart.currentDevicePixelRatio !== pixelRatio ||
            canvas.height !== deviceHeight ||
            canvas.width !== deviceWidth
          ) {
            chart.currentDevicePixelRatio = pixelRatio;
            canvas.height = deviceHeight;
            canvas.width = deviceWidth;
            chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            return true;
          }
          return false;
        }
        /**
         * Detects support for options object argument in addEventListener.
         * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
         * @private
         */ const supportsEventListenerOptions = (function () {
          let passiveSupported = false;
          try {
            const options = {
              get passive() {
                passiveSupported = true;
                return false;
              },
            };
            if (_isDomSupported()) {
              window.addEventListener('test', null, options);
              window.removeEventListener('test', null, options);
            }
          } catch (e) {
            // continue regardless of error
          }
          return passiveSupported;
        })();
        /**
         * The "used" size is the final value of a dimension property after all calculations have
         * been performed. This method uses the computed style of `element` but returns undefined
         * if the computed style is not expressed in pixels. That can happen in some cases where
         * `element` has a size relative to its parent and this last one is not yet displayed,
         * for example because of `display: none` on a parent node.
         * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
         * @returns Size in pixels or undefined if unknown.
         */ function readUsedSize(element, property) {
          const value = getStyle(element, property);
          const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
          return matches ? +matches[1] : undefined;
        }

        /**
         * @private
         */ function _pointInLine(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y),
          };
        }
        /**
         * @private
         */ function _steppedInterpolation(p1, p2, t, mode) {
          return {
            x: p1.x + t * (p2.x - p1.x),
            y:
              mode === 'middle'
                ? t < 0.5
                  ? p1.y
                  : p2.y
                : mode === 'after'
                ? t < 1
                  ? p1.y
                  : p2.y
                : t > 0
                ? p2.y
                : p1.y,
          };
        }
        /**
         * @private
         */ function _bezierInterpolation(p1, p2, t, mode) {
          const cp1 = {
            x: p1.cp2x,
            y: p1.cp2y,
          };
          const cp2 = {
            x: p2.cp1x,
            y: p2.cp1y,
          };
          const a = _pointInLine(p1, cp1, t);
          const b = _pointInLine(cp1, cp2, t);
          const c = _pointInLine(cp2, p2, t);
          const d = _pointInLine(a, b, t);
          const e = _pointInLine(b, c, t);
          return _pointInLine(d, e, t);
        }

        const getRightToLeftAdapter = function (rectX, width) {
          return {
            x(x) {
              return rectX + rectX + width - x;
            },
            setWidth(w) {
              width = w;
            },
            textAlign(align) {
              if (align === 'center') {
                return align;
              }
              return align === 'right' ? 'left' : 'right';
            },
            xPlus(x, value) {
              return x - value;
            },
            leftForLtr(x, itemWidth) {
              return x - itemWidth;
            },
          };
        };
        const getLeftToRightAdapter = function () {
          return {
            x(x) {
              return x;
            },
            setWidth(w) {},
            textAlign(align) {
              return align;
            },
            xPlus(x, value) {
              return x + value;
            },
            leftForLtr(x, _itemWidth) {
              return x;
            },
          };
        };
        function getRtlAdapter(rtl, rectX, width) {
          return rtl
            ? getRightToLeftAdapter(rectX, width)
            : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
          let style, original;
          if (direction === 'ltr' || direction === 'rtl') {
            style = ctx.canvas.style;
            original = [
              style.getPropertyValue('direction'),
              style.getPropertyPriority('direction'),
            ];
            style.setProperty('direction', direction, 'important');
            ctx.prevTextDirection = original;
          }
        }
        function restoreTextDirection(ctx, original) {
          if (original !== undefined) {
            delete ctx.prevTextDirection;
            ctx.canvas.style.setProperty('direction', original[0], original[1]);
          }
        }

        function propertyFn(property) {
          if (property === 'angle') {
            return {
              between: _angleBetween,
              compare: _angleDiff,
              normalize: _normalizeAngle,
            };
          }
          return {
            between: _isBetween,
            compare: (a, b) => a - b,
            normalize: (x) => x,
          };
        }
        function normalizeSegment({ start, end, count, loop, style }) {
          return {
            start: start % count,
            end: end % count,
            loop: loop && (end - start + 1) % count === 0,
            style,
          };
        }
        function getSegment(segment, points, bounds) {
          const { property, start: startBound, end: endBound } = bounds;
          const { between, normalize } = propertyFn(property);
          const count = points.length;
          let { start, end, loop } = segment;
          let i, ilen;
          if (loop) {
            start += count;
            end += count;
            for (i = 0, ilen = count; i < ilen; ++i) {
              if (
                !between(
                  normalize(points[start % count][property]),
                  startBound,
                  endBound
                )
              ) {
                break;
              }
              start--;
              end--;
            }
            start %= count;
            end %= count;
          }
          if (end < start) {
            end += count;
          }
          return {
            start,
            end,
            loop,
            style: segment.style,
          };
        }
        function _boundSegment(segment, points, bounds) {
          if (!bounds) {
            return [segment];
          }
          const { property, start: startBound, end: endBound } = bounds;
          const count = points.length;
          const { compare, between, normalize } = propertyFn(property);
          const { start, end, loop, style } = getSegment(
            segment,
            points,
            bounds
          );
          const result = [];
          let inside = false;
          let subStart = null;
          let value, point, prevValue;
          const startIsBefore = () =>
            between(startBound, prevValue, value) &&
            compare(startBound, prevValue) !== 0;
          const endIsBefore = () =>
            compare(endBound, value) === 0 ||
            between(endBound, prevValue, value);
          const shouldStart = () => inside || startIsBefore();
          const shouldStop = () => !inside || endIsBefore();
          for (let i = start, prev = start; i <= end; ++i) {
            point = points[i % count];
            if (point.skip) {
              continue;
            }
            value = normalize(point[property]);
            if (value === prevValue) {
              continue;
            }
            inside = between(value, startBound, endBound);
            if (subStart === null && shouldStart()) {
              subStart = compare(value, startBound) === 0 ? i : prev;
            }
            if (subStart !== null && shouldStop()) {
              result.push(
                normalizeSegment({
                  start: subStart,
                  end: i,
                  loop,
                  count,
                  style,
                })
              );
              subStart = null;
            }
            prev = i;
            prevValue = value;
          }
          if (subStart !== null) {
            result.push(
              normalizeSegment({
                start: subStart,
                end,
                loop,
                count,
                style,
              })
            );
          }
          return result;
        }
        function _boundSegments(line, bounds) {
          const result = [];
          const segments = line.segments;
          for (let i = 0; i < segments.length; i++) {
            const sub = _boundSegment(segments[i], line.points, bounds);
            if (sub.length) {
              result.push(...sub);
            }
          }
          return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
          let start = 0;
          let end = count - 1;
          if (loop && !spanGaps) {
            while (start < count && !points[start].skip) {
              start++;
            }
          }
          while (start < count && points[start].skip) {
            start++;
          }
          start %= count;
          if (loop) {
            end += start;
          }
          while (end > start && points[end % count].skip) {
            end--;
          }
          end %= count;
          return {
            start,
            end,
          };
        }
        function solidSegments(points, start, max, loop) {
          const count = points.length;
          const result = [];
          let last = start;
          let prev = points[start];
          let end;
          for (end = start + 1; end <= max; ++end) {
            const cur = points[end % count];
            if (cur.skip || cur.stop) {
              if (!prev.skip) {
                loop = false;
                result.push({
                  start: start % count,
                  end: (end - 1) % count,
                  loop,
                });
                start = last = cur.stop ? end : null;
              }
            } else {
              last = end;
              if (prev.skip) {
                start = end;
              }
            }
            prev = cur;
          }
          if (last !== null) {
            result.push({
              start: start % count,
              end: last % count,
              loop,
            });
          }
          return result;
        }
        function _computeSegments(line, segmentOptions) {
          const points = line.points;
          const spanGaps = line.options.spanGaps;
          const count = points.length;
          if (!count) {
            return [];
          }
          const loop = !!line._loop;
          const { start, end } = findStartAndEnd(points, count, loop, spanGaps);
          if (spanGaps === true) {
            return splitByStyles(
              line,
              [
                {
                  start,
                  end,
                  loop,
                },
              ],
              points,
              segmentOptions
            );
          }
          const max = end < start ? end + count : end;
          const completeLoop =
            !!line._fullLoop && start === 0 && end === count - 1;
          return splitByStyles(
            line,
            solidSegments(points, start, max, completeLoop),
            points,
            segmentOptions
          );
        }
        function splitByStyles(line, segments, points, segmentOptions) {
          if (!segmentOptions || !segmentOptions.setContext || !points) {
            return segments;
          }
          return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
          const chartContext = line._chart.getContext();
          const baseStyle = readStyle(line.options);
          const {
            _datasetIndex: datasetIndex,
            options: { spanGaps },
          } = line;
          const count = points.length;
          const result = [];
          let prevStyle = baseStyle;
          let start = segments[0].start;
          let i = start;
          function addStyle(s, e, l, st) {
            const dir = spanGaps ? -1 : 1;
            if (s === e) {
              return;
            }
            s += count;
            while (points[s % count].skip) {
              s -= dir;
            }
            while (points[e % count].skip) {
              e += dir;
            }
            if (s % count !== e % count) {
              result.push({
                start: s % count,
                end: e % count,
                loop: l,
                style: st,
              });
              prevStyle = st;
              start = e % count;
            }
          }
          for (const segment of segments) {
            start = spanGaps ? start : segment.start;
            let prev = points[start % count];
            let style;
            for (i = start + 1; i <= segment.end; i++) {
              const pt = points[i % count];
              style = readStyle(
                segmentOptions.setContext(
                  createContext(chartContext, {
                    type: 'segment',
                    p0: prev,
                    p1: pt,
                    p0DataIndex: (i - 1) % count,
                    p1DataIndex: i % count,
                    datasetIndex,
                  })
                )
              );
              if (styleChanged(style, prevStyle)) {
                addStyle(start, i - 1, segment.loop, prevStyle);
              }
              prev = pt;
              prevStyle = style;
            }
            if (start < i - 1) {
              addStyle(start, i - 1, segment.loop, prevStyle);
            }
          }
          return result;
        }
        function readStyle(options) {
          return {
            backgroundColor: options.backgroundColor,
            borderCapStyle: options.borderCapStyle,
            borderDash: options.borderDash,
            borderDashOffset: options.borderDashOffset,
            borderJoinStyle: options.borderJoinStyle,
            borderWidth: options.borderWidth,
            borderColor: options.borderColor,
          };
        }
        function styleChanged(style, prevStyle) {
          if (!prevStyle) {
            return false;
          }
          const cache = [];
          const replacer = function (key, value) {
            if (!isPatternOrGradient(value)) {
              return value;
            }
            if (!cache.includes(value)) {
              cache.push(value);
            }
            return cache.indexOf(value);
          };
          return (
            JSON.stringify(style, replacer) !==
            JSON.stringify(prevStyle, replacer)
          );
        }

        function getSizeForArea(scale, chartArea, field) {
          return scale.options.clip ? scale[field] : chartArea[field];
        }
        function getDatasetArea(meta, chartArea) {
          const { xScale, yScale } = meta;
          if (xScale && yScale) {
            return {
              left: getSizeForArea(xScale, chartArea, 'left'),
              right: getSizeForArea(xScale, chartArea, 'right'),
              top: getSizeForArea(yScale, chartArea, 'top'),
              bottom: getSizeForArea(yScale, chartArea, 'bottom'),
            };
          }
          return chartArea;
        }
        function getDatasetClipArea(chart, meta) {
          const clip = meta._clip;
          if (clip.disabled) {
            return false;
          }
          const area = getDatasetArea(meta, chart.chartArea);
          return {
            left:
              clip.left === false
                ? 0
                : area.left - (clip.left === true ? 0 : clip.left),
            right:
              clip.right === false
                ? chart.width
                : area.right + (clip.right === true ? 0 : clip.right),
            top:
              clip.top === false
                ? 0
                : area.top - (clip.top === true ? 0 : clip.top),
            bottom:
              clip.bottom === false
                ? chart.height
                : area.bottom + (clip.bottom === true ? 0 : clip.bottom),
          };
        }

        //# sourceMappingURL=helpers.dataset.js.map

        /***/
      },

    /***/ './node_modules/chart.js/dist/helpers.js':
      /*!***********************************************!*\
  !*** ./node_modules/chart.js/dist/helpers.js ***!
  \***********************************************/
      /***/ (
        __unused_webpack___webpack_module__,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ HALF_PI: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.H,
          /* harmony export */ INFINITY: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b3,
          /* harmony export */ PI: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.P,
          /* harmony export */ PITAU: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b2,
          /* harmony export */ QUARTER_PI: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b5,
          /* harmony export */ RAD_PER_DEG: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b4,
          /* harmony export */ TAU: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.T,
          /* harmony export */ TWO_THIRDS_PI: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b6,
          /* harmony export */ _addGrace: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.R,
          /* harmony export */ _alignPixel: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.X,
          /* harmony export */ _alignStartEnd: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a2,
          /* harmony export */ _angleBetween: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.p,
          /* harmony export */ _angleDiff: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b7,
          /* harmony export */ _arrayUnique: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__._,
          /* harmony export */ _attachContext: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a8,
          /* harmony export */ _bezierCurveTo: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.at,
          /* harmony export */ _bezierInterpolation: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aq,
          /* harmony export */ _boundSegment: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ay,
          /* harmony export */ _boundSegments: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ao,
          /* harmony export */ _capitalize: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a5,
          /* harmony export */ _computeSegments: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.an,
          /* harmony export */ _createResolver: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a9,
          /* harmony export */ _decimalPlaces: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aL,
          /* harmony export */ _deprecated: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aW,
          /* harmony export */ _descriptors: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aa,
          /* harmony export */ _elementsEqual: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ai,
          /* harmony export */ _factorize: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.N,
          /* harmony export */ _filterBetween: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aP,
          /* harmony export */ _getParentNode: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.I,
          /* harmony export */ _getStartAndCountOfVisiblePoints: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.q,
          /* harmony export */ _int16Range: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.W,
          /* harmony export */ _isBetween: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ak,
          /* harmony export */ _isClickEvent: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aj,
          /* harmony export */ _isDomSupported: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.M,
          /* harmony export */ _isPointInArea: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.C,
          /* harmony export */ _limitValue: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.S,
          /* harmony export */ _longestText: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aO,
          /* harmony export */ _lookup: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aQ,
          /* harmony export */ _lookupByKey: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.B,
          /* harmony export */ _measureText: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.V,
          /* harmony export */ _merger: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aU,
          /* harmony export */ _mergerIf: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aV,
          /* harmony export */ _normalizeAngle: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.az,
          /* harmony export */ _parseObjectDataRadialScale: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.y,
          /* harmony export */ _pointInLine: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ar,
          /* harmony export */ _readValueToProps: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.al,
          /* harmony export */ _rlookupByKey: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.A,
          /* harmony export */ _scaleRangesChanged: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.w,
          /* harmony export */ _setMinAndMaxByKey: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aH,
          /* harmony export */ _splitKey: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aX,
          /* harmony export */ _steppedInterpolation: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ap,
          /* harmony export */ _steppedLineTo: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.as,
          /* harmony export */ _textX: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aC,
          /* harmony export */ _toLeftRightCenter: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a1,
          /* harmony export */ _updateBezierControlPoints: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.am,
          /* harmony export */ addRoundedRectPath: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.av,
          /* harmony export */ almostEquals: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aK,
          /* harmony export */ almostWhole: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aJ,
          /* harmony export */ callback: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Q,
          /* harmony export */ clearCanvas: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.af,
          /* harmony export */ clipArea: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Y,
          /* harmony export */ clone: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aT,
          /* harmony export */ color: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.c,
          /* harmony export */ createContext: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.j,
          /* harmony export */ debounce: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ad,
          /* harmony export */ defined: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.h,
          /* harmony export */ distanceBetweenPoints: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aF,
          /* harmony export */ drawPoint: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.au,
          /* harmony export */ drawPointLegend: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aE,
          /* harmony export */ each: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.F,
          /* harmony export */ easingEffects: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.e,
          /* harmony export */ finiteOrDefault: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.O,
          /* harmony export */ fontString: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b0,
          /* harmony export */ formatNumber: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.o,
          /* harmony export */ getAngleFromPoint: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.D,
          /* harmony export */ getDatasetClipArea: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ah,
          /* harmony export */ getHoverColor: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aS,
          /* harmony export */ getMaximumSize: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.G,
          /* harmony export */ getRelativePosition: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.z,
          /* harmony export */ getRtlAdapter: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aA,
          /* harmony export */ getStyle: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a$,
          /* harmony export */ isArray: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b,
          /* harmony export */ isFinite: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.g,
          /* harmony export */ isFunction: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a7,
          /* harmony export */ isNullOrUndef: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.k,
          /* harmony export */ isNumber: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.x,
          /* harmony export */ isObject: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.i,
          /* harmony export */ isPatternOrGradient: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aR,
          /* harmony export */ listenArrayEvents: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.l,
          /* harmony export */ log10: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aN,
          /* harmony export */ merge: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a4,
          /* harmony export */ mergeIf: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ab,
          /* harmony export */ niceNum: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aI,
          /* harmony export */ noop: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aG,
          /* harmony export */ overrideTextDirection: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aB,
          /* harmony export */ readUsedSize: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.J,
          /* harmony export */ renderText: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.Z,
          /* harmony export */ requestAnimFrame: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.r,
          /* harmony export */ resolve: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a,
          /* harmony export */ resolveObjectKey: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.f,
          /* harmony export */ restoreTextDirection: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aD,
          /* harmony export */ retinaScale: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ae,
          /* harmony export */ setsEqual: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ag,
          /* harmony export */ sign: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.s,
          /* harmony export */ splineCurve: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aZ,
          /* harmony export */ splineCurveMonotone: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a_,
          /* harmony export */ supportsEventListenerOptions: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.K,
          /* harmony export */ throttled: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.L,
          /* harmony export */ toDegrees: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.U,
          /* harmony export */ toDimension: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.n,
          /* harmony export */ toFont: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.a0,
          /* harmony export */ toFontString: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aY,
          /* harmony export */ toLineHeight: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.b1,
          /* harmony export */ toPadding: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.E,
          /* harmony export */ toPercentage: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.m,
          /* harmony export */ toRadians: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.t,
          /* harmony export */ toTRBL: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.aw,
          /* harmony export */ toTRBLCorners: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ax,
          /* harmony export */ uid: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.ac,
          /* harmony export */ unclipArea: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.$,
          /* harmony export */ unlistenArrayEvents: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.u,
          /* harmony export */ valueOrDefault: () =>
            /* reexport safe */ _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__.v,
          /* harmony export */
        });
        /* harmony import */ var _chunks_helpers_dataset_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ./chunks/helpers.dataset.js */ './node_modules/chart.js/dist/chunks/helpers.dataset.js'
          );
        /*!
         * Chart.js v4.4.9
         * https://www.chartjs.org
         * (c) 2025 Chart.js Contributors
         * Released under the MIT License
         */

        //# sourceMappingURL=helpers.js.map

        /***/
      },

    /***/ './node_modules/chart.js/helpers/helpers.js':
      /*!**************************************************!*\
  !*** ./node_modules/chart.js/helpers/helpers.js ***!
  \**************************************************/
      /***/ (
        __unused_webpack___webpack_module__,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ HALF_PI: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.HALF_PI,
          /* harmony export */ INFINITY: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.INFINITY,
          /* harmony export */ PI: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.PI,
          /* harmony export */ PITAU: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.PITAU,
          /* harmony export */ QUARTER_PI: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.QUARTER_PI,
          /* harmony export */ RAD_PER_DEG: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.RAD_PER_DEG,
          /* harmony export */ TAU: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.TAU,
          /* harmony export */ TWO_THIRDS_PI: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.TWO_THIRDS_PI,
          /* harmony export */ _addGrace: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._addGrace,
          /* harmony export */ _alignPixel: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._alignPixel,
          /* harmony export */ _alignStartEnd: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._alignStartEnd,
          /* harmony export */ _angleBetween: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._angleBetween,
          /* harmony export */ _angleDiff: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._angleDiff,
          /* harmony export */ _arrayUnique: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._arrayUnique,
          /* harmony export */ _attachContext: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._attachContext,
          /* harmony export */ _bezierCurveTo: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._bezierCurveTo,
          /* harmony export */ _bezierInterpolation: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._bezierInterpolation,
          /* harmony export */ _boundSegment: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._boundSegment,
          /* harmony export */ _boundSegments: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._boundSegments,
          /* harmony export */ _capitalize: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._capitalize,
          /* harmony export */ _computeSegments: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._computeSegments,
          /* harmony export */ _createResolver: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._createResolver,
          /* harmony export */ _decimalPlaces: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._decimalPlaces,
          /* harmony export */ _deprecated: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._deprecated,
          /* harmony export */ _descriptors: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._descriptors,
          /* harmony export */ _elementsEqual: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._elementsEqual,
          /* harmony export */ _factorize: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._factorize,
          /* harmony export */ _filterBetween: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._filterBetween,
          /* harmony export */ _getParentNode: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._getParentNode,
          /* harmony export */ _getStartAndCountOfVisiblePoints: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._getStartAndCountOfVisiblePoints,
          /* harmony export */ _int16Range: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._int16Range,
          /* harmony export */ _isBetween: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._isBetween,
          /* harmony export */ _isClickEvent: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._isClickEvent,
          /* harmony export */ _isDomSupported: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._isDomSupported,
          /* harmony export */ _isPointInArea: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._isPointInArea,
          /* harmony export */ _limitValue: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._limitValue,
          /* harmony export */ _longestText: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._longestText,
          /* harmony export */ _lookup: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._lookup,
          /* harmony export */ _lookupByKey: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._lookupByKey,
          /* harmony export */ _measureText: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._measureText,
          /* harmony export */ _merger: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._merger,
          /* harmony export */ _mergerIf: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._mergerIf,
          /* harmony export */ _normalizeAngle: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._normalizeAngle,
          /* harmony export */ _parseObjectDataRadialScale: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._parseObjectDataRadialScale,
          /* harmony export */ _pointInLine: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._pointInLine,
          /* harmony export */ _readValueToProps: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._readValueToProps,
          /* harmony export */ _rlookupByKey: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._rlookupByKey,
          /* harmony export */ _scaleRangesChanged: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._scaleRangesChanged,
          /* harmony export */ _setMinAndMaxByKey: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._setMinAndMaxByKey,
          /* harmony export */ _splitKey: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._splitKey,
          /* harmony export */ _steppedInterpolation: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._steppedInterpolation,
          /* harmony export */ _steppedLineTo: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._steppedLineTo,
          /* harmony export */ _textX: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._textX,
          /* harmony export */ _toLeftRightCenter: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._toLeftRightCenter,
          /* harmony export */ _updateBezierControlPoints: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__._updateBezierControlPoints,
          /* harmony export */ addRoundedRectPath: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.addRoundedRectPath,
          /* harmony export */ almostEquals: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.almostEquals,
          /* harmony export */ almostWhole: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.almostWhole,
          /* harmony export */ callback: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.callback,
          /* harmony export */ clearCanvas: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.clearCanvas,
          /* harmony export */ clipArea: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.clipArea,
          /* harmony export */ clone: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.clone,
          /* harmony export */ color: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.color,
          /* harmony export */ createContext: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.createContext,
          /* harmony export */ debounce: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.debounce,
          /* harmony export */ defined: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.defined,
          /* harmony export */ distanceBetweenPoints: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.distanceBetweenPoints,
          /* harmony export */ drawPoint: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.drawPoint,
          /* harmony export */ drawPointLegend: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.drawPointLegend,
          /* harmony export */ each: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.each,
          /* harmony export */ easingEffects: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.easingEffects,
          /* harmony export */ finiteOrDefault: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.finiteOrDefault,
          /* harmony export */ fontString: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.fontString,
          /* harmony export */ formatNumber: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.formatNumber,
          /* harmony export */ getAngleFromPoint: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getAngleFromPoint,
          /* harmony export */ getDatasetClipArea: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getDatasetClipArea,
          /* harmony export */ getHoverColor: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getHoverColor,
          /* harmony export */ getMaximumSize: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getMaximumSize,
          /* harmony export */ getRelativePosition: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getRelativePosition,
          /* harmony export */ getRtlAdapter: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getRtlAdapter,
          /* harmony export */ getStyle: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.getStyle,
          /* harmony export */ isArray: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isArray,
          /* harmony export */ isFinite: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isFinite,
          /* harmony export */ isFunction: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isFunction,
          /* harmony export */ isNullOrUndef: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef,
          /* harmony export */ isNumber: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isNumber,
          /* harmony export */ isObject: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isObject,
          /* harmony export */ isPatternOrGradient: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.isPatternOrGradient,
          /* harmony export */ listenArrayEvents: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.listenArrayEvents,
          /* harmony export */ log10: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.log10,
          /* harmony export */ merge: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.merge,
          /* harmony export */ mergeIf: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.mergeIf,
          /* harmony export */ niceNum: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.niceNum,
          /* harmony export */ noop: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.noop,
          /* harmony export */ overrideTextDirection: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.overrideTextDirection,
          /* harmony export */ readUsedSize: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.readUsedSize,
          /* harmony export */ renderText: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.renderText,
          /* harmony export */ requestAnimFrame: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.requestAnimFrame,
          /* harmony export */ resolve: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.resolve,
          /* harmony export */ resolveObjectKey: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.resolveObjectKey,
          /* harmony export */ restoreTextDirection: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.restoreTextDirection,
          /* harmony export */ retinaScale: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.retinaScale,
          /* harmony export */ setsEqual: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.setsEqual,
          /* harmony export */ sign: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.sign,
          /* harmony export */ splineCurve: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.splineCurve,
          /* harmony export */ splineCurveMonotone: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.splineCurveMonotone,
          /* harmony export */ supportsEventListenerOptions: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.supportsEventListenerOptions,
          /* harmony export */ throttled: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.throttled,
          /* harmony export */ toDegrees: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toDegrees,
          /* harmony export */ toDimension: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toDimension,
          /* harmony export */ toFont: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toFont,
          /* harmony export */ toFontString: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toFontString,
          /* harmony export */ toLineHeight: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toLineHeight,
          /* harmony export */ toPadding: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toPadding,
          /* harmony export */ toPercentage: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toPercentage,
          /* harmony export */ toRadians: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toRadians,
          /* harmony export */ toTRBL: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toTRBL,
          /* harmony export */ toTRBLCorners: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.toTRBLCorners,
          /* harmony export */ uid: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.uid,
          /* harmony export */ unclipArea: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.unclipArea,
          /* harmony export */ unlistenArrayEvents: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.unlistenArrayEvents,
          /* harmony export */ valueOrDefault: () =>
            /* reexport safe */ _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault,
          /* harmony export */
        });
        /* harmony import */ var _dist_helpers_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../dist/helpers.js */ './node_modules/chart.js/dist/helpers.js'
          );

        /***/
      },

    /***/ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js':
      /*!**************************************************************************************!*\
  !*** ./node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js ***!
  \**************************************************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ plugin,
          /* harmony export */
        });
        /* harmony import */ var chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js/helpers */ './node_modules/chart.js/helpers/helpers.js'
          );
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chunks/helpers.dataset.js'
          );
        /*!
         * chartjs-plugin-datalabels v2.2.0
         * https://chartjs-plugin-datalabels.netlify.app
         * (c) 2017-2022 chartjs-plugin-datalabels contributors
         * Released under the MIT license
         */

        var devicePixelRatio = (function () {
          if (typeof window !== 'undefined') {
            if (window.devicePixelRatio) {
              return window.devicePixelRatio;
            }

            // devicePixelRatio is undefined on IE10
            // https://stackoverflow.com/a/20204180/8837887
            // https://github.com/chartjs/chartjs-plugin-datalabels/issues/85
            var screen = window.screen;
            if (screen) {
              return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
          }

          return 1;
        })();

        var utils = {
          // @todo move this in Chart.helpers.toTextLines
          toTextLines: function (inputs) {
            var lines = [];
            var input;

            inputs = [].concat(inputs);
            while (inputs.length) {
              input = inputs.pop();
              if (typeof input === 'string') {
                lines.unshift.apply(lines, input.split('\n'));
              } else if (Array.isArray(input)) {
                inputs.push.apply(inputs, input);
              } else if (
                !(0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(
                  inputs
                )
              ) {
                lines.unshift('' + input);
              }
            }

            return lines;
          },

          // @todo move this in Chart.helpers.canvas.textSize
          // @todo cache calls of measureText if font doesn't change?!
          textSize: function (ctx, lines, font) {
            var items = [].concat(lines);
            var ilen = items.length;
            var prev = ctx.font;
            var width = 0;
            var i;

            ctx.font = font.string;

            for (i = 0; i < ilen; ++i) {
              width = Math.max(ctx.measureText(items[i]).width, width);
            }

            ctx.font = prev;

            return {
              height: ilen * font.lineHeight,
              width: width,
            };
          },

          /**
           * Returns value bounded by min and max. This is equivalent to max(min, min(value, max)).
           * @todo move this method in Chart.helpers.bound
           * https://doc.qt.io/qt-5/qtglobal.html#qBound
           */
          bound: function (min, value, max) {
            return Math.max(min, Math.min(value, max));
          },

          /**
           * Returns an array of pair [value, state] where state is:
           * * -1: value is only in a0 (removed)
           * *  1: value is only in a1 (added)
           */
          arrayDiff: function (a0, a1) {
            var prev = a0.slice();
            var updates = [];
            var i, j, ilen, v;

            for (i = 0, ilen = a1.length; i < ilen; ++i) {
              v = a1[i];
              j = prev.indexOf(v);

              if (j === -1) {
                updates.push([v, 1]);
              } else {
                prev.splice(j, 1);
              }
            }

            for (i = 0, ilen = prev.length; i < ilen; ++i) {
              updates.push([prev[i], -1]);
            }

            return updates;
          },

          /**
           * https://github.com/chartjs/chartjs-plugin-datalabels/issues/70
           */
          rasterize: function (v) {
            return Math.round(v * devicePixelRatio) / devicePixelRatio;
          },
        };

        function orient(point, origin) {
          var x0 = origin.x;
          var y0 = origin.y;

          if (x0 === null) {
            return { x: 0, y: -1 };
          }
          if (y0 === null) {
            return { x: 1, y: 0 };
          }

          var dx = point.x - x0;
          var dy = point.y - y0;
          var ln = Math.sqrt(dx * dx + dy * dy);

          return {
            x: ln ? dx / ln : 0,
            y: ln ? dy / ln : -1,
          };
        }

        function aligned(x, y, vx, vy, align) {
          switch (align) {
            case 'center':
              vx = vy = 0;
              break;
            case 'bottom':
              vx = 0;
              vy = 1;
              break;
            case 'right':
              vx = 1;
              vy = 0;
              break;
            case 'left':
              vx = -1;
              vy = 0;
              break;
            case 'top':
              vx = 0;
              vy = -1;
              break;
            case 'start':
              vx = -vx;
              vy = -vy;
              break;
            case 'end':
              // keep natural orientation
              break;
            default:
              // clockwise rotation (in degree)
              align *= Math.PI / 180;
              vx = Math.cos(align);
              vy = Math.sin(align);
              break;
          }

          return {
            x: x,
            y: y,
            vx: vx,
            vy: vy,
          };
        }

        // Line clipping (Cohen–Sutherland algorithm)
        // https://en.wikipedia.org/wiki/Cohen–Sutherland_algorithm

        var R_INSIDE = 0;
        var R_LEFT = 1;
        var R_RIGHT = 2;
        var R_BOTTOM = 4;
        var R_TOP = 8;

        function region(x, y, rect) {
          var res = R_INSIDE;

          if (x < rect.left) {
            res |= R_LEFT;
          } else if (x > rect.right) {
            res |= R_RIGHT;
          }
          if (y < rect.top) {
            res |= R_TOP;
          } else if (y > rect.bottom) {
            res |= R_BOTTOM;
          }

          return res;
        }

        function clipped(segment, area) {
          var x0 = segment.x0;
          var y0 = segment.y0;
          var x1 = segment.x1;
          var y1 = segment.y1;
          var r0 = region(x0, y0, area);
          var r1 = region(x1, y1, area);
          var r, x, y;

          // eslint-disable-next-line no-constant-condition
          while (true) {
            if (!(r0 | r1) || r0 & r1) {
              // both points inside or on the same side: no clipping
              break;
            }

            // at least one point is outside
            r = r0 || r1;

            if (r & R_TOP) {
              x = x0 + ((x1 - x0) * (area.top - y0)) / (y1 - y0);
              y = area.top;
            } else if (r & R_BOTTOM) {
              x = x0 + ((x1 - x0) * (area.bottom - y0)) / (y1 - y0);
              y = area.bottom;
            } else if (r & R_RIGHT) {
              y = y0 + ((y1 - y0) * (area.right - x0)) / (x1 - x0);
              x = area.right;
            } else if (r & R_LEFT) {
              y = y0 + ((y1 - y0) * (area.left - x0)) / (x1 - x0);
              x = area.left;
            }

            if (r === r0) {
              x0 = x;
              y0 = y;
              r0 = region(x0, y0, area);
            } else {
              x1 = x;
              y1 = y;
              r1 = region(x1, y1, area);
            }
          }

          return {
            x0: x0,
            x1: x1,
            y0: y0,
            y1: y1,
          };
        }

        function compute$1(range, config) {
          var anchor = config.anchor;
          var segment = range;
          var x, y;

          if (config.clamp) {
            segment = clipped(segment, config.area);
          }

          if (anchor === 'start') {
            x = segment.x0;
            y = segment.y0;
          } else if (anchor === 'end') {
            x = segment.x1;
            y = segment.y1;
          } else {
            x = (segment.x0 + segment.x1) / 2;
            y = (segment.y0 + segment.y1) / 2;
          }

          return aligned(x, y, range.vx, range.vy, config.align);
        }

        var positioners = {
          arc: function (el, config) {
            var angle = (el.startAngle + el.endAngle) / 2;
            var vx = Math.cos(angle);
            var vy = Math.sin(angle);
            var r0 = el.innerRadius;
            var r1 = el.outerRadius;

            return compute$1(
              {
                x0: el.x + vx * r0,
                y0: el.y + vy * r0,
                x1: el.x + vx * r1,
                y1: el.y + vy * r1,
                vx: vx,
                vy: vy,
              },
              config
            );
          },

          point: function (el, config) {
            var v = orient(el, config.origin);
            var rx = v.x * el.options.radius;
            var ry = v.y * el.options.radius;

            return compute$1(
              {
                x0: el.x - rx,
                y0: el.y - ry,
                x1: el.x + rx,
                y1: el.y + ry,
                vx: v.x,
                vy: v.y,
              },
              config
            );
          },

          bar: function (el, config) {
            var v = orient(el, config.origin);
            var x = el.x;
            var y = el.y;
            var sx = 0;
            var sy = 0;

            if (el.horizontal) {
              x = Math.min(el.x, el.base);
              sx = Math.abs(el.base - el.x);
            } else {
              y = Math.min(el.y, el.base);
              sy = Math.abs(el.base - el.y);
            }

            return compute$1(
              {
                x0: x,
                y0: y + sy,
                x1: x + sx,
                y1: y,
                vx: v.x,
                vy: v.y,
              },
              config
            );
          },

          fallback: function (el, config) {
            var v = orient(el, config.origin);

            return compute$1(
              {
                x0: el.x,
                y0: el.y,
                x1: el.x + (el.width || 0),
                y1: el.y + (el.height || 0),
                vx: v.x,
                vy: v.y,
              },
              config
            );
          },
        };

        var rasterize = utils.rasterize;

        function boundingRects(model) {
          var borderWidth = model.borderWidth || 0;
          var padding = model.padding;
          var th = model.size.height;
          var tw = model.size.width;
          var tx = -tw / 2;
          var ty = -th / 2;

          return {
            frame: {
              x: tx - padding.left - borderWidth,
              y: ty - padding.top - borderWidth,
              w: tw + padding.width + borderWidth * 2,
              h: th + padding.height + borderWidth * 2,
            },
            text: {
              x: tx,
              y: ty,
              w: tw,
              h: th,
            },
          };
        }

        function getScaleOrigin(el, context) {
          var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;

          if (!scale) {
            return null;
          }

          if (scale.xCenter !== undefined && scale.yCenter !== undefined) {
            return { x: scale.xCenter, y: scale.yCenter };
          }

          var pixel = scale.getBasePixel();
          return el.horizontal ? { x: pixel, y: null } : { x: null, y: pixel };
        }

        function getPositioner(el) {
          if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.ArcElement) {
            return positioners.arc;
          }
          if (
            el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.PointElement
          ) {
            return positioners.point;
          }
          if (el instanceof chart_js__WEBPACK_IMPORTED_MODULE_1__.BarElement) {
            return positioners.bar;
          }
          return positioners.fallback;
        }

        function drawRoundedRect(ctx, x, y, w, h, radius) {
          var HALF_PI = Math.PI / 2;

          if (radius) {
            var r = Math.min(radius, h / 2, w / 2);
            var left = x + r;
            var top = y + r;
            var right = x + w - r;
            var bottom = y + h - r;

            ctx.moveTo(x, top);
            if (left < right && top < bottom) {
              ctx.arc(left, top, r, -Math.PI, -HALF_PI);
              ctx.arc(right, top, r, -HALF_PI, 0);
              ctx.arc(right, bottom, r, 0, HALF_PI);
              ctx.arc(left, bottom, r, HALF_PI, Math.PI);
            } else if (left < right) {
              ctx.moveTo(left, y);
              ctx.arc(right, top, r, -HALF_PI, HALF_PI);
              ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
            } else if (top < bottom) {
              ctx.arc(left, top, r, -Math.PI, 0);
              ctx.arc(left, bottom, r, 0, Math.PI);
            } else {
              ctx.arc(left, top, r, -Math.PI, Math.PI);
            }
            ctx.closePath();
            ctx.moveTo(x, y);
          } else {
            ctx.rect(x, y, w, h);
          }
        }

        function drawFrame(ctx, rect, model) {
          var bgColor = model.backgroundColor;
          var borderColor = model.borderColor;
          var borderWidth = model.borderWidth;

          if (!bgColor && (!borderColor || !borderWidth)) {
            return;
          }

          ctx.beginPath();

          drawRoundedRect(
            ctx,
            rasterize(rect.x) + borderWidth / 2,
            rasterize(rect.y) + borderWidth / 2,
            rasterize(rect.w) - borderWidth,
            rasterize(rect.h) - borderWidth,
            model.borderRadius
          );

          ctx.closePath();

          if (bgColor) {
            ctx.fillStyle = bgColor;
            ctx.fill();
          }

          if (borderColor && borderWidth) {
            ctx.strokeStyle = borderColor;
            ctx.lineWidth = borderWidth;
            ctx.lineJoin = 'miter';
            ctx.stroke();
          }
        }

        function textGeometry(rect, align, font) {
          var h = font.lineHeight;
          var w = rect.w;
          var x = rect.x;
          var y = rect.y + h / 2;

          if (align === 'center') {
            x += w / 2;
          } else if (align === 'end' || align === 'right') {
            x += w;
          }

          return {
            h: h,
            w: w,
            x: x,
            y: y,
          };
        }

        function drawTextLine(ctx, text, cfg) {
          var shadow = ctx.shadowBlur;
          var stroked = cfg.stroked;
          var x = rasterize(cfg.x);
          var y = rasterize(cfg.y);
          var w = rasterize(cfg.w);

          if (stroked) {
            ctx.strokeText(text, x, y, w);
          }

          if (cfg.filled) {
            if (shadow && stroked) {
              // Prevent drawing shadow on both the text stroke and fill, so
              // if the text is stroked, remove the shadow for the text fill.
              ctx.shadowBlur = 0;
            }

            ctx.fillText(text, x, y, w);

            if (shadow && stroked) {
              ctx.shadowBlur = shadow;
            }
          }
        }

        function drawText(ctx, lines, rect, model) {
          var align = model.textAlign;
          var color = model.color;
          var filled = !!color;
          var font = model.font;
          var ilen = lines.length;
          var strokeColor = model.textStrokeColor;
          var strokeWidth = model.textStrokeWidth;
          var stroked = strokeColor && strokeWidth;
          var i;

          if (!ilen || (!filled && !stroked)) {
            return;
          }

          // Adjust coordinates based on text alignment and line height
          rect = textGeometry(rect, align, font);

          ctx.font = font.string;
          ctx.textAlign = align;
          ctx.textBaseline = 'middle';
          ctx.shadowBlur = model.textShadowBlur;
          ctx.shadowColor = model.textShadowColor;

          if (filled) {
            ctx.fillStyle = color;
          }
          if (stroked) {
            ctx.lineJoin = 'round';
            ctx.lineWidth = strokeWidth;
            ctx.strokeStyle = strokeColor;
          }

          for (i = 0, ilen = lines.length; i < ilen; ++i) {
            drawTextLine(ctx, lines[i], {
              stroked: stroked,
              filled: filled,
              w: rect.w,
              x: rect.x,
              y: rect.y + rect.h * i,
            });
          }
        }

        var Label = function (config, ctx, el, index) {
          var me = this;

          me._config = config;
          me._index = index;
          me._model = null;
          me._rects = null;
          me._ctx = ctx;
          me._el = el;
        };

        (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(
          Label.prototype,
          {
            /**
             * @private
             */
            _modelize: function (display, lines, config, context) {
              var me = this;
              var index = me._index;
              var font = (0,
              chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toFont)(
                (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.font, {}],
                  context,
                  index
                )
              );
              var color = (0,
              chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                [config.color, chart_js__WEBPACK_IMPORTED_MODULE_2__.d.color],
                context,
                index
              );

              return {
                align: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.align, 'center'],
                  context,
                  index
                ),
                anchor: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.anchor, 'center'],
                  context,
                  index
                ),
                area: context.chart.chartArea,
                backgroundColor: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.backgroundColor, null],
                  context,
                  index
                ),
                borderColor: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.borderColor, null],
                  context,
                  index
                ),
                borderRadius: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.borderRadius, 0],
                  context,
                  index
                ),
                borderWidth: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.borderWidth, 0],
                  context,
                  index
                ),
                clamp: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.clamp, false],
                  context,
                  index
                ),
                clip: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.clip, false],
                  context,
                  index
                ),
                color: color,
                display: display,
                font: font,
                lines: lines,
                offset: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.offset, 4],
                  context,
                  index
                ),
                opacity: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.opacity, 1],
                  context,
                  index
                ),
                origin: getScaleOrigin(me._el, context),
                padding: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.toPadding)(
                  (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                    [config.padding, 4],
                    context,
                    index
                  )
                ),
                positioner: getPositioner(me._el),
                rotation:
                  (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                    [config.rotation, 0],
                    context,
                    index
                  ) *
                  (Math.PI / 180),
                size: utils.textSize(me._ctx, lines, font),
                textAlign: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.textAlign, 'start'],
                  context,
                  index
                ),
                textShadowBlur: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.textShadowBlur, 0],
                  context,
                  index
                ),
                textShadowColor: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.textShadowColor, color],
                  context,
                  index
                ),
                textStrokeColor: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.textStrokeColor, color],
                  context,
                  index
                ),
                textStrokeWidth: (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                  [config.textStrokeWidth, 0],
                  context,
                  index
                ),
              };
            },

            update: function (context) {
              var me = this;
              var model = null;
              var rects = null;
              var index = me._index;
              var config = me._config;
              var value, label, lines;

              // We first resolve the display option (separately) to avoid computing
              // other options in case the label is hidden (i.e. display: false).
              var display = (0,
              chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.resolve)(
                [config.display, true],
                context,
                index
              );

              if (display) {
                value = context.dataset.data[index];
                label = (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.valueOrDefault)(
                  (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(
                    config.formatter,
                    [value, context]
                  ),
                  value
                );
                lines = (0,
                chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(
                  label
                )
                  ? []
                  : utils.toTextLines(label);

                if (lines.length) {
                  model = me._modelize(display, lines, config, context);
                  rects = boundingRects(model);
                }
              }

              me._model = model;
              me._rects = rects;
            },

            geometry: function () {
              return this._rects ? this._rects.frame : {};
            },

            rotation: function () {
              return this._model ? this._model.rotation : 0;
            },

            visible: function () {
              return this._model && this._model.opacity;
            },

            model: function () {
              return this._model;
            },

            draw: function (chart, center) {
              var me = this;
              var ctx = chart.ctx;
              var model = me._model;
              var rects = me._rects;
              var area;

              if (!this.visible()) {
                return;
              }

              ctx.save();

              if (model.clip) {
                area = model.area;
                ctx.beginPath();
                ctx.rect(
                  area.left,
                  area.top,
                  area.right - area.left,
                  area.bottom - area.top
                );
                ctx.clip();
              }

              ctx.globalAlpha = utils.bound(0, model.opacity, 1);
              ctx.translate(rasterize(center.x), rasterize(center.y));
              ctx.rotate(model.rotation);

              drawFrame(ctx, rects.frame, model);
              drawText(ctx, model.lines, rects.text, model);

              ctx.restore();
            },
          }
        );

        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991; // eslint-disable-line es/no-number-minsafeinteger
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991; // eslint-disable-line es/no-number-maxsafeinteger

        function rotated(point, center, angle) {
          var cos = Math.cos(angle);
          var sin = Math.sin(angle);
          var cx = center.x;
          var cy = center.y;

          return {
            x: cx + cos * (point.x - cx) - sin * (point.y - cy),
            y: cy + sin * (point.x - cx) + cos * (point.y - cy),
          };
        }

        function projected(points, axis) {
          var min = MAX_INTEGER;
          var max = MIN_INTEGER;
          var origin = axis.origin;
          var i, pt, vx, vy, dp;

          for (i = 0; i < points.length; ++i) {
            pt = points[i];
            vx = pt.x - origin.x;
            vy = pt.y - origin.y;
            dp = axis.vx * vx + axis.vy * vy;
            min = Math.min(min, dp);
            max = Math.max(max, dp);
          }

          return {
            min: min,
            max: max,
          };
        }

        function toAxis(p0, p1) {
          var vx = p1.x - p0.x;
          var vy = p1.y - p0.y;
          var ln = Math.sqrt(vx * vx + vy * vy);

          return {
            vx: (p1.x - p0.x) / ln,
            vy: (p1.y - p0.y) / ln,
            origin: p0,
            ln: ln,
          };
        }

        var HitBox = function () {
          this._rotation = 0;
          this._rect = {
            x: 0,
            y: 0,
            w: 0,
            h: 0,
          };
        };

        (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(
          HitBox.prototype,
          {
            center: function () {
              var r = this._rect;
              return {
                x: r.x + r.w / 2,
                y: r.y + r.h / 2,
              };
            },

            update: function (center, rect, rotation) {
              this._rotation = rotation;
              this._rect = {
                x: rect.x + center.x,
                y: rect.y + center.y,
                w: rect.w,
                h: rect.h,
              };
            },

            contains: function (point) {
              var me = this;
              var margin = 1;
              var rect = me._rect;

              point = rotated(point, me.center(), -me._rotation);

              return !(
                point.x < rect.x - margin ||
                point.y < rect.y - margin ||
                point.x > rect.x + rect.w + margin * 2 ||
                point.y > rect.y + rect.h + margin * 2
              );
            },

            // Separating Axis Theorem
            // https://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169
            intersects: function (other) {
              var r0 = this._points();
              var r1 = other._points();
              var axes = [toAxis(r0[0], r0[1]), toAxis(r0[0], r0[3])];
              var i, pr0, pr1;

              if (this._rotation !== other._rotation) {
                // Only separate with r1 axis if the rotation is different,
                // else it's enough to separate r0 and r1 with r0 axis only!
                axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
              }

              for (i = 0; i < axes.length; ++i) {
                pr0 = projected(r0, axes[i]);
                pr1 = projected(r1, axes[i]);

                if (pr0.max < pr1.min || pr1.max < pr0.min) {
                  return false;
                }
              }

              return true;
            },

            /**
             * @private
             */
            _points: function () {
              var me = this;
              var rect = me._rect;
              var angle = me._rotation;
              var center = me.center();

              return [
                rotated({ x: rect.x, y: rect.y }, center, angle),
                rotated({ x: rect.x + rect.w, y: rect.y }, center, angle),
                rotated(
                  { x: rect.x + rect.w, y: rect.y + rect.h },
                  center,
                  angle
                ),
                rotated({ x: rect.x, y: rect.y + rect.h }, center, angle),
              ];
            },
          }
        );

        function coordinates(el, model, geometry) {
          var point = model.positioner(el, model);
          var vx = point.vx;
          var vy = point.vy;

          if (!vx && !vy) {
            // if aligned center, we don't want to offset the center point
            return { x: point.x, y: point.y };
          }

          var w = geometry.w;
          var h = geometry.h;

          // take in account the label rotation
          var rotation = model.rotation;
          var dx =
            Math.abs((w / 2) * Math.cos(rotation)) +
            Math.abs((h / 2) * Math.sin(rotation));
          var dy =
            Math.abs((w / 2) * Math.sin(rotation)) +
            Math.abs((h / 2) * Math.cos(rotation));

          // scale the unit vector (vx, vy) to get at least dx or dy equal to
          // w or h respectively (else we would calculate the distance to the
          // ellipse inscribed in the bounding rect)
          var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
          dx *= vx * vs;
          dy *= vy * vs;

          // finally, include the explicit offset
          dx += model.offset * vx;
          dy += model.offset * vy;

          return {
            x: point.x + dx,
            y: point.y + dy,
          };
        }

        function collide(labels, collider) {
          var i, j, s0, s1;

          // IMPORTANT Iterate in the reverse order since items at the end of the
          // list have an higher weight/priority and thus should be less impacted
          // by the overlapping strategy.

          for (i = labels.length - 1; i >= 0; --i) {
            s0 = labels[i].$layout;

            for (j = i - 1; j >= 0 && s0._visible; --j) {
              s1 = labels[j].$layout;

              if (s1._visible && s0._box.intersects(s1._box)) {
                collider(s0, s1);
              }
            }
          }

          return labels;
        }

        function compute(labels) {
          var i, ilen, label, state, geometry, center, proxy;

          // Initialize labels for overlap detection
          for (i = 0, ilen = labels.length; i < ilen; ++i) {
            label = labels[i];
            state = label.$layout;

            if (state._visible) {
              // Chart.js 3 removed el._model in favor of getProps(), making harder to
              // abstract reading values in positioners. Also, using string arrays to
              // read values (i.e. var {a,b,c} = el.getProps(["a","b","c"])) would make
              // positioners inefficient in the normal case (i.e. not the final values)
              // and the code a bit ugly, so let's use a Proxy instead.
              proxy = new Proxy(label._el, {
                get: (el, p) => el.getProps([p], true)[p],
              });

              geometry = label.geometry();
              center = coordinates(proxy, label.model(), geometry);
              state._box.update(center, geometry, label.rotation());
            }
          }

          // Auto hide overlapping labels
          return collide(labels, function (s0, s1) {
            var h0 = s0._hidable;
            var h1 = s1._hidable;

            if ((h0 && h1) || h1) {
              s1._visible = false;
            } else if (h0) {
              s0._visible = false;
            }
          });
        }

        var layout = {
          prepare: function (datasets) {
            var labels = [];
            var i, j, ilen, jlen, label;

            for (i = 0, ilen = datasets.length; i < ilen; ++i) {
              for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                label = datasets[i][j];
                labels.push(label);
                label.$layout = {
                  _box: new HitBox(),
                  _hidable: false,
                  _visible: true,
                  _set: i,
                  _idx: label._index,
                };
              }
            }

            // TODO New `z` option: labels with a higher z-index are drawn
            // of top of the ones with a lower index. Lowest z-index labels
            // are also discarded first when hiding overlapping labels.
            labels.sort(function (a, b) {
              var sa = a.$layout;
              var sb = b.$layout;

              return sa._idx === sb._idx
                ? sb._set - sa._set
                : sb._idx - sa._idx;
            });

            this.update(labels);

            return labels;
          },

          update: function (labels) {
            var dirty = false;
            var i, ilen, label, model, state;

            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              model = label.model();
              state = label.$layout;
              state._hidable = model && model.display === 'auto';
              state._visible = label.visible();
              dirty |= state._hidable;
            }

            if (dirty) {
              compute(labels);
            }
          },

          lookup: function (labels, point) {
            var i, state;

            // IMPORTANT Iterate in the reverse order since items at the end of
            // the list have an higher z-index, thus should be picked first.

            for (i = labels.length - 1; i >= 0; --i) {
              state = labels[i].$layout;

              if (state && state._visible && state._box.contains(point)) {
                return labels[i];
              }
            }

            return null;
          },

          draw: function (chart, labels) {
            var i, ilen, label, state, geometry, center;

            for (i = 0, ilen = labels.length; i < ilen; ++i) {
              label = labels[i];
              state = label.$layout;

              if (state._visible) {
                geometry = label.geometry();
                center = coordinates(label._el, label.model(), geometry);
                state._box.update(center, geometry, label.rotation());
                label.draw(chart, center);
              }
            }
          },
        };

        var formatter = function (value) {
          if (
            (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(
              value
            )
          ) {
            return null;
          }

          var label = value;
          var keys, klen, k;
          if (
            (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(value)
          ) {
            if (
              !(0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(
                value.label
              )
            ) {
              label = value.label;
            } else if (
              !(0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndef)(
                value.r
              )
            ) {
              label = value.r;
            } else {
              label = '';
              keys = Object.keys(value);
              for (k = 0, klen = keys.length; k < klen; ++k) {
                label +=
                  (k !== 0 ? ', ' : '') + keys[k] + ': ' + value[keys[k]];
              }
            }
          }

          return '' + label;
        };

        /**
         * IMPORTANT: make sure to also update tests and TypeScript definition
         * files (`/test/specs/defaults.spec.js` and `/types/options.d.ts`)
         */

        var defaults = {
          align: 'center',
          anchor: 'center',
          backgroundColor: null,
          borderColor: null,
          borderRadius: 0,
          borderWidth: 0,
          clamp: false,
          clip: false,
          color: undefined,
          display: true,
          font: {
            family: undefined,
            lineHeight: 1.2,
            size: undefined,
            style: undefined,
            weight: null,
          },
          formatter: formatter,
          labels: undefined,
          listeners: {},
          offset: 4,
          opacity: 1,
          padding: {
            top: 4,
            right: 4,
            bottom: 4,
            left: 4,
          },
          rotation: 0,
          textAlign: 'start',
          textStrokeColor: undefined,
          textStrokeWidth: 0,
          textShadowBlur: 0,
          textShadowColor: undefined,
        };

        /**
         * @see https://github.com/chartjs/Chart.js/issues/4176
         */

        var EXPANDO_KEY = '$datalabels';
        var DEFAULT_KEY = '$default';

        function configure(dataset, options) {
          var override = dataset.datalabels;
          var listeners = {};
          var configs = [];
          var labels, keys;

          if (override === false) {
            return null;
          }
          if (override === true) {
            override = {};
          }

          options = (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(
            {},
            [options, override]
          );
          labels = options.labels || {};
          keys = Object.keys(labels);
          delete options.labels;

          if (keys.length) {
            keys.forEach(function (key) {
              if (labels[key]) {
                configs.push(
                  (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)({}, [
                    options,
                    labels[key],
                    { _key: key },
                  ])
                );
              }
            });
          } else {
            // Default label if no "named" label defined.
            configs.push(options);
          }

          // listeners: {<event-type>: {<label-key>: <fn>}}
          listeners = configs.reduce(function (target, config) {
            (0,
            chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.each)(config.listeners || {}, function (fn, event) {
              target[event] = target[event] || {};
              target[event][config._key || DEFAULT_KEY] = fn;
            });

            delete config.listeners;
            return target;
          }, {});

          return {
            labels: configs,
            listeners: listeners,
          };
        }

        function dispatchEvent(chart, listeners, label, event) {
          if (!listeners) {
            return;
          }

          var context = label.$context;
          var groups = label.$groups;
          var callback$1;

          if (!listeners[groups._set]) {
            return;
          }

          callback$1 = listeners[groups._set][groups._key];
          if (!callback$1) {
            return;
          }

          if (
            (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.callback)(
              callback$1,
              [context, event]
            ) === true
          ) {
            // Users are allowed to tweak the given context by injecting values that can be
            // used in scriptable options to display labels differently based on the current
            // event (e.g. highlight an hovered label). That's why we update the label with
            // the output context and schedule a new chart render by setting it dirty.
            chart[EXPANDO_KEY]._dirty = true;
            label.update(context);
          }
        }

        function dispatchMoveEvents(chart, listeners, previous, label, event) {
          var enter, leave;

          if (!previous && !label) {
            return;
          }

          if (!previous) {
            enter = true;
          } else if (!label) {
            leave = true;
          } else if (previous !== label) {
            leave = enter = true;
          }

          if (leave) {
            dispatchEvent(chart, listeners.leave, previous, event);
          }
          if (enter) {
            dispatchEvent(chart, listeners.enter, label, event);
          }
        }

        function handleMoveEvents(chart, event) {
          var expando = chart[EXPANDO_KEY];
          var listeners = expando._listeners;
          var previous, label;

          if (!listeners.enter && !listeners.leave) {
            return;
          }

          if (event.type === 'mousemove') {
            label = layout.lookup(expando._labels, event);
          } else if (event.type !== 'mouseout') {
            return;
          }

          previous = expando._hovered;
          expando._hovered = label;
          dispatchMoveEvents(chart, listeners, previous, label, event);
        }

        function handleClickEvents(chart, event) {
          var expando = chart[EXPANDO_KEY];
          var handlers = expando._listeners.click;
          var label = handlers && layout.lookup(expando._labels, event);
          if (label) {
            dispatchEvent(chart, handlers, label, event);
          }
        }

        var plugin = {
          id: 'datalabels',

          defaults: defaults,

          beforeInit: function (chart) {
            chart[EXPANDO_KEY] = {
              _actives: [],
            };
          },

          beforeUpdate: function (chart) {
            var expando = chart[EXPANDO_KEY];
            expando._listened = false;
            expando._listeners = {}; // {<event-type>: {<dataset-index>: {<label-key>: <fn>}}}
            expando._datasets = []; // per dataset labels: [Label[]]
            expando._labels = []; // layouted labels: Label[]
          },

          afterDatasetUpdate: function (chart, args, options) {
            var datasetIndex = args.index;
            var expando = chart[EXPANDO_KEY];
            var labels = (expando._datasets[datasetIndex] = []);
            var visible = chart.isDatasetVisible(datasetIndex);
            var dataset = chart.data.datasets[datasetIndex];
            var config = configure(dataset, options);
            var elements = args.meta.data || [];
            var ctx = chart.ctx;
            var i, j, ilen, jlen, cfg, key, el, label;

            ctx.save();

            for (i = 0, ilen = elements.length; i < ilen; ++i) {
              el = elements[i];
              el[EXPANDO_KEY] = [];

              if (visible && el && chart.getDataVisibility(i) && !el.skip) {
                for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                  cfg = config.labels[j];
                  key = cfg._key;

                  label = new Label(cfg, ctx, el, i);
                  label.$groups = {
                    _set: datasetIndex,
                    _key: key || DEFAULT_KEY,
                  };
                  label.$context = {
                    active: false,
                    chart: chart,
                    dataIndex: i,
                    dataset: dataset,
                    datasetIndex: datasetIndex,
                  };

                  label.update(label.$context);
                  el[EXPANDO_KEY].push(label);
                  labels.push(label);
                }
              }
            }

            ctx.restore();

            // Store listeners at the chart level and per event type to optimize
            // cases where no listeners are registered for a specific event.
            (0, chart_js_helpers__WEBPACK_IMPORTED_MODULE_0__.merge)(
              expando._listeners,
              config.listeners,
              {
                merger: function (event, target, source) {
                  target[event] = target[event] || {};
                  target[event][args.index] = source[event];
                  expando._listened = true;
                },
              }
            );
          },

          afterUpdate: function (chart) {
            chart[EXPANDO_KEY]._labels = layout.prepare(
              chart[EXPANDO_KEY]._datasets
            );
          },

          // Draw labels on top of all dataset elements
          // https://github.com/chartjs/chartjs-plugin-datalabels/issues/29
          // https://github.com/chartjs/chartjs-plugin-datalabels/issues/32
          afterDatasetsDraw: function (chart) {
            layout.draw(chart, chart[EXPANDO_KEY]._labels);
          },

          beforeEvent: function (chart, args) {
            // If there is no listener registered for this chart, `listened` will be false,
            // meaning we can immediately ignore the incoming event and avoid useless extra
            // computation for users who don't implement label interactions.
            if (chart[EXPANDO_KEY]._listened) {
              var event = args.event;
              switch (event.type) {
                case 'mousemove':
                case 'mouseout':
                  handleMoveEvents(chart, event);
                  break;
                case 'click':
                  handleClickEvents(chart, event);
                  break;
              }
            }
          },

          afterEvent: function (chart) {
            var expando = chart[EXPANDO_KEY];
            var previous = expando._actives;
            var actives = (expando._actives = chart.getActiveElements());
            var updates = utils.arrayDiff(previous, actives);
            var i, ilen, j, jlen, update, label, labels;

            for (i = 0, ilen = updates.length; i < ilen; ++i) {
              update = updates[i];
              if (update[1]) {
                labels = update[0].element[EXPANDO_KEY] || [];
                for (j = 0, jlen = labels.length; j < jlen; ++j) {
                  label = labels[j];
                  label.$context.active = update[1] === 1;
                  label.update(label.$context);
                }
              }
            }

            if (expando._dirty || updates.length) {
              layout.update(expando._labels);
              chart.render();
            }

            delete expando._dirty;
          },
        };

        /***/
      },

    /***/ './node_modules/css-loader/dist/cjs.js!./src/budget-table.css':
      /*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/budget-table.css ***!
  \********************************************************************/
      /***/ (module, __webpack_exports__, __webpack_require__) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ './node_modules/css-loader/dist/runtime/sourceMaps.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../node_modules/css-loader/dist/runtime/api.js */ './node_modules/css-loader/dist/runtime/api.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          );
        // Imports

        var ___CSS_LOADER_EXPORT___ =
          _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(
            _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        // Module
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          `#budget-table {
  border-radius: 5px;
}

#budget-table,
th,
td {
  border: 1px solid;
  border-collapse: collapse;
}
`,
          '',
          {
            version: 3,
            sources: ['webpack://./src/budget-table.css'],
            names: [],
            mappings:
              'AAAA;EACE,kBAAkB;AACpB;;AAEA;;;EAGE,iBAAiB;EACjB,yBAAyB;AAC3B',
            sourcesContent: [
              '#budget-table {\n  border-radius: 5px;\n}\n\n#budget-table,\nth,\ntd {\n  border: 1px solid;\n  border-collapse: collapse;\n}\n',
            ],
            sourceRoot: '',
          },
        ]);
        // Exports
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          ___CSS_LOADER_EXPORT___;

        /***/
      },

    /***/ './node_modules/css-loader/dist/cjs.js!./src/style.css':
      /*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
      /***/ (module, __webpack_exports__, __webpack_require__) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ './node_modules/css-loader/dist/runtime/sourceMaps.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../node_modules/css-loader/dist/runtime/api.js */ './node_modules/css-loader/dist/runtime/api.js'
          );
        /* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__
          );
        // Imports

        var ___CSS_LOADER_EXPORT___ =
          _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()(
            _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()
          );
        // Module
        ___CSS_LOADER_EXPORT___.push([
          module.id,
          `/* form css start */
body {
  font-family: Arial, sans-serif;
}
/* header */
.header-sec {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 20px 0px;
  background-color: #fff;
}
.btns {
  background-color: #d0b870;
  color: white;
  border: none;
  font-size: 16px;
  font-weight: bold;
  border-radius: 50px;
  transition: background 0.3s ease-in-out;
  width: 45px;
  height: 45px;
  z-index: 4;
}
.download i {
  font-size: 18px;
}
.table-design h5 {
  font-weight: 600;
  color: #d0b870;
}
#yearlyTables th,
td {
  text-align: center;
  padding: 18px 10px !important;
}
#yearlyTables table {
  text-align: center;
}
.table {
  --bs-table-bg: transparent !important;
}
#yearlyTables th {
  font-size: 19px;
  font-weight: 700;
  color: #d0b870;
}
canvas {
  width: 100% !important;
  height: 100% !important;
  padding: 20px;
  object-fit: contain;
}

.logo img {
  width: 150px;
}

.iconbar ul {
  list-style: none;
  display: flex;
  gap: 15px;
}

.icon-item {
  width: 36px;
  height: 36px;
  border-radius: 50%;
  background: #d0b870;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: 0.3s;
}
.icon-item a {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100%;
}

.icon-item svg {
  fill: white;
  width: 20px;
  height: 20px;
}
.uk-navbar-toggle {
  padding: 0 0;
  color: #2f2f2f;
  font-weight: 300;
  text-transform: none;
}

/* css start */
.nav-pills .nav-link.active {
  background-color: #000000a3;
  color: white;
  border-radius: 5px;
  padding: 14px 30px;
  font-weight: 600;
}
.nav-pills .nav-link {
  color: black;
}
.card {
  border-radius: 12px;
  box-shadow: 0px 0px 16px 0px #00000040;
}
.input-group-text {
  background-color: #206ba4;
  color: white;
  border: none;
  background: black;
}
.card button {
  background-color: black;
  padding: 14px 20px;
  font-size: 16px;
}
.card button:hover {
  background-color: black;
}
.card-1 {
  background: #206ba4;
  margin-block: 40px !important;
}
.form-control {
  padding: 20px 0.75rem;
}
.card-2 {
  padding: 20px;
}
.card-2-inner h4 {
  font-size: 26px;
  font-weight: 700;
  color: #d0b870;
}

.card-service {
  gap: 20px;
  justify-content: space-around;
}
.tab-content h1 {
  font-size: 40px;
  color: #d0b870;
  font-weight: 700;
  text-transform: capitalize;
  padding-bottom: 10px;
  position: relative;
}
.result {
  font-size: 24px;
  font-weight: 500;
}
.card-2-inner {
  padding-block: 40px !important;
  height: 100%;
  box-shadow: rgba(0, 0, 0, 0.02) 0px 1px 3px 0px,
    rgba(27, 31, 35, 0.15) 0px 0px 0px 1px;
}

.card-2-inner h5 {
  font-size: 22px;
  font-weight: 700;
  padding-bottom: 20px;
}
.card-2-inner p {
  font-size: 22px;
  font-weight: 700;
}
.input-circle span {
  padding: 2px 12px;
  position: absolute;
  top: 12px;
  right: 15px;
  color: white;
  border-radius: 34px;
  background: lightgray;
  cursor: pointer !important;
}
.form-floating {
  position: relative;
  width: 100%;
}
input::-webkit-outer-spin-button,
input::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
.error {
  text-align: start !important;
  display: flex;
  padding: 10px;
  color: #852828;
  font-size: 16px;
  font-weight: 600;
}
/* Firefox */
input[type='number'] {
  -moz-appearance: textfield;
}
.form-control {
  padding: 8px 0.75rem;
}
.accordion-body {
  background-color: white;
}
.accordion-button:not(.collapsed) {
  color: white;
  background-color: #d0b870 !important;
  box-shadow: inset 0 calc(-1 * var(--bs-accordion-border-width)) 0
    var(--bs-accordion-border-color);
  font-weight: 600;
}
.accordion-button:not(.collapsed)::after {
  filter: brightness(0) invert(1);
}
.tab-content h1::after {
  content: '';
  border-bottom: 2px solid #000;
  position: absolute;
  width: 40%;
  left: 0;
  bottom: 1px;
  left: 50%;
  transform: translate(-50%, 0);
}
.space {
  width: 77%;
  margin: 20px auto;
}

/* footer */
footer {
  background: #2f2f2f;
  color: #fff;
  padding: 10px;
  margin-top: 4rem;
}
.footer-sec {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
}
.copyright p {
  font-size: 17px;
  line-height: 1.2;
  color: #b0a4ac;
  font-weight: 300;
  text-align: center;
}
.website p {
  font-size: 15px;
  color: #d0b870;
}
.website a {
  font-size: 15px;
  color: #b0a4ac !important;
  text-decoration: none;
}
.footer-item {
  margin: 5px 0;
}
/* projection css start */
div#projections h3 {
  padding-block: 23px;
  font-size: 26px;
  font-weight: 700;
}
div#projections ul li {
  list-style: none;
  font-size: 20px;
}
p.dynamicPara {
  font-size: 24px !important;
  color: #d0b870;
}
/* dropdown css */
select#timeDuration {
  width: 15%;
  margin-left: auto;
  font-weight: 700;
  color: #d0b870;
  padding: 18px;
  border: 2px solid;
  background: rgba(0, 0, 0, 0.8);
}
/*-- responisve --*/
@media screen and (max-width: 991px) {
  select#timeDuration {
    width: 45%;
    margin-top: 40px;
  }
  .row.mob-block > div {
    width: 100%;
  }
  .row.mob-block {
    display: block;
  }
  .space {
    width: 100%;
  }
}
@media (max-width: 760px) {
  .footer-sec {
    justify-content: center !important;
  }
}
@media (max-width: 500px) {
  select#timeDuration {
    width: 100%;
    margin-top: 40px;
  }
  .iconbar {
    display: none;
  }
  .header-sec {
    justify-content: center;
  }
}
.drops {
  width: 15%;
  margin-left: auto;
  font-weight: 700;
  color: #d0b870;
  padding: 18px !important;
  border: 2px solid;
  background: rgba(0, 0, 0, 0.8);
}
/* 
.print-button {
  padding: 10px 20px;
  background-color: #d0b870;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  margin-top: 20px;
} */

/* Print Styles */
@media print {
  .print-button,
  .navigation-bar,
  .sidebar,
  .footer {
    display: none !important; /* hide navbars, footers, buttons, etc. */
  }

  body {
    background: white;
    color: black;
  }

  /* Optional: adjust layout for printing */
  .main-content {
    width: 100%;
    padding: 0;
    margin: 0;
  }

  html,
  body {
    height: auto;
  }
}
/* @media (max-width: 991px) {
  .print-button {
    top: -22px;
    width: 50px;
  }
} */
.btn-flex {
  display: flex;
  justify-content: flex-end;
  gap: 20px;
  align-items: end;
  flex-direction: column;
  position: absolute;
  top: -25px;
  right: 0;
}

html {
  visibility: visible;
  opacity: 1;
}
`,
          '',
          {
            version: 3,
            sources: ['webpack://./src/style.css'],
            names: [],
            mappings:
              'AAAA,mBAAmB;AACnB;EACE,8BAA8B;AAChC;AACA,WAAW;AACX;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,iBAAiB;EACjB,sBAAsB;AACxB;AACA;EACE,yBAAyB;EACzB,YAAY;EACZ,YAAY;EACZ,eAAe;EACf,iBAAiB;EACjB,mBAAmB;EACnB,uCAAuC;EACvC,WAAW;EACX,YAAY;EACZ,UAAU;AACZ;AACA;EACE,eAAe;AACjB;AACA;EACE,gBAAgB;EAChB,cAAc;AAChB;AACA;;EAEE,kBAAkB;EAClB,6BAA6B;AAC/B;AACA;EACE,kBAAkB;AACpB;AACA;EACE,qCAAqC;AACvC;AACA;EACE,eAAe;EACf,gBAAgB;EAChB,cAAc;AAChB;AACA;EACE,sBAAsB;EACtB,uBAAuB;EACvB,aAAa;EACb,mBAAmB;AACrB;;AAEA;EACE,YAAY;AACd;;AAEA;EACE,gBAAgB;EAChB,aAAa;EACb,SAAS;AACX;;AAEA;EACE,WAAW;EACX,YAAY;EACZ,kBAAkB;EAClB,mBAAmB;EACnB,aAAa;EACb,uBAAuB;EACvB,mBAAmB;EACnB,gBAAgB;AAClB;AACA;EACE,aAAa;EACb,mBAAmB;EACnB,uBAAuB;EACvB,WAAW;EACX,YAAY;AACd;;AAEA;EACE,WAAW;EACX,WAAW;EACX,YAAY;AACd;AACA;EACE,YAAY;EACZ,cAAc;EACd,gBAAgB;EAChB,oBAAoB;AACtB;;AAEA,cAAc;AACd;EACE,2BAA2B;EAC3B,YAAY;EACZ,kBAAkB;EAClB,kBAAkB;EAClB,gBAAgB;AAClB;AACA;EACE,YAAY;AACd;AACA;EACE,mBAAmB;EACnB,sCAAsC;AACxC;AACA;EACE,yBAAyB;EACzB,YAAY;EACZ,YAAY;EACZ,iBAAiB;AACnB;AACA;EACE,uBAAuB;EACvB,kBAAkB;EAClB,eAAe;AACjB;AACA;EACE,uBAAuB;AACzB;AACA;EACE,mBAAmB;EACnB,6BAA6B;AAC/B;AACA;EACE,qBAAqB;AACvB;AACA;EACE,aAAa;AACf;AACA;EACE,eAAe;EACf,gBAAgB;EAChB,cAAc;AAChB;;AAEA;EACE,SAAS;EACT,6BAA6B;AAC/B;AACA;EACE,eAAe;EACf,cAAc;EACd,gBAAgB;EAChB,0BAA0B;EAC1B,oBAAoB;EACpB,kBAAkB;AACpB;AACA;EACE,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,8BAA8B;EAC9B,YAAY;EACZ;0CACwC;AAC1C;;AAEA;EACE,eAAe;EACf,gBAAgB;EAChB,oBAAoB;AACtB;AACA;EACE,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,iBAAiB;EACjB,kBAAkB;EAClB,SAAS;EACT,WAAW;EACX,YAAY;EACZ,mBAAmB;EACnB,qBAAqB;EACrB,0BAA0B;AAC5B;AACA;EACE,kBAAkB;EAClB,WAAW;AACb;AACA;;EAEE,wBAAwB;EACxB,SAAS;AACX;AACA;EACE,4BAA4B;EAC5B,aAAa;EACb,aAAa;EACb,cAAc;EACd,eAAe;EACf,gBAAgB;AAClB;AACA,YAAY;AACZ;EACE,0BAA0B;AAC5B;AACA;EACE,oBAAoB;AACtB;AACA;EACE,uBAAuB;AACzB;AACA;EACE,YAAY;EACZ,oCAAoC;EACpC;oCACkC;EAClC,gBAAgB;AAClB;AACA;EACE,+BAA+B;AACjC;AACA;EACE,WAAW;EACX,6BAA6B;EAC7B,kBAAkB;EAClB,UAAU;EACV,OAAO;EACP,WAAW;EACX,SAAS;EACT,6BAA6B;AAC/B;AACA;EACE,UAAU;EACV,iBAAiB;AACnB;;AAEA,WAAW;AACX;EACE,mBAAmB;EACnB,WAAW;EACX,aAAa;EACb,gBAAgB;AAClB;AACA;EACE,aAAa;EACb,8BAA8B;EAC9B,mBAAmB;EACnB,eAAe;AACjB;AACA;EACE,eAAe;EACf,gBAAgB;EAChB,cAAc;EACd,gBAAgB;EAChB,kBAAkB;AACpB;AACA;EACE,eAAe;EACf,cAAc;AAChB;AACA;EACE,eAAe;EACf,yBAAyB;EACzB,qBAAqB;AACvB;AACA;EACE,aAAa;AACf;AACA,yBAAyB;AACzB;EACE,mBAAmB;EACnB,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,gBAAgB;EAChB,eAAe;AACjB;AACA;EACE,0BAA0B;EAC1B,cAAc;AAChB;AACA,iBAAiB;AACjB;EACE,UAAU;EACV,iBAAiB;EACjB,gBAAgB;EAChB,cAAc;EACd,aAAa;EACb,iBAAiB;EACjB,8BAA8B;AAChC;AACA,mBAAmB;AACnB;EACE;IACE,UAAU;IACV,gBAAgB;EAClB;EACA;IACE,WAAW;EACb;EACA;IACE,cAAc;EAChB;EACA;IACE,WAAW;EACb;AACF;AACA;EACE;IACE,kCAAkC;EACpC;AACF;AACA;EACE;IACE,WAAW;IACX,gBAAgB;EAClB;EACA;IACE,aAAa;EACf;EACA;IACE,uBAAuB;EACzB;AACF;AACA;EACE,UAAU;EACV,iBAAiB;EACjB,gBAAgB;EAChB,cAAc;EACd,wBAAwB;EACxB,iBAAiB;EACjB,8BAA8B;AAChC;AACA;;;;;;;;;GASG;;AAEH,iBAAiB;AACjB;EACE;;;;IAIE,wBAAwB,EAAE,yCAAyC;EACrE;;EAEA;IACE,iBAAiB;IACjB,YAAY;EACd;;EAEA,yCAAyC;EACzC;IACE,WAAW;IACX,UAAU;IACV,SAAS;EACX;;EAEA;;IAEE,YAAY;EACd;AACF;AACA;;;;;GAKG;AACH;EACE,aAAa;EACb,yBAAyB;EACzB,SAAS;EACT,gBAAgB;EAChB,sBAAsB;EACtB,kBAAkB;EAClB,UAAU;EACV,QAAQ;AACV;;AAEA;EACE,mBAAmB;EACnB,UAAU;AACZ',
            sourcesContent: [
              "/* form css start */\r\nbody {\r\n  font-family: Arial, sans-serif;\r\n}\r\n/* header */\r\n.header-sec {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  padding: 20px 0px;\r\n  background-color: #fff;\r\n}\r\n.btns {\r\n  background-color: #d0b870;\r\n  color: white;\r\n  border: none;\r\n  font-size: 16px;\r\n  font-weight: bold;\r\n  border-radius: 50px;\r\n  transition: background 0.3s ease-in-out;\r\n  width: 45px;\r\n  height: 45px;\r\n  z-index: 4;\r\n}\r\n.download i {\r\n  font-size: 18px;\r\n}\r\n.table-design h5 {\r\n  font-weight: 600;\r\n  color: #d0b870;\r\n}\r\n#yearlyTables th,\r\ntd {\r\n  text-align: center;\r\n  padding: 18px 10px !important;\r\n}\r\n#yearlyTables table {\r\n  text-align: center;\r\n}\r\n.table {\r\n  --bs-table-bg: transparent !important;\r\n}\r\n#yearlyTables th {\r\n  font-size: 19px;\r\n  font-weight: 700;\r\n  color: #d0b870;\r\n}\r\ncanvas {\r\n  width: 100% !important;\r\n  height: 100% !important;\r\n  padding: 20px;\r\n  object-fit: contain;\r\n}\r\n\r\n.logo img {\r\n  width: 150px;\r\n}\r\n\r\n.iconbar ul {\r\n  list-style: none;\r\n  display: flex;\r\n  gap: 15px;\r\n}\r\n\r\n.icon-item {\r\n  width: 36px;\r\n  height: 36px;\r\n  border-radius: 50%;\r\n  background: #d0b870;\r\n  display: flex;\r\n  justify-content: center;\r\n  align-items: center;\r\n  transition: 0.3s;\r\n}\r\n.icon-item a {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  width: 100%;\r\n  height: 100%;\r\n}\r\n\r\n.icon-item svg {\r\n  fill: white;\r\n  width: 20px;\r\n  height: 20px;\r\n}\r\n.uk-navbar-toggle {\r\n  padding: 0 0;\r\n  color: #2f2f2f;\r\n  font-weight: 300;\r\n  text-transform: none;\r\n}\r\n\r\n/* css start */\r\n.nav-pills .nav-link.active {\r\n  background-color: #000000a3;\r\n  color: white;\r\n  border-radius: 5px;\r\n  padding: 14px 30px;\r\n  font-weight: 600;\r\n}\r\n.nav-pills .nav-link {\r\n  color: black;\r\n}\r\n.card {\r\n  border-radius: 12px;\r\n  box-shadow: 0px 0px 16px 0px #00000040;\r\n}\r\n.input-group-text {\r\n  background-color: #206ba4;\r\n  color: white;\r\n  border: none;\r\n  background: black;\r\n}\r\n.card button {\r\n  background-color: black;\r\n  padding: 14px 20px;\r\n  font-size: 16px;\r\n}\r\n.card button:hover {\r\n  background-color: black;\r\n}\r\n.card-1 {\r\n  background: #206ba4;\r\n  margin-block: 40px !important;\r\n}\r\n.form-control {\r\n  padding: 20px 0.75rem;\r\n}\r\n.card-2 {\r\n  padding: 20px;\r\n}\r\n.card-2-inner h4 {\r\n  font-size: 26px;\r\n  font-weight: 700;\r\n  color: #d0b870;\r\n}\r\n\r\n.card-service {\r\n  gap: 20px;\r\n  justify-content: space-around;\r\n}\r\n.tab-content h1 {\r\n  font-size: 40px;\r\n  color: #d0b870;\r\n  font-weight: 700;\r\n  text-transform: capitalize;\r\n  padding-bottom: 10px;\r\n  position: relative;\r\n}\r\n.result {\r\n  font-size: 24px;\r\n  font-weight: 500;\r\n}\r\n.card-2-inner {\r\n  padding-block: 40px !important;\r\n  height: 100%;\r\n  box-shadow: rgba(0, 0, 0, 0.02) 0px 1px 3px 0px,\r\n    rgba(27, 31, 35, 0.15) 0px 0px 0px 1px;\r\n}\r\n\r\n.card-2-inner h5 {\r\n  font-size: 22px;\r\n  font-weight: 700;\r\n  padding-bottom: 20px;\r\n}\r\n.card-2-inner p {\r\n  font-size: 22px;\r\n  font-weight: 700;\r\n}\r\n.input-circle span {\r\n  padding: 2px 12px;\r\n  position: absolute;\r\n  top: 12px;\r\n  right: 15px;\r\n  color: white;\r\n  border-radius: 34px;\r\n  background: lightgray;\r\n  cursor: pointer !important;\r\n}\r\n.form-floating {\r\n  position: relative;\r\n  width: 100%;\r\n}\r\ninput::-webkit-outer-spin-button,\r\ninput::-webkit-inner-spin-button {\r\n  -webkit-appearance: none;\r\n  margin: 0;\r\n}\r\n.error {\r\n  text-align: start !important;\r\n  display: flex;\r\n  padding: 10px;\r\n  color: #852828;\r\n  font-size: 16px;\r\n  font-weight: 600;\r\n}\r\n/* Firefox */\r\ninput[type='number'] {\r\n  -moz-appearance: textfield;\r\n}\r\n.form-control {\r\n  padding: 8px 0.75rem;\r\n}\r\n.accordion-body {\r\n  background-color: white;\r\n}\r\n.accordion-button:not(.collapsed) {\r\n  color: white;\r\n  background-color: #d0b870 !important;\r\n  box-shadow: inset 0 calc(-1 * var(--bs-accordion-border-width)) 0\r\n    var(--bs-accordion-border-color);\r\n  font-weight: 600;\r\n}\r\n.accordion-button:not(.collapsed)::after {\r\n  filter: brightness(0) invert(1);\r\n}\r\n.tab-content h1::after {\r\n  content: '';\r\n  border-bottom: 2px solid #000;\r\n  position: absolute;\r\n  width: 40%;\r\n  left: 0;\r\n  bottom: 1px;\r\n  left: 50%;\r\n  transform: translate(-50%, 0);\r\n}\r\n.space {\r\n  width: 77%;\r\n  margin: 20px auto;\r\n}\r\n\r\n/* footer */\r\nfooter {\r\n  background: #2f2f2f;\r\n  color: #fff;\r\n  padding: 10px;\r\n  margin-top: 4rem;\r\n}\r\n.footer-sec {\r\n  display: flex;\r\n  justify-content: space-between;\r\n  align-items: center;\r\n  flex-wrap: wrap;\r\n}\r\n.copyright p {\r\n  font-size: 17px;\r\n  line-height: 1.2;\r\n  color: #b0a4ac;\r\n  font-weight: 300;\r\n  text-align: center;\r\n}\r\n.website p {\r\n  font-size: 15px;\r\n  color: #d0b870;\r\n}\r\n.website a {\r\n  font-size: 15px;\r\n  color: #b0a4ac !important;\r\n  text-decoration: none;\r\n}\r\n.footer-item {\r\n  margin: 5px 0;\r\n}\r\n/* projection css start */\r\ndiv#projections h3 {\r\n  padding-block: 23px;\r\n  font-size: 26px;\r\n  font-weight: 700;\r\n}\r\ndiv#projections ul li {\r\n  list-style: none;\r\n  font-size: 20px;\r\n}\r\np.dynamicPara {\r\n  font-size: 24px !important;\r\n  color: #d0b870;\r\n}\r\n/* dropdown css */\r\nselect#timeDuration {\r\n  width: 15%;\r\n  margin-left: auto;\r\n  font-weight: 700;\r\n  color: #d0b870;\r\n  padding: 18px;\r\n  border: 2px solid;\r\n  background: rgba(0, 0, 0, 0.8);\r\n}\r\n/*-- responisve --*/\r\n@media screen and (max-width: 991px) {\r\n  select#timeDuration {\r\n    width: 45%;\r\n    margin-top: 40px;\r\n  }\r\n  .row.mob-block > div {\r\n    width: 100%;\r\n  }\r\n  .row.mob-block {\r\n    display: block;\r\n  }\r\n  .space {\r\n    width: 100%;\r\n  }\r\n}\r\n@media (max-width: 760px) {\r\n  .footer-sec {\r\n    justify-content: center !important;\r\n  }\r\n}\r\n@media (max-width: 500px) {\r\n  select#timeDuration {\r\n    width: 100%;\r\n    margin-top: 40px;\r\n  }\r\n  .iconbar {\r\n    display: none;\r\n  }\r\n  .header-sec {\r\n    justify-content: center;\r\n  }\r\n}\r\n.drops {\r\n  width: 15%;\r\n  margin-left: auto;\r\n  font-weight: 700;\r\n  color: #d0b870;\r\n  padding: 18px !important;\r\n  border: 2px solid;\r\n  background: rgba(0, 0, 0, 0.8);\r\n}\r\n/* \r\n.print-button {\r\n  padding: 10px 20px;\r\n  background-color: #d0b870;\r\n  color: white;\r\n  border: none;\r\n  border-radius: 6px;\r\n  cursor: pointer;\r\n  margin-top: 20px;\r\n} */\r\n\r\n/* Print Styles */\r\n@media print {\r\n  .print-button,\r\n  .navigation-bar,\r\n  .sidebar,\r\n  .footer {\r\n    display: none !important; /* hide navbars, footers, buttons, etc. */\r\n  }\r\n\r\n  body {\r\n    background: white;\r\n    color: black;\r\n  }\r\n\r\n  /* Optional: adjust layout for printing */\r\n  .main-content {\r\n    width: 100%;\r\n    padding: 0;\r\n    margin: 0;\r\n  }\r\n\r\n  html,\r\n  body {\r\n    height: auto;\r\n  }\r\n}\r\n/* @media (max-width: 991px) {\r\n  .print-button {\r\n    top: -22px;\r\n    width: 50px;\r\n  }\r\n} */\r\n.btn-flex {\r\n  display: flex;\r\n  justify-content: flex-end;\r\n  gap: 20px;\r\n  align-items: end;\r\n  flex-direction: column;\r\n  position: absolute;\r\n  top: -25px;\r\n  right: 0;\r\n}\r\n\r\nhtml {\r\n  visibility: visible;\r\n  opacity: 1;\r\n}\r\n",
            ],
            sourceRoot: '',
          },
        ]);
        // Exports
        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          ___CSS_LOADER_EXPORT___;

        /***/
      },

    /***/ './node_modules/css-loader/dist/runtime/api.js':
      /*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
      /***/ (module) => {
        /*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
        module.exports = function (cssWithMappingToString) {
          var list = [];

          // return the list of modules as css string
          list.toString = function toString() {
            return this.map(function (item) {
              var content = '';
              var needLayer = typeof item[5] !== 'undefined';
              if (item[4]) {
                content += '@supports ('.concat(item[4], ') {');
              }
              if (item[2]) {
                content += '@media '.concat(item[2], ' {');
              }
              if (needLayer) {
                content += '@layer'.concat(
                  item[5].length > 0 ? ' '.concat(item[5]) : '',
                  ' {'
                );
              }
              content += cssWithMappingToString(item);
              if (needLayer) {
                content += '}';
              }
              if (item[2]) {
                content += '}';
              }
              if (item[4]) {
                content += '}';
              }
              return content;
            }).join('');
          };

          // import a list of modules into the list
          list.i = function i(modules, media, dedupe, supports, layer) {
            if (typeof modules === 'string') {
              modules = [[null, modules, undefined]];
            }
            var alreadyImportedModules = {};
            if (dedupe) {
              for (var k = 0; k < this.length; k++) {
                var id = this[k][0];
                if (id != null) {
                  alreadyImportedModules[id] = true;
                }
              }
            }
            for (var _k = 0; _k < modules.length; _k++) {
              var item = [].concat(modules[_k]);
              if (dedupe && alreadyImportedModules[item[0]]) {
                continue;
              }
              if (typeof layer !== 'undefined') {
                if (typeof item[5] === 'undefined') {
                  item[5] = layer;
                } else {
                  item[1] = '@layer'
                    .concat(item[5].length > 0 ? ' '.concat(item[5]) : '', ' {')
                    .concat(item[1], '}');
                  item[5] = layer;
                }
              }
              if (media) {
                if (!item[2]) {
                  item[2] = media;
                } else {
                  item[1] = '@media '
                    .concat(item[2], ' {')
                    .concat(item[1], '}');
                  item[2] = media;
                }
              }
              if (supports) {
                if (!item[4]) {
                  item[4] = ''.concat(supports);
                } else {
                  item[1] = '@supports ('
                    .concat(item[4], ') {')
                    .concat(item[1], '}');
                  item[4] = supports;
                }
              }
              list.push(item);
            }
          };
          return list;
        };

        /***/
      },

    /***/ './node_modules/css-loader/dist/runtime/sourceMaps.js':
      /*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
      /***/ (module) => {
        module.exports = function (item) {
          var content = item[1];
          var cssMapping = item[3];
          if (!cssMapping) {
            return content;
          }
          if (typeof btoa === 'function') {
            var base64 = btoa(
              unescape(encodeURIComponent(JSON.stringify(cssMapping)))
            );
            var data =
              'sourceMappingURL=data:application/json;charset=utf-8;base64,'.concat(
                base64
              );
            var sourceMapping = '/*# '.concat(data, ' */');
            return [content].concat([sourceMapping]).join('\n');
          }
          return [content].join('\n');
        };

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js':
      /*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
      /***/ (module) => {
        var stylesInDOM = [];
        function getIndexByIdentifier(identifier) {
          var result = -1;
          for (var i = 0; i < stylesInDOM.length; i++) {
            if (stylesInDOM[i].identifier === identifier) {
              result = i;
              break;
            }
          }
          return result;
        }
        function modulesToDom(list, options) {
          var idCountMap = {};
          var identifiers = [];
          for (var i = 0; i < list.length; i++) {
            var item = list[i];
            var id = options.base ? item[0] + options.base : item[0];
            var count = idCountMap[id] || 0;
            var identifier = ''.concat(id, ' ').concat(count);
            idCountMap[id] = count + 1;
            var indexByIdentifier = getIndexByIdentifier(identifier);
            var obj = {
              css: item[1],
              media: item[2],
              sourceMap: item[3],
              supports: item[4],
              layer: item[5],
            };
            if (indexByIdentifier !== -1) {
              stylesInDOM[indexByIdentifier].references++;
              stylesInDOM[indexByIdentifier].updater(obj);
            } else {
              var updater = addElementStyle(obj, options);
              options.byIndex = i;
              stylesInDOM.splice(i, 0, {
                identifier: identifier,
                updater: updater,
                references: 1,
              });
            }
            identifiers.push(identifier);
          }
          return identifiers;
        }
        function addElementStyle(obj, options) {
          var api = options.domAPI(options);
          api.update(obj);
          var updater = function updater(newObj) {
            if (newObj) {
              if (
                newObj.css === obj.css &&
                newObj.media === obj.media &&
                newObj.sourceMap === obj.sourceMap &&
                newObj.supports === obj.supports &&
                newObj.layer === obj.layer
              ) {
                return;
              }
              api.update((obj = newObj));
            } else {
              api.remove();
            }
          };
          return updater;
        }
        module.exports = function (list, options) {
          options = options || {};
          list = list || [];
          var lastIdentifiers = modulesToDom(list, options);
          return function update(newList) {
            newList = newList || [];
            for (var i = 0; i < lastIdentifiers.length; i++) {
              var identifier = lastIdentifiers[i];
              var index = getIndexByIdentifier(identifier);
              stylesInDOM[index].references--;
            }
            var newLastIdentifiers = modulesToDom(newList, options);
            for (var _i = 0; _i < lastIdentifiers.length; _i++) {
              var _identifier = lastIdentifiers[_i];
              var _index = getIndexByIdentifier(_identifier);
              if (stylesInDOM[_index].references === 0) {
                stylesInDOM[_index].updater();
                stylesInDOM.splice(_index, 1);
              }
            }
            lastIdentifiers = newLastIdentifiers;
          };
        };

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/insertBySelector.js':
      /*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
      /***/ (module) => {
        var memo = {};

        /* istanbul ignore next  */
        function getTarget(target) {
          if (typeof memo[target] === 'undefined') {
            var styleTarget = document.querySelector(target);

            // Special case to return head of iframe instead of iframe itself
            if (
              window.HTMLIFrameElement &&
              styleTarget instanceof window.HTMLIFrameElement
            ) {
              try {
                // This will throw an exception if access to iframe is blocked
                // due to cross-origin restrictions
                styleTarget = styleTarget.contentDocument.head;
              } catch (e) {
                // istanbul ignore next
                styleTarget = null;
              }
            }
            memo[target] = styleTarget;
          }
          return memo[target];
        }

        /* istanbul ignore next  */
        function insertBySelector(insert, style) {
          var target = getTarget(insert);
          if (!target) {
            throw new Error(
              "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
            );
          }
          target.appendChild(style);
        }
        module.exports = insertBySelector;

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/insertStyleElement.js':
      /*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
      /***/ (module) => {
        /* istanbul ignore next  */
        function insertStyleElement(options) {
          var element = document.createElement('style');
          options.setAttributes(element, options.attributes);
          options.insert(element, options.options);
          return element;
        }
        module.exports = insertStyleElement;

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js':
      /*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
      /***/ (module, __unused_webpack_exports, __webpack_require__) => {
        /* istanbul ignore next  */
        function setAttributesWithoutAttributes(styleElement) {
          var nonce = true ? __webpack_require__.nc : 0;
          if (nonce) {
            styleElement.setAttribute('nonce', nonce);
          }
        }
        module.exports = setAttributesWithoutAttributes;

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/styleDomAPI.js':
      /*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
      /***/ (module) => {
        /* istanbul ignore next  */
        function apply(styleElement, options, obj) {
          var css = '';
          if (obj.supports) {
            css += '@supports ('.concat(obj.supports, ') {');
          }
          if (obj.media) {
            css += '@media '.concat(obj.media, ' {');
          }
          var needLayer = typeof obj.layer !== 'undefined';
          if (needLayer) {
            css += '@layer'.concat(
              obj.layer.length > 0 ? ' '.concat(obj.layer) : '',
              ' {'
            );
          }
          css += obj.css;
          if (needLayer) {
            css += '}';
          }
          if (obj.media) {
            css += '}';
          }
          if (obj.supports) {
            css += '}';
          }
          var sourceMap = obj.sourceMap;
          if (sourceMap && typeof btoa !== 'undefined') {
            css +=
              '\n/*# sourceMappingURL=data:application/json;base64,'.concat(
                btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))),
                ' */'
              );
          }

          // For old IE
          /* istanbul ignore if  */
          options.styleTagTransform(css, styleElement, options.options);
        }
        function removeStyleElement(styleElement) {
          // istanbul ignore if
          if (styleElement.parentNode === null) {
            return false;
          }
          styleElement.parentNode.removeChild(styleElement);
        }

        /* istanbul ignore next  */
        function domAPI(options) {
          if (typeof document === 'undefined') {
            return {
              update: function update() {},
              remove: function remove() {},
            };
          }
          var styleElement = options.insertStyleElement(options);
          return {
            update: function update(obj) {
              apply(styleElement, options, obj);
            },
            remove: function remove() {
              removeStyleElement(styleElement);
            },
          };
        }
        module.exports = domAPI;

        /***/
      },

    /***/ './node_modules/style-loader/dist/runtime/styleTagTransform.js':
      /*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
      /***/ (module) => {
        /* istanbul ignore next  */
        function styleTagTransform(css, styleElement) {
          if (styleElement.styleSheet) {
            styleElement.styleSheet.cssText = css;
          } else {
            while (styleElement.firstChild) {
              styleElement.removeChild(styleElement.firstChild);
            }
            styleElement.appendChild(document.createTextNode(css));
          }
        }
        module.exports = styleTagTransform;

        /***/
      },

    /***/ './src/budget-table.css':
      /*!******************************!*\
  !*** ./src/budget-table.css ***!
  \******************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ './node_modules/style-loader/dist/runtime/styleDomAPI.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ './node_modules/style-loader/dist/runtime/insertBySelector.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ './node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ './node_modules/style-loader/dist/runtime/insertStyleElement.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ './node_modules/style-loader/dist/runtime/styleTagTransform.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__
          );
        /* harmony import */ var _node_modules_css_loader_dist_cjs_js_budget_table_css__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! !!../node_modules/css-loader/dist/cjs.js!./budget-table.css */ './node_modules/css-loader/dist/cjs.js!./src/budget-table.css'
          );

        var options = {};

        options.styleTagTransform =
          _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default();
        options.setAttributes =
          _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default();
        options.insert =
          _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(
            null,
            'head'
          );
        options.domAPI =
          _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default();
        options.insertStyleElement =
          _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();

        var update =
          _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
            _node_modules_css_loader_dist_cjs_js_budget_table_css__WEBPACK_IMPORTED_MODULE_6__[
              'default'
            ],
            options
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _node_modules_css_loader_dist_cjs_js_budget_table_css__WEBPACK_IMPORTED_MODULE_6__[
            'default'
          ] &&
          _node_modules_css_loader_dist_cjs_js_budget_table_css__WEBPACK_IMPORTED_MODULE_6__[
            'default'
          ].locals
            ? _node_modules_css_loader_dist_cjs_js_budget_table_css__WEBPACK_IMPORTED_MODULE_6__[
                'default'
              ].locals
            : undefined;

        /***/
      },

    /***/ './src/calculators/calculate-retirement.js':
      /*!*************************************************!*\
  !*** ./src/calculators/calculate-retirement.js ***!
  \*************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ calculateRetirement,
          /* harmony export */
        });
        /* harmony import */ var _utils_format_number__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils/format-number */ './src/utils/format-number.js'
          );
        /* harmony import */ var _charts_asset_breakdown_chart__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../charts/asset-breakdown-chart */ './src/charts/asset-breakdown-chart.js'
          );
        /* harmony import */ var _charts_income_source_chart__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../charts/income-source-chart */ './src/charts/income-source-chart.js'
          );

        function calculateRetirement() {
          let currentAge = document.getElementById('currentAge');
          let retirementAge = document.getElementById('retirementAge');
          let expectedLifespan = document.getElementById('expectedLifespan');
          let currentSavings = document.getElementById('currentSavings');
          let monthlyContributions = document.getElementById(
            'monthlyContributions'
          );
          let annualReturn = document.getElementById('annualReturn');
          let inflationRate = document.getElementById('inflationRate');
          let desiredIncome = document.getElementById('desiredIncome');
          let realEstateAppreciation = document.getElementById(
            'realEstateAppreciation'
          );
          let mortgageBalance = document.getElementById('mortgageBalance');
          let wholeLifeInsurance =
            document.getElementById('wholeLifeInsurance');
          let lifeInsuranceMonthlyContributions = document.getElementById(
            'lifeInsuranceMonthlyContributions'
          );
          let mortgageTerm = document.getElementById('mortgageTerm');
          let mortgageInterestRate = document.getElementById(
            'mortgageInterestRate'
          );
          // 🆕 New inputs for Stock and Real Estate
          let currentStockValue = document.getElementById('currentStockValue');
          let currentRealEstateEquity = document.getElementById(
            'currentRealEstateEquity'
          );
          let stockGrowthRate = document.getElementById('stockGrowthRate');

          // ✅ Error messages
          let errors = {
            currentAge: document.getElementById('errorCurrentAge'),
            retirementAge: document.getElementById('errorRetirementAge'),
            expectedLifespan: document.getElementById('errorExpectedLifespan'),
            currentSavings: document.getElementById('errorCurrentSavings'),
            monthlyContributions: document.getElementById(
              'errorMonthlyContributions'
            ),
            annualReturn: document.getElementById('errorAnnualReturn'),
            inflationRate: document.getElementById('errorInflationRate'),
            desiredIncome: document.getElementById('errorDesiredIncome'),
            currentStockValue: document.getElementById(
              'errorCurrentStockValue'
            ),
            currentRealEstateEquity: document.getElementById(
              'errorCurrentRealEstateEquity'
            ),
            realEstateAppreciation: document.getElementById(
              'errorRealEstateAppreciation'
            ),
            mortgageBalance: document.getElementById('errormortgageBalance'),
            wholeLifeInsurance: document.getElementById(
              'errorwholeLifeInsurance'
            ),
            lifeInsuranceMonthlyContributions: document.getElementById(
              'errorLifeInsuranceMonthlyContributions'
            ),
            mortgageTerm: document.getElementById('errorMortgageTerm'),
            mortgageInterestRate: document.getElementById(
              'errorMortgageInterestRate'
            ),
            stockGrowthRate: document.getElementById('errorStockGrowthRate'),
          };
          // ✅ Clear previous errors
          Object.values(errors).forEach((error) => (error.innerText = ''));
          let isValid = true;

          // ✅ Validation function
          function validateInput(input, errorField, fieldName) {
            let min =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : 0;
            let max =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : Infinity;
            let value = parseFloat(input.value) || 0; // Fallback to 0 if empty
            if (value < min || value > max) {
              errorField.innerText = `${fieldName} must be a valid number (${min} - ${max}).`;
              isValid = false;
            }
          }

          // ✅ Validate all inputs
          validateInput(currentAge, errors.currentAge, 'Current Age', 18, 100);
          validateInput(
            retirementAge,
            errors.retirementAge,
            'Retirement Age',
            18,
            100
          );
          validateInput(
            expectedLifespan,
            errors.expectedLifespan,
            'Expected Lifespan',
            parseInt(currentAge.value, 10) || 18,
            120
          );
          validateInput(
            currentSavings,
            errors.currentSavings,
            'Current Savings',
            0
          );
          validateInput(
            monthlyContributions,
            errors.monthlyContributions,
            'Monthly Contributions',
            0
          );
          validateInput(
            annualReturn,
            errors.annualReturn,
            'Expected Annual Return (%)',
            0,
            100
          );
          validateInput(
            inflationRate,
            errors.inflationRate,
            'Inflation Rate (%)',
            0,
            100
          );
          validateInput(
            desiredIncome,
            errors.desiredIncome,
            'Desired Retirement Income',
            0
          );
          validateInput(
            currentStockValue,
            errors.currentStockValue,
            'Current Stock Value',
            0
          );
          validateInput(
            currentRealEstateEquity,
            errors.currentRealEstateEquity,
            'Current Real Estate Equity',
            0
          );
          validateInput(
            realEstateAppreciation,
            errors.realEstateAppreciation,
            'Real Estate Appreciation (%)',
            0,
            100
          );
          validateInput(
            mortgageBalance,
            errors.mortgageBalance,
            'Mortgage Balance',
            0
          );
          validateInput(
            wholeLifeInsurance,
            errors.wholeLifeInsurance,
            'Whole Life Insurance',
            0
          );
          validateInput(
            lifeInsuranceMonthlyContributions,
            errors.lifeInsuranceMonthlyContributions,
            'Life Insurance Monthly Contributions',
            0
          );
          // validateInput(mortgageTerm, errors.mortgageTerm, "Mortgage Term", 1, 50);
          validateInput(
            mortgageInterestRate,
            errors.mortgageInterestRate,
            'Mortgage Interest Rate',
            0,
            100
          );
          validateInput(
            stockGrowthRate,
            errors.stockGrowthRate,
            'Stock Growth Rate (%)',
            0,
            100
          );
          if (parseInt(currentAge.value) >= parseInt(retirementAge.value)) {
            errors.retirementAge.innerText =
              'Retirement age must be greater than current age.';
            isValid = false;
          }
          if (!isValid) return;

          // ✅ Variables for calculation
          let yearsToRetirement =
            parseInt(retirementAge.value) - parseInt(currentAge.value);
          let n = 12; // Monthly compounding
          let r = (parseFloat(annualReturn.value) || 0) / 100 / n; // Handle empty return gracefully
          let t = yearsToRetirement * n;

          // ✅ Future Value Calculations (Avoid NaN)
          let fvCurrentSavings =
            (parseFloat(currentSavings.value) || 0) *
            Math.pow(
              1 + (parseFloat(annualReturn.value) || 0) / 100,
              yearsToRetirement
            );
          let fvContributions =
            r !== 0
              ? (parseFloat(monthlyContributions.value) || 0) *
                (((Math.pow(1 + r, t) - 1) / r) * (1 + r))
              : 0;

          // ✅ Stock and Real Estate appreciation (Avoid NaN)
          let fvStock =
            (parseFloat(currentStockValue.value) || 0) *
            Math.pow(1 + 0.03, yearsToRetirement);
          let realEstateRate =
            (parseFloat(realEstateAppreciation.value) || 0) / 100;
          let adjustedMortgage = parseFloat(mortgageBalance.value) || 0;

          // Real estate equity: owned portion of equity minus owned mortgage
          let fvRealEstate =
            (parseFloat(currentRealEstateEquity.value) || 0) *
            Math.pow(1 + realEstateRate, yearsToRetirement);
          if (isNaN(fvRealEstate)) fvRealEstate = 0;
          // ✅ Total Savings (Check for NaN and fallback to 0)
          let lifeInsuranceMonthly =
            parseFloat(lifeInsuranceMonthlyContributions.value) || 0;
          let fvLifeInsuranceContributions =
            r !== 0
              ? lifeInsuranceMonthly * ((Math.pow(1 + r, t) - 1) / r) * (1 + r)
              : 0;
          let currentWholeLifeValue = parseFloat(wholeLifeInsurance.value) || 0;
          let fvWholeLifeLumpSum = currentWholeLifeValue * Math.pow(1 + r, t);
          let fvWholeLifeInsurance =
            fvWholeLifeLumpSum + fvLifeInsuranceContributions;
          let totalSavings =
            (isNaN(fvCurrentSavings) ? 0 : fvCurrentSavings) +
            (isNaN(fvContributions) ? 0 : fvContributions) +
            (isNaN(fvStock) ? 0 : fvStock) +
            (isNaN(fvRealEstate) ? 0 : fvRealEstate) +
            fvWholeLifeInsurance;
          // 🆕 Add remaining mortgage payments to savings if it ends before retirement
          const mortgageEndYears = mortgageTerm / 12;
          if (mortgageEndYears < yearsToRetirement) {
            const remainingYears = yearsToRetirement - mortgageEndYears;
            const futureExtraSavings =
              r !== 0
                ? monthlyPayment *
                  12 *
                  ((Math.pow(1 + r, remainingYears * n) - 1) / r) *
                  (1 + r)
                : 0;
            totalSavings += isNaN(futureExtraSavings) ? 0 : futureExtraSavings;
          }

          // ✅ Adjusted Income with Inflation (Fallback to 0)
          let adjustedIncome =
            (parseFloat(desiredIncome.value) || 0) *
            Math.pow(
              1 + (parseFloat(inflationRate.value) || 0) / 100,
              yearsToRetirement
            );

          // ✅ Time-based projections for all assets
          let projections = [];
          stockGrowthRate = stockGrowthRate.value / 100;
          for (let i = 5; i <= yearsToRetirement; i += 5) {
            const realEstateValue =
              (parseFloat(currentRealEstateEquity.value) || 0) *
              Math.pow(1 + realEstateRate, i);
            const principal = adjustedMortgage;
            const termMonths = parseFloat(mortgageTerm.value || 0) * 12;
            const monthlyRate =
              parseFloat(mortgageInterestRate.value || 0) / 100 / 12;
            const monthlyPayment =
              (principal *
                (monthlyRate * Math.pow(1 + monthlyRate, termMonths))) /
              (Math.pow(1 + monthlyRate, termMonths) - 1);
            const monthsPaid = Math.min(i * 12, termMonths);
            const remainingMortgage =
              principal * Math.pow(1 + monthlyRate, monthsPaid) -
              (monthlyPayment * (Math.pow(1 + monthlyRate, monthsPaid) - 1)) /
                monthlyRate;
            const netRealEstate = isNaN(realEstateValue - remainingMortgage)
              ? 0
              : realEstateValue - remainingMortgage;

            // 🆕 If mortgage is paid off, calculate the extra savings
            let extraInvestmentValue = 0;
            if (i * 12 > termMonths) {
              const extraMonths = i * 12 - termMonths;
              const extraMonthly = monthlyPayment;
              const extraYears = extraMonths / 12;
              extraInvestmentValue =
                r !== 0
                  ? extraMonthly *
                    12 *
                    ((Math.pow(1 + r, extraYears * n) - 1) / r) *
                    (1 + r)
                  : 0;
            }

            // 🧠 Insurance + extra investment FV
            const insuranceContributionFV =
              r !== 0
                ? lifeInsuranceMonthly *
                  ((Math.pow(1 + r, i * n) - 1) / r) *
                  (1 + r)
                : 0;
            const projectedWholeLifeInsurance =
              (parseFloat(wholeLifeInsurance.value) || 0) *
              Math.pow(1 + (parseFloat(annualReturn.value) || 0) / 100, i);
            const totalInsuranceValue =
              projectedWholeLifeInsurance + insuranceContributionFV;
            projections.push({
              year: i,
              stockValue:
                (parseFloat(currentStockValue.value) || 0) *
                Math.pow(1 + stockGrowthRate, i),
              realEstateValue: netRealEstate,
              insuranceValue: totalInsuranceValue,
              extraInvestmentValue: isNaN(extraInvestmentValue)
                ? 0
                : extraInvestmentValue,
            });
          }

          // ✅ Withdrawal Simulation
          let withdrawalYears = 0;
          let remainingBalance = totalSavings;
          let yearlyWithdrawal = adjustedIncome;
          while (remainingBalance > 0) {
            withdrawalYears++;

            // Prevent infinite loops
            if (withdrawalYears > 100) break;
            remainingBalance -= yearlyWithdrawal;
            remainingBalance *= 1 + (parseFloat(annualReturn.value) || 0) / 100;
            yearlyWithdrawal *=
              1 + (parseFloat(inflationRate.value) || 0) / 100;
          }
          expectedLifespan = expectedLifespan.value;
          let retirementYears =
            expectedLifespan - parseInt(retirementAge.value);
          let shortfallSurplusDiv = document.querySelector('.short');
          let shortfallSurplus;
          if (adjustedIncome === 0 || totalSavings === 0) {
            shortfallSurplus = '';
            shortfallSurplusDiv.style.backgroundColor = '#FFF';
            document.querySelector('.shortcap').style.color = '';
          } else if (withdrawalYears >= retirementYears) {
            shortfallSurplus = 'Surplus (Funds last throughout retirement)';
            shortfallSurplusDiv.style.backgroundColor = '#d0b870';
            document.querySelector('.shortcap').style.color = 'black';
          } else {
            document.querySelector('.shortcap').style.color = '#d0b870';
            shortfallSurplus = `Funds wont last throughout the retirement years, short by ${
              retirementYears - withdrawalYears
            } years)`;
            shortfallSurplusDiv.style.backgroundColor = '#f86d6d';
          }

          // ✅ Display Output
          if (annualReturn.value != '') {
            document.getElementById('totalSavings').innerHTML = `${(0,
            _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
              totalSavings
            )}`;
            let totalSavingsEl = document.getElementById('totalSavings');
            let totalSavingsCard = document.querySelector('.totalSavingsCard');
            let totalSavingshead = document.querySelector('.totalSavingshead');
            totalSavingsEl.style.color = 'black';
            totalSavingshead.style.color = 'black';
            totalSavingsCard.style.background = '#d0b870';
          }
          document.getElementById('annualWithdrawal').innerHTML = `${(0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            adjustedIncome
          )}`;

          // Only display years until depletion if desired income filled
          if (desiredIncome.value && inflationRate.value) {
            let displayYears = isNaN(withdrawalYears)
              ? 'N/A'
              : withdrawalYears > 100
              ? '> 100'
              : withdrawalYears;
            document.getElementById(
              'yearsUntilDepletion'
            ).innerHTML = `${displayYears}`;
          } else {
            document.getElementById('yearsUntilDepletion').innerHTML = '';
          }
          document.getElementById('shortfallSurplus').innerHTML = isNaN(
            withdrawalYears
          )
            ? 'N/A'
            : shortfallSurplus;

          // ✅ Display New Projections
          let projectionsDiv = document.getElementById('projections');
          projectionsDiv.innerHTML = `<h3 class="dynamicHead">Time-based Asset Projections:</h3>`;
          projections.forEach((proj) => {
            const total =
              proj.stockValue + proj.realEstateValue + proj.insuranceValue;
            projectionsDiv.innerHTML += `
        <p class="dynamicPara">In <strong>${proj.year} years:</strong></p>
        <ul>
          <li class="dynamicList">Stock Value: ${(0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            proj.stockValue
          )}</li>
          <li class="dynamicList">Real Estate Value: ${(0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            proj.realEstateValue
          )}</li>
          <li class="dynamicList">Life Insurance Value: ${(0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            proj.insuranceValue
          )}</li>
          <li class="dynamicList"><strong>Total Value: ${(0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            total
          )}</strong></li>
        </ul>`;
          });
          if (
            fvStock > 0 ||
            fvRealEstate > 0 ||
            fvWholeLifeInsurance > 0 ||
            fvContributions > 0
          ) {
            (0,
            _charts_asset_breakdown_chart__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ])(
              fvStock,
              fvRealEstate,
              fvWholeLifeInsurance,
              fvCurrentSavings + fvContributions
            );
            (0,
            _charts_income_source_chart__WEBPACK_IMPORTED_MODULE_2__[
              'default'
            ])(fvContributions, fvStock, fvRealEstate, fvWholeLifeInsurance);
          }
        }

        /***/
      },

    /***/ './src/calculators/house-flip.js':
      /*!***************************************!*\
  !*** ./src/calculators/house-flip.js ***!
  \***************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ calculateHouseFlip,
          /* harmony export */
        });
        /* harmony import */ var _utils_format_number__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils/format-number */ './src/utils/format-number.js'
          );
        /* harmony import */ var _utils_format_number_percent__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../utils/format-number-percent */ './src/utils/format-number-percent.js'
          );
        /* harmony import */ var _chart_utils_reset_canvas__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../chart-utils/reset-canvas */ './src/chart-utils/reset-canvas.js'
          );
        /* harmony import */ var _charts_project_cost_breakdown_chart__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../charts/project-cost-breakdown-chart */ './src/charts/project-cost-breakdown-chart.js'
          );
        /* harmony import */ var _charts_arv_distribution_chart__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../charts/arv-distribution-chart */ './src/charts/arv-distribution-chart.js'
          );
        /* harmony import */ var _utils_interest_project_duration__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ../utils/interest-project-duration */ './src/utils/interest-project-duration.js'
          );

        function calculateHouseFlip() {
          let purchase =
            parseFloat(document.getElementById('purchasePrice').value) || 0;
          let reno =
            parseFloat(document.getElementById('renoCosts').value) || 0;
          let holding =
            parseFloat(document.getElementById('holdingCosts').value) || 0;
          let arv =
            parseFloat(document.getElementById('afterRepairValue').value) || 0;
          let desiredProfitMargin =
            parseFloat(document.getElementById('desiredProfitMargin').value) ||
            0;
          // Loan & Gap Fields
          let interestRate =
            parseFloat(document.getElementById('houseinterestRate').value) || 0;
          let loanPoints =
            parseFloat(document.getElementById('loanPoints').value) || 0;
          let termYears =
            parseFloat(document.getElementById('houseLoanYear').value) || 0;
          let totalPayments = termYears * 12;
          let gapFundingRate =
            parseFloat(document.getElementById('gapCosts').value) || 0;
          // Additional Fields
          let downPaymentPercent =
            parseFloat(document.getElementById('downPaymentPercent').value) ||
            0;
          // let commissionPercent = parseFloat(document.getElementById("commissionPercent").value) || 0;
          let resaleCostPercent =
            parseFloat(document.getElementById('resaleCosts').value) || 0;
          let resaleCosts = (arv * resaleCostPercent) / 100;
          let address = document.getElementById('propertyAddress').value;
          let months =
            parseFloat(document.getElementById('projectMonths').value) || 0;
          let monthlyRent =
            parseFloat(document.getElementById('houseMonthlyRent').value) || 0;
          let annualPropertyTaxes =
            parseFloat(document.getElementById('propertyTaxesHF').value) || 0;
          let annualInsurance =
            parseFloat(document.getElementById('insurance').value) || 0;
          let annualMaintenance =
            parseFloat(
              document.getElementById('houseAnnualMaintenance').value
            ) || 0;
          let annualUtilities =
            parseFloat(document.getElementById('houseAnnualUtilities').value) ||
            0;
          let downPaymentType =
            document.getElementById('downPaymentType').value;
          let downPaymentBase =
            downPaymentType === 'purchaseAndReno' ? purchase + reno : purchase;
          let closing =
            parseFloat(document.getElementById('closingCosts').value) || 0;
          let downPayment = (downPaymentBase * downPaymentPercent) / 100;
          let monthlyRate = interestRate / 100 / 12;
          let loanAmount =
            downPaymentType === 'purchaseAndReno'
              ? purchase + reno - downPayment
              : purchase - downPayment;
          let proratedMaintenance = (annualMaintenance / 12) * months;
          let proratedUtilities = (annualUtilities / 12) * months;

          // let loanInterest = (loanAmount * (interestRate / 100)) * (months / 12);
          let loanFees = (loanAmount * loanPoints) / 100;
          let proratedTaxes = (annualPropertyTaxes / 12) * months;
          let proratedInsurance = (annualInsurance / 12) * months;
          let monthlyMortgagePayment =
            termYears > 0
              ? (loanAmount * monthlyRate) /
                (1 - Math.pow(1 + monthlyRate, -totalPayments))
              : 0;
          let totalMortgagePaid = monthlyMortgagePayment * months;
          let interestPaid = (0,
          _utils_interest_project_duration__WEBPACK_IMPORTED_MODULE_5__[
            'default'
          ])(loanAmount, monthlyMortgagePayment, months, monthlyRate);
          let loanInterest = interestPaid;
          let totalProjectCost =
            purchase +
            reno +
            holding +
            closing +
            resaleCosts +
            totalMortgagePaid +
            loanFees +
            proratedTaxes +
            proratedInsurance +
            proratedMaintenance +
            proratedUtilities;
          // **Corrected Investment Calculation**
          let gapCosts = totalProjectCost - (loanAmount + downPayment);
          let gapFundingFees =
            gapCosts > 0 ? (gapCosts * gapFundingRate) / 100 : 0;
          let totalInvestment =
            purchase +
            reno +
            holding +
            closing +
            totalMortgagePaid +
            loanFees +
            gapFundingFees +
            proratedTaxes +
            proratedInsurance +
            proratedMaintenance +
            proratedUtilities;
          let totalCashInvested =
            downPayment +
            (downPaymentType !== 'purchaseAndReno' ? reno : 0) +
            holding +
            closing +
            totalMortgagePaid +
            gapFundingFees +
            proratedTaxes +
            proratedInsurance +
            proratedMaintenance +
            proratedUtilities +
            loanFees;

          // ✅ Profit Calculation
          let grossProfit = arv - purchase;
          let netProfit = arv - totalInvestment - resaleCosts;

          // ✅ Profit Margin & Cash-on-Cash Return
          let profitMargin = arv > 0 ? (netProfit / arv) * 100 : 0;
          let cashOnCashReturn =
            totalCashInvested > 0 ? (netProfit / totalCashInvested) * 100 : 0;
          let totalHoldingExpenses =
            holding +
            proratedTaxes +
            proratedInsurance +
            proratedMaintenance +
            proratedUtilities +
            loanInterest +
            gapFundingFees;

          // ✅ Break-even Years Calculation
          let monthlyRentalProfit = (
            arv * 0.01 -
            totalHoldingExpenses / months
          ).toFixed(2);
          let breakEvenYears =
            Number(monthlyRentalProfit) > 0 && netProfit > 0
              ? (netProfit / (Number(monthlyRentalProfit) * 12)).toFixed(2)
              : 'N/A';
          let monthlyHoldingCost =
            months > 0 ? (totalHoldingExpenses / months).toFixed(2) : 0;

          // ✅ Flipping vs. Rental Analysis
          let rentalVsFlip =
            netProfit > 0 && monthlyRent > 0
              ? (netProfit / monthlyRent).toFixed(2)
              : 'N/A';
          // ✅ Profit Min % and $ Calculation
          let profitMinPercent = (profitMargin * 0.8).toFixed(2); // Assuming 80% of profit margin as min
          let profitMinDollar = (netProfit * 0.8).toFixed(2); // 80% of the net profit as min
          let projection = (netProfit * 0.9).toFixed(2); // Projection at 90% of the net profit

          // ✅ Deal? Logic
          let deal =
            profitMargin >= desiredProfitMargin && netProfit > 0 ? 'YES' : 'NO';
          let requiredARV =
            desiredProfitMargin > 0
              ? totalInvestment / (1 - desiredProfitMargin / 100)
              : 0;
          let totalInvestmentExcludingPurchase =
            reno +
            holding +
            loanInterest +
            loanFees +
            gapFundingFees +
            proratedTaxes +
            proratedInsurance +
            proratedMaintenance +
            proratedUtilities;
          let targetNetProfit =
            (totalInvestmentExcludingPurchase + purchase) *
            (desiredProfitMargin / 100);

          // But since we want to solve for purchase (maxPurchasePrice), we need to restructure:
          let allOtherCosts =
            reno +
            holding +
            closing +
            resaleCosts +
            totalMortgagePaid +
            loanFees +
            gapFundingFees +
            proratedTaxes +
            proratedInsurance +
            proratedMaintenance +
            proratedUtilities;
          let maxPurchasePrice =
            arv * (1 - desiredProfitMargin / 100) - allOtherCosts;

          // ✅ Display Results
          // document.getElementById("grossProfit").innerText = formatNumber(grossProfit);
          document.getElementById('totalInvestment').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            totalInvestment
          );
          document.getElementById('netProfit').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            netProfit
          );
          document.getElementById('totalCashInvested').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            totalCashInvested
          );
          document.getElementById('profitMargin').innerText =
            (0,
            _utils_format_number_percent__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ])(profitMargin) + '%';
          document.getElementById('cashOnCashReturn').innerText =
            (0,
            _utils_format_number_percent__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ])(cashOnCashReturn) + '%';
          document.getElementById('breakEvenYears').innerText = breakEvenYears;
          document.getElementById('rentalVsFlip').innerText =
            rentalVsFlip !== 'N/A'
              ? rentalVsFlip > months
                ? `Best to flip. ${rentalVsFlip} rental months to match flip profit.`
                : `Best to rent. ${rentalVsFlip} rental months to match flip profit.`
              : 'N/A';

          // document.getElementById("profitMinPercent").innerText = `${profitMinPercent}%`;
          // document.getElementById("profitMinDollar").innerText = `${formatNumber(profitMinDollar)}`;
          // document.getElementById("projection").innerText = `${formatNumber(projection)}`;
          document.getElementById('dealStatus').innerText = deal;
          document.getElementById('monthlyHoldingCost').innerText = `${(0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            monthlyHoldingCost
          )}`;
          // document.getElementById("proratedTaxes").innerText = formatNumber(proratedTaxes);
          // document.getElementById("proratedInsurance").innerText = formatNumber(proratedInsurance);
          document.getElementById('displayedAddress').innerText = address
            ? `📍 ${address}`
            : '';
          if (gapFundingRate > 0) {
            document.getElementById('calculatedGapCost').innerText = (0,
            _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
              gapFundingFees
            );
          }
          // document.getElementById("requiredARV").innerText = formatNumber(requiredARV);
          document.getElementById('maxPurchasePrice').innerText =
            maxPurchasePrice > 0
              ? (0,
                _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
                  maxPurchasePrice
                )
              : 0;

          // ✅ Color Code Cards
          // let grossProfitCard = document.querySelector(".grossProfitcard");
          // grossProfitCard.style.backgroundColor = grossProfit >= 0 ? "#d0b870" : "#f86d6d";
          // document.querySelector(".grosspro").style.color = grossProfit >= 0 ? "black" : "#d0b870";

          let netProfitEl = document.getElementById('netProfit');
          let netprocard = document.querySelector('.netprocard');
          let netprocardhead = document.querySelector('.netprocardhead');
          netProfitEl.style.color = netProfit > 0 ? 'black' : 'black'; // gold if profit, red if loss
          netprocardhead.style.color = netProfit > 0 ? 'black' : '#d0b870'; // gold if profit, red if loss
          netprocard.style.background =
            netProfit === 0 ? '#ffffff' : netProfit > 0 ? '#d0b870' : '#f86d6d';
          let profitMarginEl = document.getElementById('profitMargin');
          let promarcard = document.querySelector('.promarcard');
          let promarcardhead = document.querySelector('.promarcardhead');
          profitMarginEl.style.color =
            profitMargin >= desiredProfitMargin ? 'black' : 'black';
          promarcardhead.style.color =
            profitMargin >= desiredProfitMargin ? '#d0b870' : 'black'; // gold if profit, red if loss
          promarcard.style.background =
            profitMargin === 0
              ? '#ffffff'
              : profitMargin >= desiredProfitMargin
              ? '#d0b870'
              : '#f86d6d';
          let rentalVsFlipEl = document.getElementById('rentalVsFlip');
          let rvfcard = document.querySelector('.rvfcard');
          let rvfcardhead = document.querySelector('.rvfcardhead');
          rentalVsFlipEl.style.color =
            rentalVsFlip !== 'N/A' && rentalVsFlip > months ? 'black' : 'black';
          rvfcardhead.style.color =
            rentalVsFlip !== 'N/A' && rentalVsFlip > months
              ? 'black'
              : '#d0b870'; // gold if profit, red if loss
          rvfcard.style.background =
            rentalVsFlip === 'N/A'
              ? '#ffffff'
              : rentalVsFlip !== 'N/A' && rentalVsFlip > months
              ? '#d0b870'
              : '#f86d6d';
          let dealCardd = document.querySelector('.dealCardd');
          let dealCarddhead = document.querySelector('.dealCarddhead');
          document.getElementById('dealStatus').style.color =
            deal === 'YES' ? 'black' : 'black';
          dealCarddhead.style.color = deal === 'YES' ? 'black' : '#d0b870'; // gold if profit, red if loss
          dealCardd.style.background = deal === 'YES' ? '#d0b870' : '#f86d6d';
          // ✅ Reset Charts Before Rendering
          (0,
          _chart_utils_reset_canvas__WEBPACK_IMPORTED_MODULE_2__['default'])(
            'projectCostBreakdownChart'
          );
          (0,
          _chart_utils_reset_canvas__WEBPACK_IMPORTED_MODULE_2__['default'])(
            'arvDistributionChart'
          );
          (0,
          _charts_project_cost_breakdown_chart__WEBPACK_IMPORTED_MODULE_3__[
            'default'
          ])({
            purchase,
            reno,
            holding,
            loanInterest,
            loanFees,
            resaleCosts,
            closing,
            proratedTaxes,
            proratedInsurance,
          });
          (0,
          _charts_arv_distribution_chart__WEBPACK_IMPORTED_MODULE_4__[
            'default'
          ])({
            investment: totalInvestment,
            resaleCosts,
            netProfit,
          });
        }

        /***/
      },

    /***/ './src/calculators/rental.js':
      /*!***********************************!*\
  !*** ./src/calculators/rental.js ***!
  \***********************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ calculateRentalProperty,
          /* harmony export */
        });
        /* harmony import */ var _utils_format_number__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! ../utils/format-number */ './src/utils/format-number.js'
          );
        /* harmony import */ var _utils_format_number_percent__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ../utils/format-number-percent */ './src/utils/format-number-percent.js'
          );
        /* harmony import */ var _charts_portfolio_chart__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! ../charts/portfolio-chart */ './src/charts/portfolio-chart.js'
          );
        /* harmony import */ var _charts_cashflow_chart__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! ../charts/cashflow-chart */ './src/charts/cashflow-chart.js'
          );
        /* harmony import */ var _utils_table_data__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! ../utils/table-data */ './src/utils/table-data.js'
          );
        /* harmony import */ var _utils_update_table_range__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! ../utils/update-table-range */ './src/utils/update-table-range.js'
          );

        function calculateRentalProperty() {
          // Get values and convert to numbers
          let propertyPrice =
            parseFloat(document.getElementById('propertyPrice').value.trim()) ||
            0;
          let initialRenovations =
            parseFloat(
              document.getElementById('initialRenovations').value.trim()
            ) || 0;
          let downPaymentPercent =
            parseFloat(document.getElementById('downPayment').value.trim()) ||
            0;
          let downPayment = (downPaymentPercent / 100) * propertyPrice;
          let loanTerm =
            parseFloat(document.getElementById('loanTerm').value.trim()) || 0;
          let interestRate =
            parseFloat(document.getElementById('interestRate').value.trim()) ||
            0;
          let monthlyRent =
            parseFloat(document.getElementById('monthlyRent').value.trim()) ||
            0;
          let vacancyRate =
            parseFloat(document.getElementById('vacancyRate').value.trim()) ||
            0;
          let propertyTaxes =
            parseFloat(document.getElementById('propertyTaxes').value.trim()) ||
            0;
          let insuranceCosts =
            parseFloat(
              document.getElementById('insuranceCosts').value.trim()
            ) || 0;
          let maintenanceCosts =
            parseFloat(
              document.getElementById('maintenanceCosts').value.trim()
            ) || 0;
          let managementFees =
            parseFloat(
              document.getElementById('managementFees').value.trim()
            ) || 0;
          let utilities =
            parseFloat(document.getElementById('utilities').value.trim()) || 0;
          let renovations =
            parseFloat(document.getElementById('renovations').value.trim()) ||
            0;
          let rentGrowth =
            parseFloat(document.getElementById('rentGrowth').value.trim()) || 0;
          let closingCostsPercent =
            parseFloat(
              document.getElementById('closingCostsRent').value.trim()
            ) || 0;
          let closingCosts = (closingCostsPercent / 100) * propertyPrice;
          // getting time value
          let timeDuration =
            parseInt(document.getElementById('timeDuration').value.trim()) ||
            10;
          let appreciationRate =
            parseFloat(
              document.getElementById('appreciationRate').value.trim()
            ) || 3;

          // Reference error span elements
          let errors = {
            propertyPrice: document.getElementById('errorPropertyPrice'),
            initialRenovations: document.getElementById(
              'errorInitialRenovations'
            ),
            downPayment: document.getElementById('errorDownPaymentPer'),
            loanTerm: document.getElementById('errorLoanTerm'),
            interestRate: document.getElementById('errorInterestRate'),
            monthlyRent: document.getElementById('errorMonthlyRent'),
            vacancyRate: document.getElementById('errorVacancyRate'),
            propertyTaxes: document.getElementById('errorPropertyTaxes'),
            insuranceCosts: document.getElementById('errorInsuranceCosts'),
            maintenanceCosts: document.getElementById('errorMaintenanceCosts'),
            managementFees: document.getElementById('errorManagementFees'),
            utilities: document.getElementById('errorUtilities'),
            renovations: document.getElementById('errorRenovations'),
            rentGrowth: document.getElementById('errorRentGrowth'),
            closingCosts: document.getElementById('errorClosingCostsRent'),
          };
          // Clear previous error messages
          Object.values(errors).forEach((error) => (error.innerText = ''));
          let isValid = true;

          // 🚨 **Validations**
          function validateInput(value, errorField, fieldName) {
            let min =
              arguments.length > 3 && arguments[3] !== undefined
                ? arguments[3]
                : 0;
            let max =
              arguments.length > 4 && arguments[4] !== undefined
                ? arguments[4]
                : Infinity;
            if (
              fieldName == 'Down Payment (%)' &&
              (value < min || value > max)
            ) {
              errorField.innerText = `${fieldName} must be less than 100 .`;
            } else if (
              fieldName == 'Loan Term (Years)' &&
              (value < min || value > max)
            ) {
              errorField.innerText = `${fieldName} must be less than 30 .`;
            } else {
              if (value < min || value > max) {
                errorField.innerText = `${fieldName} must be greater than ${min} .`;
                isValid = false;
              }
            }
          }
          validateInput(
            propertyPrice,
            errors.propertyPrice,
            'Property Price',
            1000
          );
          validateInput(
            downPaymentPercent,
            errors.downPayment,
            'Down Payment (%)',
            0,
            100
          );
          validateInput(loanTerm, errors.loanTerm, 'Loan Term (Years)', 1, 30);
          validateInput(
            interestRate,
            errors.interestRate,
            'Interest Rate (%)',
            0,
            100
          );
          validateInput(monthlyRent, errors.monthlyRent, 'Monthly Rent', 0);
          validateInput(
            vacancyRate,
            errors.vacancyRate,
            'Vacancy Rate (%)',
            0,
            100
          );
          validateInput(
            propertyTaxes,
            errors.propertyTaxes,
            'Annual Property Taxes',
            0
          );
          validateInput(
            insuranceCosts,
            errors.insuranceCosts,
            'Annual Insurance Costs',
            0
          );
          validateInput(
            maintenanceCosts,
            errors.maintenanceCosts,
            'Annual Maintenance Costs',
            0
          );
          validateInput(
            managementFees,
            errors.managementFees,
            'Management Fees (%)',
            0,
            100
          );
          validateInput(utilities, errors.utilities, 'Utilities', 0);
          validateInput(renovations, errors.renovations, 'Renovations', 0);
          validateInput(
            rentGrowth,
            errors.rentGrowth,
            'Rent Growth (%)',
            0,
            100
          );
          validateInput(
            closingCostsPercent,
            errors.closingCosts,
            'Closing Costs (%)',
            0,
            100
          );
          validateInput(
            initialRenovations,
            errors.initialRenovations,
            'Initial Renovations',
            0
          );
          if (!isValid) return;

          // ✅ Loan Calculation
          let loanAmount = propertyPrice - downPayment;
          let monthlyRate = interestRate / 100 / 12;
          let numPayments = loanTerm * 12;
          let mortgagePayment =
            monthlyRate > 0
              ? (loanAmount *
                  (monthlyRate * Math.pow(1 + monthlyRate, numPayments))) /
                (Math.pow(1 + monthlyRate, numPayments) - 1)
              : loanTerm > 0
              ? loanAmount / numPayments
              : 0;

          // ✅ Rental Income Calculation
          let grossRentIncome = monthlyRent * 12;
          let vacancyLoss = grossRentIncome * (vacancyRate / 100);
          let adjustedRentIncome = grossRentIncome - vacancyLoss;

          // ✅ Operating Expenses Calculation
          let operatingExpenses =
            propertyTaxes +
            insuranceCosts +
            maintenanceCosts +
            adjustedRentIncome * (managementFees / 100) +
            utilities +
            renovations;
          // ✅ NOI Calculation
          let noi = adjustedRentIncome - operatingExpenses;

          // ✅ Annual Mortgage Payment
          let annualMortgagePayment = mortgagePayment * 12;

          // ✅ Cash Flow Calculation
          let cashFlowAnnual = noi - annualMortgagePayment;
          let cashFlowMonthly = cashFlowAnnual / 12;

          // ✅ Cap Rate Calculation
          let capRate = (noi / propertyPrice) * 100;

          // ✅ Cash-on-Cash Return Calculation
          let totalCashInvested =
            downPayment + closingCosts + initialRenovations;
          let cocReturn =
            totalCashInvested > 0
              ? (cashFlowAnnual / totalCashInvested) * 100
              : 0;

          // ✅ Debt Service Ratio (DSR) Calculation
          let debtServiceRatio =
            annualMortgagePayment > 0 ? noi / annualMortgagePayment : 0;
          // For charts and table projections
          let rentProjections = [];
          let adjustedRentProjections = [];
          let monthlyPropertyTaxes = propertyTaxes / 12;
          let monthlyInsurance = insuranceCosts / 12;
          let monthlyMaintenance = maintenanceCosts / 12;
          let monthlyManagementFees =
            (adjustedRentIncome * (managementFees / 100)) / 12;
          let monthlyUtilities = utilities / 12;
          let monthlyRenovations = renovations / 12;
          let totalMonthlyCosts =
            mortgagePayment +
            monthlyPropertyTaxes +
            monthlyInsurance +
            monthlyMaintenance +
            monthlyManagementFees +
            monthlyUtilities +
            monthlyRenovations;
          for (let i = 0; i < timeDuration; i++) {
            let yearRent = monthlyRent * 12 * Math.pow(1 + rentGrowth / 100, i);
            let yearVacancyLoss = yearRent * (vacancyRate / 100);
            let yearAdjustedRent = yearRent - yearVacancyLoss;
            rentProjections.push(yearRent);
            adjustedRentProjections.push(yearAdjustedRent);
          }

          // ✅ Display Results
          document.getElementById('loanAmount').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            loanAmount
          );
          document.getElementById('mortgagePayment').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            totalMonthlyCosts
          );
          document.getElementById('noi').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(noi);
          document.getElementById('cashFlow').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            cashFlowMonthly
          );
          document.getElementById('capRate').innerText =
            (0,
            _utils_format_number_percent__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ])(capRate) + '%';
          document.getElementById('cocReturn').innerText =
            (0,
            _utils_format_number_percent__WEBPACK_IMPORTED_MODULE_1__[
              'default'
            ])(cocReturn) + '%';
          document.getElementById('annualCashFlow').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            cashFlowAnnual
          );
          document.getElementById('cashInvestedRent').innerText = (0,
          _utils_format_number__WEBPACK_IMPORTED_MODULE_0__['default'])(
            totalCashInvested
          );
          document.getElementById('debtServiceRatio').innerText =
            debtServiceRatio.toFixed(2);

          // Change background color if DSR is greater than 1.2
          let dsrElement = document.getElementById('debtcard');
          if (debtServiceRatio > 1.2) {
            dsrElement.style.backgroundColor = '#d0b870';
            document.querySelector('.dssr').style.color = 'black';
          } else {
            dsrElement.style.backgroundColor = 'rgb(248, 109, 109)'; // Reset to default if DSR is not > 1.2
          }
          (0, _charts_portfolio_chart__WEBPACK_IMPORTED_MODULE_2__['default'])(
            adjustedRentIncome,
            operatingExpenses,
            cashFlowAnnual,
            timeDuration
          );
          (0, _charts_cashflow_chart__WEBPACK_IMPORTED_MODULE_3__['default'])(
            annualMortgagePayment,
            operatingExpenses,
            cashFlowAnnual,
            timeDuration
          );
          var year =
            parseFloat(document.getElementById('years_tbl').value.trim()) || 1;
          // document.getElementById("year_b").innerText = year;
          (0, _utils_table_data__WEBPACK_IMPORTED_MODULE_4__['default'])(
            year,
            true
          );
          (0,
          _utils_update_table_range__WEBPACK_IMPORTED_MODULE_5__['default'])();
        }

        /***/
      },

    /***/ './src/chart-utils/reset-canvas.js':
      /*!*****************************************!*\
  !*** ./src/chart-utils/reset-canvas.js ***!
  \*****************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ resetCanvas,
          /* harmony export */
        });
        function resetCanvas(id) {
          let canvasWrapper = document.getElementById(id).parentNode;
          canvasWrapper.innerHTML = `<canvas id="${id}"></canvas>`;
        }

        /***/
      },

    /***/ './src/charts/arv-distribution-chart.js':
      /*!**********************************************!*\
  !*** ./src/charts/arv-distribution-chart.js ***!
  \**********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ createARVDistributionChart,
          /* harmony export */
        });
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chartjs-plugin-datalabels */ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js'
          );

        chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(
          ...chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables
        );

        function createARVDistributionChart(data) {
          const ctx = document
            .getElementById('arvDistributionChart')
            .getContext('2d');
          const labels = ['Total Investment', 'Resale Costs', 'Net Profit'];
          const values = [data.investment, data.resaleCosts, data.netProfit];
          const total = values.reduce((a, b) => a + b, 0);
          new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(ctx, {
            type: 'pie',
            data: {
              labels: labels,
              datasets: [
                {
                  data: values,
                  backgroundColor: ['#2980b9', '#f1c40f', '#2ecc71'],
                  borderColor: '#ffffff',
                  borderWidth: 4,
                  hoverOffset: 20,
                },
              ],
            },
            options: {
              responsive: true,
              plugins: {
                title: {
                  display: true,
                  text: 'ARV Distribution',
                  font: {
                    size: 20,
                    weight: 'bold',
                  },
                  color: '#000000',
                },
                legend: {
                  position: 'right',
                  labels: {
                    boxWidth: 14,
                    padding: 16,
                    font: {
                      size: 14,
                      color: '#000000',
                    },
                  },
                },
                tooltip: {
                  callbacks: {
                    label: function (ctx) {
                      const value = ctx.parsed;
                      const percentage = ((value / total) * 100).toFixed(2);
                      return `${
                        ctx.label
                      }: $${value.toLocaleString()} (${percentage}%)`;
                    },
                  },
                },
                datalabels: {
                  color: '#ffffff',
                  font: {
                    weight: 'bold',
                    size: 14,
                  },
                  formatter: (value, context) => {
                    const percentage = (value / total) * 100;
                    return `${percentage.toFixed(1)}%`;
                  },
                  display: function (context) {
                    const value = context.dataset.data[context.dataIndex];
                    const percentage = (value / total) * 100;
                    return percentage >= 5; // Show only if the slice is 5% or more
                  },
                },
              },
            },
            plugins: [
              chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__['default'],
            ],
          });
        }

        /***/
      },

    /***/ './src/charts/asset-breakdown-chart.js':
      /*!*********************************************!*\
  !*** ./src/charts/asset-breakdown-chart.js ***!
  \*********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ renderAssetBreakdownChart,
          /* harmony export */
        });
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chartjs-plugin-datalabels */ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js'
          );

        chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(
          ...chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables
        );

        function renderAssetBreakdownChart(
          fvStock,
          fvRealEstate,
          fvWholeLifeInsurance,
          fvSavings
        ) {
          const ctx = document
            .getElementById('assetBreakdownChart')
            .getContext('2d');
          const total =
            fvStock + fvRealEstate + fvWholeLifeInsurance + fvSavings;
          const chartData = {
            labels: [
              'Stocks',
              'Real Estate',
              'Whole Life Insurance',
              'Savings',
            ],
            datasets: [
              {
                label: 'Asset Distribution at Retirement',
                data: [fvStock, fvRealEstate, fvWholeLifeInsurance, fvSavings],
                backgroundColor: ['#F39655', '#B77CE9 ', '#55CBE5 ', '#e67e22'],
                borderColor: '#ffffff',
                borderWidth: 4,
                hoverOffset: 20,
              },
            ],
          };

          // Destroy previous chart instance if it exists
          if (
            window.assetBreakdownChart instanceof
            chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart
          ) {
            window.assetBreakdownChart.destroy();
          }
          window.assetBreakdownChart =
            new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(ctx, {
              type: 'pie',
              data: chartData,
              options: {
                responsive: true,
                plugins: {
                  title: {
                    display: true,
                    text: 'Asset Allocation Breakdown at Retirement',
                    font: {
                      size: 20,
                      weight: 'bold',
                    },
                    color: '#000000',
                  },
                  legend: {
                    position: 'right',
                    labels: {
                      boxWidth: 14,
                      padding: 16,
                      font: {
                        size: 14,
                        color: '#000000',
                      },
                    },
                  },
                  tooltip: {
                    callbacks: {
                      label: function (ctx) {
                        const value = ctx.parsed;
                        const percentage = ((value / total) * 100).toFixed(2);
                        return `${
                          ctx.label
                        }: $${value.toLocaleString()} (${percentage}%)`;
                      },
                    },
                  },
                  datalabels: {
                    color: '#ffffff',
                    font: {
                      weight: 'bold',
                      size: 14,
                    },
                    formatter: (value, context) => {
                      const percentage = (value / total) * 100;
                      return `${percentage.toFixed(1)}%`;
                    },
                    display: function (context) {
                      const value = context.dataset.data[context.dataIndex];
                      const percentage = (value / total) * 100;
                      return percentage >= 5; // Only show if 5% or more
                    },
                  },
                },
              },
              plugins: [
                chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ],
              ],
            });
        }

        /***/
      },

    /***/ './src/charts/cashflow-chart.js':
      /*!**************************************!*\
  !*** ./src/charts/cashflow-chart.js ***!
  \**************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ renderCashFlowPieChart,
          /* harmony export */
        });
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chartjs-plugin-datalabels */ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js'
          );

        chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(
          ...chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables
        );

        function renderCashFlowPieChart(
          mortgagePaymentAnnual,
          operatingExpenses,
          cashFlowAnnual
        ) {
          let timeDuration =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : 1;
          const ctx = document
            .getElementById('cashFlowPieChart')
            .getContext('2d');
          if (
            window.cashFlowPieChart instanceof
            chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart
          ) {
            window.cashFlowPieChart.destroy();
          }

          // Scale all values by time duration (in years)
          const scaledMortgage = mortgagePaymentAnnual * timeDuration;
          const scaledExpenses = operatingExpenses * timeDuration;
          const scaledCashFlow = cashFlowAnnual * timeDuration;
          const labels = ['Mortgage Payments', 'Operating Expenses'];
          const values = [scaledMortgage, scaledExpenses];
          const colors = ['#55CBE5', '#F39655'];
          const netLabel = scaledCashFlow >= 0 ? 'Net Profit' : 'Net Loss';
          const netColor = scaledCashFlow >= 0 ? '#4CAF50' : '#FF5722';
          labels.push(netLabel);
          values.push(Math.abs(scaledCashFlow));
          colors.push(netColor);
          const totalFlow = values.reduce((acc, val) => acc + val, 0);
          window.cashFlowPieChart =
            new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(ctx, {
              type: 'pie',
              data: {
                labels: labels,
                datasets: [
                  {
                    label: 'Cash Flow Breakdown',
                    data: values.map((val) => val.toFixed(2)),
                    backgroundColor: colors,
                    hoverOffset: 15,
                    borderWidth: 3,
                    borderColor: '#fff',
                  },
                ],
              },
              options: {
                responsive: true,
                interaction: {
                  mode: 'nearest',
                  intersect: false,
                },
                plugins: {
                  title: {
                    display: true,
                    text: `Cash Flow Breakdown (Over ${timeDuration} Year${
                      timeDuration > 1 ? 's' : ''
                    })`,
                    font: {
                      size: 22,
                      weight: 'bold',
                    },
                    color: '#333',
                  },
                  tooltip: {
                    enabled: true,
                    mode: 'index',
                    intersect: false,
                    backgroundColor: 'rgba(0, 0, 0, 0.9)',
                    titleFont: {
                      size: 20,
                      weight: 'bold',
                    },
                    bodyFont: {
                      size: 16,
                    },
                    padding: 14,
                    boxPadding: 6,
                    borderColor: '#fff',
                    borderWidth: 1,
                    callbacks: {
                      label: function (context) {
                        const label = context.label || '';
                        const value = parseFloat(context.raw);
                        const percentage = ((value / totalFlow) * 100).toFixed(
                          2
                        );
                        return `${label}: $${value.toFixed(
                          2
                        )} (${percentage}%)`;
                      },
                      afterBody: function () {
                        return `Total: $${totalFlow.toFixed(2)}`;
                      },
                    },
                  },
                  legend: {
                    display: true,
                    labels: {
                      font: {
                        size: 16,
                      },
                      boxWidth: 25,
                      usePointStyle: true,
                      padding: 20,
                    },
                  },
                  datalabels: {
                    color: 'white',
                    font: {
                      size: 14,
                      weight: 'bold',
                    },
                    formatter: (value, context) => {
                      const sum = context.chart.data.datasets[0].data.reduce(
                        (a, b) => parseFloat(a) + parseFloat(b),
                        0
                      );
                      const percentage = ((value / sum) * 100).toFixed(1);
                      return percentage >= 5 ? `${percentage}%` : '';
                    },
                  },
                  animation: {
                    animateRotate: true,
                    animateScale: true,
                    duration: 1500,
                    easing: 'easeOutBounce',
                  },
                },
              },
              plugins: [
                chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ],
              ],
            });
        }

        /***/
      },

    /***/ './src/charts/income-source-chart.js':
      /*!*******************************************!*\
  !*** ./src/charts/income-source-chart.js ***!
  \*******************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ renderIncomeSourcePie,
          /* harmony export */
        });
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chartjs-plugin-datalabels */ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js'
          );

        chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(
          ...chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables
        );

        let incomeSourceChartInstance;
        function renderIncomeSourcePie(
          contributions,
          stock,
          realEstate,
          insurance
        ) {
          const ctx = document
            .getElementById('incomeSourceChart')
            .getContext('2d');
          const dataValues = [contributions, stock, realEstate, insurance];
          const total = dataValues.reduce((a, b) => a + b, 0);
          if (incomeSourceChartInstance) {
            incomeSourceChartInstance.destroy();
          }
          incomeSourceChartInstance =
            new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(ctx, {
              type: 'pie',
              data: {
                labels: [
                  'Contributions',
                  'Stock',
                  'Real Estate',
                  'Whole Life Insurance',
                ],
                datasets: [
                  {
                    label: 'Income Source Contribution at Retirement',
                    data: dataValues,
                    backgroundColor: [
                      '#55CBE5',
                      '#e74c3c',
                      '#F39655',
                      '#B77CE9',
                    ],
                    borderColor: '#ffffff',
                    borderWidth: 4,
                    hoverOffset: 20,
                  },
                ],
              },
              options: {
                responsive: true,
                plugins: {
                  title: {
                    display: true,
                    text: `Income Sources at Retirement`,
                    font: {
                      size: 20,
                      weight: 'bold',
                    },
                    color: '#000000',
                  },
                  legend: {
                    position: 'right',
                    labels: {
                      boxWidth: 14,
                      padding: 16,
                      font: {
                        size: 14,
                        color: '#000000',
                      },
                    },
                  },
                  tooltip: {
                    callbacks: {
                      label: function (ctx) {
                        const value = ctx.parsed;
                        const percentage = ((value / total) * 100).toFixed(2);
                        return `${
                          ctx.label
                        }: $${value.toLocaleString()} (${percentage}%)`;
                      },
                    },
                  },
                  datalabels: {
                    color: 'white',
                    font: {
                      weight: 'bold',
                      size: 14,
                    },
                    formatter: (value, ctx) => {
                      const percentage = (value / total) * 100;
                      return percentage >= 5 ? `${percentage.toFixed(1)}%` : '';
                    },
                  },
                },
                animation: {
                  animateRotate: true,
                  animateScale: true,
                  duration: 1500,
                  easing: 'easeOutBounce',
                },
              },
              plugins: [
                chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ],
              ],
            });
        }

        /***/
      },

    /***/ './src/charts/portfolio-chart.js':
      /*!***************************************!*\
  !*** ./src/charts/portfolio-chart.js ***!
  \***************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ renderPortfolioPieChart,
          /* harmony export */
        });
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chartjs-plugin-datalabels */ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js'
          );

        chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(
          ...chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables
        );

        function renderPortfolioPieChart(
          adjustedRentIncome,
          operatingExpenses,
          cashFlowAnnual
        ) {
          let timeDuration =
            arguments.length > 3 && arguments[3] !== undefined
              ? arguments[3]
              : 1;
          const ctx = document
            .getElementById('portfolioPieChart')
            .getContext('2d');
          if (
            window.portfolioPieChart instanceof
            chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart
          ) {
            window.portfolioPieChart.destroy();
          }

          // Scale values based on selected duration
          const scaledIncome = adjustedRentIncome * timeDuration;
          const scaledExpenses = operatingExpenses * timeDuration;
          const scaledCashFlow = cashFlowAnnual * timeDuration;
          const labels = ['Income', 'Expenses'];
          const values = [scaledIncome, scaledExpenses];
          const colors = ['#B77CE9', '#55CBE5'];
          const profitLabel = scaledCashFlow >= 0 ? 'Profit' : 'Loss';
          const profitValue = Math.abs(scaledCashFlow);
          const profitColor = scaledCashFlow >= 0 ? '#3B8D21' : '#F39655';
          labels.push(profitLabel);
          values.push(profitValue);
          colors.push(profitColor);
          const total = values.reduce((a, b) => a + b, 0);
          window.portfolioPieChart =
            new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(ctx, {
              type: 'pie',
              data: {
                labels: labels,
                datasets: [
                  {
                    data: values,
                    backgroundColor: colors,
                    borderColor: '#fff',
                    borderWidth: 2,
                    hoverOffset: 12,
                  },
                ],
              },
              options: {
                responsive: true,
                plugins: {
                  legend: {
                    position: 'bottom',
                    labels: {
                      color: 'black',
                      font: {
                        size: 14,
                        family: 'Arial, sans-serif',
                      },
                      padding: 15,
                    },
                  },
                  title: {
                    display: true,
                    text: `Portfolio Composition (Over ${timeDuration} Year${
                      timeDuration > 1 ? 's' : ''
                    })`,
                    font: {
                      size: 20,
                      weight: 'bold',
                      family: 'Arial, sans-serif',
                    },
                    color: '#333',
                    padding: {
                      top: 10,
                      bottom: 20,
                    },
                  },
                  tooltip: {
                    callbacks: {
                      label: function (context) {
                        const value = parseFloat(context.raw);
                        const percentage = ((value / total) * 100).toFixed(1);
                        return `${context.label}: $${value.toFixed(
                          2
                        )} (${percentage}%)`;
                      },
                      afterBody: function () {
                        return `Total: $${total.toFixed(2)}`;
                      },
                    },
                  },
                  datalabels: {
                    color: 'white',
                    font: {
                      size: 14,
                      weight: 'bold',
                    },
                    formatter: (value, context) => {
                      const sum = context.chart.data.datasets[0].data.reduce(
                        (a, b) => a + b,
                        0
                      );
                      const percentage = ((value / sum) * 100).toFixed(1);
                      return percentage >= 5 ? `${percentage}%` : '';
                    },
                  },
                },
              },
              plugins: [
                chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__[
                  'default'
                ],
              ],
            });
        }

        /***/
      },

    /***/ './src/charts/project-cost-breakdown-chart.js':
      /*!****************************************************!*\
  !*** ./src/charts/project-cost-breakdown-chart.js ***!
  \****************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ createProjectCostBreakdownChart,
          /* harmony export */
        });
        /* harmony import */ var chart_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! chart.js */ './node_modules/chart.js/dist/chart.js'
          );
        /* harmony import */ var chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! chartjs-plugin-datalabels */ './node_modules/chartjs-plugin-datalabels/dist/chartjs-plugin-datalabels.esm.js'
          );

        chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart.register(
          ...chart_js__WEBPACK_IMPORTED_MODULE_0__.registerables
        );

        function createProjectCostBreakdownChart(data) {
          const ctx = document
            .getElementById('projectCostBreakdownChart')
            .getContext('2d');

          // Combine holding-related costs into one
          const combinedHolding =
            data.holding +
            data.loanInterest +
            data.proratedTaxes +
            data.proratedInsurance;
          const labels = [
            'Purchase',
            'Renovation',
            'Holding (incl. interest, taxes, insurance)',
            'Loan Fees',
            'Resale Costs',
            'Closing Costs',
          ];
          const values = [
            data.purchase,
            data.reno,
            combinedHolding,
            data.loanFees,
            data.resaleCosts,
            data.closing,
          ];
          const total = values.reduce((a, b) => a + b, 0);
          new chart_js__WEBPACK_IMPORTED_MODULE_0__.Chart(ctx, {
            type: 'doughnut',
            data: {
              labels: labels,
              datasets: [
                {
                  data: values,
                  backgroundColor: [
                    '#F39655',
                    '#B77CE9',
                    '#55CBE5',
                    '#e74c3c',
                    '#1abc9c',
                    '#e67e22',
                  ],
                  borderColor: '#ffffff',
                  borderWidth: 4,
                  hoverOffset: 20,
                },
              ],
            },
            options: {
              responsive: true,
              cutout: '0%',
              plugins: {
                datalabels: {
                  color: '#ffffff',
                  font: {
                    weight: 'bold',
                    size: 14,
                  },
                  formatter: (value, context) => {
                    const percentage = (value / total) * 100;
                    return `${percentage.toFixed(1)}%`;
                  },
                  display: function (context) {
                    const value = context.dataset.data[context.dataIndex];
                    const percentage = (value / total) * 100;
                    return percentage >= 5;
                  },
                },
                title: {
                  display: true,
                  text: 'Project Cost Breakdown',
                  font: {
                    size: 20,
                    weight: 'bold',
                    color: '#000000',
                  },
                },
                legend: {
                  position: 'right',
                  labels: {
                    boxWidth: 14,
                    padding: 16,
                    font: {
                      size: 14,
                      color: '#000000',
                    },
                  },
                },
                tooltip: {
                  callbacks: {
                    label: function (ctx) {
                      const value = ctx.parsed;
                      const percentage = ((value / total) * 100).toFixed(2);
                      return `${
                        ctx.label
                      }: $${value.toLocaleString()} (${percentage}%)`;
                    },
                  },
                },
              },
            },
            plugins: [
              chartjs_plugin_datalabels__WEBPACK_IMPORTED_MODULE_1__['default'],
            ],
          });
        }

        /***/
      },

    /***/ './src/style.css':
      /*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => __WEBPACK_DEFAULT_EXPORT__,
          /* harmony export */
        });
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ './node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ './node_modules/style-loader/dist/runtime/styleDomAPI.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ './node_modules/style-loader/dist/runtime/insertBySelector.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ './node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ './node_modules/style-loader/dist/runtime/insertStyleElement.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ =
          __webpack_require__(
            /*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ './node_modules/style-loader/dist/runtime/styleTagTransform.js'
          );
        /* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default =
          /*#__PURE__*/ __webpack_require__.n(
            _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__
          );
        /* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ =
          __webpack_require__(
            /*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ './node_modules/css-loader/dist/cjs.js!./src/style.css'
          );

        var options = {};

        options.styleTagTransform =
          _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default();
        options.setAttributes =
          _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default();
        options.insert =
          _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(
            null,
            'head'
          );
        options.domAPI =
          _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default();
        options.insertStyleElement =
          _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default();

        var update =
          _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(
            _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[
              'default'
            ],
            options
          );

        /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ =
          _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[
            'default'
          ] &&
          _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[
            'default'
          ].locals
            ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__[
                'default'
              ].locals
            : undefined;

        /***/
      },

    /***/ './src/utils/format-number-percent.js':
      /*!********************************************!*\
  !*** ./src/utils/format-number-percent.js ***!
  \********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ formatNumberPercent,
          /* harmony export */
        });
        function formatNumberPercent(value) {
          return value % 1 === 0
            ? value.toLocaleString()
            : value.toLocaleString(undefined, {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2,
              });
        }

        /***/
      },

    /***/ './src/utils/format-number.js':
      /*!************************************!*\
  !*** ./src/utils/format-number.js ***!
  \************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ formatNumber,
          /* harmony export */
        });
        function formatNumber(value) {
          let formattedValue =
            value % 1 === 0
              ? Math.abs(value).toLocaleString()
              : Math.abs(value).toLocaleString(undefined, {
                  minimumFractionDigits: 2,
                  maximumFractionDigits: 2,
                });
          return value < 0 ? `- $${formattedValue}` : `$${formattedValue}`;
        }

        /***/
      },

    /***/ './src/utils/generate-table-markup.js':
      /*!********************************************!*\
  !*** ./src/utils/generate-table-markup.js ***!
  \********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ generateCombinedYearTable,
          /* harmony export */
        });
        function generateCombinedYearTable(dataArray) {
          const dynamicCategories = [
            'Gross Rent',
            'Vacancy',
            'Operating Income',
            'Operating Expenses',
            'Management Fees',
            'Vacancy Loss',
            'Net Operating Income (NOI)',
            'Loan Payments',
            'Capital Expenditures',
            'Cash Flow',
          ];
          const staticExpenses = {
            'Property Taxes':
              parseFloat(document.getElementById('propertyTaxes').value) || 0,
            Insurance:
              parseFloat(document.getElementById('insuranceCosts').value) || 0,
            Maintenance:
              parseFloat(document.getElementById('maintenanceCosts').value) ||
              0,
            Utilities:
              parseFloat(document.getElementById('utilities').value) || 0,
            Renovations:
              parseFloat(document.getElementById('renovations').value) || 0,
          };
          const div = document.createElement('div');
          div.classList.add('mb-5', 'table-design');

          // 🌟 Static Expenses Table
          let staticTable = `
      <h5>Fixed Annual Expenses</h5>
      <table class="table table-bordered">
        <thead class="clr-bg" style="background-color: #333333; color: white;">
          <tr><th>Category</th><th>Amount</th></tr>
        </thead>
        <tbody>
          ${Object.entries(staticExpenses)
            .map((_ref) => {
              let [key, val] = _ref;
              return `
            <tr><td>${key}</td><td>$${val.toFixed(2)}</td></tr>
          `;
            })
            .join('')}
        </tbody>
      </table>
    `;

          // 📅 Yearly Data Table (Dynamic Values)
          let dynamicTable = `
      <h5>Yearly Financials: Years ${dataArray
        .map((d) => d.year)
        .join(', ')}</h5>
      <table class="table table-bordered">
        <thead class="clr-bg" style="background-color: #333333; color: white;">
          <tr>
            <th>Category</th>
            ${dataArray.map((d) => `<th>Year ${d.year}</th>`).join('')}
          </tr>
        </thead>
        <tbody>
    `;
          dynamicCategories.forEach((cat) => {
            dynamicTable += `<tr><td>${cat}</td>`;
            dataArray.forEach((data) => {
              let value = 0;
              switch (cat) {
                case 'Gross Rent':
                  value = data.grossRentIncome;
                  break;
                case 'Vacancy':
                  value = data.vacancyLoss;
                  break;
                case 'Operating Income':
                  value = data.adjustedRentIncome;
                  break;
                case 'Operating Expenses':
                  value = data.operatingExpenses;
                  break;
                case 'Management Fees':
                  value =
                    (data.adjustedRentIncome *
                      (parseFloat(
                        document.getElementById('managementFees').value
                      ) || 0)) /
                    100;
                  break;
                case 'Vacancy Loss':
                  value = data.vacancyLoss;
                  break;
                case 'Net Operating Income (NOI)':
                  value = data.netOperatingIncome;
                  break;
                case 'Loan Payments':
                  value = -data.annualMortgagePayment;
                  break;
                case 'Capital Expenditures':
                  value = -data.capitalExpenditures;
                  break;
                case 'Cash Flow':
                  value = data.cashFlow;
                  break;
              }
              dynamicTable += `<td>$${value.toFixed(2)}</td>`;
            });
            dynamicTable += `</tr>`;
          });
          dynamicTable += `</tbody></table>`;

          // 🧩 Combine and Return
          div.innerHTML = dynamicTable + staticTable;
          return div;
        }

        /***/
      },

    /***/ './src/utils/interest-project-duration.js':
      /*!************************************************!*\
  !*** ./src/utils/interest-project-duration.js ***!
  \************************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ interestProjectDuration,
          /* harmony export */
        });
        function interestProjectDuration(
          principal,
          monthlyPmts,
          projectMonths,
          monthlyInterest
        ) {
          let interestAccrued = 0;
          let remainingBalance = principal;
          for (let i = 0; i < projectMonths; i++) {
            const interest = remainingBalance * monthlyInterest;
            interestAccrued += interest;
            remainingBalance += interest - monthlyPmts;
          }
          return interestAccrued;
        }

        /***/
      },

    /***/ './src/utils/populate-years-dropdown.js':
      /*!**********************************************!*\
  !*** ./src/utils/populate-years-dropdown.js ***!
  \**********************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () =>
            /* binding */ populateYearsDropdown,
          /* harmony export */
        });
        function populateYearsDropdown() {
          const select = document.getElementById('years_tbl');
          select.innerHTML = ''; // Clear existing options

          for (let i = 1; i <= 30; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = `${i} ${i === 1 ? 'Year' : 'Years'}`;

            // Set 10 years as the default selected value
            if (i === 1) {
              option.selected = true;
            }
            select.appendChild(option);
          }
        }

        /***/
      },

    /***/ './src/utils/table-data.js':
      /*!*********************************!*\
  !*** ./src/utils/table-data.js ***!
  \*********************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ getTableData,
          /* harmony export */
        });
        function getTableData(year) {
          let returnData =
            arguments.length > 1 && arguments[1] !== undefined
              ? arguments[1]
              : false;
          // Get values and convert to numbers
          let propertyPrice =
            parseFloat(document.getElementById('propertyPrice').value.trim()) ||
            0;
          let downPayment =
            parseFloat(document.getElementById('downPayment').value.trim()) ||
            0;
          let loanTerm =
            parseFloat(document.getElementById('loanTerm').value.trim()) || 0;
          let interestRate =
            parseFloat(document.getElementById('interestRate').value.trim()) ||
            0;
          let monthlyRent =
            parseFloat(document.getElementById('monthlyRent').value.trim()) ||
            0;
          let vacancyRate =
            parseFloat(document.getElementById('vacancyRate').value.trim()) ||
            0;
          let propertyTaxes =
            parseFloat(document.getElementById('propertyTaxes').value.trim()) ||
            0;
          let insuranceCosts =
            parseFloat(
              document.getElementById('insuranceCosts').value.trim()
            ) || 0;
          let maintenanceCosts =
            parseFloat(
              document.getElementById('maintenanceCosts').value.trim()
            ) || 0;
          let managementFees =
            parseFloat(
              document.getElementById('managementFees').value.trim()
            ) || 0;
          let appreciationRate =
            parseFloat(
              document.getElementById('appreciationRate').value.trim()
            ) || 3;
          let rentIncreaseRate = 2;
          let utilities =
            parseFloat(document.getElementById('utilities').value.trim()) || 0;
          let renovations =
            parseFloat(document.getElementById('renovations').value.trim()) ||
            0;
          if (!year || year < 0) return;

          // Loan calculation
          let loanAmount = propertyPrice - downPayment;
          let monthlyRate = interestRate / 100 / 12;
          let numPayments = loanTerm * 12;
          let mortgagePayment =
            monthlyRate > 0
              ? (loanAmount *
                  (monthlyRate * Math.pow(1 + monthlyRate, numPayments))) /
                (Math.pow(1 + monthlyRate, numPayments) - 1)
              : loanAmount / numPayments;

          // Appreciation and Rent growth
          let appreciationFactor = Math.pow(1 + appreciationRate / 100, year);
          let rentFactor = Math.pow(1 + rentIncreaseRate / 100, year);
          let grossRentIncome = monthlyRent * 12 * rentFactor;
          let vacancyLoss = grossRentIncome * (vacancyRate / 100);
          let adjustedRentIncome = grossRentIncome - vacancyLoss;
          let managementCost = grossRentIncome * (managementFees / 100);

          // Operating Expenses
          let operatingExpenses =
            vacancyLoss +
            propertyTaxes +
            insuranceCosts +
            maintenanceCosts +
            managementCost +
            utilities +
            renovations;
          let netOperatingIncome = grossRentIncome - operatingExpenses;
          let annualMortgagePayment = mortgagePayment * 12;
          let cashFlowAnnual = netOperatingIncome - annualMortgagePayment;

          // If returnData is true, send values back instead of updating UI
          if (returnData) {
            return {
              year,
              grossRentIncome,
              vacancyLoss,
              adjustedRentIncome,
              operatingExpenses,
              netOperatingIncome,
              annualMortgagePayment,
              capitalExpenditures: 1425,
              // or dynamic later
              cashFlow: cashFlowAnnual,
            };
          }
          return;
          // Elements below don't exist in the DOM

          // Update UI
          document.getElementById('year_b').innerHTML = year;
          document.getElementById(
            'gross_rent'
          ).innerText = `$${grossRentIncome.toFixed(2)}`;
          document.getElementById(
            'vacancy_rate'
          ).innerText = `– $${vacancyLoss.toFixed(2)}`;
          document.getElementById(
            'operating_income'
          ).innerText = `$${adjustedRentIncome.toFixed(2)}`;
          document.getElementById(
            'operating_expenses'
          ).innerText = `– $${operatingExpenses.toFixed(2)}`;
          document.getElementById(
            'net_operating_income'
          ).innerText = `$${netOperatingIncome.toFixed(2)}`;
          document.getElementById(
            'loan_payments'
          ).innerText = `– $${annualMortgagePayment.toFixed(2)}`;
          document.getElementById(
            'cash_flow'
          ).innerText = `$${cashFlowAnnual.toFixed(2)}`;
          console.log(`Data displayed for year: ${year}`);
        }

        /***/
      },

    /***/ './src/utils/update-table-range.js':
      /*!*****************************************!*\
  !*** ./src/utils/update-table-range.js ***!
  \*****************************************/
      /***/ (
        __unused_webpack_module,
        __webpack_exports__,
        __webpack_require__
      ) => {
        __webpack_require__.r(__webpack_exports__);
        /* harmony export */ __webpack_require__.d(__webpack_exports__, {
          /* harmony export */ default: () => /* binding */ updateTableRange,
          /* harmony export */
        });
        /* harmony import */ var _table_data__WEBPACK_IMPORTED_MODULE_0__ =
          __webpack_require__(/*! ./table-data */ './src/utils/table-data.js');
        /* harmony import */ var _generate_table_markup__WEBPACK_IMPORTED_MODULE_1__ =
          __webpack_require__(
            /*! ./generate-table-markup */ './src/utils/generate-table-markup.js'
          );

        function updateTableRange() {
          const selectedYear = parseInt(
            document.getElementById('years_tbl').value
          );
          const tableContainer = document.getElementById('yearlyTables');
          tableContainer.innerHTML = '';
          let years = [];
          if (selectedYear <= 1) {
            years = [0, 1, 2];
          } else if (selectedYear >= 30) {
            years = [28, 29, 30];
          } else {
            years = [selectedYear - 1, selectedYear, selectedYear + 1];
          }
          const tableData = years
            .map((year) =>
              (0, _table_data__WEBPACK_IMPORTED_MODULE_0__['default'])(
                year,
                true
              )
            )
            .filter(Boolean);
          if (tableData.length > 0) {
            const combinedTable = (0,
            _generate_table_markup__WEBPACK_IMPORTED_MODULE_1__['default'])(
              tableData
            );
            tableContainer.appendChild(combinedTable);
          }
        }

        /***/
      },

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/ var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/ function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/ var cachedModule = __webpack_module_cache__[moduleId];
    /******/ if (cachedModule !== undefined) {
      /******/ return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/ var module = (__webpack_module_cache__[moduleId] = {
      /******/ id: moduleId,
      /******/ // no module.loaded needed
      /******/ exports: {},
      /******/
    });
    /******/
    /******/ // Execute the module function
    /******/ __webpack_modules__[moduleId](
      module,
      module.exports,
      __webpack_require__
    );
    /******/
    /******/ // Return the exports of the module
    /******/ return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/ (() => {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/ __webpack_require__.n = (module) => {
      /******/ var getter =
        module && module.__esModule
          ? /******/ () => module['default']
          : /******/ () => module;
      /******/ __webpack_require__.d(getter, { a: getter });
      /******/ return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/ (() => {
    /******/ // define getter functions for harmony exports
    /******/ __webpack_require__.d = (exports, definition) => {
      /******/ for (var key in definition) {
        /******/ if (
          __webpack_require__.o(definition, key) &&
          !__webpack_require__.o(exports, key)
        ) {
          /******/ Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key],
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/ (() => {
    /******/ __webpack_require__.o = (obj, prop) =>
      Object.prototype.hasOwnProperty.call(obj, prop);
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/ (() => {
    /******/ // define __esModule on exports
    /******/ __webpack_require__.r = (exports) => {
      /******/ if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/ Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module',
        });
        /******/
      }
      /******/ Object.defineProperty(exports, '__esModule', { value: true });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/nonce */
  /******/ (() => {
    /******/ __webpack_require__.nc = undefined;
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
  (() => {
    /*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
    __webpack_require__.r(__webpack_exports__);
    /* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ =
      __webpack_require__(/*! ./style.css */ './src/style.css');
    /* harmony import */ var _budget_table_css__WEBPACK_IMPORTED_MODULE_1__ =
      __webpack_require__(/*! ./budget-table.css */ './src/budget-table.css');
    /* harmony import */ var _calculators_house_flip__WEBPACK_IMPORTED_MODULE_2__ =
      __webpack_require__(
        /*! ./calculators/house-flip */ './src/calculators/house-flip.js'
      );
    /* harmony import */ var _calculators_calculate_retirement__WEBPACK_IMPORTED_MODULE_3__ =
      __webpack_require__(
        /*! ./calculators/calculate-retirement */ './src/calculators/calculate-retirement.js'
      );
    /* harmony import */ var _calculators_rental__WEBPACK_IMPORTED_MODULE_4__ =
      __webpack_require__(
        /*! ./calculators/rental */ './src/calculators/rental.js'
      );
    /* harmony import */ var _utils_update_table_range__WEBPACK_IMPORTED_MODULE_5__ =
      __webpack_require__(
        /*! ./utils/update-table-range */ './src/utils/update-table-range.js'
      );
    /* harmony import */ var _utils_populate_years_dropdown__WEBPACK_IMPORTED_MODULE_6__ =
      __webpack_require__(
        /*! ./utils/populate-years-dropdown */ './src/utils/populate-years-dropdown.js'
      );
    /* harmony import */ var _downloaders_pdf_event_listeners__WEBPACK_IMPORTED_MODULE_7__ =
      __webpack_require__(
        /*! ../downloaders/pdf-event-listeners */ './downloaders/pdf-event-listeners.js'
      );

    document.addEventListener('DOMContentLoaded', function () {
      const inputs = document.querySelectorAll(
        '#purchasePrice,#propertyAddress, #renoCosts, #holdingCosts, #desiredProfitMargin, #closingCosts, #afterRepairValue,#projectMonths,#resaleCosts,#downPaymentPercent,#gapCosts,#loanPoints,#houseLoanYear,#houseinterestRate,#houseMonthlyRent,#insurance,#propertyTaxesHF,#downPaymentType,#houseAnnualMaintenance,#houseAnnualUtilities'
      );
      const input2 = document.querySelectorAll(
        '#currentAge, #retirementAge, #expectedLifespan, #currentSavings,#lifeInsuranceMonthlyContributions,#wholeLifeInsurance, #monthlyContributions, #annualReturn,#desiredIncome,#inflationRate,#currentRealEstateEquity,#currentStockValue, #stockGrowthRate, #realEstateAppreciation,#mortgageBalance , #mortgageInterestRate , #mortgageTerm'
      );
      const input3 = document.querySelectorAll(
        '#managementFees, #maintenanceCosts, #insuranceCosts,#renovations,#utilities,#rentGrowth,#closingCostsRent, #propertyTaxes, #vacancyRate,#monthlyRent,#interestRate,#loanTerm,#downPayment,#propertyPrice,#timeDuration , #appreciationRate, #initialRenovations '
      );
      inputs.forEach((input) => {
        input.addEventListener(
          'input',
          _calculators_house_flip__WEBPACK_IMPORTED_MODULE_2__['default']
        );
      });
      input2.forEach((input) => {
        input.addEventListener(
          'input',
          _calculators_calculate_retirement__WEBPACK_IMPORTED_MODULE_3__[
            'default'
          ]
        );
      });
      input3.forEach((input) => {
        input.addEventListener(
          'input',
          _calculators_rental__WEBPACK_IMPORTED_MODULE_4__['default']
        );
      });
      (0,
      _downloaders_pdf_event_listeners__WEBPACK_IMPORTED_MODULE_7__[
        'default'
      ])();

      // Attach event listener to dropdown for updating table range
      const yearsDropdown = document.getElementById('years_tbl');
      if (yearsDropdown) {
        yearsDropdown.addEventListener(
          'change',
          _utils_update_table_range__WEBPACK_IMPORTED_MODULE_5__['default']
        );
      }

      // Run calculators
      (0, _calculators_house_flip__WEBPACK_IMPORTED_MODULE_2__['default'])();
      (0,
      _calculators_calculate_retirement__WEBPACK_IMPORTED_MODULE_3__[
        'default'
      ])();
      (0, _calculators_rental__WEBPACK_IMPORTED_MODULE_4__['default'])();

      // Populate rental years dropdown
      (0,
      _utils_populate_years_dropdown__WEBPACK_IMPORTED_MODULE_6__['default'])();
    });
  })();

  /******/
})();
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFlLFNBQVNBLHlCQUF5QkEsQ0FBQSxFQUFHO0VBQ2xEQyxRQUFRLENBQUNDLGNBQWMsQ0FBQyxjQUFjLENBQUMsQ0FBQ0MsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLE1BQU07SUFDdEUsSUFBSUMsTUFBTSxDQUFDQyxLQUFLLElBQUksT0FBT0MsV0FBVyxLQUFLLFdBQVcsRUFBRTtNQUN0RCxNQUFNO1FBQUVDO01BQU0sQ0FBQyxHQUFHSCxNQUFNLENBQUNDLEtBQUs7TUFDOUIsTUFBTUcsR0FBRyxHQUFHLElBQUlELEtBQUssQ0FBQyxDQUFDOztNQUV2QjtNQUNBLFNBQVNFLFFBQVFBLENBQUNDLEVBQUUsRUFBRTtRQUNwQixNQUFNQyxPQUFPLEdBQUdWLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDUSxFQUFFLENBQUM7UUFDM0MsT0FBT0MsT0FBTyxJQUFJQSxPQUFPLENBQUNDLEtBQUssR0FBR0QsT0FBTyxDQUFDQyxLQUFLLEdBQUcsS0FBSztNQUN6RDs7TUFFQTtNQUNBLE1BQU1DLFdBQVcsR0FBR1osUUFBUSxDQUFDYSxhQUFhLENBQUMsS0FBSyxDQUFDO01BQ2pERCxXQUFXLENBQUNILEVBQUUsR0FBRyxpQkFBaUI7TUFDbENHLFdBQVcsQ0FBQ0UsS0FBSyxDQUFDQyxPQUFPLEdBQUcsTUFBTTtNQUNsQ0gsV0FBVyxDQUFDRSxLQUFLLENBQUNFLGVBQWUsR0FBRyxNQUFNO01BQzFDSixXQUFXLENBQUNFLEtBQUssQ0FBQ0csS0FBSyxHQUFHLE1BQU07TUFDaENMLFdBQVcsQ0FBQ0UsS0FBSyxDQUFDSSxLQUFLLEdBQUcsT0FBTztNQUNqQ04sV0FBVyxDQUFDRSxLQUFLLENBQUNLLE1BQU0sR0FBRyxNQUFNOztNQUVqQztNQUNBLE1BQU1DLFVBQVUsR0FBR3BCLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLFlBQVksQ0FBQztNQUN4RFcsV0FBVyxDQUFDUyxXQUFXLENBQUNELFVBQVUsQ0FBQ0UsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDOztNQUVuRDtNQUNBLE1BQU1DLFVBQVUsR0FBR3ZCLFFBQVEsQ0FBQ2EsYUFBYSxDQUFDLEtBQUssQ0FBQztNQUNoRFUsVUFBVSxDQUFDQyxTQUFTLEdBQUc7QUFDN0I7QUFDQTtBQUNBLG9FQUFvRWhCLFFBQVEsQ0FDNUQsaUJBQ0YsQ0FBQztBQUNmLDJFQUEyRUEsUUFBUSxDQUNuRSxlQUNGLENBQUM7QUFDZixvRUFBb0VBLFFBQVEsQ0FDNUQsV0FDRixDQUFDO0FBQ2YsZ0VBQWdFQSxRQUFRLENBQ3hELGNBQ0YsQ0FBQztBQUNmLGlFQUFpRUEsUUFBUSxDQUN6RCxjQUNGLENBQUM7QUFDZixzRUFBc0VBLFFBQVEsQ0FDOUQsa0JBQ0YsQ0FBQztBQUNmLGlFQUFpRUEsUUFBUSxDQUN6RCxlQUNGLENBQUM7QUFDZixzRUFBc0VBLFFBQVEsQ0FDOUQsa0JBQ0YsQ0FBQztBQUNmLHNFQUFzRUEsUUFBUSxDQUM5RCxtQkFDRixDQUFDO0FBQ2YsOERBQThEQSxRQUFRLENBQ3RELFlBQ0YsQ0FBQztBQUNmLDREQUE0REEsUUFBUSxDQUNwRCxlQUNGLENBQUM7QUFDZiw2REFBNkRBLFFBQVEsQ0FDckQsVUFDRixDQUFDO0FBQ2YsdUVBQXVFQSxRQUFRLENBQy9ELG9CQUNGLENBQUM7QUFDZixnRUFBZ0VBLFFBQVEsQ0FDeEQsYUFDRixDQUFDO0FBQ2Ysd0VBQXdFQSxRQUFRLENBQ2hFLHFCQUNGLENBQUM7QUFDZix5RUFBeUVBLFFBQVEsQ0FDakUsaUJBQ0YsQ0FBQztBQUNmLHNFQUFzRUEsUUFBUSxDQUM5RCx3QkFDRixDQUFDO0FBQ2Ysb0VBQW9FQSxRQUFRLENBQzVELHNCQUNGLENBQUM7QUFDZixvRUFBb0VBLFFBQVEsQ0FDNUQsV0FDRixDQUFDO0FBQ2YseUVBQXlFQSxRQUFRLENBQ2pFLGlCQUNGLENBQUM7QUFDZjtBQUNBLFdBQVc7TUFDTEksV0FBVyxDQUFDUyxXQUFXLENBQUNFLFVBQVUsQ0FBQztNQUNuQ3ZCLFFBQVEsQ0FBQ3lCLElBQUksQ0FBQ0osV0FBVyxDQUFDVCxXQUFXLENBQUMsQ0FBQyxDQUFDOztNQUV4QztNQUNBUCxXQUFXLENBQUNPLFdBQVcsRUFBRTtRQUFFYyxLQUFLLEVBQUUsQ0FBQztRQUFFQyxPQUFPLEVBQUU7TUFBSyxDQUFDLENBQUMsQ0FDbERDLElBQUksQ0FBRUMsTUFBTSxJQUFLO1FBQ2hCLE1BQU1DLFFBQVEsR0FBRyxHQUFHO1FBQ3BCLE1BQU1DLFVBQVUsR0FBR3hCLEdBQUcsQ0FBQ3lCLFFBQVEsQ0FBQ0MsUUFBUSxDQUFDQyxNQUFNO1FBQy9DLElBQUlDLFNBQVMsR0FBSU4sTUFBTSxDQUFDSyxNQUFNLEdBQUdKLFFBQVEsR0FBSUQsTUFBTSxDQUFDWCxLQUFLO1FBQ3pELElBQUlrQixVQUFVLEdBQUdELFNBQVM7UUFDMUIsSUFBSUUsUUFBUSxHQUFHLEVBQUU7UUFFakIsTUFBTUMsT0FBTyxHQUFHVCxNQUFNLENBQUNVLFNBQVMsQ0FBQyxXQUFXLENBQUM7O1FBRTdDO1FBQ0FoQyxHQUFHLENBQUNpQyxRQUFRLENBQUNGLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFRCxRQUFRLEVBQUVQLFFBQVEsRUFBRUssU0FBUyxDQUFDO1FBQy9EQyxVQUFVLElBQUlMLFVBQVUsR0FBRyxFQUFFOztRQUU3QjtRQUNBLE9BQU9LLFVBQVUsR0FBRyxDQUFDLEVBQUU7VUFDckJDLFFBQVEsR0FBR0QsVUFBVSxHQUFHRCxTQUFTO1VBQ2pDNUIsR0FBRyxDQUFDa0MsT0FBTyxDQUFDLENBQUM7VUFDYmxDLEdBQUcsQ0FBQ2lDLFFBQVEsQ0FBQ0YsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUVELFFBQVEsRUFBRVAsUUFBUSxFQUFFSyxTQUFTLENBQUM7VUFDL0RDLFVBQVUsSUFBSUwsVUFBVSxHQUFHLEVBQUU7UUFDL0I7UUFFQXhCLEdBQUcsQ0FBQ21DLElBQUksQ0FBQyw2QkFBNkIsQ0FBQztRQUN2QzlCLFdBQVcsQ0FBQytCLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztNQUN4QixDQUFDLENBQUMsQ0FDREMsS0FBSyxDQUFFQyxLQUFLLElBQUs7UUFDaEJDLE9BQU8sQ0FBQ0QsS0FBSyxDQUFDLCtCQUErQixFQUFFQSxLQUFLLENBQUM7TUFDdkQsQ0FBQyxDQUFDO0lBQ04sQ0FBQyxNQUFNO01BQ0xDLE9BQU8sQ0FBQ0QsS0FBSyxDQUFDLDRDQUE0QyxDQUFDO0lBQzdEO0VBQ0YsQ0FBQyxDQUFDO0FBQ0o7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEl5RDtBQUNDO0FBQ1I7QUFFbkMsU0FBU0ksc0JBQXNCQSxDQUFBLEVBQUc7RUFDL0NsRCwyREFBeUIsQ0FBQyxDQUFDO0VBQzNCZ0QsMkRBQTBCLENBQUMsQ0FBQztFQUM1QkMsdURBQXNCLENBQUMsQ0FBQztBQUMxQjs7Ozs7Ozs7Ozs7Ozs7QUNSZSxTQUFTQSxzQkFBc0JBLENBQUEsRUFBRztFQUMvQ2hELFFBQVEsQ0FDTEMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUMvQkMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFlBQVk7SUFDckMsSUFBSUMsTUFBTSxDQUFDQyxLQUFLLElBQUksT0FBT0MsV0FBVyxLQUFLLFdBQVcsRUFBRTtNQUN0RCxNQUFNO1FBQUVDO01BQU0sQ0FBQyxHQUFHSCxNQUFNLENBQUNDLEtBQUs7TUFDOUIsTUFBTUcsR0FBRyxHQUFHLElBQUlELEtBQUssQ0FBQyxDQUFDOztNQUV2QjtNQUNBLFNBQVNFLFFBQVFBLENBQUNDLEVBQUUsRUFBRTtRQUNwQixNQUFNQyxPQUFPLEdBQUdWLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDUSxFQUFFLENBQUM7UUFDM0MsT0FBT0MsT0FBTyxJQUFJQSxPQUFPLENBQUNDLEtBQUssR0FBR0QsT0FBTyxDQUFDQyxLQUFLLEdBQUcsS0FBSztNQUN6RDtNQUVBLE1BQU1TLFVBQVUsR0FBR3BCLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUM7O01BRTNEO01BQ0FJLFdBQVcsQ0FBQ2UsVUFBVSxFQUFFO1FBQUVNLEtBQUssRUFBRSxDQUFDO1FBQUVDLE9BQU8sRUFBRTtNQUFLLENBQUMsQ0FBQyxDQUNqREMsSUFBSSxDQUFFQyxNQUFNLElBQUs7UUFDaEIsTUFBTUMsUUFBUSxHQUFHLEdBQUc7UUFDcEIsTUFBTUMsVUFBVSxHQUFHeEIsR0FBRyxDQUFDeUIsUUFBUSxDQUFDQyxRQUFRLENBQUNDLE1BQU07UUFDL0MsSUFBSUMsU0FBUyxHQUFJTixNQUFNLENBQUNLLE1BQU0sR0FBR0osUUFBUSxHQUFJRCxNQUFNLENBQUNYLEtBQUs7UUFDekQsSUFBSWtCLFVBQVUsR0FBR0QsU0FBUztRQUMxQixJQUFJRSxRQUFRLEdBQUcsRUFBRTtRQUVqQixNQUFNQyxPQUFPLEdBQUdULE1BQU0sQ0FBQ1UsU0FBUyxDQUFDLFdBQVcsQ0FBQzs7UUFFN0M7UUFDQWhDLEdBQUcsQ0FBQ2lDLFFBQVEsQ0FBQ0YsT0FBTyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUVELFFBQVEsRUFBRVAsUUFBUSxFQUFFSyxTQUFTLENBQUM7UUFDL0RDLFVBQVUsSUFBSUwsVUFBVSxHQUFHLEVBQUU7O1FBRTdCO1FBQ0EsT0FBT0ssVUFBVSxHQUFHLENBQUMsRUFBRTtVQUNyQkMsUUFBUSxHQUFHRCxVQUFVLEdBQUdELFNBQVM7VUFDakM1QixHQUFHLENBQUNrQyxPQUFPLENBQUMsQ0FBQztVQUNibEMsR0FBRyxDQUFDaUMsUUFBUSxDQUFDRixPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRUQsUUFBUSxFQUFFUCxRQUFRLEVBQUVLLFNBQVMsQ0FBQztVQUMvREMsVUFBVSxJQUFJTCxVQUFVLEdBQUcsRUFBRTtRQUMvQjtRQUVBeEIsR0FBRyxDQUFDa0MsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDOztRQUVmO1FBQ0EsTUFBTWxCLFVBQVUsR0FBR3ZCLFFBQVEsQ0FBQ2EsYUFBYSxDQUFDLEtBQUssQ0FBQztRQUNoRFUsVUFBVSxDQUFDVCxLQUFLLENBQUNDLE9BQU8sR0FBRyxNQUFNO1FBQ2pDUSxVQUFVLENBQUNULEtBQUssQ0FBQ0UsZUFBZSxHQUFHLE1BQU07UUFDekNPLFVBQVUsQ0FBQ1QsS0FBSyxDQUFDRyxLQUFLLEdBQUcsTUFBTTtRQUMvQk0sVUFBVSxDQUFDVCxLQUFLLENBQUNJLEtBQUssR0FBRyxPQUFPO1FBQ2hDSyxVQUFVLENBQUNULEtBQUssQ0FBQ0ssTUFBTSxHQUFHLE1BQU07UUFDaENJLFVBQVUsQ0FBQ0MsU0FBUyxHQUFHO0FBQ25DO0FBQ0E7QUFDQSxnRUFBZ0VoQixRQUFRLENBQzFELGVBQ0YsQ0FBQztBQUNiLDhEQUE4REEsUUFBUSxDQUN4RCxhQUNGLENBQUM7QUFDYiwwREFBMERBLFFBQVEsQ0FDcEQsVUFDRixDQUFDO0FBQ2IsOERBQThEQSxRQUFRLENBQ3hELGNBQ0YsQ0FBQztBQUNiLDhEQUE4REEsUUFBUSxDQUN4RCxhQUNGLENBQUM7QUFDYiw2REFBNkRBLFFBQVEsQ0FDdkQsYUFDRixDQUFDO0FBQ2IsNkRBQTZEQSxRQUFRLENBQ3ZELGtCQUNGLENBQUM7QUFDYixnRUFBZ0VBLFFBQVEsQ0FDMUQsZUFDRixDQUFDO0FBQ2Isb0VBQW9FQSxRQUFRLENBQzlELGFBQ0YsQ0FBQztBQUNiLGtFQUFrRUEsUUFBUSxDQUM1RCxXQUNGLENBQUM7QUFDYixpRUFBaUVBLFFBQVEsQ0FDM0QsZ0JBQ0YsQ0FBQztBQUNiLG1FQUFtRUEsUUFBUSxDQUM3RCxrQkFDRixDQUFDO0FBQ2IsaUVBQWlFQSxRQUFRLENBQzNELGdCQUNGLENBQUM7QUFDYiwyRUFBMkVBLFFBQVEsQ0FDckUsa0JBQ0YsQ0FBQztBQUNiLG1FQUFtRUEsUUFBUSxDQUM3RCxZQUNGLENBQUM7QUFDYjtBQUNBLFNBQVM7UUFFR1IsUUFBUSxDQUFDeUIsSUFBSSxDQUFDSixXQUFXLENBQUNFLFVBQVUsQ0FBQyxDQUFDLENBQUM7O1FBRXZDO1FBQ0FsQixXQUFXLENBQUNrQixVQUFVLEVBQUU7VUFBRUcsS0FBSyxFQUFFLENBQUM7VUFBRUMsT0FBTyxFQUFFO1FBQUssQ0FBQyxDQUFDLENBQUNDLElBQUksQ0FDdERzQixPQUFPLElBQUs7VUFDWCxNQUFNQyxRQUFRLEdBQUdELE9BQU8sQ0FBQ1gsU0FBUyxDQUFDLFdBQVcsQ0FBQztVQUMvQyxNQUFNYSxTQUFTLEdBQUcsR0FBRztVQUNyQixNQUFNQyxVQUFVLEdBQUlILE9BQU8sQ0FBQ2hCLE1BQU0sR0FBR2tCLFNBQVMsR0FBSUYsT0FBTyxDQUFDaEMsS0FBSztVQUMvRCxJQUFJb0MsV0FBVyxHQUFHRCxVQUFVO1VBQzVCLElBQUlFLFNBQVMsR0FBRyxFQUFFOztVQUVsQjtVQUNBLE9BQU9ELFdBQVcsR0FBRyxDQUFDLEVBQUU7WUFDdEIvQyxHQUFHLENBQUNpQyxRQUFRLENBQ1ZXLFFBQVEsRUFDUixLQUFLLEVBQ0wsRUFBRSxFQUNGSSxTQUFTLEVBQ1RILFNBQVMsRUFDVEMsVUFDRixDQUFDO1lBQ0RDLFdBQVcsSUFBSXZCLFVBQVUsR0FBRyxFQUFFO1lBQzlCLElBQUl1QixXQUFXLEdBQUcsQ0FBQyxFQUFFL0MsR0FBRyxDQUFDa0MsT0FBTyxDQUFDLENBQUM7VUFDcEM7VUFFQWxDLEdBQUcsQ0FBQ21DLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxDQUFDLENBQUM7VUFDNUNuQixVQUFVLENBQUNvQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdkIsQ0FDRixDQUFDO01BQ0gsQ0FBQyxDQUFDLENBQ0RDLEtBQUssQ0FBRUMsS0FBSyxJQUFLO1FBQ2hCQyxPQUFPLENBQUNELEtBQUssQ0FBQywrQkFBK0IsRUFBRUEsS0FBSyxDQUFDO01BQ3ZELENBQUMsQ0FBQztJQUNOLENBQUMsTUFBTTtNQUNMQyxPQUFPLENBQUNELEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQztJQUM3RDtFQUNGLENBQUMsQ0FBQztBQUNOOzs7Ozs7Ozs7Ozs7OztBQ3hJZSxTQUFTRSwwQkFBMEJBLENBQUEsRUFBRztFQUNuRC9DLFFBQVEsQ0FDTEMsY0FBYyxDQUFDLGVBQWUsQ0FBQyxDQUMvQkMsZ0JBQWdCLENBQUMsT0FBTyxFQUFFLFlBQVk7SUFDckMsSUFBSUMsTUFBTSxDQUFDQyxLQUFLLElBQUksT0FBT0MsV0FBVyxLQUFLLFdBQVcsRUFBRTtNQUN0RCxNQUFNO1FBQUVDO01BQU0sQ0FBQyxHQUFHSCxNQUFNLENBQUNDLEtBQUs7TUFDOUIsTUFBTUcsR0FBRyxHQUFHLElBQUlELEtBQUssQ0FBQyxDQUFDOztNQUV2QjtNQUNBLFNBQVNFLFFBQVFBLENBQUNDLEVBQUUsRUFBRTtRQUNwQixNQUFNQyxPQUFPLEdBQUdWLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDUSxFQUFFLENBQUM7UUFDM0MsT0FBT0MsT0FBTyxJQUFJQSxPQUFPLENBQUNDLEtBQUssR0FBR0QsT0FBTyxDQUFDQyxLQUFLLEdBQUcsS0FBSztNQUN6RDs7TUFFQTtNQUNBLE1BQU1DLFdBQVcsR0FBR1osUUFBUSxDQUFDYSxhQUFhLENBQUMsS0FBSyxDQUFDO01BQ2pERCxXQUFXLENBQUNILEVBQUUsR0FBRyxpQkFBaUI7TUFDbENHLFdBQVcsQ0FBQ0UsS0FBSyxDQUFDQyxPQUFPLEdBQUcsTUFBTTtNQUNsQ0gsV0FBVyxDQUFDRSxLQUFLLENBQUNFLGVBQWUsR0FBRyxNQUFNO01BQzFDSixXQUFXLENBQUNFLEtBQUssQ0FBQ0csS0FBSyxHQUFHLE1BQU07TUFDaENMLFdBQVcsQ0FBQ0UsS0FBSyxDQUFDSSxLQUFLLEdBQUcsT0FBTztNQUNqQ04sV0FBVyxDQUFDRSxLQUFLLENBQUNLLE1BQU0sR0FBRyxNQUFNOztNQUVqQztNQUNBLE1BQU1DLFVBQVUsR0FBR3BCLFFBQVEsQ0FBQ0MsY0FBYyxDQUFDLGFBQWEsQ0FBQztNQUN6RFcsV0FBVyxDQUFDUyxXQUFXLENBQUNELFVBQVUsQ0FBQ0UsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDOztNQUVuRDtNQUNBLE1BQU1DLFVBQVUsR0FBR3ZCLFFBQVEsQ0FBQ2EsYUFBYSxDQUFDLEtBQUssQ0FBQztNQUNoRFUsVUFBVSxDQUFDQyxTQUFTLEdBQUc7QUFDL0I7QUFDQTtBQUNBLDhEQUE4RGhCLFFBQVEsQ0FDdEQsWUFDRixDQUFDO0FBQ2YsaUVBQWlFQSxRQUFRLENBQ3pELGVBQ0YsQ0FBQztBQUNmLG1FQUFtRUEsUUFBUSxDQUMzRCxnQkFDRixDQUFDO0FBQ2YseUVBQXlFQSxRQUFRLENBQ2pFLHNCQUNGLENBQUM7QUFDZixnRUFBZ0VBLFFBQVEsQ0FDeEQsY0FDRixDQUFDO0FBQ2YsaUVBQWlFQSxRQUFRLENBQ3pELGVBQ0YsQ0FBQztBQUNmLGtFQUFrRUEsUUFBUSxDQUMxRCxlQUNGLENBQUM7QUFDZiw4RUFBOEVBLFFBQVEsQ0FDdEUsb0JBQ0YsQ0FBQztBQUNmLGlHQUFpR0EsUUFBUSxDQUN6RixtQ0FDRixDQUFDO0FBQ2YsdUVBQXVFQSxRQUFRLENBQy9ELG1CQUNGLENBQUM7QUFDZiw4RUFBOEVBLFFBQVEsQ0FDdEUseUJBQ0YsQ0FBQztBQUNmLDRFQUE0RUEsUUFBUSxDQUNwRSxpQkFDRixDQUFDO0FBQ2YseUVBQXlFQSxRQUFRLENBQ2pFLGNBQ0YsQ0FBQztBQUNmLDhFQUE4RUEsUUFBUSxDQUN0RSxzQkFDRixDQUFDO0FBQ2Y7QUFDQSxXQUFXO01BQ0hJLFdBQVcsQ0FBQ1MsV0FBVyxDQUFDRSxVQUFVLENBQUM7TUFDbkN2QixRQUFRLENBQUN5QixJQUFJLENBQUNKLFdBQVcsQ0FBQ1QsV0FBVyxDQUFDLENBQUMsQ0FBQzs7TUFFeEM7TUFDQVAsV0FBVyxDQUFDTyxXQUFXLEVBQUU7UUFBRWMsS0FBSyxFQUFFLENBQUM7UUFBRUMsT0FBTyxFQUFFO01BQUssQ0FBQyxDQUFDLENBQ2xEQyxJQUFJLENBQUVDLE1BQU0sSUFBSztRQUNoQixNQUFNQyxRQUFRLEdBQUcsR0FBRztRQUNwQixNQUFNQyxVQUFVLEdBQUd4QixHQUFHLENBQUN5QixRQUFRLENBQUNDLFFBQVEsQ0FBQ0MsTUFBTTtRQUMvQyxJQUFJQyxTQUFTLEdBQUlOLE1BQU0sQ0FBQ0ssTUFBTSxHQUFHSixRQUFRLEdBQUlELE1BQU0sQ0FBQ1gsS0FBSztRQUN6RCxJQUFJa0IsVUFBVSxHQUFHRCxTQUFTO1FBQzFCLElBQUlFLFFBQVEsR0FBRyxFQUFFO1FBRWpCLE1BQU1DLE9BQU8sR0FBR1QsTUFBTSxDQUFDVSxTQUFTLENBQUMsV0FBVyxDQUFDOztRQUU3QztRQUNBaEMsR0FBRyxDQUFDaUMsUUFBUSxDQUFDRixPQUFPLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRUQsUUFBUSxFQUFFUCxRQUFRLEVBQUVLLFNBQVMsQ0FBQztRQUMvREMsVUFBVSxJQUFJTCxVQUFVLEdBQUcsRUFBRTs7UUFFN0I7UUFDQSxPQUFPSyxVQUFVLEdBQUcsQ0FBQyxFQUFFO1VBQ3JCQyxRQUFRLEdBQUdELFVBQVUsR0FBR0QsU0FBUztVQUNqQzVCLEdBQUcsQ0FBQ2tDLE9BQU8sQ0FBQyxDQUFDO1VBQ2JsQyxHQUFHLENBQUNpQyxRQUFRLENBQUNGLE9BQU8sRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFRCxRQUFRLEVBQUVQLFFBQVEsRUFBRUssU0FBUyxDQUFDO1VBQy9EQyxVQUFVLElBQUlMLFVBQVUsR0FBRyxFQUFFO1FBQy9CO1FBRUF4QixHQUFHLENBQUNtQyxJQUFJLENBQUMsb0NBQW9DLENBQUM7UUFDOUM5QixXQUFXLENBQUMrQixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDeEIsQ0FBQyxDQUFDLENBQ0RDLEtBQUssQ0FBRUMsS0FBSyxJQUFLO1FBQ2hCQyxPQUFPLENBQUNELEtBQUssQ0FBQywrQkFBK0IsRUFBRUEsS0FBSyxDQUFDO01BQ3ZELENBQUMsQ0FBQztJQUNOLENBQUMsTUFBTTtNQUNMQyxPQUFPLENBQUNELEtBQUssQ0FBQyw0Q0FBNEMsQ0FBQztJQUM3RDtFQUNGLENBQUMsQ0FBQztBQUNOOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxLQUFLLFNBQVM7QUFDM0MsYUFBYSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUU7QUFDNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLFNBQVM7QUFDakQsZUFBZSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUk7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0IsdUJBQXVCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsbUJBQW1CLFdBQVc7QUFDOUI7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNkRBQVM7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBMkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1CQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2REFBWTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixrQ0FBa0MsNkRBQVk7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseURBQTRCO0FBQ3pEO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUyxFQUFFLDZEQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Z0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFVBQVU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFVBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRSt0QjtBQUMvdEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3B1V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBO0FBQ0EsZ0JBQWdCLHVDQUF1QztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdEQUFLO0FBQ3pEO0FBQ0E7QUFDQSxvREFBb0QsZ0RBQUs7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xELGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsZ0NBQWdDO0FBQ2hDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFlBQVksa0dBQWtHO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZEQUE2RDtBQUN6RSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQTBDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2REFBNkQ7QUFDekU7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekMsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBLFVBQVUsa0JBQWtCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGFBQWE7QUFDOUMsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0EsS0FBSyxtQkFBbUI7QUFDeEIsS0FBSztBQUNMOztBQUVBO0FBQ0Esb0JBQW9CLGdEQUFVO0FBQzlCO0FBQ0E7QUFDQSxvQkFBb0Isa0RBQVk7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQixnREFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsVUFBVTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVEQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3REFBTSxDQUFDLHlEQUFPLGlCQUFpQjtBQUM5QyxnQkFBZ0IseURBQU8sZ0JBQWdCLHVDQUFVOztBQUVqRDtBQUNBLGFBQWEseURBQU87QUFDcEIsY0FBYyx5REFBTztBQUNyQjtBQUNBLHVCQUF1Qix5REFBTztBQUM5QixtQkFBbUIseURBQU87QUFDMUIsb0JBQW9CLHlEQUFPO0FBQzNCLG1CQUFtQix5REFBTztBQUMxQixhQUFhLHlEQUFPO0FBQ3BCLFlBQVkseURBQU87QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUFPO0FBQ3JCLGVBQWUseURBQU87QUFDdEI7QUFDQSxlQUFlLDJEQUFTLENBQUMseURBQU87QUFDaEM7QUFDQSxnQkFBZ0IseURBQU87QUFDdkI7QUFDQSxpQkFBaUIseURBQU87QUFDeEIsc0JBQXNCLHlEQUFPO0FBQzdCLHVCQUF1Qix5REFBTztBQUM5Qix1QkFBdUIseURBQU87QUFDOUIsdUJBQXVCLHlEQUFPO0FBQzlCO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHlEQUFPOztBQUV6QjtBQUNBO0FBQ0EsY0FBYyxnRUFBYyxDQUFDLDBEQUFRO0FBQ3JDLGNBQWMsK0RBQWE7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxnRUFBZ0U7QUFDaEUsZ0VBQWdFOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFtQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sdUZBQXVGLE1BQU0sWUFBWSxNQUFNLFVBQVUsS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxLQUFLLFlBQVksV0FBVyxVQUFVLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxVQUFVLFVBQVUsS0FBSyxLQUFLLFVBQVUsTUFBTSxLQUFLLFlBQVksV0FBVyxNQUFNLE1BQU0sWUFBWSxhQUFhLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksV0FBVyxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsWUFBWSxPQUFPLEtBQUssVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsTUFBTSxLQUFLLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsV0FBVyxVQUFVLE1BQU0sS0FBSyxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxPQUFPLFVBQVUsS0FBSyxZQUFZLFdBQVcsWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsS0FBSyxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsTUFBTSxLQUFLLFlBQVksTUFBTSxLQUFLLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxZQUFZLFdBQVcsT0FBTyxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxXQUFXLEtBQUssT0FBTyxPQUFPLEtBQUssVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFVBQVUsWUFBWSxNQUFNLEtBQUssWUFBWSxhQUFhLFdBQVcsVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLE1BQU0sS0FBSyxZQUFZLFdBQVcsS0FBSyxNQUFNLFlBQVksV0FBVyxLQUFLLEtBQUssWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLFlBQVksTUFBTSxVQUFVLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLE1BQU0sT0FBTyxhQUFhLE1BQU0sS0FBSyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxXQUFXLFVBQVUsVUFBVSxVQUFVLFlBQVksTUFBTSxLQUFLLFVBQVUsWUFBWSxPQUFPLFVBQVUsS0FBSyxZQUFZLFdBQVcsVUFB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QUFnQixDQUFDLE9BQU8sRUFBRXlELHlFQUFtQixDQUFDO0VBQ3RELENBQUMsQ0FBQztFQUNGd1csTUFBTSxDQUFDblYsT0FBTyxDQUFFSSxLQUFLLElBQUs7SUFDeEJBLEtBQUssQ0FBQ2xGLGdCQUFnQixDQUFDLE9BQU8sRUFBRXlPLDJEQUF1QixDQUFDO0VBQzFELENBQUMsQ0FBQztFQUVGMUwsNEVBQXNCLENBQUMsQ0FBQzs7RUFFeEI7RUFDQSxNQUFNbVgsYUFBYSxHQUFHcGEsUUFBUSxDQUFDQyxjQUFjLENBQUMsV0FBVyxDQUFDO0VBQzFELElBQUltYSxhQUFhLEVBQUU7SUFDakJBLGFBQWEsQ0FBQ2xhLGdCQUFnQixDQUFDLFFBQVEsRUFBRXdPLGlFQUFnQixDQUFDO0VBQzVEOztFQUVBO0VBQ0EzRSxtRUFBa0IsQ0FBQyxDQUFDO0VBQ3BCcEcsNkVBQW1CLENBQUMsQ0FBQztFQUNyQmdMLCtEQUF1QixDQUFDLENBQUM7O0VBRXpCO0VBQ0FtSywwRUFBcUIsQ0FBQyxDQUFDO0FBQ3pCLENBQUMsQ0FBQyxDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9kb3dubG9hZGVycy9ob3VzZS1mbGlwLXBkZi5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL2Rvd25sb2FkZXJzL3BkZi1ldmVudC1saXN0ZW5lcnMuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9kb3dubG9hZGVycy9yZW50YWwtcGRmLmpzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vZG93bmxvYWRlcnMvcmV0aXJlbWVudC1wZGYuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9ub2RlX21vZHVsZXMvQGt1cmtsZS9jb2xvci9kaXN0L2NvbG9yLmVzbS5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2NoYXJ0LmpzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vbm9kZV9tb2R1bGVzL2NoYXJ0LmpzL2Rpc3QvY2h1bmtzL2hlbHBlcnMuZGF0YXNldC5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL25vZGVfbW9kdWxlcy9jaGFydC5qcy9kaXN0L2hlbHBlcnMuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9ub2RlX21vZHVsZXMvY2hhcnQuanMvaGVscGVycy9oZWxwZXJzLmpzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vbm9kZV9tb2R1bGVzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvZGlzdC9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzLmVzbS5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9idWRnZXQtdGFibGUuY3NzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vc3JjL3N0eWxlLmNzcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlVGFnVHJhbnNmb3JtLmpzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vc3JjL2J1ZGdldC10YWJsZS5jc3M/YTFjMCIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9jYWxjdWxhdG9ycy9jYWxjdWxhdGUtcmV0aXJlbWVudC5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9jYWxjdWxhdG9ycy9ob3VzZS1mbGlwLmpzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vc3JjL2NhbGN1bGF0b3JzL3JlbnRhbC5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9jaGFydC11dGlscy9yZXNldC1jYW52YXMuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9zcmMvY2hhcnRzL2Fydi1kaXN0cmlidXRpb24tY2hhcnQuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9zcmMvY2hhcnRzL2Fzc2V0LWJyZWFrZG93bi1jaGFydC5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9jaGFydHMvY2FzaGZsb3ctY2hhcnQuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9zcmMvY2hhcnRzL2luY29tZS1zb3VyY2UtY2hhcnQuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9zcmMvY2hhcnRzL3BvcnRmb2xpby1jaGFydC5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9jaGFydHMvcHJvamVjdC1jb3N0LWJyZWFrZG93bi1jaGFydC5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9zdHlsZS5jc3M/NzE2MyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy91dGlscy9mb3JtYXQtbnVtYmVyLXBlcmNlbnQuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9zcmMvdXRpbHMvZm9ybWF0LW51bWJlci5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy91dGlscy9nZW5lcmF0ZS10YWJsZS1tYXJrdXAuanMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvLi9zcmMvdXRpbHMvaW50ZXJlc3QtcHJvamVjdC1kdXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy91dGlscy9wb3B1bGF0ZS15ZWFycy1kcm9wZG93bi5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy91dGlscy90YWJsZS1kYXRhLmpzIiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrLy4vc3JjL3V0aWxzL3VwZGF0ZS10YWJsZS1yYW5nZS5qcyIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZmluYW5jZS1jYWxjdWxhdG9ycy1yZXdvcmsvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2ZpbmFuY2UtY2FsY3VsYXRvcnMtcmV3b3JrL3dlYnBhY2svcnVudGltZS9ub25jZSIsIndlYnBhY2s6Ly9maW5hbmNlLWNhbGN1bGF0b3JzLXJld29yay8uL3NyYy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXR1cEhvdXNlRmxpcFBkZkRvd25sb2FkKCkge1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93bmxvYWQtcGRmJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgaWYgKHdpbmRvdy5qc3BkZiAmJiB0eXBlb2YgaHRtbDJjYW52YXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCB7IGpzUERGIH0gPSB3aW5kb3cuanNwZGY7XG4gICAgICBjb25zdCBkb2MgPSBuZXcganNQREYoKTtcblxuICAgICAgLy8gRnVuY3Rpb24gdG8gZ2V0IHZhbHVlcyBmcm9tIGlucHV0IGZpZWxkc1xuICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoaWQpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC52YWx1ZSA/IGVsZW1lbnQudmFsdWUgOiAnTi9BJztcbiAgICAgIH1cblxuICAgICAgLy8gQ29tYmluZSBleGlzdGluZyBjb250ZW50IGFuZCBob3VzZSBmbGlwcGluZyBhbmFseXNpcyBpbnRvIGEgc2luZ2xlIGRpdlxuICAgICAgY29uc3QgY29tYmluZWREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGNvbWJpbmVkRGl2LmlkID0gJ2NvbWJpbmVkQ29udGVudCc7XG4gICAgICBjb21iaW5lZERpdi5zdHlsZS5wYWRkaW5nID0gJzIwcHgnO1xuICAgICAgY29tYmluZWREaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgY29tYmluZWREaXYuc3R5bGUuY29sb3IgPSAnIzAwMCc7XG4gICAgICBjb21iaW5lZERpdi5zdHlsZS53aWR0aCA9ICc4MDBweCc7XG4gICAgICBjb21iaW5lZERpdi5zdHlsZS5tYXJnaW4gPSAnYXV0byc7XG5cbiAgICAgIC8vIENsb25lIHRoZSBvcmlnaW5hbCBjb250ZW50XG4gICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnRQREYnKTtcbiAgICAgIGNvbWJpbmVkRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgLy8gQ3JlYXRlIHJlc3VsdHMgc2VjdGlvblxuICAgICAgY29uc3QgcmVzdWx0c0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgcmVzdWx0c0Rpdi5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICA8aDIgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlcjsgbWFyZ2luLXRvcDogMjBweDtcIj5JbnB1dHM8L2gyPlxuICAgICAgICAgICAgPHRhYmxlIGJvcmRlcj1cIjFcIiBjZWxsc3BhY2luZz1cIjBcIiBjZWxscGFkZGluZz1cIjVcIiBzdHlsZT1cIndpZHRoOjEwMCU7IHRleHQtYWxpZ246bGVmdDtcIj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPlByb3BlcnR5IEFkZHJlc3M6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ3Byb3BlcnR5QWRkcmVzcydcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Qcm9wZXJ0eSBQdXJjaGFzZSBQcmljZTo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAncHVyY2hhc2VQcmljZSdcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5SZW5vdmF0aW9uIENvc3RzOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdyZW5vQ29zdHMnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+Q2xvc2luZyBDb3N0czo8L3N0cm9uZz48L3RkPjx0ZD4ke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdjbG9zaW5nQ29zdHMnXG4gICAgICAgICAgICAgICl9JTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkhvbGRpbmcgQ29zdHM6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2hvbGRpbmdDb3N0cydcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5BZnRlciBSZXBhaXIgVmFsdWU6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2FmdGVyUmVwYWlyVmFsdWUnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+UHJvamVjdCBNb250aHM6PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAncHJvamVjdE1vbnRocydcbiAgICAgICAgICAgICAgKX0gTW9udGhzPC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+SG91c2UgTW9udGhseSBSZW50Ojwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdob3VzZU1vbnRobHlSZW50J1xuICAgICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkhvdXNlIEludGVyZXN0IFJhdGU6PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnaG91c2VpbnRlcmVzdFJhdGUnXG4gICAgICAgICAgICAgICl9JTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkxvYW4gUG9pbnRzOjwvc3Ryb25nPjwvdGQ+PHRkPiR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2xvYW5Qb2ludHMnXG4gICAgICAgICAgICAgICl9JTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkxvYW4gVGVybTo8L3N0cm9uZz48L3RkPjx0ZD4ke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdob3VzZUxvYW5ZZWFyJ1xuICAgICAgICAgICAgICApfSBZZWFyczwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkdhcCBDb3N0czo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnZ2FwQ29zdHMnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+RG93biBQYXltZW50IFBlcmNlbnQ6PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnZG93blBheW1lbnRQZXJjZW50J1xuICAgICAgICAgICAgICApfSU8L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5SZXNhbGUgQ29zdHM6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ3Jlc2FsZUNvc3RzJ1xuICAgICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkRlc2lyZWQgUHJvZml0IE1hcmdpbjo8L3N0cm9uZz48L3RkPjx0ZD4ke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdkZXNpcmVkUHJvZml0TWFyZ2luJ1xuICAgICAgICAgICAgICApfSU8L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Eb3duIFBheW1lbnQgQmFzZWQgT246PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2Rvd25QYXltZW50VHlwZSdcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Bbm51YWwgTWFpbnRlbmFuY2U6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2hvdXNlQW5udWFsTWFpbnRlbmFuY2UnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+QW5udWFsIFV0aWxpdGllczo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnaG91c2VBbm51YWxVdGlsaXRpZXMnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+QW5udWFsIEluc3VyYW5jZTo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnaW5zdXJhbmNlJ1xuICAgICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkFubnVhbCBQcm9wZXJ0eSBUYXhlczo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAncHJvcGVydHlUYXhlc0hGJ1xuICAgICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgYDtcbiAgICAgIGNvbWJpbmVkRGl2LmFwcGVuZENoaWxkKHJlc3VsdHNEaXYpO1xuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjb21iaW5lZERpdik7IC8vIEFwcGVuZCB0byBkb2N1bWVudCBmb3IgcmVuZGVyaW5nXG5cbiAgICAgIC8vIENhcHR1cmUgY29udGVudCBhcyBtdWx0aXBsZSBpbWFnZXNcbiAgICAgIGh0bWwyY2FudmFzKGNvbWJpbmVkRGl2LCB7IHNjYWxlOiAyLCB1c2VDT1JTOiB0cnVlIH0pXG4gICAgICAgIC50aGVuKChjYW52YXMpID0+IHtcbiAgICAgICAgICBjb25zdCBpbWdXaWR0aCA9IDE5MDtcbiAgICAgICAgICBjb25zdCBwYWdlSGVpZ2h0ID0gZG9jLmludGVybmFsLnBhZ2VTaXplLmhlaWdodDtcbiAgICAgICAgICBsZXQgaW1nSGVpZ2h0ID0gKGNhbnZhcy5oZWlnaHQgKiBpbWdXaWR0aCkgLyBjYW52YXMud2lkdGg7XG4gICAgICAgICAgbGV0IGhlaWdodExlZnQgPSBpbWdIZWlnaHQ7XG4gICAgICAgICAgbGV0IHBvc2l0aW9uID0gMTA7XG5cbiAgICAgICAgICBjb25zdCBpbWdEYXRhID0gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJyk7XG5cbiAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFnZVxuICAgICAgICAgIGRvYy5hZGRJbWFnZShpbWdEYXRhLCAnUE5HJywgMTAsIHBvc2l0aW9uLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICBoZWlnaHRMZWZ0IC09IHBhZ2VIZWlnaHQgLSAyMDtcblxuICAgICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIHBhZ2VzIGlmIGNvbnRlbnQgb3ZlcmZsb3dzXG4gICAgICAgICAgd2hpbGUgKGhlaWdodExlZnQgPiAwKSB7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGhlaWdodExlZnQgLSBpbWdIZWlnaHQ7XG4gICAgICAgICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgICAgICAgZG9jLmFkZEltYWdlKGltZ0RhdGEsICdQTkcnLCAxMCwgcG9zaXRpb24sIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgaGVpZ2h0TGVmdCAtPSBwYWdlSGVpZ2h0IC0gMjA7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jLnNhdmUoJ2hvdXNlX2ZsaXBwaW5nX2FuYWx5c2lzLnBkZicpO1xuICAgICAgICAgIGNvbWJpbmVkRGl2LnJlbW92ZSgpOyAvLyBDbGVhbiB1cCB0ZW1wb3JhcnkgZGl2XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYXB0dXJpbmcgSFRNTCBjb250ZW50OicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGIG9yIGh0bWwyY2FudmFzIG5vdCBsb2FkZWQgY29ycmVjdGx5LicpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJpbXBvcnQgc2V0dXBIb3VzZUZsaXBQZGZEb3dubG9hZCBmcm9tICcuL2hvdXNlLWZsaXAtcGRmJztcbmltcG9ydCBzZXR1cFJldGlyZW1lbnRQZGZEb3dubG9hZCBmcm9tICcuL3JldGlyZW1lbnQtcGRmJztcbmltcG9ydCBzZXR1cFJlbnRhbFBkZkRvd25sb2FkIGZyb20gJy4vcmVudGFsLXBkZic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGluaXRpYWxpemVQZGZMaXN0ZW5lcnMoKSB7XG4gIHNldHVwSG91c2VGbGlwUGRmRG93bmxvYWQoKTtcbiAgc2V0dXBSZXRpcmVtZW50UGRmRG93bmxvYWQoKTtcbiAgc2V0dXBSZW50YWxQZGZEb3dubG9hZCgpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBSZW50YWxQZGZEb3dubG9hZCgpIHtcbiAgZG9jdW1lbnRcbiAgICAuZ2V0RWxlbWVudEJ5SWQoJ2Rvd25sb2FkLXBkZjMnKVxuICAgIC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh3aW5kb3cuanNwZGYgJiYgdHlwZW9mIGh0bWwyY2FudmFzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB7IGpzUERGIH0gPSB3aW5kb3cuanNwZGY7XG4gICAgICAgIGNvbnN0IGRvYyA9IG5ldyBqc1BERigpO1xuXG4gICAgICAgIC8vIEZ1bmN0aW9uIHRvIGdldCB2YWx1ZXMgZnJvbSBpbnB1dCBmaWVsZHNcbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoaWQpIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudmFsdWUgPyBlbGVtZW50LnZhbHVlIDogJ04vQSc7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnRQREYzJyk7IC8vIEZpcnN0IHBhZ2UgY29udGVudFxuXG4gICAgICAgIC8vIFN0ZXAgMTogQ2FwdHVyZSB0aGUgZmlyc3Qgc2VjdGlvbiAoY29udGVudFBERjMpXG4gICAgICAgIGh0bWwyY2FudmFzKGNvbnRlbnREaXYsIHsgc2NhbGU6IDIsIHVzZUNPUlM6IHRydWUgfSlcbiAgICAgICAgICAudGhlbigoY2FudmFzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbWdXaWR0aCA9IDE5MDtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGltZ0hlaWdodCA9IChjYW52YXMuaGVpZ2h0ICogaW1nV2lkdGgpIC8gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgbGV0IGhlaWdodExlZnQgPSBpbWdIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSAxMDtcblxuICAgICAgICAgICAgY29uc3QgaW1nRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFnZSBjb250ZW50XG4gICAgICAgICAgICBkb2MuYWRkSW1hZ2UoaW1nRGF0YSwgJ1BORycsIDEwLCBwb3NpdGlvbiwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgICBoZWlnaHRMZWZ0IC09IHBhZ2VIZWlnaHQgLSAyMDtcblxuICAgICAgICAgICAgLy8gQWRkIG5ldyBwYWdlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgICAgIHdoaWxlIChoZWlnaHRMZWZ0ID4gMCkge1xuICAgICAgICAgICAgICBwb3NpdGlvbiA9IGhlaWdodExlZnQgLSBpbWdIZWlnaHQ7XG4gICAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7XG4gICAgICAgICAgICAgIGRvYy5hZGRJbWFnZShpbWdEYXRhLCAnUE5HJywgMTAsIHBvc2l0aW9uLCBpbWdXaWR0aCwgaW1nSGVpZ2h0KTtcbiAgICAgICAgICAgICAgaGVpZ2h0TGVmdCAtPSBwYWdlSGVpZ2h0IC0gMjA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRvYy5hZGRQYWdlKCk7IC8vIE1vdmUgdG8gbmV4dCBwYWdlIGZvciBpbnB1dCBkYXRhXG5cbiAgICAgICAgICAgIC8vIFN0ZXAgMjogQ3JlYXRlIHJlc3VsdHMgc2VjdGlvblxuICAgICAgICAgICAgY29uc3QgcmVzdWx0c0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgcmVzdWx0c0Rpdi5zdHlsZS5wYWRkaW5nID0gJzIwcHgnO1xuICAgICAgICAgICAgcmVzdWx0c0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZic7XG4gICAgICAgICAgICByZXN1bHRzRGl2LnN0eWxlLmNvbG9yID0gJyMwMDAnO1xuICAgICAgICAgICAgcmVzdWx0c0Rpdi5zdHlsZS53aWR0aCA9ICc4MDBweCc7XG4gICAgICAgICAgICByZXN1bHRzRGl2LnN0eWxlLm1hcmdpbiA9ICdhdXRvJztcbiAgICAgICAgICAgIHJlc3VsdHNEaXYuaW5uZXJIVE1MID0gYFxuICAgICAgICAgIDxoMiBzdHlsZT1cInRleHQtYWxpZ246Y2VudGVyOyBtYXJnaW4tdG9wOiAyMHB4O1wiPlJlbnRhbCBQcm9wZXJ0eSBJbnB1dHM8L2gyPlxuICAgICAgICAgIDx0YWJsZSBib3JkZXI9XCIxXCIgY2VsbHNwYWNpbmc9XCIwXCIgY2VsbHBhZGRpbmc9XCI1XCIgc3R5bGU9XCJ3aWR0aDoxMDAlOyB0ZXh0LWFsaWduOmxlZnQ7XCI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+UHJvcGVydHkgUHJpY2U6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICdwcm9wZXJ0eVByaWNlJ1xuICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+RG93biBQYXltZW50Ojwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAnZG93blBheW1lbnQnXG4gICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Mb2FuIFRlcm06PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgJ2xvYW5UZXJtJ1xuICAgICAgICAgICAgKX0gWWVhcnM8L3RkPjwvdHI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+SW50ZXJlc3QgUmF0ZTo8L3N0cm9uZz48L3RkPjx0ZD4ke2dldFZhbHVlKFxuICAgICAgICAgICAgICAnaW50ZXJlc3RSYXRlJ1xuICAgICAgICAgICAgKX0lPC90ZD48L3RyPlxuICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPk1vbnRobHkgUmVudDo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgJ21vbnRobHlSZW50J1xuICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+VmFjYW5jeSBSYXRlOjwvc3Ryb25nPjwvdGQ+PHRkPiR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICd2YWNhbmN5UmF0ZSdcbiAgICAgICAgICAgICl9JTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5DbG9zaW5nIENvc3Q6PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgJ2Nsb3NpbmdDb3N0c1JlbnQnXG4gICAgICAgICAgICApfSU8L3RkPjwvdHI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+UHJvcGVydHkgVGF4ZXM6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICdwcm9wZXJ0eVRheGVzJ1xuICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+QW5udWFsIFJlbm92YXRpb25zOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAncmVub3ZhdGlvbnMnXG4gICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Bbm51YWwgVXRpbGl0aWVzOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAndXRpbGl0aWVzJ1xuICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+SW5zdXJhbmNlIENvc3RzOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAnaW5zdXJhbmNlQ29zdHMnXG4gICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5NYWludGVuYW5jZSBDb3N0czo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgJ21haW50ZW5hbmNlQ29zdHMnXG4gICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5NYW5hZ2VtZW50IEZlZXM6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICdtYW5hZ2VtZW50RmVlcydcbiAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPlByb3BlcnR5IEFwcHJlY2lhdGlvbiBSYXRlOjwvc3Ryb25nPjwvdGQ+PHRkPiR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICdhcHByZWNpYXRpb25SYXRlJ1xuICAgICAgICAgICAgKX0lPC90ZD48L3RyPlxuICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkFubnVhbCBSZW50IEdyb3d0aDo8L3N0cm9uZz48L3RkPjx0ZD4ke2dldFZhbHVlKFxuICAgICAgICAgICAgICAncmVudEdyb3d0aCdcbiAgICAgICAgICAgICl9JTwvdGQ+PC90cj5cbiAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICBgO1xuXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJlc3VsdHNEaXYpOyAvLyBBcHBlbmQgdG8gZG9jdW1lbnQgZm9yIHJlbmRlcmluZ1xuXG4gICAgICAgICAgICAvLyBTdGVwIDM6IENhcHR1cmUgdGhlIHJlc3VsdHMgc2VjdGlvblxuICAgICAgICAgICAgaHRtbDJjYW52YXMocmVzdWx0c0RpdiwgeyBzY2FsZTogMiwgdXNlQ09SUzogdHJ1ZSB9KS50aGVuKFxuICAgICAgICAgICAgICAoY2FudmFzMikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGltZ0RhdGEyID0gY2FudmFzMi50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGltZ1dpZHRoMiA9IDE5MDtcbiAgICAgICAgICAgICAgICBjb25zdCBpbWdIZWlnaHQyID0gKGNhbnZhczIuaGVpZ2h0ICogaW1nV2lkdGgyKSAvIGNhbnZhczIud2lkdGg7XG4gICAgICAgICAgICAgICAgbGV0IGhlaWdodExlZnQyID0gaW1nSGVpZ2h0MjtcbiAgICAgICAgICAgICAgICBsZXQgcG9zaXRpb24yID0gMTA7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgbmV3IHBhZ2VzIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIHdoaWxlIChoZWlnaHRMZWZ0MiA+IDApIHtcbiAgICAgICAgICAgICAgICAgIGRvYy5hZGRJbWFnZShcbiAgICAgICAgICAgICAgICAgICAgaW1nRGF0YTIsXG4gICAgICAgICAgICAgICAgICAgICdQTkcnLFxuICAgICAgICAgICAgICAgICAgICAxMCxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24yLFxuICAgICAgICAgICAgICAgICAgICBpbWdXaWR0aDIsXG4gICAgICAgICAgICAgICAgICAgIGltZ0hlaWdodDJcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICBoZWlnaHRMZWZ0MiAtPSBwYWdlSGVpZ2h0IC0gMjA7XG4gICAgICAgICAgICAgICAgICBpZiAoaGVpZ2h0TGVmdDIgPiAwKSBkb2MuYWRkUGFnZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRvYy5zYXZlKCdyZW50YWxfcHJvcGVydHlfZXZhbHVhdGlvbi5wZGYnKTsgLy8gU2F2ZSBQREZcbiAgICAgICAgICAgICAgICByZXN1bHRzRGl2LnJlbW92ZSgpOyAvLyBDbGVhbiB1cCB0ZW1wb3JhcnkgZGl2XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjYXB0dXJpbmcgSFRNTCBjb250ZW50OicsIGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2pzUERGIG9yIGh0bWwyY2FudmFzIG5vdCBsb2FkZWQgY29ycmVjdGx5LicpO1xuICAgICAgfVxuICAgIH0pO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0dXBSZXRpcmVtZW50UGRmRG93bmxvYWQoKSB7XG4gIGRvY3VtZW50XG4gICAgLmdldEVsZW1lbnRCeUlkKCdkb3dubG9hZC1wZGYyJylcbiAgICAuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAod2luZG93LmpzcGRmICYmIHR5cGVvZiBodG1sMmNhbnZhcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc3QgeyBqc1BERiB9ID0gd2luZG93LmpzcGRmO1xuICAgICAgICBjb25zdCBkb2MgPSBuZXcganNQREYoKTtcblxuICAgICAgICAvLyBGdW5jdGlvbiB0byBnZXQgdmFsdWVzIGZyb20gaW5wdXQgZmllbGRzXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKGlkKSB7XG4gICAgICAgICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnZhbHVlID8gZWxlbWVudC52YWx1ZSA6ICdOL0EnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tYmluZSB0aGUgZXhpc3RpbmcgY29udGVudCBhbmQgcmV0aXJlbWVudCBwbGFubmluZyBhbmFseXNpcyBpbnRvIGEgc2luZ2xlIGRpdlxuICAgICAgICBjb25zdCBjb21iaW5lZERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb21iaW5lZERpdi5pZCA9ICdjb21iaW5lZENvbnRlbnQnO1xuICAgICAgICBjb21iaW5lZERpdi5zdHlsZS5wYWRkaW5nID0gJzIwcHgnO1xuICAgICAgICBjb21iaW5lZERpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmZic7XG4gICAgICAgIGNvbWJpbmVkRGl2LnN0eWxlLmNvbG9yID0gJyMwMDAnO1xuICAgICAgICBjb21iaW5lZERpdi5zdHlsZS53aWR0aCA9ICc4MDBweCc7XG4gICAgICAgIGNvbWJpbmVkRGl2LnN0eWxlLm1hcmdpbiA9ICdhdXRvJztcblxuICAgICAgICAvLyBDbG9uZSB0aGUgb3JpZ2luYWwgY29udGVudFxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnRQREYyJyk7XG4gICAgICAgIGNvbWJpbmVkRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYuY2xvbmVOb2RlKHRydWUpKTtcblxuICAgICAgICAvLyBDcmVhdGUgcmVzdWx0cyBzZWN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdHNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgcmVzdWx0c0Rpdi5pbm5lckhUTUwgPSBgXG4gICAgICAgICAgICA8aDIgc3R5bGU9XCJ0ZXh0LWFsaWduOmNlbnRlcjsgbWFyZ2luLXRvcDogMjBweDtcIj5SZXRpcmVtZW50IFBsYW5uaW5nIElucHV0czwvaDI+XG4gICAgICAgICAgICA8dGFibGUgYm9yZGVyPVwiMVwiIGNlbGxzcGFjaW5nPVwiMFwiIGNlbGxwYWRkaW5nPVwiNVwiIHN0eWxlPVwid2lkdGg6MTAwJTsgdGV4dC1hbGlnbjpsZWZ0O1wiPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+Q3VycmVudCBBZ2U6PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnY3VycmVudEFnZSdcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5SZXRpcmVtZW50IEFnZTo8L3N0cm9uZz48L3RkPjx0ZD4ke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdyZXRpcmVtZW50QWdlJ1xuICAgICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgPHRyPjx0ZD48c3Ryb25nPkN1cnJlbnQgU2F2aW5nczo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnY3VycmVudFNhdmluZ3MnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+TW9udGhseSBDb250cmlidXRpb25zOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdtb250aGx5Q29udHJpYnV0aW9ucydcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Bbm51YWwgUmV0dXJuOjwvc3Ryb25nPjwvdGQ+PHRkPiR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2FubnVhbFJldHVybidcbiAgICAgICAgICAgICAgKX0lPC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+SW5mbGF0aW9uIFJhdGU6PC9zdHJvbmc+PC90ZD48dGQ+JHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnaW5mbGF0aW9uUmF0ZSdcbiAgICAgICAgICAgICAgKX0lPC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+RGVzaXJlZCBJbmNvbWU6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2Rlc2lyZWRJbmNvbWUnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+V2hvbGUgTGlmZSBJbnN1cmFuY2UgVmFsdWU6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ3dob2xlTGlmZUluc3VyYW5jZSdcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5Nb250aGx5IENvbnRyaWJ1dGlvbnMgdG8gV2hvbGUgTGlmZSBJbnN1cmFuY2U6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ2xpZmVJbnN1cmFuY2VNb250aGx5Q29udHJpYnV0aW9ucydcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5DdXJyZW50IFN0b2NrIFZhbHVlOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdjdXJyZW50U3RvY2tWYWx1ZSdcbiAgICAgICAgICAgICAgKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgIDx0cj48dGQ+PHN0cm9uZz5DdXJyZW50IFJlYWwgRXN0YXRlIEVxdWl0eTo8L3N0cm9uZz48L3RkPjx0ZD4kJHtnZXRWYWx1ZShcbiAgICAgICAgICAgICAgICAnY3VycmVudFJlYWxFc3RhdGVFcXVpdHknXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+Q3VycmVudCBNb3J0Z2FnZSBCYWxhbmNlOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdtb3J0Z2FnZUJhbGFuY2UnXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+TW9ydGdhZ2UgVGVybSAoWWVhcnMpOjwvc3Ryb25nPjwvdGQ+PHRkPiQke2dldFZhbHVlKFxuICAgICAgICAgICAgICAgICdtb3J0Z2FnZVRlcm0nXG4gICAgICAgICAgICAgICl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICA8dHI+PHRkPjxzdHJvbmc+TW9ydGdhZ2UgSW50ZXJlc3QgUmF0ZSAoJSk6PC9zdHJvbmc+PC90ZD48dGQ+JCR7Z2V0VmFsdWUoXG4gICAgICAgICAgICAgICAgJ21vcnRnYWdlSW50ZXJlc3RSYXRlJ1xuICAgICAgICAgICAgICApfTwvdGQ+PC90cj5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgICAgYDtcbiAgICAgICAgY29tYmluZWREaXYuYXBwZW5kQ2hpbGQocmVzdWx0c0Rpdik7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY29tYmluZWREaXYpOyAvLyBBcHBlbmQgdG8gZG9jdW1lbnQgZm9yIHJlbmRlcmluZ1xuXG4gICAgICAgIC8vIENhcHR1cmUgY29udGVudCBhcyBtdWx0aXBsZSBpbWFnZXNcbiAgICAgICAgaHRtbDJjYW52YXMoY29tYmluZWREaXYsIHsgc2NhbGU6IDIsIHVzZUNPUlM6IHRydWUgfSlcbiAgICAgICAgICAudGhlbigoY2FudmFzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpbWdXaWR0aCA9IDE5MDtcbiAgICAgICAgICAgIGNvbnN0IHBhZ2VIZWlnaHQgPSBkb2MuaW50ZXJuYWwucGFnZVNpemUuaGVpZ2h0O1xuICAgICAgICAgICAgbGV0IGltZ0hlaWdodCA9IChjYW52YXMuaGVpZ2h0ICogaW1nV2lkdGgpIC8gY2FudmFzLndpZHRoO1xuICAgICAgICAgICAgbGV0IGhlaWdodExlZnQgPSBpbWdIZWlnaHQ7XG4gICAgICAgICAgICBsZXQgcG9zaXRpb24gPSAxMDtcblxuICAgICAgICAgICAgY29uc3QgaW1nRGF0YSA9IGNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xuXG4gICAgICAgICAgICAvLyBBZGQgZmlyc3QgcGFnZVxuICAgICAgICAgICAgZG9jLmFkZEltYWdlKGltZ0RhdGEsICdQTkcnLCAxMCwgcG9zaXRpb24sIGltZ1dpZHRoLCBpbWdIZWlnaHQpO1xuICAgICAgICAgICAgaGVpZ2h0TGVmdCAtPSBwYWdlSGVpZ2h0IC0gMjA7XG5cbiAgICAgICAgICAgIC8vIEFkZCBhZGRpdGlvbmFsIHBhZ2VzIGlmIGNvbnRlbnQgb3ZlcmZsb3dzXG4gICAgICAgICAgICB3aGlsZSAoaGVpZ2h0TGVmdCA+IDApIHtcbiAgICAgICAgICAgICAgcG9zaXRpb24gPSBoZWlnaHRMZWZ0IC0gaW1nSGVpZ2h0O1xuICAgICAgICAgICAgICBkb2MuYWRkUGFnZSgpO1xuICAgICAgICAgICAgICBkb2MuYWRkSW1hZ2UoaW1nRGF0YSwgJ1BORycsIDEwLCBwb3NpdGlvbiwgaW1nV2lkdGgsIGltZ0hlaWdodCk7XG4gICAgICAgICAgICAgIGhlaWdodExlZnQgLT0gcGFnZUhlaWdodCAtIDIwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkb2Muc2F2ZSgncmV0aXJlbWVudF9wbGFubmluZ19jYWxjdWxhdG9yLnBkZicpO1xuICAgICAgICAgICAgY29tYmluZWREaXYucmVtb3ZlKCk7IC8vIENsZWFuIHVwIHRlbXBvcmFyeSBkaXZcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNhcHR1cmluZyBIVE1MIGNvbnRlbnQ6JywgZXJyb3IpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignanNQREYgb3IgaHRtbDJjYW52YXMgbm90IGxvYWRlZCBjb3JyZWN0bHkuJyk7XG4gICAgICB9XG4gICAgfSk7XG59XG4iLCIvKiFcbiAqIEBrdXJrbGUvY29sb3IgdjAuMy40XG4gKiBodHRwczovL2dpdGh1Yi5jb20va3Vya2xlL2NvbG9yI3JlYWRtZVxuICogKGMpIDIwMjQgSnVra2EgS3Vya2VsYVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHJvdW5kKHYpIHtcbiAgcmV0dXJuIHYgKyAwLjUgfCAwO1xufVxuY29uc3QgbGltID0gKHYsIGwsIGgpID0+IE1hdGgubWF4KE1hdGgubWluKHYsIGgpLCBsKTtcbmZ1bmN0aW9uIHAyYih2KSB7XG4gIHJldHVybiBsaW0ocm91bmQodiAqIDIuNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSksIDAsIDEwMCk7XG59XG5mdW5jdGlvbiBuMmIodikge1xuICByZXR1cm4gbGltKHJvdW5kKHYgKiAyNTUpLCAwLCAyNTUpO1xufVxuZnVuY3Rpb24gYjJuKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2IC8gMi41NSkgLyAxMDAsIDAsIDEpO1xufVxuZnVuY3Rpb24gbjJwKHYpIHtcbiAgcmV0dXJuIGxpbShyb3VuZCh2ICogMTAwKSwgMCwgMTAwKTtcbn1cblxuY29uc3QgbWFwJDEgPSB7MDogMCwgMTogMSwgMjogMiwgMzogMywgNDogNCwgNTogNSwgNjogNiwgNzogNywgODogOCwgOTogOSwgQTogMTAsIEI6IDExLCBDOiAxMiwgRDogMTMsIEU6IDE0LCBGOiAxNSwgYTogMTAsIGI6IDExLCBjOiAxMiwgZDogMTMsIGU6IDE0LCBmOiAxNX07XG5jb25zdCBoZXggPSBbLi4uJzAxMjM0NTY3ODlBQkNERUYnXTtcbmNvbnN0IGgxID0gYiA9PiBoZXhbYiAmIDB4Rl07XG5jb25zdCBoMiA9IGIgPT4gaGV4WyhiICYgMHhGMCkgPj4gNF0gKyBoZXhbYiAmIDB4Rl07XG5jb25zdCBlcSA9IGIgPT4gKChiICYgMHhGMCkgPj4gNCkgPT09IChiICYgMHhGKTtcbmNvbnN0IGlzU2hvcnQgPSB2ID0+IGVxKHYucikgJiYgZXEodi5nKSAmJiBlcSh2LmIpICYmIGVxKHYuYSk7XG5mdW5jdGlvbiBoZXhQYXJzZShzdHIpIHtcbiAgdmFyIGxlbiA9IHN0ci5sZW5ndGg7XG4gIHZhciByZXQ7XG4gIGlmIChzdHJbMF0gPT09ICcjJykge1xuICAgIGlmIChsZW4gPT09IDQgfHwgbGVuID09PSA1KSB7XG4gICAgICByZXQgPSB7XG4gICAgICAgIHI6IDI1NSAmIG1hcCQxW3N0clsxXV0gKiAxNyxcbiAgICAgICAgZzogMjU1ICYgbWFwJDFbc3RyWzJdXSAqIDE3LFxuICAgICAgICBiOiAyNTUgJiBtYXAkMVtzdHJbM11dICogMTcsXG4gICAgICAgIGE6IGxlbiA9PT0gNSA/IG1hcCQxW3N0cls0XV0gKiAxNyA6IDI1NVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gNyB8fCBsZW4gPT09IDkpIHtcbiAgICAgIHJldCA9IHtcbiAgICAgICAgcjogbWFwJDFbc3RyWzFdXSA8PCA0IHwgbWFwJDFbc3RyWzJdXSxcbiAgICAgICAgZzogbWFwJDFbc3RyWzNdXSA8PCA0IHwgbWFwJDFbc3RyWzRdXSxcbiAgICAgICAgYjogbWFwJDFbc3RyWzVdXSA8PCA0IHwgbWFwJDFbc3RyWzZdXSxcbiAgICAgICAgYTogbGVuID09PSA5ID8gKG1hcCQxW3N0cls3XV0gPDwgNCB8IG1hcCQxW3N0cls4XV0pIDogMjU1XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuY29uc3QgYWxwaGEgPSAoYSwgZikgPT4gYSA8IDI1NSA/IGYoYSkgOiAnJztcbmZ1bmN0aW9uIGhleFN0cmluZyh2KSB7XG4gIHZhciBmID0gaXNTaG9ydCh2KSA/IGgxIDogaDI7XG4gIHJldHVybiB2XG4gICAgPyAnIycgKyBmKHYucikgKyBmKHYuZykgKyBmKHYuYikgKyBhbHBoYSh2LmEsIGYpXG4gICAgOiB1bmRlZmluZWQ7XG59XG5cbmNvbnN0IEhVRV9SRSA9IC9eKGhzbGE/fGh3Ynxoc3YpXFwoXFxzKihbLSsuZVxcZF0rKSg/OmRlZyk/W1xccyxdKyhbLSsuZVxcZF0rKSVbXFxzLF0rKFstKy5lXFxkXSspJSg/OltcXHMsXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiBoc2wycmdibihoLCBzLCBsKSB7XG4gIGNvbnN0IGEgPSBzICogTWF0aC5taW4obCwgMSAtIGwpO1xuICBjb25zdCBmID0gKG4sIGsgPSAobiArIGggLyAzMCkgJSAxMikgPT4gbCAtIGEgKiBNYXRoLm1heChNYXRoLm1pbihrIC0gMywgOSAtIGssIDEpLCAtMSk7XG4gIHJldHVybiBbZigwKSwgZig4KSwgZig0KV07XG59XG5mdW5jdGlvbiBoc3YycmdibihoLCBzLCB2KSB7XG4gIGNvbnN0IGYgPSAobiwgayA9IChuICsgaCAvIDYwKSAlIDYpID0+IHYgLSB2ICogcyAqIE1hdGgubWF4KE1hdGgubWluKGssIDQgLSBrLCAxKSwgMCk7XG4gIHJldHVybiBbZig1KSwgZigzKSwgZigxKV07XG59XG5mdW5jdGlvbiBod2IycmdibihoLCB3LCBiKSB7XG4gIGNvbnN0IHJnYiA9IGhzbDJyZ2JuKGgsIDEsIDAuNSk7XG4gIGxldCBpO1xuICBpZiAodyArIGIgPiAxKSB7XG4gICAgaSA9IDEgLyAodyArIGIpO1xuICAgIHcgKj0gaTtcbiAgICBiICo9IGk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IDM7IGkrKykge1xuICAgIHJnYltpXSAqPSAxIC0gdyAtIGI7XG4gICAgcmdiW2ldICs9IHc7XG4gIH1cbiAgcmV0dXJuIHJnYjtcbn1cbmZ1bmN0aW9uIGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCkge1xuICBpZiAociA9PT0gbWF4KSB7XG4gICAgcmV0dXJuICgoZyAtIGIpIC8gZCkgKyAoZyA8IGIgPyA2IDogMCk7XG4gIH1cbiAgaWYgKGcgPT09IG1heCkge1xuICAgIHJldHVybiAoYiAtIHIpIC8gZCArIDI7XG4gIH1cbiAgcmV0dXJuIChyIC0gZykgLyBkICsgNDtcbn1cbmZ1bmN0aW9uIHJnYjJoc2wodikge1xuICBjb25zdCByYW5nZSA9IDI1NTtcbiAgY29uc3QgciA9IHYuciAvIHJhbmdlO1xuICBjb25zdCBnID0gdi5nIC8gcmFuZ2U7XG4gIGNvbnN0IGIgPSB2LmIgLyByYW5nZTtcbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xuICBsZXQgaCwgcywgZDtcbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG4gICAgaCA9IGh1ZVZhbHVlKHIsIGcsIGIsIGQsIG1heCk7XG4gICAgaCA9IGggKiA2MCArIDAuNTtcbiAgfVxuICByZXR1cm4gW2ggfCAwLCBzIHx8IDAsIGxdO1xufVxuZnVuY3Rpb24gY2FsbG4oZiwgYSwgYiwgYykge1xuICByZXR1cm4gKFxuICAgIEFycmF5LmlzQXJyYXkoYSlcbiAgICAgID8gZihhWzBdLCBhWzFdLCBhWzJdKVxuICAgICAgOiBmKGEsIGIsIGMpXG4gICkubWFwKG4yYik7XG59XG5mdW5jdGlvbiBoc2wycmdiKGgsIHMsIGwpIHtcbiAgcmV0dXJuIGNhbGxuKGhzbDJyZ2JuLCBoLCBzLCBsKTtcbn1cbmZ1bmN0aW9uIGh3YjJyZ2IoaCwgdywgYikge1xuICByZXR1cm4gY2FsbG4oaHdiMnJnYm4sIGgsIHcsIGIpO1xufVxuZnVuY3Rpb24gaHN2MnJnYihoLCBzLCB2KSB7XG4gIHJldHVybiBjYWxsbihoc3YycmdibiwgaCwgcywgdik7XG59XG5mdW5jdGlvbiBodWUoaCkge1xuICByZXR1cm4gKGggJSAzNjAgKyAzNjApICUgMzYwO1xufVxuZnVuY3Rpb24gaHVlUGFyc2Uoc3RyKSB7XG4gIGNvbnN0IG0gPSBIVUVfUkUuZXhlYyhzdHIpO1xuICBsZXQgYSA9IDI1NTtcbiAgbGV0IHY7XG4gIGlmICghbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAobVs1XSAhPT0gdikge1xuICAgIGEgPSBtWzZdID8gcDJiKCttWzVdKSA6IG4yYigrbVs1XSk7XG4gIH1cbiAgY29uc3QgaCA9IGh1ZSgrbVsyXSk7XG4gIGNvbnN0IHAxID0gK21bM10gLyAxMDA7XG4gIGNvbnN0IHAyID0gK21bNF0gLyAxMDA7XG4gIGlmIChtWzFdID09PSAnaHdiJykge1xuICAgIHYgPSBod2IycmdiKGgsIHAxLCBwMik7XG4gIH0gZWxzZSBpZiAobVsxXSA9PT0gJ2hzdicpIHtcbiAgICB2ID0gaHN2MnJnYihoLCBwMSwgcDIpO1xuICB9IGVsc2Uge1xuICAgIHYgPSBoc2wycmdiKGgsIHAxLCBwMik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiB2WzBdLFxuICAgIGc6IHZbMV0sXG4gICAgYjogdlsyXSxcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByb3RhdGUodiwgZGVnKSB7XG4gIHZhciBoID0gcmdiMmhzbCh2KTtcbiAgaFswXSA9IGh1ZShoWzBdICsgZGVnKTtcbiAgaCA9IGhzbDJyZ2IoaCk7XG4gIHYuciA9IGhbMF07XG4gIHYuZyA9IGhbMV07XG4gIHYuYiA9IGhbMl07XG59XG5mdW5jdGlvbiBoc2xTdHJpbmcodikge1xuICBpZiAoIXYpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgYSA9IHJnYjJoc2wodik7XG4gIGNvbnN0IGggPSBhWzBdO1xuICBjb25zdCBzID0gbjJwKGFbMV0pO1xuICBjb25zdCBsID0gbjJwKGFbMl0pO1xuICByZXR1cm4gdi5hIDwgMjU1XG4gICAgPyBgaHNsYSgke2h9LCAke3N9JSwgJHtsfSUsICR7YjJuKHYuYSl9KWBcbiAgICA6IGBoc2woJHtofSwgJHtzfSUsICR7bH0lKWA7XG59XG5cbmNvbnN0IG1hcCA9IHtcblx0eDogJ2RhcmsnLFxuXHRaOiAnbGlnaHQnLFxuXHRZOiAncmUnLFxuXHRYOiAnYmx1Jyxcblx0VzogJ2dyJyxcblx0VjogJ21lZGl1bScsXG5cdFU6ICdzbGF0ZScsXG5cdEE6ICdlZScsXG5cdFQ6ICdvbCcsXG5cdFM6ICdvcicsXG5cdEI6ICdyYScsXG5cdEM6ICdsYXRlZycsXG5cdEQ6ICdpZ2h0cycsXG5cdFI6ICdpbicsXG5cdFE6ICd0dXJxdW9pcycsXG5cdEU6ICdoaScsXG5cdFA6ICdybycsXG5cdE86ICdhbCcsXG5cdE46ICdsZScsXG5cdE06ICdkZScsXG5cdEw6ICd5ZWxsbycsXG5cdEY6ICdlbicsXG5cdEs6ICdjaCcsXG5cdEc6ICdhcmtzJyxcblx0SDogJ2VhJyxcblx0STogJ2lnaHRnJyxcblx0SjogJ3doJ1xufTtcbmNvbnN0IG5hbWVzJDEgPSB7XG5cdE9pY2VYZTogJ2YwZjhmZicsXG5cdGFudGlxdWV3RXRlOiAnZmFlYmQ3Jyxcblx0YXF1YTogJ2ZmZmYnLFxuXHRhcXVhbWFyUmU6ICc3ZmZmZDQnLFxuXHRhenVZOiAnZjBmZmZmJyxcblx0YmVpZ2U6ICdmNWY1ZGMnLFxuXHRiaXNxdWU6ICdmZmU0YzQnLFxuXHRibGFjazogJzAnLFxuXHRibGFuS2VkT21vbmQ6ICdmZmViY2QnLFxuXHRYZTogJ2ZmJyxcblx0WGV2aVRldDogJzhhMmJlMicsXG5cdGJQd246ICdhNTJhMmEnLFxuXHRidXJseXdvb2Q6ICdkZWI4ODcnLFxuXHRjYU10WGU6ICc1ZjllYTAnLFxuXHRLYXJ0WXVzZTogJzdmZmYwMCcsXG5cdEtvY1RhdGU6ICdkMjY5MWUnLFxuXHRjU086ICdmZjdmNTAnLFxuXHRjU25mbG93ZXJYZTogJzY0OTVlZCcsXG5cdGNTbnNpbGs6ICdmZmY4ZGMnLFxuXHRjcmltc29uOiAnZGMxNDNjJyxcblx0Y3lhbjogJ2ZmZmYnLFxuXHR4WGU6ICc4YicsXG5cdHhjeWFuOiAnOGI4YicsXG5cdHhnVE1uUGQ6ICdiODg2MGInLFxuXHR4V2F5OiAnYTlhOWE5Jyxcblx0eGdZRjogJzY0MDAnLFxuXHR4Z1l5OiAnYTlhOWE5Jyxcblx0eGtoYWtpOiAnYmRiNzZiJyxcblx0eG1hZ0Z0YTogJzhiMDA4YicsXG5cdHhUaXZlZ1lGOiAnNTU2YjJmJyxcblx0eFNhbmdlOiAnZmY4YzAwJyxcblx0eFNjRWQ6ICc5OTMyY2MnLFxuXHR4WWQ6ICc4YjAwMDAnLFxuXHR4c09tb246ICdlOTk2N2EnLFxuXHR4c0hnWUY6ICc4ZmJjOGYnLFxuXHR4VVhlOiAnNDgzZDhiJyxcblx0eFVXYXk6ICcyZjRmNGYnLFxuXHR4VWdZeTogJzJmNGY0ZicsXG5cdHhRZTogJ2NlZDEnLFxuXHR4dmlUZXQ6ICc5NDAwZDMnLFxuXHRkQXBwUms6ICdmZjE0OTMnLFxuXHRkQXBza3lYZTogJ2JmZmYnLFxuXHRkaW1XYXk6ICc2OTY5NjknLFxuXHRkaW1nWXk6ICc2OTY5NjknLFxuXHRkb2RnZXJYZTogJzFlOTBmZicsXG5cdGZpWWJyaWNrOiAnYjIyMjIyJyxcblx0ZmxTT3dFdGU6ICdmZmZhZjAnLFxuXHRmb1lzdFdBbjogJzIyOGIyMicsXG5cdGZ1S3NpYTogJ2ZmMDBmZicsXG5cdGdhUnNiU286ICdkY2RjZGMnLFxuXHRnaG9zdHdFdGU6ICdmOGY4ZmYnLFxuXHRnVGQ6ICdmZmQ3MDAnLFxuXHRnVE1uUGQ6ICdkYWE1MjAnLFxuXHRXYXk6ICc4MDgwODAnLFxuXHRnWUY6ICc4MDAwJyxcblx0Z1lGTHc6ICdhZGZmMmYnLFxuXHRnWXk6ICc4MDgwODAnLFxuXHRob25leU13OiAnZjBmZmYwJyxcblx0aG90cFJrOiAnZmY2OWI0Jyxcblx0UmRpYW5ZZDogJ2NkNWM1YycsXG5cdFJkaWdvOiAnNGIwMDgyJyxcblx0aXZTeTogJ2ZmZmZmMCcsXG5cdGtoYWtpOiAnZjBlNjhjJyxcblx0bGF2Rk1yOiAnZTZlNmZhJyxcblx0bGF2Rk1yWHNoOiAnZmZmMGY1Jyxcblx0bGF3bmdZRjogJzdjZmMwMCcsXG5cdE5tb25jRWZmb246ICdmZmZhY2QnLFxuXHRaWGU6ICdhZGQ4ZTYnLFxuXHRaY1NPOiAnZjA4MDgwJyxcblx0WmN5YW46ICdlMGZmZmYnLFxuXHRaZ1RNblBkTHc6ICdmYWZhZDInLFxuXHRaV2F5OiAnZDNkM2QzJyxcblx0WmdZRjogJzkwZWU5MCcsXG5cdFpnWXk6ICdkM2QzZDMnLFxuXHRacFJrOiAnZmZiNmMxJyxcblx0WnNPbW9uOiAnZmZhMDdhJyxcblx0WnNIZ1lGOiAnMjBiMmFhJyxcblx0WnNreVhlOiAnODdjZWZhJyxcblx0WlVXYXk6ICc3Nzg4OTknLFxuXHRaVWdZeTogJzc3ODg5OScsXG5cdFpzdEFsWGU6ICdiMGM0ZGUnLFxuXHRaTHc6ICdmZmZmZTAnLFxuXHRsaW1lOiAnZmYwMCcsXG5cdGxpbWVnWUY6ICczMmNkMzInLFxuXHRsUkY6ICdmYWYwZTYnLFxuXHRtYWdGdGE6ICdmZjAwZmYnLFxuXHRtYVBvbjogJzgwMDAwMCcsXG5cdFZhcXVhbWFyUmU6ICc2NmNkYWEnLFxuXHRWWGU6ICdjZCcsXG5cdFZTY0VkOiAnYmE1NWQzJyxcblx0VnB1cnBOOiAnOTM3MGRiJyxcblx0VnNIZ1lGOiAnM2NiMzcxJyxcblx0VlVYZTogJzdiNjhlZScsXG5cdFZzcHJSZ2dZRjogJ2ZhOWEnLFxuXHRWUWU6ICc0OGQxY2MnLFxuXHRWdmlUZXRZZDogJ2M3MTU4NScsXG5cdG1pZG5pZ2h0WGU6ICcxOTE5NzAnLFxuXHRtUnRjWWFtOiAnZjVmZmZhJyxcblx0bWlzdHlQc2U6ICdmZmU0ZTEnLFxuXHRtb2NjYXNSOiAnZmZlNGI1Jyxcblx0bmF2YWpvd0V0ZTogJ2ZmZGVhZCcsXG5cdG5hdnk6ICc4MCcsXG5cdFRkbGFjZTogJ2ZkZjVlNicsXG5cdFRpdmU6ICc4MDgwMDAnLFxuXHRUaXZlZEJiOiAnNmI4ZTIzJyxcblx0U2FuZ2U6ICdmZmE1MDAnLFxuXHRTYW5nZVlkOiAnZmY0NTAwJyxcblx0U2NFZDogJ2RhNzBkNicsXG5cdHBPZWdUTW5QZDogJ2VlZThhYScsXG5cdHBPZWdZRjogJzk4ZmI5OCcsXG5cdHBPZVFlOiAnYWZlZWVlJyxcblx0cE9ldmlUZXRZZDogJ2RiNzA5MycsXG5cdHBhcGF5YXdFcDogJ2ZmZWZkNScsXG5cdHBIS3B1ZmY6ICdmZmRhYjknLFxuXHRwZXJ1OiAnY2Q4NTNmJyxcblx0cFJrOiAnZmZjMGNiJyxcblx0cGx1bTogJ2RkYTBkZCcsXG5cdHBvd01yWGU6ICdiMGUwZTYnLFxuXHRwdXJwTjogJzgwMDA4MCcsXG5cdFliZWNjYXB1cnBOOiAnNjYzMzk5Jyxcblx0WWQ6ICdmZjAwMDAnLFxuXHRQc3licm93bjogJ2JjOGY4ZicsXG5cdFB5T1hlOiAnNDE2OWUxJyxcblx0c2FkZE5iUHduOiAnOGI0NTEzJyxcblx0c09tb246ICdmYTgwNzInLFxuXHRzYW5keWJQd246ICdmNGE0NjAnLFxuXHRzSGdZRjogJzJlOGI1NycsXG5cdHNIc2hlbGw6ICdmZmY1ZWUnLFxuXHRzaUZuYTogJ2EwNTIyZCcsXG5cdHNpbHZlcjogJ2MwYzBjMCcsXG5cdHNreVhlOiAnODdjZWViJyxcblx0VVhlOiAnNmE1YWNkJyxcblx0VVdheTogJzcwODA5MCcsXG5cdFVnWXk6ICc3MDgwOTAnLFxuXHRzbm93OiAnZmZmYWZhJyxcblx0c3ByUmdnWUY6ICdmZjdmJyxcblx0c3RBbFhlOiAnNDY4MmI0Jyxcblx0dGFuOiAnZDJiNDhjJyxcblx0dGVPOiAnODA4MCcsXG5cdHRFc3ROOiAnZDhiZmQ4Jyxcblx0dG9tYXRvOiAnZmY2MzQ3Jyxcblx0UWU6ICc0MGUwZDAnLFxuXHR2aVRldDogJ2VlODJlZScsXG5cdEpIdDogJ2Y1ZGViMycsXG5cdHdFdGU6ICdmZmZmZmYnLFxuXHR3RXRlc21va2U6ICdmNWY1ZjUnLFxuXHRMdzogJ2ZmZmYwMCcsXG5cdEx3Z1lGOiAnOWFjZDMyJ1xufTtcbmZ1bmN0aW9uIHVucGFjaygpIHtcbiAgY29uc3QgdW5wYWNrZWQgPSB7fTtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG5hbWVzJDEpO1xuICBjb25zdCB0a2V5cyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gIGxldCBpLCBqLCBrLCBvaywgbms7XG4gIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgb2sgPSBuayA9IGtleXNbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IHRrZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICBrID0gdGtleXNbal07XG4gICAgICBuayA9IG5rLnJlcGxhY2UoaywgbWFwW2tdKTtcbiAgICB9XG4gICAgayA9IHBhcnNlSW50KG5hbWVzJDFbb2tdLCAxNik7XG4gICAgdW5wYWNrZWRbbmtdID0gW2sgPj4gMTYgJiAweEZGLCBrID4+IDggJiAweEZGLCBrICYgMHhGRl07XG4gIH1cbiAgcmV0dXJuIHVucGFja2VkO1xufVxuXG5sZXQgbmFtZXM7XG5mdW5jdGlvbiBuYW1lUGFyc2Uoc3RyKSB7XG4gIGlmICghbmFtZXMpIHtcbiAgICBuYW1lcyA9IHVucGFjaygpO1xuICAgIG5hbWVzLnRyYW5zcGFyZW50ID0gWzAsIDAsIDAsIDBdO1xuICB9XG4gIGNvbnN0IGEgPSBuYW1lc1tzdHIudG9Mb3dlckNhc2UoKV07XG4gIHJldHVybiBhICYmIHtcbiAgICByOiBhWzBdLFxuICAgIGc6IGFbMV0sXG4gICAgYjogYVsyXSxcbiAgICBhOiBhLmxlbmd0aCA9PT0gNCA/IGFbM10gOiAyNTVcbiAgfTtcbn1cblxuY29uc3QgUkdCX1JFID0gL15yZ2JhP1xcKFxccyooWy0rLlxcZF0rKSglKT9bXFxzLF0rKFstKy5lXFxkXSspKCUpP1tcXHMsXSsoWy0rLmVcXGRdKykoJSk/KD86W1xccywvXSsoWy0rLmVcXGRdKykoJSk/KT9cXHMqXFwpJC87XG5mdW5jdGlvbiByZ2JQYXJzZShzdHIpIHtcbiAgY29uc3QgbSA9IFJHQl9SRS5leGVjKHN0cik7XG4gIGxldCBhID0gMjU1O1xuICBsZXQgciwgZywgYjtcbiAgaWYgKCFtKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChtWzddICE9PSByKSB7XG4gICAgY29uc3QgdiA9ICttWzddO1xuICAgIGEgPSBtWzhdID8gcDJiKHYpIDogbGltKHYgKiAyNTUsIDAsIDI1NSk7XG4gIH1cbiAgciA9ICttWzFdO1xuICBnID0gK21bM107XG4gIGIgPSArbVs1XTtcbiAgciA9IDI1NSAmIChtWzJdID8gcDJiKHIpIDogbGltKHIsIDAsIDI1NSkpO1xuICBnID0gMjU1ICYgKG1bNF0gPyBwMmIoZykgOiBsaW0oZywgMCwgMjU1KSk7XG4gIGIgPSAyNTUgJiAobVs2XSA/IHAyYihiKSA6IGxpbShiLCAwLCAyNTUpKTtcbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG5mdW5jdGlvbiByZ2JTdHJpbmcodikge1xuICByZXR1cm4gdiAmJiAoXG4gICAgdi5hIDwgMjU1XG4gICAgICA/IGByZ2JhKCR7di5yfSwgJHt2Lmd9LCAke3YuYn0sICR7YjJuKHYuYSl9KWBcbiAgICAgIDogYHJnYigke3Yucn0sICR7di5nfSwgJHt2LmJ9KWBcbiAgKTtcbn1cblxuY29uc3QgdG8gPSB2ID0+IHYgPD0gMC4wMDMxMzA4ID8gdiAqIDEyLjkyIDogTWF0aC5wb3codiwgMS4wIC8gMi40KSAqIDEuMDU1IC0gMC4wNTU7XG5jb25zdCBmcm9tID0gdiA9PiB2IDw9IDAuMDQwNDUgPyB2IC8gMTIuOTIgOiBNYXRoLnBvdygodiArIDAuMDU1KSAvIDEuMDU1LCAyLjQpO1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUocmdiMSwgcmdiMiwgdCkge1xuICBjb25zdCByID0gZnJvbShiMm4ocmdiMS5yKSk7XG4gIGNvbnN0IGcgPSBmcm9tKGIybihyZ2IxLmcpKTtcbiAgY29uc3QgYiA9IGZyb20oYjJuKHJnYjEuYikpO1xuICByZXR1cm4ge1xuICAgIHI6IG4yYih0byhyICsgdCAqIChmcm9tKGIybihyZ2IyLnIpKSAtIHIpKSksXG4gICAgZzogbjJiKHRvKGcgKyB0ICogKGZyb20oYjJuKHJnYjIuZykpIC0gZykpKSxcbiAgICBiOiBuMmIodG8oYiArIHQgKiAoZnJvbShiMm4ocmdiMi5iKSkgLSBiKSkpLFxuICAgIGE6IHJnYjEuYSArIHQgKiAocmdiMi5hIC0gcmdiMS5hKVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb2RIU0wodiwgaSwgcmF0aW8pIHtcbiAgaWYgKHYpIHtcbiAgICBsZXQgdG1wID0gcmdiMmhzbCh2KTtcbiAgICB0bXBbaV0gPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0bXBbaV0gKyB0bXBbaV0gKiByYXRpbywgaSA9PT0gMCA/IDM2MCA6IDEpKTtcbiAgICB0bXAgPSBoc2wycmdiKHRtcCk7XG4gICAgdi5yID0gdG1wWzBdO1xuICAgIHYuZyA9IHRtcFsxXTtcbiAgICB2LmIgPSB0bXBbMl07XG4gIH1cbn1cbmZ1bmN0aW9uIGNsb25lKHYsIHByb3RvKSB7XG4gIHJldHVybiB2ID8gT2JqZWN0LmFzc2lnbihwcm90byB8fCB7fSwgdikgOiB2O1xufVxuZnVuY3Rpb24gZnJvbU9iamVjdChpbnB1dCkge1xuICB2YXIgdiA9IHtyOiAwLCBnOiAwLCBiOiAwLCBhOiAyNTV9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICBpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcbiAgICAgIHYgPSB7cjogaW5wdXRbMF0sIGc6IGlucHV0WzFdLCBiOiBpbnB1dFsyXSwgYTogMjU1fTtcbiAgICAgIGlmIChpbnB1dC5sZW5ndGggPiAzKSB7XG4gICAgICAgIHYuYSA9IG4yYihpbnB1dFszXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHYgPSBjbG9uZShpbnB1dCwge3I6IDAsIGc6IDAsIGI6IDAsIGE6IDF9KTtcbiAgICB2LmEgPSBuMmIodi5hKTtcbiAgfVxuICByZXR1cm4gdjtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uUGFyc2Uoc3RyKSB7XG4gIGlmIChzdHIuY2hhckF0KDApID09PSAncicpIHtcbiAgICByZXR1cm4gcmdiUGFyc2Uoc3RyKTtcbiAgfVxuICByZXR1cm4gaHVlUGFyc2Uoc3RyKTtcbn1cbmNsYXNzIENvbG9yIHtcbiAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBDb2xvcikge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gdHlwZW9mIGlucHV0O1xuICAgIGxldCB2O1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdiA9IGZyb21PYmplY3QoaW5wdXQpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHYgPSBoZXhQYXJzZShpbnB1dCkgfHwgbmFtZVBhcnNlKGlucHV0KSB8fCBmdW5jdGlvblBhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdGhpcy5fcmdiID0gdjtcbiAgICB0aGlzLl92YWxpZCA9ICEhdjtcbiAgfVxuICBnZXQgdmFsaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkO1xuICB9XG4gIGdldCByZ2IoKSB7XG4gICAgdmFyIHYgPSBjbG9uZSh0aGlzLl9yZ2IpO1xuICAgIGlmICh2KSB7XG4gICAgICB2LmEgPSBiMm4odi5hKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgc2V0IHJnYihvYmopIHtcbiAgICB0aGlzLl9yZ2IgPSBmcm9tT2JqZWN0KG9iaik7XG4gIH1cbiAgcmdiU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZCA/IHJnYlN0cmluZyh0aGlzLl9yZ2IpIDogdW5kZWZpbmVkO1xuICB9XG4gIGhleFN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWQgPyBoZXhTdHJpbmcodGhpcy5fcmdiKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBoc2xTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkID8gaHNsU3RyaW5nKHRoaXMuX3JnYikgOiB1bmRlZmluZWQ7XG4gIH1cbiAgbWl4KGNvbG9yLCB3ZWlnaHQpIHtcbiAgICBpZiAoY29sb3IpIHtcbiAgICAgIGNvbnN0IGMxID0gdGhpcy5yZ2I7XG4gICAgICBjb25zdCBjMiA9IGNvbG9yLnJnYjtcbiAgICAgIGxldCB3MjtcbiAgICAgIGNvbnN0IHAgPSB3ZWlnaHQgPT09IHcyID8gMC41IDogd2VpZ2h0O1xuICAgICAgY29uc3QgdyA9IDIgKiBwIC0gMTtcbiAgICAgIGNvbnN0IGEgPSBjMS5hIC0gYzIuYTtcbiAgICAgIGNvbnN0IHcxID0gKCh3ICogYSA9PT0gLTEgPyB3IDogKHcgKyBhKSAvICgxICsgdyAqIGEpKSArIDEpIC8gMi4wO1xuICAgICAgdzIgPSAxIC0gdzE7XG4gICAgICBjMS5yID0gMHhGRiAmIHcxICogYzEuciArIHcyICogYzIuciArIDAuNTtcbiAgICAgIGMxLmcgPSAweEZGICYgdzEgKiBjMS5nICsgdzIgKiBjMi5nICsgMC41O1xuICAgICAgYzEuYiA9IDB4RkYgJiB3MSAqIGMxLmIgKyB3MiAqIGMyLmIgKyAwLjU7XG4gICAgICBjMS5hID0gcCAqIGMxLmEgKyAoMSAtIHApICogYzIuYTtcbiAgICAgIHRoaXMucmdiID0gYzE7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGludGVycG9sYXRlKGNvbG9yLCB0KSB7XG4gICAgaWYgKGNvbG9yKSB7XG4gICAgICB0aGlzLl9yZ2IgPSBpbnRlcnBvbGF0ZSh0aGlzLl9yZ2IsIGNvbG9yLl9yZ2IsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gbmV3IENvbG9yKHRoaXMucmdiKTtcbiAgfVxuICBhbHBoYShhKSB7XG4gICAgdGhpcy5fcmdiLmEgPSBuMmIoYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgY2xlYXJlcihyYXRpbykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICByZ2IuYSAqPSAxIC0gcmF0aW87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZ3JleXNjYWxlKCkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX3JnYjtcbiAgICBjb25zdCB2YWwgPSByb3VuZChyZ2IuciAqIDAuMyArIHJnYi5nICogMC41OSArIHJnYi5iICogMC4xMSk7XG4gICAgcmdiLnIgPSByZ2IuZyA9IHJnYi5iID0gdmFsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG9wYXF1ZXIocmF0aW8pIHtcbiAgICBjb25zdCByZ2IgPSB0aGlzLl9yZ2I7XG4gICAgcmdiLmEgKj0gMSArIHJhdGlvO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIG5lZ2F0ZSgpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5fcmdiO1xuICAgIHYuciA9IDI1NSAtIHYucjtcbiAgICB2LmcgPSAyNTUgLSB2Lmc7XG4gICAgdi5iID0gMjU1IC0gdi5iO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGxpZ2h0ZW4ocmF0aW8pIHtcbiAgICBtb2RIU0wodGhpcy5fcmdiLCAyLCByYXRpbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGFya2VuKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMiwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBzYXR1cmF0ZShyYXRpbykge1xuICAgIG1vZEhTTCh0aGlzLl9yZ2IsIDEsIHJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBkZXNhdHVyYXRlKHJhdGlvKSB7XG4gICAgbW9kSFNMKHRoaXMuX3JnYiwgMSwgLXJhdGlvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICByb3RhdGUoZGVnKSB7XG4gICAgcm90YXRlKHRoaXMuX3JnYiwgZGVnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleF9lc20oaW5wdXQpIHtcbiAgcmV0dXJuIG5ldyBDb2xvcihpbnB1dCk7XG59XG5cbmV4cG9ydCB7IENvbG9yLCBiMm4sIGIycCwgaW5kZXhfZXNtIGFzIGRlZmF1bHQsIGhleFBhcnNlLCBoZXhTdHJpbmcsIGhzbDJyZ2IsIGhzbFN0cmluZywgaHN2MnJnYiwgaHVlUGFyc2UsIGh3YjJyZ2IsIGxpbSwgbjJiLCBuMnAsIG5hbWVQYXJzZSwgcDJiLCByZ2IyaHNsLCByZ2JQYXJzZSwgcmdiU3RyaW5nLCByb3RhdGUsIHJvdW5kIH07XG4iLCIvKiFcbiAqIENoYXJ0LmpzIHY0LjQuOVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDI1IENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBlIGFzIGVmZmVjdHMsIGMgYXMgY29sb3IsIGkgYXMgaXNPYmplY3QsIGQgYXMgZGVmYXVsdHMsIGIgYXMgaXNBcnJheSwgdiBhcyB2YWx1ZU9yRGVmYXVsdCwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCBsIGFzIGxpc3RlbkFycmF5RXZlbnRzLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGcgYXMgaXNOdW1iZXJGaW5pdGUsIGggYXMgZGVmaW5lZCwgcyBhcyBzaWduLCBqIGFzIGNyZWF0ZUNvbnRleHQsIGsgYXMgaXNOdWxsT3JVbmRlZiwgXyBhcyBfYXJyYXlVbmlxdWUsIHQgYXMgdG9SYWRpYW5zLCBtIGFzIHRvUGVyY2VudGFnZSwgbiBhcyB0b0RpbWVuc2lvbiwgVCBhcyBUQVUsIG8gYXMgZm9ybWF0TnVtYmVyLCBwIGFzIF9hbmdsZUJldHdlZW4sIEggYXMgSEFMRl9QSSwgUCBhcyBQSSwgcSBhcyBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cywgdyBhcyBfc2NhbGVSYW5nZXNDaGFuZ2VkLCB4IGFzIGlzTnVtYmVyLCB5IGFzIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZSwgeiBhcyBnZXRSZWxhdGl2ZVBvc2l0aW9uLCBBIGFzIF9ybG9va3VwQnlLZXksIEIgYXMgX2xvb2t1cEJ5S2V5LCBDIGFzIF9pc1BvaW50SW5BcmVhLCBEIGFzIGdldEFuZ2xlRnJvbVBvaW50LCBFIGFzIHRvUGFkZGluZywgRiBhcyBlYWNoLCBHIGFzIGdldE1heGltdW1TaXplLCBJIGFzIF9nZXRQYXJlbnROb2RlLCBKIGFzIHJlYWRVc2VkU2l6ZSwgSyBhcyBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zLCBMIGFzIHRocm90dGxlZCwgTSBhcyBfaXNEb21TdXBwb3J0ZWQsIE4gYXMgX2ZhY3Rvcml6ZSwgTyBhcyBmaW5pdGVPckRlZmF1bHQsIFEgYXMgY2FsbGJhY2ssIFIgYXMgX2FkZEdyYWNlLCBTIGFzIF9saW1pdFZhbHVlLCBVIGFzIHRvRGVncmVlcywgViBhcyBfbWVhc3VyZVRleHQsIFcgYXMgX2ludDE2UmFuZ2UsIFggYXMgX2FsaWduUGl4ZWwsIFkgYXMgY2xpcEFyZWEsIFogYXMgcmVuZGVyVGV4dCwgJCBhcyB1bmNsaXBBcmVhLCBhMCBhcyB0b0ZvbnQsIGExIGFzIF90b0xlZnRSaWdodENlbnRlciwgYTIgYXMgX2FsaWduU3RhcnRFbmQsIGEzIGFzIG92ZXJyaWRlcywgYTQgYXMgbWVyZ2UsIGE1IGFzIF9jYXBpdGFsaXplLCBhNiBhcyBkZXNjcmlwdG9ycywgYTcgYXMgaXNGdW5jdGlvbiwgYTggYXMgX2F0dGFjaENvbnRleHQsIGE5IGFzIF9jcmVhdGVSZXNvbHZlciwgYWEgYXMgX2Rlc2NyaXB0b3JzLCBhYiBhcyBtZXJnZUlmLCBhYyBhcyB1aWQsIGFkIGFzIGRlYm91bmNlLCBhZSBhcyByZXRpbmFTY2FsZSwgYWYgYXMgY2xlYXJDYW52YXMsIGFnIGFzIHNldHNFcXVhbCwgYWggYXMgZ2V0RGF0YXNldENsaXBBcmVhLCBhaSBhcyBfZWxlbWVudHNFcXVhbCwgYWogYXMgX2lzQ2xpY2tFdmVudCwgYWsgYXMgX2lzQmV0d2VlbiwgYWwgYXMgX3JlYWRWYWx1ZVRvUHJvcHMsIGFtIGFzIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzLCBhbiBhcyBfY29tcHV0ZVNlZ21lbnRzLCBhbyBhcyBfYm91bmRTZWdtZW50cywgYXAgYXMgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uLCBhcSBhcyBfYmV6aWVySW50ZXJwb2xhdGlvbiwgYXIgYXMgX3BvaW50SW5MaW5lLCBhcyBhcyBfc3RlcHBlZExpbmVUbywgYXQgYXMgX2JlemllckN1cnZlVG8sIGF1IGFzIGRyYXdQb2ludCwgYXYgYXMgYWRkUm91bmRlZFJlY3RQYXRoLCBhdyBhcyB0b1RSQkwsIGF4IGFzIHRvVFJCTENvcm5lcnMsIGF5IGFzIF9ib3VuZFNlZ21lbnQsIGF6IGFzIF9ub3JtYWxpemVBbmdsZSwgYUEgYXMgZ2V0UnRsQWRhcHRlciwgYUIgYXMgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uLCBhQyBhcyBfdGV4dFgsIGFEIGFzIHJlc3RvcmVUZXh0RGlyZWN0aW9uLCBhRSBhcyBkcmF3UG9pbnRMZWdlbmQsIGFGIGFzIGRpc3RhbmNlQmV0d2VlblBvaW50cywgYUcgYXMgbm9vcCwgYUggYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhSSBhcyBuaWNlTnVtLCBhSiBhcyBhbG1vc3RXaG9sZSwgYUsgYXMgYWxtb3N0RXF1YWxzLCBhTCBhcyBfZGVjaW1hbFBsYWNlcywgYU0gYXMgVGlja3MsIGFOIGFzIGxvZzEwLCBhTyBhcyBfbG9uZ2VzdFRleHQsIGFQIGFzIF9maWx0ZXJCZXR3ZWVuLCBhUSBhcyBfbG9va3VwIH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5kYXRhc2V0LmpzJztcbmltcG9ydCAnQGt1cmtsZS9jb2xvcic7XG5cbmNsYXNzIEFuaW1hdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2hhcnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2xhc3REYXRlID0gdW5kZWZpbmVkO1xuICAgIH1cbiBfbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgdHlwZSkge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBhbmltcy5saXN0ZW5lcnNbdHlwZV07XG4gICAgICAgIGNvbnN0IG51bVN0ZXBzID0gYW5pbXMuZHVyYXRpb247XG4gICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKChmbik9PmZuKHtcbiAgICAgICAgICAgICAgICBjaGFydCxcbiAgICAgICAgICAgICAgICBpbml0aWFsOiBhbmltcy5pbml0aWFsLFxuICAgICAgICAgICAgICAgIG51bVN0ZXBzLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGVwOiBNYXRoLm1pbihkYXRlIC0gYW5pbXMuc3RhcnQsIG51bVN0ZXBzKVxuICAgICAgICAgICAgfSkpO1xuICAgIH1cbiBfcmVmcmVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdCA9IHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpPT57XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWZyZXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiBfdXBkYXRlKGRhdGUgPSBEYXRlLm5vdygpKSB7XG4gICAgICAgIGxldCByZW1haW5pbmcgPSAwO1xuICAgICAgICB0aGlzLl9jaGFydHMuZm9yRWFjaCgoYW5pbXMsIGNoYXJ0KT0+e1xuICAgICAgICAgICAgaWYgKCFhbmltcy5ydW5uaW5nIHx8ICFhbmltcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IGFuaW1zLml0ZW1zO1xuICAgICAgICAgICAgbGV0IGkgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgbGV0IGRyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgIGxldCBpdGVtO1xuICAgICAgICAgICAgZm9yKDsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5fYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLl90b3RhbCA+IGFuaW1zLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGl0ZW0uX3RvdGFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGl0ZW0udGljayhkYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgZHJhdyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXNbaV0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRyYXcpIHtcbiAgICAgICAgICAgICAgICBjaGFydC5kcmF3KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgZGF0ZSwgJ3Byb2dyZXNzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1zLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub3RpZnkoY2hhcnQsIGFuaW1zLCBkYXRlLCAnY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBhbmltcy5pbml0aWFsID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW1haW5pbmcgKz0gaXRlbXMubGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fbGFzdERhdGUgPSBkYXRlO1xuICAgICAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gX2dldEFuaW1zKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0cyA9IHRoaXMuX2NoYXJ0cztcbiAgICAgICAgbGV0IGFuaW1zID0gY2hhcnRzLmdldChjaGFydCk7XG4gICAgICAgIGlmICghYW5pbXMpIHtcbiAgICAgICAgICAgIGFuaW1zID0ge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgaXRlbXM6IFtdLFxuICAgICAgICAgICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZTogW10sXG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjaGFydHMuc2V0KGNoYXJ0LCBhbmltcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuaW1zO1xuICAgIH1cbiBsaXN0ZW4oY2hhcnQsIGV2ZW50LCBjYikge1xuICAgICAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkubGlzdGVuZXJzW2V2ZW50XS5wdXNoKGNiKTtcbiAgICB9XG4gYWRkKGNoYXJ0LCBpdGVtcykge1xuICAgICAgICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9nZXRBbmltcyhjaGFydCkuaXRlbXMucHVzaCguLi5pdGVtcyk7XG4gICAgfVxuIGhhcyhjaGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0QW5pbXMoY2hhcnQpLml0ZW1zLmxlbmd0aCA+IDA7XG4gICAgfVxuIHN0YXJ0KGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgICAgIGlmICghYW5pbXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhbmltcy5ydW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgYW5pbXMuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICBhbmltcy5kdXJhdGlvbiA9IGFuaW1zLml0ZW1zLnJlZHVjZSgoYWNjLCBjdXIpPT5NYXRoLm1heChhY2MsIGN1ci5fZHVyYXRpb24pLCAwKTtcbiAgICAgICAgdGhpcy5fcmVmcmVzaCgpO1xuICAgIH1cbiAgICBydW5uaW5nKGNoYXJ0KSB7XG4gICAgICAgIGlmICghdGhpcy5fcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLnJ1bm5pbmcgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiBzdG9wKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGFuaW1zID0gdGhpcy5fY2hhcnRzLmdldChjaGFydCk7XG4gICAgICAgIGlmICghYW5pbXMgfHwgIWFuaW1zLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gYW5pbXMuaXRlbXM7XG4gICAgICAgIGxldCBpID0gaXRlbXMubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yKDsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgaXRlbXNbaV0uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICAgICAgYW5pbXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5fbm90aWZ5KGNoYXJ0LCBhbmltcywgRGF0ZS5ub3coKSwgJ2NvbXBsZXRlJyk7XG4gICAgfVxuIHJlbW92ZShjaGFydCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gICAgfVxufVxudmFyIGFuaW1hdG9yID0gLyogI19fUFVSRV9fICovIG5ldyBBbmltYXRvcigpO1xuXG5jb25zdCB0cmFuc3BhcmVudCA9ICd0cmFuc3BhcmVudCc7XG5jb25zdCBpbnRlcnBvbGF0b3JzID0ge1xuICAgIGJvb2xlYW4gKGZyb20sIHRvLCBmYWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGZhY3RvciA+IDAuNSA/IHRvIDogZnJvbTtcbiAgICB9LFxuIGNvbG9yIChmcm9tLCB0bywgZmFjdG9yKSB7XG4gICAgICAgIGNvbnN0IGMwID0gY29sb3IoZnJvbSB8fCB0cmFuc3BhcmVudCk7XG4gICAgICAgIGNvbnN0IGMxID0gYzAudmFsaWQgJiYgY29sb3IodG8gfHwgdHJhbnNwYXJlbnQpO1xuICAgICAgICByZXR1cm4gYzEgJiYgYzEudmFsaWQgPyBjMS5taXgoYzAsIGZhY3RvcikuaGV4U3RyaW5nKCkgOiB0bztcbiAgICB9LFxuICAgIG51bWJlciAoZnJvbSwgdG8sIGZhY3Rvcikge1xuICAgICAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogZmFjdG9yO1xuICAgIH1cbn07XG5jbGFzcyBBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGNmZywgdGFyZ2V0LCBwcm9wLCB0byl7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgdG8gPSByZXNvbHZlKFtcbiAgICAgICAgICAgIGNmZy50byxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgY2ZnLmZyb21cbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGZyb20gPSByZXNvbHZlKFtcbiAgICAgICAgICAgIGNmZy5mcm9tLFxuICAgICAgICAgICAgY3VycmVudFZhbHVlLFxuICAgICAgICAgICAgdG9cbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IHRydWU7XG4gICAgICAgIHRoaXMuX2ZuID0gY2ZnLmZuIHx8IGludGVycG9sYXRvcnNbY2ZnLnR5cGUgfHwgdHlwZW9mIGZyb21dO1xuICAgICAgICB0aGlzLl9lYXNpbmcgPSBlZmZlY3RzW2NmZy5lYXNpbmddIHx8IGVmZmVjdHMubGluZWFyO1xuICAgICAgICB0aGlzLl9zdGFydCA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSArIChjZmcuZGVsYXkgfHwgMCkpO1xuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMuX3RvdGFsID0gTWF0aC5mbG9vcihjZmcuZHVyYXRpb24pO1xuICAgICAgICB0aGlzLl9sb29wID0gISFjZmcubG9vcDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLl9wcm9wID0gcHJvcDtcbiAgICAgICAgdGhpcy5fZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMuX3RvID0gdG87XG4gICAgICAgIHRoaXMuX3Byb21pc2VzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RpdmU7XG4gICAgfVxuICAgIHVwZGF0ZShjZmcsIHRvLCBkYXRlKSB7XG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLl90YXJnZXRbdGhpcy5fcHJvcF07XG4gICAgICAgICAgICBjb25zdCBlbGFwc2VkID0gZGF0ZSAtIHRoaXMuX3N0YXJ0O1xuICAgICAgICAgICAgY29uc3QgcmVtYWluID0gdGhpcy5fZHVyYXRpb24gLSBlbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBkYXRlO1xuICAgICAgICAgICAgdGhpcy5fZHVyYXRpb24gPSBNYXRoLmZsb29yKE1hdGgubWF4KHJlbWFpbiwgY2ZnLmR1cmF0aW9uKSk7XG4gICAgICAgICAgICB0aGlzLl90b3RhbCArPSBlbGFwc2VkO1xuICAgICAgICAgICAgdGhpcy5fbG9vcCA9ICEhY2ZnLmxvb3A7XG4gICAgICAgICAgICB0aGlzLl90byA9IHJlc29sdmUoW1xuICAgICAgICAgICAgICAgIGNmZy50byxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUsXG4gICAgICAgICAgICAgICAgY2ZnLmZyb21cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdGhpcy5fZnJvbSA9IHJlc29sdmUoW1xuICAgICAgICAgICAgICAgIGNmZy5mcm9tLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSxcbiAgICAgICAgICAgICAgICB0b1xuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAodGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2soRGF0ZS5ub3coKSk7XG4gICAgICAgICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeShmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGljayhkYXRlKSB7XG4gICAgICAgIGNvbnN0IGVsYXBzZWQgPSBkYXRlIC0gdGhpcy5fc3RhcnQ7XG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb247XG4gICAgICAgIGNvbnN0IHByb3AgPSB0aGlzLl9wcm9wO1xuICAgICAgICBjb25zdCBmcm9tID0gdGhpcy5fZnJvbTtcbiAgICAgICAgY29uc3QgbG9vcCA9IHRoaXMuX2xvb3A7XG4gICAgICAgIGNvbnN0IHRvID0gdGhpcy5fdG87XG4gICAgICAgIGxldCBmYWN0b3I7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IGZyb20gIT09IHRvICYmIChsb29wIHx8IGVsYXBzZWQgPCBkdXJhdGlvbik7XG4gICAgICAgIGlmICghdGhpcy5fYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXRbcHJvcF0gPSB0bztcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeSh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWxhcHNlZCA8IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFtwcm9wXSA9IGZyb207XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmFjdG9yID0gZWxhcHNlZCAvIGR1cmF0aW9uICUgMjtcbiAgICAgICAgZmFjdG9yID0gbG9vcCAmJiBmYWN0b3IgPiAxID8gMiAtIGZhY3RvciA6IGZhY3RvcjtcbiAgICAgICAgZmFjdG9yID0gdGhpcy5fZWFzaW5nKE1hdGgubWluKDEsIE1hdGgubWF4KDAsIGZhY3RvcikpKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0W3Byb3BdID0gdGhpcy5fZm4oZnJvbSwgdG8sIGZhY3Rvcik7XG4gICAgfVxuICAgIHdhaXQoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gdGhpcy5fcHJvbWlzZXMgfHwgKHRoaXMuX3Byb21pc2VzID0gW10pO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKT0+e1xuICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgcmVzLFxuICAgICAgICAgICAgICAgIHJlalxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfbm90aWZ5KHJlc29sdmVkKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IHJlc29sdmVkID8gJ3JlcycgOiAncmVqJztcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSB0aGlzLl9wcm9taXNlcyB8fCBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHByb21pc2VzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHByb21pc2VzW2ldW21ldGhvZF0oKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgQW5pbWF0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoY2hhcnQsIGNvbmZpZyl7XG4gICAgICAgIHRoaXMuX2NoYXJ0ID0gY2hhcnQ7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgaWYgKCFpc09iamVjdChjb25maWcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmFuaW1hdGlvbik7XG4gICAgICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgICAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjb25maWcpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IGNmZyA9IGNvbmZpZ1trZXldO1xuICAgICAgICAgICAgaWYgKCFpc09iamVjdChjZmcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGFuaW1hdGlvbk9wdGlvbnMpe1xuICAgICAgICAgICAgICAgIHJlc29sdmVkW29wdGlvbl0gPSBjZmdbb3B0aW9uXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIChpc0FycmF5KGNmZy5wcm9wZXJ0aWVzKSAmJiBjZmcucHJvcGVydGllcyB8fCBbXG4gICAgICAgICAgICAgICAga2V5XG4gICAgICAgICAgICBdKS5mb3JFYWNoKChwcm9wKT0+e1xuICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSBrZXkgfHwgIWFuaW1hdGVkUHJvcHMuaGFzKHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkUHJvcHMuc2V0KHByb3AsIHJlc29sdmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuIF9hbmltYXRlT3B0aW9ucyh0YXJnZXQsIHZhbHVlcykge1xuICAgICAgICBjb25zdCBuZXdPcHRpb25zID0gdmFsdWVzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSByZXNvbHZlVGFyZ2V0T3B0aW9ucyh0YXJnZXQsIG5ld09wdGlvbnMpO1xuICAgICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gdGhpcy5fY3JlYXRlQW5pbWF0aW9ucyhvcHRpb25zLCBuZXdPcHRpb25zKTtcbiAgICAgICAgaWYgKG5ld09wdGlvbnMuJHNoYXJlZCkge1xuICAgICAgICAgICAgYXdhaXRBbGwodGFyZ2V0Lm9wdGlvbnMuJGFuaW1hdGlvbnMsIG5ld09wdGlvbnMpLnRoZW4oKCk9PntcbiAgICAgICAgICAgICAgICB0YXJnZXQub3B0aW9ucyA9IG5ld09wdGlvbnM7XG4gICAgICAgICAgICB9LCAoKT0+e1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbnM7XG4gICAgfVxuIF9jcmVhdGVBbmltYXRpb25zKHRhcmdldCwgdmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGFuaW1hdGVkUHJvcHMgPSB0aGlzLl9wcm9wZXJ0aWVzO1xuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgICAgIGNvbnN0IHJ1bm5pbmcgPSB0YXJnZXQuJGFuaW1hdGlvbnMgfHwgKHRhcmdldC4kYW5pbWF0aW9ucyA9IHt9KTtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBPYmplY3Qua2V5cyh2YWx1ZXMpO1xuICAgICAgICBjb25zdCBkYXRlID0gRGF0ZS5ub3coKTtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvcihpID0gcHJvcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgY29uc3QgcHJvcCA9IHByb3BzW2ldO1xuICAgICAgICAgICAgaWYgKHByb3AuY2hhckF0KDApID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm9wID09PSAnb3B0aW9ucycpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goLi4udGhpcy5fYW5pbWF0ZU9wdGlvbnModGFyZ2V0LCB2YWx1ZXMpKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW3Byb3BdO1xuICAgICAgICAgICAgbGV0IGFuaW1hdGlvbiA9IHJ1bm5pbmdbcHJvcF07XG4gICAgICAgICAgICBjb25zdCBjZmcgPSBhbmltYXRlZFByb3BzLmdldChwcm9wKTtcbiAgICAgICAgICAgIGlmIChhbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ZnICYmIGFuaW1hdGlvbi5hY3RpdmUoKSkge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24udXBkYXRlKGNmZywgdmFsdWUsIGRhdGUpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjZmcgfHwgIWNmZy5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcnVubmluZ1twcm9wXSA9IGFuaW1hdGlvbiA9IG5ldyBBbmltYXRpb24oY2ZnLCB0YXJnZXQsIHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiB1cGRhdGUodGFyZ2V0LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Byb3BlcnRpZXMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIHZhbHVlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IHRoaXMuX2NyZWF0ZUFuaW1hdGlvbnModGFyZ2V0LCB2YWx1ZXMpO1xuICAgICAgICBpZiAoYW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yLmFkZCh0aGlzLl9jaGFydCwgYW5pbWF0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGF3YWl0QWxsKGFuaW1hdGlvbnMsIHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBydW5uaW5nID0gW107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3BlcnRpZXMpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgY29uc3QgYW5pbSA9IGFuaW1hdGlvbnNba2V5c1tpXV07XG4gICAgICAgIGlmIChhbmltICYmIGFuaW0uYWN0aXZlKCkpIHtcbiAgICAgICAgICAgIHJ1bm5pbmcucHVzaChhbmltLndhaXQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHJ1bm5pbmcpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVRhcmdldE9wdGlvbnModGFyZ2V0LCBuZXdPcHRpb25zKSB7XG4gICAgaWYgKCFuZXdPcHRpb25zKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IG9wdGlvbnMgPSB0YXJnZXQub3B0aW9ucztcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBuZXdPcHRpb25zO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRpb25zLiRzaGFyZWQpIHtcbiAgICAgICAgdGFyZ2V0Lm9wdGlvbnMgPSBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgJHNoYXJlZDogZmFsc2UsXG4gICAgICAgICAgICAkYW5pbWF0aW9uczoge31cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuXG5mdW5jdGlvbiBzY2FsZUNsaXAoc2NhbGUsIGFsbG93ZWRPdmVyZmxvdykge1xuICAgIGNvbnN0IG9wdHMgPSBzY2FsZSAmJiBzY2FsZS5vcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IHJldmVyc2UgPSBvcHRzLnJldmVyc2U7XG4gICAgY29uc3QgbWluID0gb3B0cy5taW4gPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gICAgY29uc3QgbWF4ID0gb3B0cy5tYXggPT09IHVuZGVmaW5lZCA/IGFsbG93ZWRPdmVyZmxvdyA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHJldmVyc2UgPyBtYXggOiBtaW4sXG4gICAgICAgIGVuZDogcmV2ZXJzZSA/IG1pbiA6IG1heFxuICAgIH07XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xpcCh4U2NhbGUsIHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KSB7XG4gICAgaWYgKGFsbG93ZWRPdmVyZmxvdyA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB4ID0gc2NhbGVDbGlwKHhTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgICBjb25zdCB5ID0gc2NhbGVDbGlwKHlTY2FsZSwgYWxsb3dlZE92ZXJmbG93KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHkuZW5kLFxuICAgICAgICByaWdodDogeC5lbmQsXG4gICAgICAgIGJvdHRvbTogeS5zdGFydCxcbiAgICAgICAgbGVmdDogeC5zdGFydFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0NsaXAodmFsdWUpIHtcbiAgICBsZXQgdCwgciwgYiwgbDtcbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHQgPSB2YWx1ZS50b3A7XG4gICAgICAgIHIgPSB2YWx1ZS5yaWdodDtcbiAgICAgICAgYiA9IHZhbHVlLmJvdHRvbTtcbiAgICAgICAgbCA9IHZhbHVlLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdCA9IHIgPSBiID0gbCA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHQsXG4gICAgICAgIHJpZ2h0OiByLFxuICAgICAgICBib3R0b206IGIsXG4gICAgICAgIGxlZnQ6IGwsXG4gICAgICAgIGRpc2FibGVkOiB2YWx1ZSA9PT0gZmFsc2VcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0U29ydGVkRGF0YXNldEluZGljZXMoY2hhcnQsIGZpbHRlclZpc2libGUpIHtcbiAgICBjb25zdCBrZXlzID0gW107XG4gICAgY29uc3QgbWV0YXNldHMgPSBjaGFydC5fZ2V0U29ydGVkRGF0YXNldE1ldGFzKGZpbHRlclZpc2libGUpO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvcihpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGtleXMucHVzaChtZXRhc2V0c1tpXS5pbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gYXBwbHlTdGFjayhzdGFjaywgdmFsdWUsIGRzSW5kZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGtleXMgPSBzdGFjay5rZXlzO1xuICAgIGNvbnN0IHNpbmdsZU1vZGUgPSBvcHRpb25zLm1vZGUgPT09ICdzaW5nbGUnO1xuICAgIGxldCBpLCBpbGVuLCBkYXRhc2V0SW5kZXgsIG90aGVyVmFsdWU7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGZvdW5kID0gZmFsc2U7XG4gICAgZm9yKGkgPSAwLCBpbGVuID0ga2V5cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBkYXRhc2V0SW5kZXggPSAra2V5c1tpXTtcbiAgICAgICAgaWYgKGRhdGFzZXRJbmRleCA9PT0gZHNJbmRleCkge1xuICAgICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYWxsKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBvdGhlclZhbHVlID0gc3RhY2sudmFsdWVzW2RhdGFzZXRJbmRleF07XG4gICAgICAgIGlmIChpc051bWJlckZpbml0ZShvdGhlclZhbHVlKSAmJiAoc2luZ2xlTW9kZSB8fCB2YWx1ZSA9PT0gMCB8fCBzaWduKHZhbHVlKSA9PT0gc2lnbihvdGhlclZhbHVlKSkpIHtcbiAgICAgICAgICAgIHZhbHVlICs9IG90aGVyVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCAmJiAhb3B0aW9ucy5hbGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKSB7XG4gICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgIH0gPSBtZXRhO1xuICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/ICd4JyA6ICd5JztcbiAgICBjb25zdCB2QXhpc0tleSA9IHZTY2FsZS5heGlzID09PSAneCcgPyAneCcgOiAneSc7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIGNvbnN0IGFkYXRhID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBsZXQgaSwgaWxlbiwga2V5O1xuICAgIGZvcihpID0gMCwgaWxlbiA9IGtleXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgYWRhdGFbaV0gPSB7XG4gICAgICAgICAgICBbaUF4aXNLZXldOiBrZXksXG4gICAgICAgICAgICBbdkF4aXNLZXldOiBkYXRhW2tleV1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGFkYXRhO1xufVxuZnVuY3Rpb24gaXNTdGFja2VkKHNjYWxlLCBtZXRhKSB7XG4gICAgY29uc3Qgc3RhY2tlZCA9IHNjYWxlICYmIHNjYWxlLm9wdGlvbnMuc3RhY2tlZDtcbiAgICByZXR1cm4gc3RhY2tlZCB8fCBzdGFja2VkID09PSB1bmRlZmluZWQgJiYgbWV0YS5zdGFjayAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0U3RhY2tLZXkoaW5kZXhTY2FsZSwgdmFsdWVTY2FsZSwgbWV0YSkge1xuICAgIHJldHVybiBgJHtpbmRleFNjYWxlLmlkfS4ke3ZhbHVlU2NhbGUuaWR9LiR7bWV0YS5zdGFjayB8fCBtZXRhLnR5cGV9YDtcbn1cbmZ1bmN0aW9uIGdldFVzZXJCb3VuZHMoc2NhbGUpIHtcbiAgICBjb25zdCB7IG1pbiAsIG1heCAsIG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gc2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluRGVmaW5lZCA/IG1pbiA6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxcbiAgICAgICAgbWF4OiBtYXhEZWZpbmVkID8gbWF4IDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldE9yQ3JlYXRlU3RhY2soc3RhY2tzLCBzdGFja0tleSwgaW5kZXhWYWx1ZSkge1xuICAgIGNvbnN0IHN1YlN0YWNrID0gc3RhY2tzW3N0YWNrS2V5XSB8fCAoc3RhY2tzW3N0YWNrS2V5XSA9IHt9KTtcbiAgICByZXR1cm4gc3ViU3RhY2tbaW5kZXhWYWx1ZV0gfHwgKHN1YlN0YWNrW2luZGV4VmFsdWVdID0ge30pO1xufVxuZnVuY3Rpb24gZ2V0TGFzdEluZGV4SW5TdGFjayhzdGFjaywgdlNjYWxlLCBwb3NpdGl2ZSwgdHlwZSkge1xuICAgIGZvciAoY29uc3QgbWV0YSBvZiB2U2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkucmV2ZXJzZSgpKXtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGFja1ttZXRhLmluZGV4XTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIHZhbHVlID4gMCB8fCAhcG9zaXRpdmUgJiYgdmFsdWUgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0YS5pbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVN0YWNrcyhjb250cm9sbGVyLCBwYXJzZWQpIHtcbiAgICBjb25zdCB7IGNoYXJ0ICwgX2NhY2hlZE1ldGE6IG1ldGEgIH0gPSBjb250cm9sbGVyO1xuICAgIGNvbnN0IHN0YWNrcyA9IGNoYXJ0Ll9zdGFja3MgfHwgKGNoYXJ0Ll9zdGFja3MgPSB7fSk7XG4gICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgLCBpbmRleDogZGF0YXNldEluZGV4ICB9ID0gbWV0YTtcbiAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgY29uc3Qga2V5ID0gZ2V0U3RhY2tLZXkoaVNjYWxlLCB2U2NhbGUsIG1ldGEpO1xuICAgIGNvbnN0IGlsZW4gPSBwYXJzZWQubGVuZ3RoO1xuICAgIGxldCBzdGFjaztcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IHBhcnNlZFtpXTtcbiAgICAgICAgY29uc3QgeyBbaUF4aXNdOiBpbmRleCAsIFt2QXhpc106IHZhbHVlICB9ID0gaXRlbTtcbiAgICAgICAgY29uc3QgaXRlbVN0YWNrcyA9IGl0ZW0uX3N0YWNrcyB8fCAoaXRlbS5fc3RhY2tzID0ge30pO1xuICAgICAgICBzdGFjayA9IGl0ZW1TdGFja3NbdkF4aXNdID0gZ2V0T3JDcmVhdGVTdGFjayhzdGFja3MsIGtleSwgaW5kZXgpO1xuICAgICAgICBzdGFja1tkYXRhc2V0SW5kZXhdID0gdmFsdWU7XG4gICAgICAgIHN0YWNrLl90b3AgPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIHRydWUsIG1ldGEudHlwZSk7XG4gICAgICAgIHN0YWNrLl9ib3R0b20gPSBnZXRMYXN0SW5kZXhJblN0YWNrKHN0YWNrLCB2U2NhbGUsIGZhbHNlLCBtZXRhLnR5cGUpO1xuICAgICAgICBjb25zdCB2aXN1YWxWYWx1ZXMgPSBzdGFjay5fdmlzdWFsVmFsdWVzIHx8IChzdGFjay5fdmlzdWFsVmFsdWVzID0ge30pO1xuICAgICAgICB2aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEZpcnN0U2NhbGVJZChjaGFydCwgYXhpcykge1xuICAgIGNvbnN0IHNjYWxlcyA9IGNoYXJ0LnNjYWxlcztcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2NhbGVzKS5maWx0ZXIoKGtleSk9PnNjYWxlc1trZXldLmF4aXMgPT09IGF4aXMpLnNoaWZ0KCk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhc2V0Q29udGV4dChwYXJlbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGRhdGFzZXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgZGF0YXNldEluZGV4OiBpbmRleCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgICAgdHlwZTogJ2RhdGFzZXQnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEYXRhQ29udGV4dChwYXJlbnQsIGluZGV4LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIGFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGRhdGFJbmRleDogaW5kZXgsXG4gICAgICAgIHBhcnNlZDogdW5kZWZpbmVkLFxuICAgICAgICByYXc6IHVuZGVmaW5lZCxcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgaW5kZXgsXG4gICAgICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICAgICAgdHlwZTogJ2RhdGEnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjbGVhclN0YWNrcyhtZXRhLCBpdGVtcykge1xuICAgIGNvbnN0IGRhdGFzZXRJbmRleCA9IG1ldGEuY29udHJvbGxlci5pbmRleDtcbiAgICBjb25zdCBheGlzID0gbWV0YS52U2NhbGUgJiYgbWV0YS52U2NhbGUuYXhpcztcbiAgICBpZiAoIWF4aXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpdGVtcyA9IGl0ZW1zIHx8IG1ldGEuX3BhcnNlZDtcbiAgICBmb3IgKGNvbnN0IHBhcnNlZCBvZiBpdGVtcyl7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IHBhcnNlZC5fc3RhY2tzO1xuICAgICAgICBpZiAoIXN0YWNrcyB8fCBzdGFja3NbYXhpc10gPT09IHVuZGVmaW5lZCB8fCBzdGFja3NbYXhpc11bZGF0YXNldEluZGV4XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHN0YWNrc1theGlzXVtkYXRhc2V0SW5kZXhdO1xuICAgICAgICBpZiAoc3RhY2tzW2F4aXNdLl92aXN1YWxWYWx1ZXMgIT09IHVuZGVmaW5lZCAmJiBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzdGFja3NbYXhpc10uX3Zpc3VhbFZhbHVlc1tkYXRhc2V0SW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgaXNEaXJlY3RVcGRhdGVNb2RlID0gKG1vZGUpPT5tb2RlID09PSAncmVzZXQnIHx8IG1vZGUgPT09ICdub25lJztcbmNvbnN0IGNsb25lSWZOb3RTaGFyZWQgPSAoY2FjaGVkLCBzaGFyZWQpPT5zaGFyZWQgPyBjYWNoZWQgOiBPYmplY3QuYXNzaWduKHt9LCBjYWNoZWQpO1xuY29uc3QgY3JlYXRlU3RhY2sgPSAoY2FuU3RhY2ssIG1ldGEsIGNoYXJ0KT0+Y2FuU3RhY2sgJiYgIW1ldGEuaGlkZGVuICYmIG1ldGEuX3N0YWNrZWQgJiYge1xuICAgICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICAgIHZhbHVlczogbnVsbFxuICAgIH07XG5jbGFzcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gc3RhdGljIGRlZmF1bHRzID0ge307XG4gc3RhdGljIGRhdGFzZXRFbGVtZW50VHlwZSA9IG51bGw7XG4gc3RhdGljIGRhdGFFbGVtZW50VHlwZSA9IG51bGw7XG4gY29uc3RydWN0b3IoY2hhcnQsIGRhdGFzZXRJbmRleCl7XG4gICAgICAgIHRoaXMuY2hhcnQgPSBjaGFydDtcbiAgICAgICAgdGhpcy5fY3R4ID0gY2hhcnQuY3R4O1xuICAgICAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgICAgICB0aGlzLl9jYWNoZWREYXRhT3B0cyA9IHt9O1xuICAgICAgICB0aGlzLl9jYWNoZWRNZXRhID0gdGhpcy5nZXRNZXRhKCk7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0aGlzLl9jYWNoZWRNZXRhLnR5cGU7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fb2JqZWN0RGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc2hhcmVkT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZHJhd1N0YXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9kcmF3Q291bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnN1cHBvcnRzRGVjaW1hdGlvbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLiRjb250ZXh0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YXNldEVsZW1lbnRUeXBlO1xuICAgICAgICB0aGlzLmRhdGFFbGVtZW50VHlwZSA9IG5ldy50YXJnZXQuZGF0YUVsZW1lbnRUeXBlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHRoaXMuY29uZmlndXJlKCk7XG4gICAgICAgIHRoaXMubGlua1NjYWxlcygpO1xuICAgICAgICBtZXRhLl9zdGFja2VkID0gaXNTdGFja2VkKG1ldGEudlNjYWxlLCBtZXRhKTtcbiAgICAgICAgdGhpcy5hZGRFbGVtZW50cygpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmZpbGwgJiYgIXRoaXMuY2hhcnQuaXNQbHVnaW5FbmFibGVkKCdmaWxsZXInKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiVHJpZWQgdG8gdXNlIHRoZSAnZmlsbCcgb3B0aW9uIHdpdGhvdXQgdGhlICdGaWxsZXInIHBsdWdpbiBlbmFibGVkLiBQbGVhc2UgaW1wb3J0IGFuZCByZWdpc3RlciB0aGUgJ0ZpbGxlcicgcGx1Z2luIGFuZCBtYWtlIHN1cmUgaXQgaXMgbm90IGRpc2FibGVkIGluIHRoZSBvcHRpb25zXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZUluZGV4KGRhdGFzZXRJbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pbmRleCAhPT0gZGF0YXNldEluZGV4KSB7XG4gICAgICAgICAgICBjbGVhclN0YWNrcyh0aGlzLl9jYWNoZWRNZXRhKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZGV4ID0gZGF0YXNldEluZGV4O1xuICAgIH1cbiAgICBsaW5rU2NhbGVzKCkge1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgICAgIGNvbnN0IGNob29zZUlkID0gKGF4aXMsIHgsIHksIHIpPT5heGlzID09PSAneCcgPyB4IDogYXhpcyA9PT0gJ3InID8gciA6IHk7XG4gICAgICAgIGNvbnN0IHhpZCA9IG1ldGEueEF4aXNJRCA9IHZhbHVlT3JEZWZhdWx0KGRhdGFzZXQueEF4aXNJRCwgZ2V0Rmlyc3RTY2FsZUlkKGNoYXJ0LCAneCcpKTtcbiAgICAgICAgY29uc3QgeWlkID0gbWV0YS55QXhpc0lEID0gdmFsdWVPckRlZmF1bHQoZGF0YXNldC55QXhpc0lELCBnZXRGaXJzdFNjYWxlSWQoY2hhcnQsICd5JykpO1xuICAgICAgICBjb25zdCByaWQgPSBtZXRhLnJBeGlzSUQgPSB2YWx1ZU9yRGVmYXVsdChkYXRhc2V0LnJBeGlzSUQsIGdldEZpcnN0U2NhbGVJZChjaGFydCwgJ3InKSk7XG4gICAgICAgIGNvbnN0IGluZGV4QXhpcyA9IG1ldGEuaW5kZXhBeGlzO1xuICAgICAgICBjb25zdCBpaWQgPSBtZXRhLmlBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHhpZCwgeWlkLCByaWQpO1xuICAgICAgICBjb25zdCB2aWQgPSBtZXRhLnZBeGlzSUQgPSBjaG9vc2VJZChpbmRleEF4aXMsIHlpZCwgeGlkLCByaWQpO1xuICAgICAgICBtZXRhLnhTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh4aWQpO1xuICAgICAgICBtZXRhLnlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh5aWQpO1xuICAgICAgICBtZXRhLnJTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChyaWQpO1xuICAgICAgICBtZXRhLmlTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZChpaWQpO1xuICAgICAgICBtZXRhLnZTY2FsZSA9IHRoaXMuZ2V0U2NhbGVGb3JJZCh2aWQpO1xuICAgIH1cbiAgICBnZXREYXRhc2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW3RoaXMuaW5kZXhdO1xuICAgIH1cbiAgICBnZXRNZXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhc2V0TWV0YSh0aGlzLmluZGV4KTtcbiAgICB9XG4gZ2V0U2NhbGVGb3JJZChzY2FsZUlEKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYXJ0LnNjYWxlc1tzY2FsZUlEXTtcbiAgICB9XG4gX2dldE90aGVyU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIHJldHVybiBzY2FsZSA9PT0gbWV0YS5pU2NhbGUgPyBtZXRhLnZTY2FsZSA6IG1ldGEuaVNjYWxlO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlKCdyZXNldCcpO1xuICAgIH1cbiBfZGVzdHJveSgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICAgICAgICB1bmxpc3RlbkFycmF5RXZlbnRzKHRoaXMuX2RhdGEsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgICAgICBjbGVhclN0YWNrcyhtZXRhKTtcbiAgICAgICAgfVxuICAgIH1cbiBfZGF0YUNoZWNrKCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5nZXREYXRhc2V0KCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBkYXRhc2V0LmRhdGEgfHwgKGRhdGFzZXQuZGF0YSA9IFtdKTtcbiAgICAgICAgY29uc3QgX2RhdGEgPSB0aGlzLl9kYXRhO1xuICAgICAgICBpZiAoaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGNvbnZlcnRPYmplY3REYXRhVG9BcnJheShkYXRhLCBtZXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChfZGF0YSAhPT0gZGF0YSkge1xuICAgICAgICAgICAgaWYgKF9kYXRhKSB7XG4gICAgICAgICAgICAgICAgdW5saXN0ZW5BcnJheUV2ZW50cyhfZGF0YSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgICAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgICAgICAgICAgbWV0YS5fcGFyc2VkID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBPYmplY3QuaXNFeHRlbnNpYmxlKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuQXJyYXlFdmVudHMoZGF0YSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zeW5jTGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRWxlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICB0aGlzLl9kYXRhQ2hlY2soKTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICBtZXRhLmRhdGFzZXQgPSBuZXcgdGhpcy5kYXRhc2V0RWxlbWVudFR5cGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZE9yVXBkYXRlRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZ2V0RGF0YXNldCgpO1xuICAgICAgICBsZXQgc3RhY2tDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2RhdGFDaGVjaygpO1xuICAgICAgICBjb25zdCBvbGRTdGFja2VkID0gbWV0YS5fc3RhY2tlZDtcbiAgICAgICAgbWV0YS5fc3RhY2tlZCA9IGlzU3RhY2tlZChtZXRhLnZTY2FsZSwgbWV0YSk7XG4gICAgICAgIGlmIChtZXRhLnN0YWNrICE9PSBkYXRhc2V0LnN0YWNrKSB7XG4gICAgICAgICAgICBzdGFja0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2xlYXJTdGFja3MobWV0YSk7XG4gICAgICAgICAgICBtZXRhLnN0YWNrID0gZGF0YXNldC5zdGFjaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXN5bmNFbGVtZW50cyhyZXNldE5ld0VsZW1lbnRzKTtcbiAgICAgICAgaWYgKHN0YWNrQ2hhbmdlZCB8fCBvbGRTdGFja2VkICE9PSBtZXRhLl9zdGFja2VkKSB7XG4gICAgICAgICAgICB1cGRhdGVTdGFja3ModGhpcywgbWV0YS5fcGFyc2VkKTtcbiAgICAgICAgICAgIG1ldGEuX3N0YWNrZWQgPSBpc1N0YWNrZWQobWV0YS52U2NhbGUsIG1ldGEpO1xuICAgICAgICB9XG4gICAgfVxuIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jaGFydC5jb25maWc7XG4gICAgICAgIGNvbnN0IHNjb3BlS2V5cyA9IGNvbmZpZy5kYXRhc2V0U2NvcGVLZXlzKHRoaXMuX3R5cGUpO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMsIHRydWUpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIHRoaXMuX3BhcnNpbmcgPSB0aGlzLm9wdGlvbnMucGFyc2luZztcbiAgICAgICAgdGhpcy5fY2FjaGVkRGF0YU9wdHMgPSB7fTtcbiAgICB9XG4gcGFyc2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHsgX2NhY2hlZE1ldGE6IG1ldGEgLCBfZGF0YTogZGF0YSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgX3N0YWNrZWQgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgICAgICBsZXQgc29ydGVkID0gc3RhcnQgPT09IDAgJiYgY291bnQgPT09IGRhdGEubGVuZ3RoID8gdHJ1ZSA6IG1ldGEuX3NvcnRlZDtcbiAgICAgICAgbGV0IHByZXYgPSBzdGFydCA+IDAgJiYgbWV0YS5fcGFyc2VkW3N0YXJ0IC0gMV07XG4gICAgICAgIGxldCBpLCBjdXIsIHBhcnNlZDtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNpbmcgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtZXRhLl9wYXJzZWQgPSBkYXRhO1xuICAgICAgICAgICAgbWV0YS5fc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBhcnNlZCA9IGRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNBcnJheShkYXRhW3N0YXJ0XSkpIHtcbiAgICAgICAgICAgICAgICBwYXJzZWQgPSB0aGlzLnBhcnNlQXJyYXlEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHRoaXMucGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc05vdEluT3JkZXJDb21wYXJlZFRvUHJldiA9ICgpPT5jdXJbaUF4aXNdID09PSBudWxsIHx8IHByZXYgJiYgY3VyW2lBeGlzXSA8IHByZXZbaUF4aXNdO1xuICAgICAgICAgICAgZm9yKGkgPSAwOyBpIDwgY291bnQ7ICsraSl7XG4gICAgICAgICAgICAgICAgbWV0YS5fcGFyc2VkW2kgKyBzdGFydF0gPSBjdXIgPSBwYXJzZWRbaV07XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNOb3RJbk9yZGVyQ29tcGFyZWRUb1ByZXYoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJldiA9IGN1cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXRhLl9zb3J0ZWQgPSBzb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9zdGFja2VkKSB7XG4gICAgICAgICAgICB1cGRhdGVTdGFja3ModGhpcywgcGFyc2VkKTtcbiAgICAgICAgfVxuICAgIH1cbiBwYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgaUF4aXMgPSBpU2NhbGUuYXhpcztcbiAgICAgICAgY29uc3QgdkF4aXMgPSB2U2NhbGUuYXhpcztcbiAgICAgICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgICAgICBjb25zdCBzaW5nbGVTY2FsZSA9IGlTY2FsZSA9PT0gdlNjYWxlO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBsZXQgaSwgaWxlbiwgaW5kZXg7XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICAgICAgICAgIFtpQXhpc106IHNpbmdsZVNjYWxlIHx8IGlTY2FsZS5wYXJzZShsYWJlbHNbaW5kZXhdLCBpbmRleCksXG4gICAgICAgICAgICAgICAgW3ZBeGlzXTogdlNjYWxlLnBhcnNlKGRhdGFbaW5kZXhdLCBpbmRleClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gcGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHsgeFNjYWxlICwgeVNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICAgICAgbGV0IGksIGlsZW4sIGluZGV4LCBpdGVtO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBjb3VudDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgICAgICAgIGl0ZW0gPSBkYXRhW2luZGV4XTtcbiAgICAgICAgICAgIHBhcnNlZFtpXSA9IHtcbiAgICAgICAgICAgICAgICB4OiB4U2NhbGUucGFyc2UoaXRlbVswXSwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIHk6IHlTY2FsZS5wYXJzZShpdGVtWzFdLCBpbmRleClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICBjb25zdCB7IHhTY2FsZSAsIHlTY2FsZSAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IHsgeEF4aXNLZXkgPSd4JyAsIHlBeGlzS2V5ID0neScgIH0gPSB0aGlzLl9wYXJzaW5nO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgICAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGluZGV4ID0gaSArIHN0YXJ0O1xuICAgICAgICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgcGFyc2VkW2ldID0ge1xuICAgICAgICAgICAgICAgIHg6IHhTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHhBeGlzS2V5KSwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIHk6IHlTY2FsZS5wYXJzZShyZXNvbHZlT2JqZWN0S2V5KGl0ZW0sIHlBeGlzS2V5KSwgaW5kZXgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuIGdldFBhcnNlZChpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkTWV0YS5fcGFyc2VkW2luZGV4XTtcbiAgICB9XG4gZ2V0RGF0YUVsZW1lbnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgfVxuIGFwcGx5U3RhY2soc2NhbGUsIHBhcnNlZCwgbW9kZSkge1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlZFtzY2FsZS5heGlzXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSB7XG4gICAgICAgICAgICBrZXlzOiBnZXRTb3J0ZWREYXRhc2V0SW5kaWNlcyhjaGFydCwgdHJ1ZSksXG4gICAgICAgICAgICB2YWx1ZXM6IHBhcnNlZC5fc3RhY2tzW3NjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGFwcGx5U3RhY2soc3RhY2ssIHZhbHVlLCBtZXRhLmluZGV4LCB7XG4gICAgICAgICAgICBtb2RlXG4gICAgICAgIH0pO1xuICAgIH1cbiB1cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFZhbHVlID0gcGFyc2VkW3NjYWxlLmF4aXNdO1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJzZWRWYWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHBhcnNlZFZhbHVlO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBzdGFjayAmJiBwYXJzZWQuX3N0YWNrc1tzY2FsZS5heGlzXTtcbiAgICAgICAgaWYgKHN0YWNrICYmIHZhbHVlcykge1xuICAgICAgICAgICAgc3RhY2sudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgdmFsdWUgPSBhcHBseVN0YWNrKHN0YWNrLCBwYXJzZWRWYWx1ZSwgdGhpcy5fY2FjaGVkTWV0YS5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCB2YWx1ZSk7XG4gICAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgdmFsdWUpO1xuICAgIH1cbiBnZXRNaW5NYXgoc2NhbGUsIGNhblN0YWNrKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBfcGFyc2VkID0gbWV0YS5fcGFyc2VkO1xuICAgICAgICBjb25zdCBzb3J0ZWQgPSBtZXRhLl9zb3J0ZWQgJiYgc2NhbGUgPT09IG1ldGEuaVNjYWxlO1xuICAgICAgICBjb25zdCBpbGVuID0gX3BhcnNlZC5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG90aGVyU2NhbGUgPSB0aGlzLl9nZXRPdGhlclNjYWxlKHNjYWxlKTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBjcmVhdGVTdGFjayhjYW5TdGFjaywgbWV0YSwgdGhpcy5jaGFydCk7XG4gICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IG1pbjogb3RoZXJNaW4gLCBtYXg6IG90aGVyTWF4ICB9ID0gZ2V0VXNlckJvdW5kcyhvdGhlclNjYWxlKTtcbiAgICAgICAgbGV0IGksIHBhcnNlZDtcbiAgICAgICAgZnVuY3Rpb24gX3NraXAoKSB7XG4gICAgICAgICAgICBwYXJzZWQgPSBfcGFyc2VkW2ldO1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJWYWx1ZSA9IHBhcnNlZFtvdGhlclNjYWxlLmF4aXNdO1xuICAgICAgICAgICAgcmV0dXJuICFpc051bWJlckZpbml0ZShwYXJzZWRbc2NhbGUuYXhpc10pIHx8IG90aGVyTWluID4gb3RoZXJWYWx1ZSB8fCBvdGhlck1heCA8IG90aGVyVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGlmIChfc2tpcCgpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spO1xuICAgICAgICAgICAgaWYgKHNvcnRlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb3J0ZWQpIHtcbiAgICAgICAgICAgIGZvcihpID0gaWxlbiAtIDE7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgICAgICBpZiAoX3NraXAoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVSYW5nZUZyb21QYXJzZWQocmFuZ2UsIHNjYWxlLCBwYXJzZWQsIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIGdldEFsbFBhcnNlZFZhbHVlcyhzY2FsZSkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLl9jYWNoZWRNZXRhLl9wYXJzZWQ7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IHBhcnNlZC5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZWRbaV1bc2NhbGUuYXhpc107XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuIGdldE1heE92ZXJmbG93KCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgICAgICBjb25zdCB2U2NhbGUgPSBtZXRhLnZTY2FsZTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGlTY2FsZSA/ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSkgOiAnJyxcbiAgICAgICAgICAgIHZhbHVlOiB2U2NhbGUgPyAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pIDogJydcbiAgICAgICAgfTtcbiAgICB9XG4gX3VwZGF0ZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICB0aGlzLnVwZGF0ZShtb2RlIHx8ICdkZWZhdWx0Jyk7XG4gICAgICAgIG1ldGEuX2NsaXAgPSB0b0NsaXAodmFsdWVPckRlZmF1bHQodGhpcy5vcHRpb25zLmNsaXAsIGRlZmF1bHRDbGlwKG1ldGEueFNjYWxlLCBtZXRhLnlTY2FsZSwgdGhpcy5nZXRNYXhPdmVyZmxvdygpKSkpO1xuICAgIH1cbiB1cGRhdGUobW9kZSkge31cbiAgICBkcmF3KCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9jdHg7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgICAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSB0aGlzLl9kcmF3U3RhcnQgfHwgMDtcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLl9kcmF3Q291bnQgfHwgZWxlbWVudHMubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgIGNvbnN0IGRyYXdBY3RpdmVFbGVtZW50c09uVG9wID0gdGhpcy5vcHRpb25zLmRyYXdBY3RpdmVFbGVtZW50c09uVG9wO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKG1ldGEuZGF0YXNldCkge1xuICAgICAgICAgICAgbWV0YS5kYXRhc2V0LmRyYXcoY3R4LCBhcmVhLCBzdGFydCwgY291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpe1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5hY3RpdmUgJiYgZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3ApIHtcbiAgICAgICAgICAgICAgICBhY3RpdmUucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgIGFjdGl2ZVtpXS5kcmF3KGN0eCwgYXJlYSk7XG4gICAgICAgIH1cbiAgICB9XG4gZ2V0U3R5bGUoaW5kZXgsIGFjdGl2ZSkge1xuICAgICAgICBjb25zdCBtb2RlID0gYWN0aXZlID8gJ2FjdGl2ZScgOiAnZGVmYXVsdCc7XG4gICAgICAgIHJldHVybiBpbmRleCA9PT0gdW5kZWZpbmVkICYmIHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldCA/IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKSA6IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCB8fCAwLCBtb2RlKTtcbiAgICB9XG4gZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGRhdGFzZXQgPSB0aGlzLmdldERhdGFzZXQoKTtcbiAgICAgICAgbGV0IGNvbnRleHQ7XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5fY2FjaGVkTWV0YS5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YVtpbmRleF07XG4gICAgICAgICAgICBjb250ZXh0ID0gZWxlbWVudC4kY29udGV4dCB8fCAoZWxlbWVudC4kY29udGV4dCA9IGNyZWF0ZURhdGFDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpLCBpbmRleCwgZWxlbWVudCkpO1xuICAgICAgICAgICAgY29udGV4dC5wYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICAgICAgICBjb250ZXh0LnJhdyA9IGRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICAgICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhSW5kZXggPSBpbmRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRleHQgPSB0aGlzLiRjb250ZXh0IHx8ICh0aGlzLiRjb250ZXh0ID0gY3JlYXRlRGF0YXNldENvbnRleHQodGhpcy5jaGFydC5nZXRDb250ZXh0KCksIHRoaXMuaW5kZXgpKTtcbiAgICAgICAgICAgIGNvbnRleHQuZGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICAgICAgICBjb250ZXh0LmluZGV4ID0gY29udGV4dC5kYXRhc2V0SW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYWN0aXZlID0gISFhY3RpdmU7XG4gICAgICAgIGNvbnRleHQubW9kZSA9IG1vZGU7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbiByZXNvbHZlRGF0YXNldEVsZW1lbnRPcHRpb25zKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZS5pZCwgbW9kZSk7XG4gICAgfVxuIHJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaW5kZXgsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVFbGVtZW50T3B0aW9ucyh0aGlzLmRhdGFFbGVtZW50VHlwZS5pZCwgbW9kZSwgaW5kZXgpO1xuICAgIH1cbiBfcmVzb2x2ZUVsZW1lbnRPcHRpb25zKGVsZW1lbnRUeXBlLCBtb2RlID0gJ2RlZmF1bHQnLCBpbmRleCkge1xuICAgICAgICBjb25zdCBhY3RpdmUgPSBtb2RlID09PSAnYWN0aXZlJztcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBlbGVtZW50VHlwZSArICctJyArIG1vZGU7XG4gICAgICAgIGNvbnN0IGNhY2hlZCA9IGNhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgY29uc3Qgc2hhcmluZyA9IHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyAmJiBkZWZpbmVkKGluZGV4KTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNsb25lSWZOb3RTaGFyZWQoY2FjaGVkLCBzaGFyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLmNoYXJ0LmNvbmZpZztcbiAgICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRFbGVtZW50U2NvcGVLZXlzKHRoaXMuX3R5cGUsIGVsZW1lbnRUeXBlKTtcbiAgICAgICAgY29uc3QgcHJlZml4ZXMgPSBhY3RpdmUgPyBbXG4gICAgICAgICAgICBgJHtlbGVtZW50VHlwZX1Ib3ZlcmAsXG4gICAgICAgICAgICAnaG92ZXInLFxuICAgICAgICAgICAgZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAnJ1xuICAgICAgICBdIDogW1xuICAgICAgICAgICAgZWxlbWVudFR5cGUsXG4gICAgICAgICAgICAnJ1xuICAgICAgICBdO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgICBjb25zdCBuYW1lcyA9IE9iamVjdC5rZXlzKGRlZmF1bHRzLmVsZW1lbnRzW2VsZW1lbnRUeXBlXSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSAoKT0+dGhpcy5nZXRDb250ZXh0KGluZGV4LCBhY3RpdmUsIG1vZGUpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBjb25maWcucmVzb2x2ZU5hbWVkT3B0aW9ucyhzY29wZXMsIG5hbWVzLCBjb250ZXh0LCBwcmVmaXhlcyk7XG4gICAgICAgIGlmICh2YWx1ZXMuJHNoYXJlZCkge1xuICAgICAgICAgICAgdmFsdWVzLiRzaGFyZWQgPSBzaGFyaW5nO1xuICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShjbG9uZUlmTm90U2hhcmVkKHZhbHVlcywgc2hhcmluZykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfVxuIF9yZXNvbHZlQW5pbWF0aW9ucyhpbmRleCwgdHJhbnNpdGlvbiwgYWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWREYXRhT3B0cztcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgYW5pbWF0aW9uLSR7dHJhbnNpdGlvbn1gO1xuICAgICAgICBjb25zdCBjYWNoZWQgPSBjYWNoZVtjYWNoZUtleV07XG4gICAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICAgIGlmIChjaGFydC5vcHRpb25zLmFuaW1hdGlvbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuY2hhcnQuY29uZmlnO1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVLZXlzID0gY29uZmlnLmRhdGFzZXRBbmltYXRpb25TY29wZUtleXModGhpcy5fdHlwZSwgdHJhbnNpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKHRoaXMuZ2V0RGF0YXNldCgpLCBzY29wZUtleXMpO1xuICAgICAgICAgICAgb3B0aW9ucyA9IGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIHRoaXMuZ2V0Q29udGV4dChpbmRleCwgYWN0aXZlLCB0cmFuc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9ucyA9IG5ldyBBbmltYXRpb25zKGNoYXJ0LCBvcHRpb25zICYmIG9wdGlvbnMuYW5pbWF0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2NhY2hlYWJsZSkge1xuICAgICAgICAgICAgY2FjaGVbY2FjaGVLZXldID0gT2JqZWN0LmZyZWV6ZShhbmltYXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG4gZ2V0U2hhcmVkT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy4kc2hhcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NoYXJlZE9wdGlvbnMgfHwgKHRoaXMuX3NoYXJlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSk7XG4gICAgfVxuIGluY2x1ZGVPcHRpb25zKG1vZGUsIHNoYXJlZE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuICFzaGFyZWRPcHRpb25zIHx8IGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSB8fCB0aGlzLmNoYXJ0Ll9hbmltYXRpb25zRGlzYWJsZWQ7XG4gICAgfVxuIF9nZXRTaGFyZWRPcHRpb25zKHN0YXJ0LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0T3B0cyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzbHlTaGFyZWRPcHRpb25zID0gdGhpcy5fc2hhcmVkT3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucykgfHwgc2hhcmVkT3B0aW9ucyAhPT0gcHJldmlvdXNseVNoYXJlZE9wdGlvbnM7XG4gICAgICAgIHRoaXMudXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBmaXJzdE9wdHMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2hhcmVkT3B0aW9ucyxcbiAgICAgICAgICAgIGluY2x1ZGVPcHRpb25zXG4gICAgICAgIH07XG4gICAgfVxuIHVwZGF0ZUVsZW1lbnQoZWxlbWVudCwgaW5kZXgsIHByb3BlcnRpZXMsIG1vZGUpIHtcbiAgICAgICAgaWYgKGlzRGlyZWN0VXBkYXRlTW9kZShtb2RlKSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKGluZGV4LCBtb2RlKS51cGRhdGUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgICAgIH1cbiAgICB9XG4gdXBkYXRlU2hhcmVkT3B0aW9ucyhzaGFyZWRPcHRpb25zLCBtb2RlLCBuZXdPcHRpb25zKSB7XG4gICAgICAgIGlmIChzaGFyZWRPcHRpb25zICYmICFpc0RpcmVjdFVwZGF0ZU1vZGUobW9kZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKHVuZGVmaW5lZCwgbW9kZSkudXBkYXRlKHNoYXJlZE9wdGlvbnMsIG5ld09wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxuIF9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgbW9kZSwgYWN0aXZlKSB7XG4gICAgICAgIGVsZW1lbnQuYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5nZXRTdHlsZShpbmRleCwgYWN0aXZlKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZUFuaW1hdGlvbnMoaW5kZXgsIG1vZGUsIGFjdGl2ZSkudXBkYXRlKGVsZW1lbnQsIHtcbiAgICAgICAgICAgIG9wdGlvbnM6ICFhY3RpdmUgJiYgdGhpcy5nZXRTaGFyZWRPcHRpb25zKG9wdGlvbnMpIHx8IG9wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUhvdmVyU3R5bGUoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCkge1xuICAgICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCBpbmRleCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICB9XG4gICAgc2V0SG92ZXJTdHlsZShlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIGluZGV4LCAnYWN0aXZlJywgdHJ1ZSk7XG4gICAgfVxuIF9yZW1vdmVEYXRhc2V0SG92ZXJTdHlsZSgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YXNldDtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0eWxlKGVsZW1lbnQsIHVuZGVmaW5lZCwgJ2FjdGl2ZScsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiBfc2V0RGF0YXNldEhvdmVyU3R5bGUoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGFzZXQ7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdHlsZShlbGVtZW50LCB1bmRlZmluZWQsICdhY3RpdmUnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiBfcmVzeW5jRWxlbWVudHMocmVzZXROZXdFbGVtZW50cykge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLl9jYWNoZWRNZXRhLmRhdGE7XG4gICAgICAgIGZvciAoY29uc3QgW21ldGhvZCwgYXJnMSwgYXJnMl0gb2YgdGhpcy5fc3luY0xpc3Qpe1xuICAgICAgICAgICAgdGhpc1ttZXRob2RdKGFyZzEsIGFyZzIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N5bmNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IG51bU1ldGEgPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IG51bURhdGEgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgY29uc3QgY291bnQgPSBNYXRoLm1pbihudW1EYXRhLCBudW1NZXRhKTtcbiAgICAgICAgaWYgKGNvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKDAsIGNvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVtRGF0YSA+IG51bU1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2luc2VydEVsZW1lbnRzKG51bU1ldGEsIG51bURhdGEgLSBudW1NZXRhLCByZXNldE5ld0VsZW1lbnRzKTtcbiAgICAgICAgfSBlbHNlIGlmIChudW1EYXRhIDwgbnVtTWV0YSkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlRWxlbWVudHMobnVtRGF0YSwgbnVtTWV0YSAtIG51bURhdGEpO1xuICAgICAgICB9XG4gICAgfVxuIF9pbnNlcnRFbGVtZW50cyhzdGFydCwgY291bnQsIHJlc2V0TmV3RWxlbWVudHMgPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhO1xuICAgICAgICBjb25zdCBlbmQgPSBzdGFydCArIGNvdW50O1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgY29uc3QgbW92ZSA9IChhcnIpPT57XG4gICAgICAgICAgICBhcnIubGVuZ3RoICs9IGNvdW50O1xuICAgICAgICAgICAgZm9yKGkgPSBhcnIubGVuZ3RoIC0gMTsgaSA+PSBlbmQ7IGktLSl7XG4gICAgICAgICAgICAgICAgYXJyW2ldID0gYXJyW2kgLSBjb3VudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG1vdmUoZGF0YSk7XG4gICAgICAgIGZvcihpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSl7XG4gICAgICAgICAgICBkYXRhW2ldID0gbmV3IHRoaXMuZGF0YUVsZW1lbnRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgICAgICAgIG1vdmUobWV0YS5fcGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcnNlKHN0YXJ0LCBjb3VudCk7XG4gICAgICAgIGlmIChyZXNldE5ld0VsZW1lbnRzKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGRhdGEsIHN0YXJ0LCBjb3VudCwgJ3Jlc2V0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudHMoZWxlbWVudCwgc3RhcnQsIGNvdW50LCBtb2RlKSB7fVxuIF9yZW1vdmVFbGVtZW50cyhzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGlmICh0aGlzLl9wYXJzaW5nKSB7XG4gICAgICAgICAgICBjb25zdCByZW1vdmVkID0gbWV0YS5fcGFyc2VkLnNwbGljZShzdGFydCwgY291bnQpO1xuICAgICAgICAgICAgaWYgKG1ldGEuX3N0YWNrZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclN0YWNrcyhtZXRhLCByZW1vdmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtZXRhLmRhdGEuc3BsaWNlKHN0YXJ0LCBjb3VudCk7XG4gICAgfVxuIF9zeW5jKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3BhcnNpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX3N5bmNMaXN0LnB1c2goYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBbbWV0aG9kLCBhcmcxLCBhcmcyXSA9IGFyZ3M7XG4gICAgICAgICAgICB0aGlzW21ldGhvZF0oYXJnMSwgYXJnMik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGFydC5fZGF0YUNoYW5nZXMucHVzaChbXG4gICAgICAgICAgICB0aGlzLmluZGV4LFxuICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgX29uRGF0YVB1c2goKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fc3luYyhbXG4gICAgICAgICAgICAnX2luc2VydEVsZW1lbnRzJyxcbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0YXNldCgpLmRhdGEubGVuZ3RoIC0gY291bnQsXG4gICAgICAgICAgICBjb3VudFxuICAgICAgICBdKTtcbiAgICB9XG4gICAgX29uRGF0YVBvcCgpIHtcbiAgICAgICAgdGhpcy5fc3luYyhbXG4gICAgICAgICAgICAnX3JlbW92ZUVsZW1lbnRzJyxcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZE1ldGEuZGF0YS5sZW5ndGggLSAxLFxuICAgICAgICAgICAgMVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgX29uRGF0YVNoaWZ0KCkge1xuICAgICAgICB0aGlzLl9zeW5jKFtcbiAgICAgICAgICAgICdfcmVtb3ZlRWxlbWVudHMnLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIDFcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIF9vbkRhdGFTcGxpY2Uoc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGlmIChjb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fc3luYyhbXG4gICAgICAgICAgICAgICAgJ19yZW1vdmVFbGVtZW50cycsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgY291bnRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gICAgICAgIGlmIChuZXdDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5fc3luYyhbXG4gICAgICAgICAgICAgICAgJ19pbnNlcnRFbGVtZW50cycsXG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgbmV3Q291bnRcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9vbkRhdGFVbnNoaWZ0KCkge1xuICAgICAgICB0aGlzLl9zeW5jKFtcbiAgICAgICAgICAgICdfaW5zZXJ0RWxlbWVudHMnLFxuICAgICAgICAgICAgMCxcbiAgICAgICAgICAgIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgICAgXSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgdHlwZSkge1xuICAgIGlmICghc2NhbGUuX2NhY2hlLiRiYXIpIHtcbiAgICAgICAgY29uc3QgdmlzaWJsZU1ldGFzID0gc2NhbGUuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSk7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgZm9yKGxldCBpID0gMCwgaWxlbiA9IHZpc2libGVNZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICAgICAgdmFsdWVzID0gdmFsdWVzLmNvbmNhdCh2aXNpYmxlTWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXMoc2NhbGUpKTtcbiAgICAgICAgfVxuICAgICAgICBzY2FsZS5fY2FjaGUuJGJhciA9IF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydCgoYSwgYik9PmEgLSBiKSk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZS5fY2FjaGUuJGJhcjtcbn1cbiBmdW5jdGlvbiBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKSB7XG4gICAgY29uc3Qgc2NhbGUgPSBtZXRhLmlTY2FsZTtcbiAgICBjb25zdCB2YWx1ZXMgPSBnZXRBbGxTY2FsZVZhbHVlcyhzY2FsZSwgbWV0YS50eXBlKTtcbiAgICBsZXQgbWluID0gc2NhbGUuX2xlbmd0aDtcbiAgICBsZXQgaSwgaWxlbiwgY3VyciwgcHJldjtcbiAgICBjb25zdCB1cGRhdGVNaW5BbmRQcmV2ID0gKCk9PntcbiAgICAgICAgaWYgKGN1cnIgPT09IDMyNzY3IHx8IGN1cnIgPT09IC0zMjc2OCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWZpbmVkKHByZXYpKSB7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguYWJzKGN1cnIgLSBwcmV2KSB8fCBtaW4pO1xuICAgICAgICB9XG4gICAgICAgIHByZXYgPSBjdXJyO1xuICAgIH07XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGN1cnIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlc1tpXSk7XG4gICAgICAgIHVwZGF0ZU1pbkFuZFByZXYoKTtcbiAgICB9XG4gICAgcHJldiA9IHVuZGVmaW5lZDtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBzY2FsZS50aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBjdXJyID0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKGkpO1xuICAgICAgICB1cGRhdGVNaW5BbmRQcmV2KCk7XG4gICAgfVxuICAgIHJldHVybiBtaW47XG59XG4gZnVuY3Rpb24gY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCkge1xuICAgIGNvbnN0IHRoaWNrbmVzcyA9IG9wdGlvbnMuYmFyVGhpY2tuZXNzO1xuICAgIGxldCBzaXplLCByYXRpbztcbiAgICBpZiAoaXNOdWxsT3JVbmRlZih0aGlja25lc3MpKSB7XG4gICAgICAgIHNpemUgPSBydWxlci5taW4gKiBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICAgICAgcmF0aW8gPSBvcHRpb25zLmJhclBlcmNlbnRhZ2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc2l6ZSA9IHRoaWNrbmVzcyAqIHN0YWNrQ291bnQ7XG4gICAgICAgIHJhdGlvID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2h1bms6IHNpemUgLyBzdGFja0NvdW50LFxuICAgICAgICByYXRpbyxcbiAgICAgICAgc3RhcnQ6IHJ1bGVyLnBpeGVsc1tpbmRleF0gLSBzaXplIC8gMlxuICAgIH07XG59XG4gZnVuY3Rpb24gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIHtcbiAgICBjb25zdCBwaXhlbHMgPSBydWxlci5waXhlbHM7XG4gICAgY29uc3QgY3VyciA9IHBpeGVsc1tpbmRleF07XG4gICAgbGV0IHByZXYgPSBpbmRleCA+IDAgPyBwaXhlbHNbaW5kZXggLSAxXSA6IG51bGw7XG4gICAgbGV0IG5leHQgPSBpbmRleCA8IHBpeGVscy5sZW5ndGggLSAxID8gcGl4ZWxzW2luZGV4ICsgMV0gOiBudWxsO1xuICAgIGNvbnN0IHBlcmNlbnQgPSBvcHRpb25zLmNhdGVnb3J5UGVyY2VudGFnZTtcbiAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICBwcmV2ID0gY3VyciAtIChuZXh0ID09PSBudWxsID8gcnVsZXIuZW5kIC0gcnVsZXIuc3RhcnQgOiBuZXh0IC0gY3Vycik7XG4gICAgfVxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgIG5leHQgPSBjdXJyICsgY3VyciAtIHByZXY7XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0ID0gY3VyciAtIChjdXJyIC0gTWF0aC5taW4ocHJldiwgbmV4dCkpIC8gMiAqIHBlcmNlbnQ7XG4gICAgY29uc3Qgc2l6ZSA9IE1hdGguYWJzKG5leHQgLSBwcmV2KSAvIDIgKiBwZXJjZW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIGNodW5rOiBzaXplIC8gc3RhY2tDb3VudCxcbiAgICAgICAgcmF0aW86IG9wdGlvbnMuYmFyUGVyY2VudGFnZSxcbiAgICAgICAgc3RhcnRcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VGbG9hdEJhcihlbnRyeSwgaXRlbSwgdlNjYWxlLCBpKSB7XG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHZTY2FsZS5wYXJzZShlbnRyeVswXSwgaSk7XG4gICAgY29uc3QgZW5kVmFsdWUgPSB2U2NhbGUucGFyc2UoZW50cnlbMV0sIGkpO1xuICAgIGNvbnN0IG1pbiA9IE1hdGgubWluKHN0YXJ0VmFsdWUsIGVuZFZhbHVlKTtcbiAgICBjb25zdCBtYXggPSBNYXRoLm1heChzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgbGV0IGJhclN0YXJ0ID0gbWluO1xuICAgIGxldCBiYXJFbmQgPSBtYXg7XG4gICAgaWYgKE1hdGguYWJzKG1pbikgPiBNYXRoLmFicyhtYXgpKSB7XG4gICAgICAgIGJhclN0YXJ0ID0gbWF4O1xuICAgICAgICBiYXJFbmQgPSBtaW47XG4gICAgfVxuICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gYmFyRW5kO1xuICAgIGl0ZW0uX2N1c3RvbSA9IHtcbiAgICAgICAgYmFyU3RhcnQsXG4gICAgICAgIGJhckVuZCxcbiAgICAgICAgc3RhcnQ6IHN0YXJ0VmFsdWUsXG4gICAgICAgIGVuZDogZW5kVmFsdWUsXG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkge1xuICAgIGlmIChpc0FycmF5KGVudHJ5KSkge1xuICAgICAgICBwYXJzZUZsb2F0QmFyKGVudHJ5LCBpdGVtLCB2U2NhbGUsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1bdlNjYWxlLmF4aXNdID0gdlNjYWxlLnBhcnNlKGVudHJ5LCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBwYXJzZUFycmF5T3JQcmltaXRpdmUobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgY29uc3QgaVNjYWxlID0gbWV0YS5pU2NhbGU7XG4gICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgY29uc3QgbGFiZWxzID0gaVNjYWxlLmdldExhYmVscygpO1xuICAgIGNvbnN0IHNpbmdsZVNjYWxlID0gaVNjYWxlID09PSB2U2NhbGU7XG4gICAgY29uc3QgcGFyc2VkID0gW107XG4gICAgbGV0IGksIGlsZW4sIGl0ZW0sIGVudHJ5O1xuICAgIGZvcihpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgZW50cnkgPSBkYXRhW2ldO1xuICAgICAgICBpdGVtID0ge307XG4gICAgICAgIGl0ZW1baVNjYWxlLmF4aXNdID0gc2luZ2xlU2NhbGUgfHwgaVNjYWxlLnBhcnNlKGxhYmVsc1tpXSwgaSk7XG4gICAgICAgIHBhcnNlZC5wdXNoKHBhcnNlVmFsdWUoZW50cnksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkO1xufVxuZnVuY3Rpb24gaXNGbG9hdEJhcihjdXN0b20pIHtcbiAgICByZXR1cm4gY3VzdG9tICYmIGN1c3RvbS5iYXJTdGFydCAhPT0gdW5kZWZpbmVkICYmIGN1c3RvbS5iYXJFbmQgIT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJhclNpZ24oc2l6ZSwgdlNjYWxlLCBhY3R1YWxCYXNlKSB7XG4gICAgaWYgKHNpemUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ24oc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiAodlNjYWxlLmlzSG9yaXpvbnRhbCgpID8gMSA6IC0xKSAqICh2U2NhbGUubWluID49IGFjdHVhbEJhc2UgPyAxIDogLTEpO1xufVxuZnVuY3Rpb24gYm9yZGVyUHJvcHMocHJvcGVydGllcykge1xuICAgIGxldCByZXZlcnNlLCBzdGFydCwgZW5kLCB0b3AsIGJvdHRvbTtcbiAgICBpZiAocHJvcGVydGllcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPiBwcm9wZXJ0aWVzLng7XG4gICAgICAgIHN0YXJ0ID0gJ2xlZnQnO1xuICAgICAgICBlbmQgPSAncmlnaHQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldmVyc2UgPSBwcm9wZXJ0aWVzLmJhc2UgPCBwcm9wZXJ0aWVzLnk7XG4gICAgICAgIHN0YXJ0ID0gJ2JvdHRvbSc7XG4gICAgICAgIGVuZCA9ICd0b3AnO1xuICAgIH1cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICB0b3AgPSAnZW5kJztcbiAgICAgICAgYm90dG9tID0gJ3N0YXJ0JztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSAnc3RhcnQnO1xuICAgICAgICBib3R0b20gPSAnZW5kJztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgcmV2ZXJzZSxcbiAgICAgICAgdG9wLFxuICAgICAgICBib3R0b21cbiAgICB9O1xufVxuZnVuY3Rpb24gc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpIHtcbiAgICBsZXQgZWRnZSA9IG9wdGlvbnMuYm9yZGVyU2tpcHBlZDtcbiAgICBjb25zdCByZXMgPSB7fTtcbiAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgcHJvcGVydGllcy5ib3JkZXJTa2lwcGVkID0gcmVzO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChlZGdlID09PSB0cnVlKSB7XG4gICAgICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHtcbiAgICAgICAgICAgIHRvcDogdHJ1ZSxcbiAgICAgICAgICAgIHJpZ2h0OiB0cnVlLFxuICAgICAgICAgICAgYm90dG9tOiB0cnVlLFxuICAgICAgICAgICAgbGVmdDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHsgc3RhcnQgLCBlbmQgLCByZXZlcnNlICwgdG9wICwgYm90dG9tICB9ID0gYm9yZGVyUHJvcHMocHJvcGVydGllcyk7XG4gICAgaWYgKGVkZ2UgPT09ICdtaWRkbGUnICYmIHN0YWNrKSB7XG4gICAgICAgIHByb3BlcnRpZXMuZW5hYmxlQm9yZGVyUmFkaXVzID0gdHJ1ZTtcbiAgICAgICAgaWYgKChzdGFjay5fdG9wIHx8IDApID09PSBpbmRleCkge1xuICAgICAgICAgICAgZWRnZSA9IHRvcDtcbiAgICAgICAgfSBlbHNlIGlmICgoc3RhY2suX2JvdHRvbSB8fCAwKSA9PT0gaW5kZXgpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBib3R0b207XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNbcGFyc2VFZGdlKGJvdHRvbSwgc3RhcnQsIGVuZCwgcmV2ZXJzZSldID0gdHJ1ZTtcbiAgICAgICAgICAgIGVkZ2UgPSB0b3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzW3BhcnNlRWRnZShlZGdlLCBzdGFydCwgZW5kLCByZXZlcnNlKV0gPSB0cnVlO1xuICAgIHByb3BlcnRpZXMuYm9yZGVyU2tpcHBlZCA9IHJlcztcbn1cbmZ1bmN0aW9uIHBhcnNlRWRnZShlZGdlLCBhLCBiLCByZXZlcnNlKSB7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgZWRnZSA9IHN3YXAoZWRnZSwgYSwgYik7XG4gICAgICAgIGVkZ2UgPSBzdGFydEVuZChlZGdlLCBiLCBhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlZGdlID0gc3RhcnRFbmQoZWRnZSwgYSwgYik7XG4gICAgfVxuICAgIHJldHVybiBlZGdlO1xufVxuZnVuY3Rpb24gc3dhcChvcmlnLCB2MSwgdjIpIHtcbiAgICByZXR1cm4gb3JpZyA9PT0gdjEgPyB2MiA6IG9yaWcgPT09IHYyID8gdjEgOiBvcmlnO1xufVxuZnVuY3Rpb24gc3RhcnRFbmQodiwgc3RhcnQsIGVuZCkge1xuICAgIHJldHVybiB2ID09PSAnc3RhcnQnID8gc3RhcnQgOiB2ID09PSAnZW5kJyA/IGVuZCA6IHY7XG59XG5mdW5jdGlvbiBzZXRJbmZsYXRlQW1vdW50KHByb3BlcnRpZXMsIHsgaW5mbGF0ZUFtb3VudCAgfSwgcmF0aW8pIHtcbiAgICBwcm9wZXJ0aWVzLmluZmxhdGVBbW91bnQgPSBpbmZsYXRlQW1vdW50ID09PSAnYXV0bycgPyByYXRpbyA9PT0gMSA/IDAuMzMgOiAwIDogaW5mbGF0ZUFtb3VudDtcbn1cbmNsYXNzIEJhckNvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGlkID0gJ2Jhcic7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgICAgICBkYXRhRWxlbWVudFR5cGU6ICdiYXInLFxuICAgICAgICBjYXRlZ29yeVBlcmNlbnRhZ2U6IDAuOCxcbiAgICAgICAgYmFyUGVyY2VudGFnZTogMC45LFxuICAgICAgICBncm91cGVkOiB0cnVlLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBudW1iZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnLFxuICAgICAgICAgICAgICAgICAgICAnd2lkdGgnLFxuICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0J1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICAgICAgc2NhbGVzOiB7XG4gICAgICAgICAgICBfaW5kZXhfOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2NhdGVnb3J5JyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZhbHVlXzoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInLFxuICAgICAgICAgICAgICAgIGJlZ2luQXRaZXJvOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuIHBhcnNlUHJpbWl0aXZlRGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlQXJyYXlPclByaW1pdGl2ZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgeyB4QXhpc0tleSA9J3gnICwgeUF4aXNLZXkgPSd5JyAgfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgICAgIGNvbnN0IGlBeGlzS2V5ID0gaVNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgICAgIGNvbnN0IHZBeGlzS2V5ID0gdlNjYWxlLmF4aXMgPT09ICd4JyA/IHhBeGlzS2V5IDogeUF4aXNLZXk7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IFtdO1xuICAgICAgICBsZXQgaSwgaWxlbiwgaXRlbSwgb2JqO1xuICAgICAgICBmb3IoaSA9IHN0YXJ0LCBpbGVuID0gc3RhcnQgKyBjb3VudDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBvYmogPSBkYXRhW2ldO1xuICAgICAgICAgICAgaXRlbSA9IHt9O1xuICAgICAgICAgICAgaXRlbVtpU2NhbGUuYXhpc10gPSBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShvYmosIGlBeGlzS2V5KSwgaSk7XG4gICAgICAgICAgICBwYXJzZWQucHVzaChwYXJzZVZhbHVlKHJlc29sdmVPYmplY3RLZXkob2JqLCB2QXhpc0tleSksIGl0ZW0sIHZTY2FsZSwgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuIHVwZGF0ZVJhbmdlRnJvbVBhcnNlZChyYW5nZSwgc2NhbGUsIHBhcnNlZCwgc3RhY2spIHtcbiAgICAgICAgc3VwZXIudXBkYXRlUmFuZ2VGcm9tUGFyc2VkKHJhbmdlLCBzY2FsZSwgcGFyc2VkLCBzdGFjayk7XG4gICAgICAgIGNvbnN0IGN1c3RvbSA9IHBhcnNlZC5fY3VzdG9tO1xuICAgICAgICBpZiAoY3VzdG9tICYmIHNjYWxlID09PSB0aGlzLl9jYWNoZWRNZXRhLnZTY2FsZSkge1xuICAgICAgICAgICAgcmFuZ2UubWluID0gTWF0aC5taW4ocmFuZ2UubWluLCBjdXN0b20ubWluKTtcbiAgICAgICAgICAgIHJhbmdlLm1heCA9IE1hdGgubWF4KHJhbmdlLm1heCwgY3VzdG9tLm1heCk7XG4gICAgICAgIH1cbiAgICB9XG4gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiBnZXRMYWJlbEFuZFZhbHVlKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB7IGlTY2FsZSAsIHZTY2FsZSAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgICAgY29uc3QgY3VzdG9tID0gcGFyc2VkLl9jdXN0b207XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaXNGbG9hdEJhcihjdXN0b20pID8gJ1snICsgY3VzdG9tLnN0YXJ0ICsgJywgJyArIGN1c3RvbS5lbmQgKyAnXScgOiAnJyArIHZTY2FsZS5nZXRMYWJlbEZvclZhbHVlKHBhcnNlZFt2U2NhbGUuYXhpc10pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6ICcnICsgaVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW2lTY2FsZS5heGlzXSksXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLmVuYWJsZU9wdGlvblNoYXJpbmcgPSB0cnVlO1xuICAgICAgICBzdXBlci5pbml0aWFsaXplKCk7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBtZXRhLnN0YWNrID0gdGhpcy5nZXREYXRhc2V0KCkuc3RhY2s7XG4gICAgfVxuICAgIHVwZGF0ZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKG1ldGEuZGF0YSwgMCwgbWV0YS5kYXRhLmxlbmd0aCwgbW9kZSk7XG4gICAgfVxuICAgIHVwZGF0ZUVsZW1lbnRzKGJhcnMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgICAgIGNvbnN0IHsgaW5kZXggLCBfY2FjaGVkTWV0YTogeyB2U2NhbGUgIH0gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBiYXNlID0gdlNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICAgICAgICBjb25zdCBob3Jpem9udGFsID0gdlNjYWxlLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICBjb25zdCBydWxlciA9IHRoaXMuX2dldFJ1bGVyKCk7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVkT3B0aW9ucyAsIGluY2x1ZGVPcHRpb25zICB9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgICAgIGZvcihsZXQgaSA9IHN0YXJ0OyBpIDwgc3RhcnQgKyBjb3VudDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGkpO1xuICAgICAgICAgICAgY29uc3QgdnBpeGVscyA9IHJlc2V0IHx8IGlzTnVsbE9yVW5kZWYocGFyc2VkW3ZTY2FsZS5heGlzXSkgPyB7XG4gICAgICAgICAgICAgICAgYmFzZSxcbiAgICAgICAgICAgICAgICBoZWFkOiBiYXNlXG4gICAgICAgICAgICB9IDogdGhpcy5fY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaSk7XG4gICAgICAgICAgICBjb25zdCBpcGl4ZWxzID0gdGhpcy5fY2FsY3VsYXRlQmFySW5kZXhQaXhlbHMoaSwgcnVsZXIpO1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSAocGFyc2VkLl9zdGFja3MgfHwge30pW3ZTY2FsZS5heGlzXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbCxcbiAgICAgICAgICAgICAgICBiYXNlOiB2cGl4ZWxzLmJhc2UsXG4gICAgICAgICAgICAgICAgZW5hYmxlQm9yZGVyUmFkaXVzOiAhc3RhY2sgfHwgaXNGbG9hdEJhcihwYXJzZWQuX2N1c3RvbSkgfHwgaW5kZXggPT09IHN0YWNrLl90b3AgfHwgaW5kZXggPT09IHN0YWNrLl9ib3R0b20sXG4gICAgICAgICAgICAgICAgeDogaG9yaXpvbnRhbCA/IHZwaXhlbHMuaGVhZCA6IGlwaXhlbHMuY2VudGVyLFxuICAgICAgICAgICAgICAgIHk6IGhvcml6b250YWwgPyBpcGl4ZWxzLmNlbnRlciA6IHZwaXhlbHMuaGVhZCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGhvcml6b250YWwgPyBpcGl4ZWxzLnNpemUgOiBNYXRoLmFicyh2cGl4ZWxzLnNpemUpLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBob3Jpem9udGFsID8gTWF0aC5hYnModnBpeGVscy5zaXplKSA6IGlwaXhlbHMuc2l6ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGJhcnNbaV0uYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBwcm9wZXJ0aWVzLm9wdGlvbnMgfHwgYmFyc1tpXS5vcHRpb25zO1xuICAgICAgICAgICAgc2V0Qm9yZGVyU2tpcHBlZChwcm9wZXJ0aWVzLCBvcHRpb25zLCBzdGFjaywgaW5kZXgpO1xuICAgICAgICAgICAgc2V0SW5mbGF0ZUFtb3VudChwcm9wZXJ0aWVzLCBvcHRpb25zLCBydWxlci5yYXRpbyk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQoYmFyc1tpXSwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gX2dldFN0YWNrcyhsYXN0LCBkYXRhSW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBpU2NhbGUgIH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBtZXRhc2V0cyA9IGlTY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcyh0aGlzLl90eXBlKS5maWx0ZXIoKG1ldGEpPT5tZXRhLmNvbnRyb2xsZXIub3B0aW9ucy5ncm91cGVkKTtcbiAgICAgICAgY29uc3Qgc3RhY2tlZCA9IGlTY2FsZS5vcHRpb25zLnN0YWNrZWQ7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IFtdO1xuICAgICAgICBjb25zdCBjdXJyZW50UGFyc2VkID0gdGhpcy5fY2FjaGVkTWV0YS5jb250cm9sbGVyLmdldFBhcnNlZChkYXRhSW5kZXgpO1xuICAgICAgICBjb25zdCBpU2NhbGVWYWx1ZSA9IGN1cnJlbnRQYXJzZWQgJiYgY3VycmVudFBhcnNlZFtpU2NhbGUuYXhpc107XG4gICAgICAgIGNvbnN0IHNraXBOdWxsID0gKG1ldGEpPT57XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBtZXRhLl9wYXJzZWQuZmluZCgoaXRlbSk9Pml0ZW1baVNjYWxlLmF4aXNdID09PSBpU2NhbGVWYWx1ZSk7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSBwYXJzZWQgJiYgcGFyc2VkW21ldGEudlNjYWxlLmF4aXNdO1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodmFsKSB8fCBpc05hTih2YWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBtZXRhc2V0cyl7XG4gICAgICAgICAgICBpZiAoZGF0YUluZGV4ICE9PSB1bmRlZmluZWQgJiYgc2tpcE51bGwobWV0YSkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja2VkID09PSBmYWxzZSB8fCBzdGFja3MuaW5kZXhPZihtZXRhLnN0YWNrKSA9PT0gLTEgfHwgc3RhY2tlZCA9PT0gdW5kZWZpbmVkICYmIG1ldGEuc3RhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YWNrcy5wdXNoKG1ldGEuc3RhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGxhc3QpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0YWNrcy5wdXNoKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YWNrcztcbiAgICB9XG4gX2dldFN0YWNrQ291bnQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFN0YWNrcyh1bmRlZmluZWQsIGluZGV4KS5sZW5ndGg7XG4gICAgfVxuIF9nZXRTdGFja0luZGV4KGRhdGFzZXRJbmRleCwgbmFtZSwgZGF0YUluZGV4KSB7XG4gICAgICAgIGNvbnN0IHN0YWNrcyA9IHRoaXMuX2dldFN0YWNrcyhkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCk7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZSAhPT0gdW5kZWZpbmVkID8gc3RhY2tzLmluZGV4T2YobmFtZSkgOiAtMTtcbiAgICAgICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IHN0YWNrcy5sZW5ndGggLSAxIDogaW5kZXg7XG4gICAgfVxuIF9nZXRSdWxlcigpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGlTY2FsZSA9IG1ldGEuaVNjYWxlO1xuICAgICAgICBjb25zdCBwaXhlbHMgPSBbXTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IG1ldGEuZGF0YS5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgcGl4ZWxzLnB1c2goaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRQYXJzZWQoaSlbaVNjYWxlLmF4aXNdLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFyVGhpY2tuZXNzID0gb3B0cy5iYXJUaGlja25lc3M7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJhclRoaWNrbmVzcyB8fCBjb21wdXRlTWluU2FtcGxlU2l6ZShtZXRhKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIHBpeGVscyxcbiAgICAgICAgICAgIHN0YXJ0OiBpU2NhbGUuX3N0YXJ0UGl4ZWwsXG4gICAgICAgICAgICBlbmQ6IGlTY2FsZS5fZW5kUGl4ZWwsXG4gICAgICAgICAgICBzdGFja0NvdW50OiB0aGlzLl9nZXRTdGFja0NvdW50KCksXG4gICAgICAgICAgICBzY2FsZTogaVNjYWxlLFxuICAgICAgICAgICAgZ3JvdXBlZDogb3B0cy5ncm91cGVkLFxuICAgICAgICAgICAgcmF0aW86IGJhclRoaWNrbmVzcyA/IDEgOiBvcHRzLmNhdGVnb3J5UGVyY2VudGFnZSAqIG9wdHMuYmFyUGVyY2VudGFnZVxuICAgICAgICB9O1xuICAgIH1cbiBfY2FsY3VsYXRlQmFyVmFsdWVQaXhlbHMoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBfY2FjaGVkTWV0YTogeyB2U2NhbGUgLCBfc3RhY2tlZCAsIGluZGV4OiBkYXRhc2V0SW5kZXggIH0gLCBvcHRpb25zOiB7IGJhc2U6IGJhc2VWYWx1ZSAsIG1pbkJhckxlbmd0aCAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGFjdHVhbEJhc2UgPSBiYXNlVmFsdWUgfHwgMDtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICBjb25zdCBjdXN0b20gPSBwYXJzZWQuX2N1c3RvbTtcbiAgICAgICAgY29uc3QgZmxvYXRpbmcgPSBpc0Zsb2F0QmFyKGN1c3RvbSk7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlZFt2U2NhbGUuYXhpc107XG4gICAgICAgIGxldCBzdGFydCA9IDA7XG4gICAgICAgIGxldCBsZW5ndGggPSBfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogdmFsdWU7XG4gICAgICAgIGxldCBoZWFkLCBzaXplO1xuICAgICAgICBpZiAobGVuZ3RoICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgc3RhcnQgPSBsZW5ndGggLSB2YWx1ZTtcbiAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbG9hdGluZykge1xuICAgICAgICAgICAgdmFsdWUgPSBjdXN0b20uYmFyU3RhcnQ7XG4gICAgICAgICAgICBsZW5ndGggPSBjdXN0b20uYmFyRW5kIC0gY3VzdG9tLmJhclN0YXJ0O1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAwICYmIHNpZ24odmFsdWUpICE9PSBzaWduKGN1c3RvbS5iYXJFbmQpKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQgKz0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRWYWx1ZSA9ICFpc051bGxPclVuZGVmKGJhc2VWYWx1ZSkgJiYgIWZsb2F0aW5nID8gYmFzZVZhbHVlIDogc3RhcnQ7XG4gICAgICAgIGxldCBiYXNlID0gdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoc3RhcnRWYWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICAgICAgaGVhZCA9IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKHN0YXJ0ICsgbGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlYWQgPSBiYXNlO1xuICAgICAgICB9XG4gICAgICAgIHNpemUgPSBoZWFkIC0gYmFzZTtcbiAgICAgICAgaWYgKE1hdGguYWJzKHNpemUpIDwgbWluQmFyTGVuZ3RoKSB7XG4gICAgICAgICAgICBzaXplID0gYmFyU2lnbihzaXplLCB2U2NhbGUsIGFjdHVhbEJhc2UpICogbWluQmFyTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBhY3R1YWxCYXNlKSB7XG4gICAgICAgICAgICAgICAgYmFzZSAtPSBzaXplIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0UGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDApO1xuICAgICAgICAgICAgY29uc3QgZW5kUGl4ZWwgPSB2U2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDEpO1xuICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4oc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgoc3RhcnRQaXhlbCwgZW5kUGl4ZWwpO1xuICAgICAgICAgICAgYmFzZSA9IE1hdGgubWF4KE1hdGgubWluKGJhc2UsIG1heCksIG1pbik7XG4gICAgICAgICAgICBoZWFkID0gYmFzZSArIHNpemU7XG4gICAgICAgICAgICBpZiAoX3N0YWNrZWQgJiYgIWZsb2F0aW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLl9zdGFja3NbdlNjYWxlLmF4aXNdLl92aXN1YWxWYWx1ZXNbZGF0YXNldEluZGV4XSA9IHZTY2FsZS5nZXRWYWx1ZUZvclBpeGVsKGhlYWQpIC0gdlNjYWxlLmdldFZhbHVlRm9yUGl4ZWwoYmFzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2UgPT09IHZTY2FsZS5nZXRQaXhlbEZvclZhbHVlKGFjdHVhbEJhc2UpKSB7XG4gICAgICAgICAgICBjb25zdCBoYWxmR3JpZCA9IHNpZ24oc2l6ZSkgKiB2U2NhbGUuZ2V0TGluZVdpZHRoRm9yVmFsdWUoYWN0dWFsQmFzZSkgLyAyO1xuICAgICAgICAgICAgYmFzZSArPSBoYWxmR3JpZDtcbiAgICAgICAgICAgIHNpemUgLT0gaGFsZkdyaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemUsXG4gICAgICAgICAgICBiYXNlLFxuICAgICAgICAgICAgaGVhZCxcbiAgICAgICAgICAgIGNlbnRlcjogaGVhZCArIHNpemUgLyAyXG4gICAgICAgIH07XG4gICAgfVxuIF9jYWxjdWxhdGVCYXJJbmRleFBpeGVscyhpbmRleCwgcnVsZXIpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSBydWxlci5zY2FsZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3Qgc2tpcE51bGwgPSBvcHRpb25zLnNraXBOdWxsO1xuICAgICAgICBjb25zdCBtYXhCYXJUaGlja25lc3MgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLm1heEJhclRoaWNrbmVzcywgSW5maW5pdHkpO1xuICAgICAgICBsZXQgY2VudGVyLCBzaXplO1xuICAgICAgICBpZiAocnVsZXIuZ3JvdXBlZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2tDb3VudCA9IHNraXBOdWxsID8gdGhpcy5fZ2V0U3RhY2tDb3VudChpbmRleCkgOiBydWxlci5zdGFja0NvdW50O1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zLmJhclRoaWNrbmVzcyA9PT0gJ2ZsZXgnID8gY29tcHV0ZUZsZXhDYXRlZ29yeVRyYWl0cyhpbmRleCwgcnVsZXIsIG9wdGlvbnMsIHN0YWNrQ291bnQpIDogY29tcHV0ZUZpdENhdGVnb3J5VHJhaXRzKGluZGV4LCBydWxlciwgb3B0aW9ucywgc3RhY2tDb3VudCk7XG4gICAgICAgICAgICBjb25zdCBzdGFja0luZGV4ID0gdGhpcy5fZ2V0U3RhY2tJbmRleCh0aGlzLmluZGV4LCB0aGlzLl9jYWNoZWRNZXRhLnN0YWNrLCBza2lwTnVsbCA/IGluZGV4IDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNlbnRlciA9IHJhbmdlLnN0YXJ0ICsgcmFuZ2UuY2h1bmsgKiBzdGFja0luZGV4ICsgcmFuZ2UuY2h1bmsgLyAyO1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcmFuZ2UuY2h1bmsgKiByYW5nZS5yYXRpbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZW50ZXIgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGluZGV4KVtzY2FsZS5heGlzXSwgaW5kZXgpO1xuICAgICAgICAgICAgc2l6ZSA9IE1hdGgubWluKG1heEJhclRoaWNrbmVzcywgcnVsZXIubWluICogcnVsZXIucmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYXNlOiBjZW50ZXIgLSBzaXplIC8gMixcbiAgICAgICAgICAgIGhlYWQ6IGNlbnRlciArIHNpemUgLyAyLFxuICAgICAgICAgICAgY2VudGVyLFxuICAgICAgICAgICAgc2l6ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgdlNjYWxlID0gbWV0YS52U2NhbGU7XG4gICAgICAgIGNvbnN0IHJlY3RzID0gbWV0YS5kYXRhO1xuICAgICAgICBjb25zdCBpbGVuID0gcmVjdHMubGVuZ3RoO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvcig7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0UGFyc2VkKGkpW3ZTY2FsZS5heGlzXSAhPT0gbnVsbCAmJiAhcmVjdHNbaV0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmVjdHNbaV0uZHJhdyh0aGlzLl9jdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBCdWJibGVDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBpZCA9ICdidWJibGUnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiBmYWxzZSxcbiAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBudW1iZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAgICAgJ2JvcmRlcldpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgJ3JhZGl1cydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICB9XG4gcGFyc2VQcmltaXRpdmVEYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSBzdXBlci5wYXJzZVByaW1pdGl2ZURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBwYXJzZWRbaV0uX2N1c3RvbSA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpICsgc3RhcnQpLnJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiBwYXJzZUFycmF5RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VBcnJheURhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHBhcnNlZC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtzdGFydCArIGldO1xuICAgICAgICAgICAgcGFyc2VkW2ldLl9jdXN0b20gPSB2YWx1ZU9yRGVmYXVsdChpdGVtWzJdLCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSArIHN0YXJ0KS5yYWRpdXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuIHBhcnNlT2JqZWN0RGF0YShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gc3VwZXIucGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJzZWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGFbc3RhcnQgKyBpXTtcbiAgICAgICAgICAgIHBhcnNlZFtpXS5fY3VzdG9tID0gdmFsdWVPckRlZmF1bHQoaXRlbSAmJiBpdGVtLnIgJiYgK2l0ZW0uciwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkgKyBzdGFydCkucmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkO1xuICAgIH1cbiBnZXRNYXhPdmVyZmxvdygpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuX2NhY2hlZE1ldGEuZGF0YTtcbiAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgIGZvcihsZXQgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBkYXRhW2ldLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpKSAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXggPiAwICYmIG1heDtcbiAgICB9XG4gZ2V0TGFiZWxBbmRWYWx1ZShpbmRleCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5jaGFydC5kYXRhLmxhYmVscyB8fCBbXTtcbiAgICAgICAgY29uc3QgeyB4U2NhbGUgLCB5U2NhbGUgIH0gPSBtZXRhO1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICAgIGNvbnN0IHggPSB4U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueCk7XG4gICAgICAgIGNvbnN0IHkgPSB5U2NhbGUuZ2V0TGFiZWxGb3JWYWx1ZShwYXJzZWQueSk7XG4gICAgICAgIGNvbnN0IHIgPSBwYXJzZWQuX2N1c3RvbTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgICAgICAgdmFsdWU6ICcoJyArIHggKyAnLCAnICsgeSArIChyID8gJywgJyArIHIgOiAnJykgKyAnKSdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKHBvaW50cywgMCwgcG9pbnRzLmxlbmd0aCwgbW9kZSk7XG4gICAgfVxuICAgIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICAgICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgIH0gPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB7IHNoYXJlZE9wdGlvbnMgLCBpbmNsdWRlT3B0aW9ucyAgfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgICAgICBjb25zdCBpQXhpcyA9IGlTY2FsZS5heGlzO1xuICAgICAgICBjb25zdCB2QXhpcyA9IHZTY2FsZS5heGlzO1xuICAgICAgICBmb3IobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9ICFyZXNldCAmJiB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gcmVzZXQgPyBpU2NhbGUuZ2V0UGl4ZWxGb3JEZWNpbWFsKDAuNSkgOiBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdKTtcbiAgICAgICAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbdkF4aXNdKTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IGlzTmFOKGlQaXhlbCkgfHwgaXNOYU4odlBpeGVsKTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIHBvaW50LmFjdGl2ZSA/ICdhY3RpdmUnIDogbW9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucy5yYWRpdXMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChwb2ludCwgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gcmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpbmRleCwgbW9kZSkge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCk7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBzdXBlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKTtcbiAgICAgICAgaWYgKHZhbHVlcy4kc2hhcmVkKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZXMsIHtcbiAgICAgICAgICAgICAgICAkc2hhcmVkOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFkaXVzID0gdmFsdWVzLnJhZGl1cztcbiAgICAgICAgaWYgKG1vZGUgIT09ICdhY3RpdmUnKSB7XG4gICAgICAgICAgICB2YWx1ZXMucmFkaXVzID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZXMucmFkaXVzICs9IHZhbHVlT3JEZWZhdWx0KHBhcnNlZCAmJiBwYXJzZWQuX2N1c3RvbSwgcmFkaXVzKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFJhdGlvQW5kT2Zmc2V0KHJvdGF0aW9uLCBjaXJjdW1mZXJlbmNlLCBjdXRvdXQpIHtcbiAgICBsZXQgcmF0aW9YID0gMTtcbiAgICBsZXQgcmF0aW9ZID0gMTtcbiAgICBsZXQgb2Zmc2V0WCA9IDA7XG4gICAgbGV0IG9mZnNldFkgPSAwO1xuICAgIGlmIChjaXJjdW1mZXJlbmNlIDwgVEFVKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSByb3RhdGlvbjtcbiAgICAgICAgY29uc3QgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgY2lyY3VtZmVyZW5jZTtcbiAgICAgICAgY29uc3Qgc3RhcnRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgICAgIGNvbnN0IHN0YXJ0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgICAgICBjb25zdCBlbmRYID0gTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgICAgICBjb25zdCBlbmRZID0gTWF0aC5zaW4oZW5kQW5nbGUpO1xuICAgICAgICBjb25zdCBjYWxjTWF4ID0gKGFuZ2xlLCBhLCBiKT0+X2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gMSA6IE1hdGgubWF4KGEsIGEgKiBjdXRvdXQsIGIsIGIgKiBjdXRvdXQpO1xuICAgICAgICBjb25zdCBjYWxjTWluID0gKGFuZ2xlLCBhLCBiKT0+X2FuZ2xlQmV0d2VlbihhbmdsZSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIHRydWUpID8gLTEgOiBNYXRoLm1pbihhLCBhICogY3V0b3V0LCBiLCBiICogY3V0b3V0KTtcbiAgICAgICAgY29uc3QgbWF4WCA9IGNhbGNNYXgoMCwgc3RhcnRYLCBlbmRYKTtcbiAgICAgICAgY29uc3QgbWF4WSA9IGNhbGNNYXgoSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICAgICAgY29uc3QgbWluWCA9IGNhbGNNaW4oUEksIHN0YXJ0WCwgZW5kWCk7XG4gICAgICAgIGNvbnN0IG1pblkgPSBjYWxjTWluKFBJICsgSEFMRl9QSSwgc3RhcnRZLCBlbmRZKTtcbiAgICAgICAgcmF0aW9YID0gKG1heFggLSBtaW5YKSAvIDI7XG4gICAgICAgIHJhdGlvWSA9IChtYXhZIC0gbWluWSkgLyAyO1xuICAgICAgICBvZmZzZXRYID0gLShtYXhYICsgbWluWCkgLyAyO1xuICAgICAgICBvZmZzZXRZID0gLShtYXhZICsgbWluWSkgLyAyO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByYXRpb1gsXG4gICAgICAgIHJhdGlvWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WVxuICAgIH07XG59XG5jbGFzcyBEb3VnaG51dENvbnRyb2xsZXIgZXh0ZW5kcyBEYXRhc2V0Q29udHJvbGxlciB7XG4gICAgc3RhdGljIGlkID0gJ2RvdWdobnV0JztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZmFsc2UsXG4gICAgICAgIGRhdGFFbGVtZW50VHlwZTogJ2FyYycsXG4gICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgYW5pbWF0ZVJvdGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFuaW1hdGVTY2FsZTogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0aW9uczoge1xuICAgICAgICAgICAgbnVtYmVyczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmN1bWZlcmVuY2UnLFxuICAgICAgICAgICAgICAgICAgICAnZW5kQW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgICAgICAgICAgICAgICAnb3V0ZXJSYWRpdXMnLFxuICAgICAgICAgICAgICAgICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICAgICAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgJ2JvcmRlcldpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgJ3NwYWNpbmcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjdXRvdXQ6ICc1MCUnLFxuICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICAgICAgICByYWRpdXM6ICcxMDAlJyxcbiAgICAgICAgc3BhY2luZzogMCxcbiAgICAgICAgaW5kZXhBeGlzOiAncidcbiAgICB9O1xuICAgIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICAgICAgX3NjcmlwdGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ3NwYWNpbmcnLFxuICAgICAgICBfaW5kZXhhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdzcGFjaW5nJyAmJiAhbmFtZS5zdGFydHNXaXRoKCdib3JkZXJEYXNoJykgJiYgIW5hbWUuc3RhcnRzV2l0aCgnaG92ZXJCb3JkZXJEYXNoJylcbiAgICB9O1xuIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgICAgIGFzcGVjdFJhdGlvOiAxLFxuICAgICAgICBwbHVnaW5zOiB7XG4gICAgICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZ2VuZXJhdGVMYWJlbHMgKGNoYXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gY2hhcnQuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmxhYmVscy5sZW5ndGggJiYgZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhYmVsczogeyBwb2ludFN0eWxlICwgY29sb3IgIH0gIH0gPSBjaGFydC5sZWdlbmQub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YS5sYWJlbHMubWFwKChsYWJlbCwgaSk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IG1ldGEuY29udHJvbGxlci5nZXRTdHlsZShpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGxhYmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJva2VTdHlsZTogc3R5bGUuYm9yZGVyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250Q29sb3I6IGNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiBzdHlsZS5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW46ICFjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xpY2sgKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQuY2hhcnQudG9nZ2xlRGF0YVZpc2liaWxpdHkobGVnZW5kSXRlbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGxlZ2VuZC5jaGFydC51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKGNoYXJ0LCBkYXRhc2V0SW5kZXgpe1xuICAgICAgICBzdXBlcihjaGFydCwgZGF0YXNldEluZGV4KTtcbiAgICAgICAgdGhpcy5lbmFibGVPcHRpb25TaGFyaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGxpbmtTY2FsZXMoKSB7fVxuIHBhcnNlKHN0YXJ0LCBjb3VudCkge1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5nZXREYXRhc2V0KCkuZGF0YTtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGlmICh0aGlzLl9wYXJzaW5nID09PSBmYWxzZSkge1xuICAgICAgICAgICAgbWV0YS5fcGFyc2VkID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBnZXR0ZXIgPSAoaSk9PitkYXRhW2ldO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGRhdGFbc3RhcnRdKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5ID0ndmFsdWUnICB9ID0gdGhpcy5fcGFyc2luZztcbiAgICAgICAgICAgICAgICBnZXR0ZXIgPSAoaSk9PityZXNvbHZlT2JqZWN0S2V5KGRhdGFbaV0sIGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgICAgIGZvcihpID0gc3RhcnQsIGlsZW4gPSBzdGFydCArIGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgICAgICBtZXRhLl9wYXJzZWRbaV0gPSBnZXR0ZXIoaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gX2dldFJvdGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy5yb3RhdGlvbiAtIDkwKTtcbiAgICB9XG4gX2dldENpcmN1bWZlcmVuY2UoKSB7XG4gICAgICAgIHJldHVybiB0b1JhZGlhbnModGhpcy5vcHRpb25zLmNpcmN1bWZlcmVuY2UpO1xuICAgIH1cbiBfZ2V0Um90YXRpb25FeHRlbnRzKCkge1xuICAgICAgICBsZXQgbWluID0gVEFVO1xuICAgICAgICBsZXQgbWF4ID0gLVRBVTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGg7ICsraSl7XG4gICAgICAgICAgICBpZiAodGhpcy5jaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpICYmIHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoaSkudHlwZSA9PT0gdGhpcy5fdHlwZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkpLmNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm90YXRpb24gPSBjb250cm9sbGVyLl9nZXRSb3RhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSBjb250cm9sbGVyLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCByb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCByb3RhdGlvbiArIGNpcmN1bWZlcmVuY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByb3RhdGlvbjogbWluLFxuICAgICAgICAgICAgY2lyY3VtZmVyZW5jZTogbWF4IC0gbWluXG4gICAgICAgIH07XG4gICAgfVxuIHVwZGF0ZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgeyBjaGFydEFyZWEgIH0gPSBjaGFydDtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGFyY3MgPSBtZXRhLmRhdGE7XG4gICAgICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldE1heEJvcmRlcldpZHRoKCkgKyB0aGlzLmdldE1heE9mZnNldChhcmNzKSArIHRoaXMub3B0aW9ucy5zcGFjaW5nO1xuICAgICAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoKE1hdGgubWluKGNoYXJ0QXJlYS53aWR0aCwgY2hhcnRBcmVhLmhlaWdodCkgLSBzcGFjaW5nKSAvIDIsIDApO1xuICAgICAgICBjb25zdCBjdXRvdXQgPSBNYXRoLm1pbih0b1BlcmNlbnRhZ2UodGhpcy5vcHRpb25zLmN1dG91dCwgbWF4U2l6ZSksIDEpO1xuICAgICAgICBjb25zdCBjaGFydFdlaWdodCA9IHRoaXMuX2dldFJpbmdXZWlnaHQodGhpcy5pbmRleCk7XG4gICAgICAgIGNvbnN0IHsgY2lyY3VtZmVyZW5jZSAsIHJvdGF0aW9uICB9ID0gdGhpcy5fZ2V0Um90YXRpb25FeHRlbnRzKCk7XG4gICAgICAgIGNvbnN0IHsgcmF0aW9YICwgcmF0aW9ZICwgb2Zmc2V0WCAsIG9mZnNldFkgIH0gPSBnZXRSYXRpb0FuZE9mZnNldChyb3RhdGlvbiwgY2lyY3VtZmVyZW5jZSwgY3V0b3V0KTtcbiAgICAgICAgY29uc3QgbWF4V2lkdGggPSAoY2hhcnRBcmVhLndpZHRoIC0gc3BhY2luZykgLyByYXRpb1g7XG4gICAgICAgIGNvbnN0IG1heEhlaWdodCA9IChjaGFydEFyZWEuaGVpZ2h0IC0gc3BhY2luZykgLyByYXRpb1k7XG4gICAgICAgIGNvbnN0IG1heFJhZGl1cyA9IE1hdGgubWF4KE1hdGgubWluKG1heFdpZHRoLCBtYXhIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gdG9EaW1lbnNpb24odGhpcy5vcHRpb25zLnJhZGl1cywgbWF4UmFkaXVzKTtcbiAgICAgICAgY29uc3QgaW5uZXJSYWRpdXMgPSBNYXRoLm1heChvdXRlclJhZGl1cyAqIGN1dG91dCwgMCk7XG4gICAgICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIHRoaXMuX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKTtcbiAgICAgICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WCAqIG91dGVyUmFkaXVzO1xuICAgICAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZICogb3V0ZXJSYWRpdXM7XG4gICAgICAgIG1ldGEudG90YWwgPSB0aGlzLmNhbGN1bGF0ZVRvdGFsKCk7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSBvdXRlclJhZGl1cyAtIHJhZGl1c0xlbmd0aCAqIHRoaXMuX2dldFJpbmdXZWlnaHRPZmZzZXQodGhpcy5pbmRleCk7XG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSBNYXRoLm1heCh0aGlzLm91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogY2hhcnRXZWlnaHQsIDApO1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnRzKGFyY3MsIDAsIGFyY3MubGVuZ3RoLCBtb2RlKTtcbiAgICB9XG4gX2NpcmN1bWZlcmVuY2UoaSwgcmVzZXQpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGNpcmN1bWZlcmVuY2UgPSB0aGlzLl9nZXRDaXJjdW1mZXJlbmNlKCk7XG4gICAgICAgIGlmIChyZXNldCAmJiBvcHRzLmFuaW1hdGlvbi5hbmltYXRlUm90YXRlIHx8ICF0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpIHx8IG1ldGEuX3BhcnNlZFtpXSA9PT0gbnVsbCB8fCBtZXRhLmRhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jYWxjdWxhdGVDaXJjdW1mZXJlbmNlKG1ldGEuX3BhcnNlZFtpXSAqIGNpcmN1bWZlcmVuY2UgLyBUQVUpO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cyhhcmNzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IGNoYXJ0QXJlYSA9IGNoYXJ0LmNoYXJ0QXJlYTtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyO1xuICAgICAgICBjb25zdCBjZW50ZXJZID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDI7XG4gICAgICAgIGNvbnN0IGFuaW1hdGVTY2FsZSA9IHJlc2V0ICYmIGFuaW1hdGlvbk9wdHMuYW5pbWF0ZVNjYWxlO1xuICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLmlubmVyUmFkaXVzO1xuICAgICAgICBjb25zdCBvdXRlclJhZGl1cyA9IGFuaW1hdGVTY2FsZSA/IDAgOiB0aGlzLm91dGVyUmFkaXVzO1xuICAgICAgICBjb25zdCB7IHNoYXJlZE9wdGlvbnMgLCBpbmNsdWRlT3B0aW9ucyAgfSA9IHRoaXMuX2dldFNoYXJlZE9wdGlvbnMoc3RhcnQsIG1vZGUpO1xuICAgICAgICBsZXQgc3RhcnRBbmdsZSA9IHRoaXMuX2dldFJvdGF0aW9uKCk7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBzdGFydDsgKytpKXtcbiAgICAgICAgICAgIHN0YXJ0QW5nbGUgKz0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSl7XG4gICAgICAgICAgICBjb25zdCBjaXJjdW1mZXJlbmNlID0gdGhpcy5fY2lyY3VtZmVyZW5jZShpLCByZXNldCk7XG4gICAgICAgICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICB4OiBjZW50ZXJYICsgdGhpcy5vZmZzZXRYLFxuICAgICAgICAgICAgICAgIHk6IGNlbnRlclkgKyB0aGlzLm9mZnNldFksXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgICBlbmRBbmdsZTogc3RhcnRBbmdsZSArIGNpcmN1bWZlcmVuY2UsXG4gICAgICAgICAgICAgICAgY2lyY3VtZmVyZW5jZSxcbiAgICAgICAgICAgICAgICBvdXRlclJhZGl1cyxcbiAgICAgICAgICAgICAgICBpbm5lclJhZGl1c1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbmNsdWRlT3B0aW9ucykge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMub3B0aW9ucyA9IHNoYXJlZE9wdGlvbnMgfHwgdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnRBbmdsZSArPSBjaXJjdW1mZXJlbmNlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2FsY3VsYXRlVG90YWwoKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBtZXRhRGF0YSA9IG1ldGEuZGF0YTtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IG1ldGFEYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbWV0YS5fcGFyc2VkW2ldO1xuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFpc05hTih2YWx1ZSkgJiYgdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSAmJiAhbWV0YURhdGFbaV0uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgdG90YWwgKz0gTWF0aC5hYnModmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9XG4gICAgY2FsY3VsYXRlQ2lyY3VtZmVyZW5jZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCB0b3RhbCA9IHRoaXMuX2NhY2hlZE1ldGEudG90YWw7XG4gICAgICAgIGlmICh0b3RhbCA+IDAgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIFRBVSAqIChNYXRoLmFicyh2YWx1ZSkgLyB0b3RhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0sIGNoYXJ0Lm9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiBsYWJlbHNbaW5kZXhdIHx8ICcnLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0TWF4Qm9yZGVyV2lkdGgoYXJjcykge1xuICAgICAgICBsZXQgbWF4ID0gMDtcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBsZXQgaSwgaWxlbiwgbWV0YSwgY29udHJvbGxlciwgb3B0aW9ucztcbiAgICAgICAgaWYgKCFhcmNzKSB7XG4gICAgICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBjaGFydC5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgICAgICAgICBhcmNzID0gbWV0YS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyID0gbWV0YS5jb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmNzKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBhcmNzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBvcHRpb25zID0gY29udHJvbGxlci5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGkpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYm9yZGVyQWxpZ24gIT09ICdpbm5lcicpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIG9wdGlvbnMuYm9yZGVyV2lkdGggfHwgMCwgb3B0aW9ucy5ob3ZlckJvcmRlcldpZHRoIHx8IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldE1heE9mZnNldChhcmNzKSB7XG4gICAgICAgIGxldCBtYXggPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwLCBpbGVuID0gYXJjcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpKTtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgb3B0aW9ucy5vZmZzZXQgfHwgMCwgb3B0aW9ucy5ob3Zlck9mZnNldCB8fCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiBfZ2V0UmluZ1dlaWdodE9mZnNldChkYXRhc2V0SW5kZXgpIHtcbiAgICAgICAgbGV0IHJpbmdXZWlnaHRPZmZzZXQgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgZGF0YXNldEluZGV4OyArK2kpe1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShpKSkge1xuICAgICAgICAgICAgICAgIHJpbmdXZWlnaHRPZmZzZXQgKz0gdGhpcy5fZ2V0UmluZ1dlaWdodChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmluZ1dlaWdodE9mZnNldDtcbiAgICB9XG4gX2dldFJpbmdXZWlnaHQoZGF0YXNldEluZGV4KSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1heCh2YWx1ZU9yRGVmYXVsdCh0aGlzLmNoYXJ0LmRhdGEuZGF0YXNldHNbZGF0YXNldEluZGV4XS53ZWlnaHQsIDEpLCAwKTtcbiAgICB9XG4gX2dldFZpc2libGVEYXRhc2V0V2VpZ2h0VG90YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSaW5nV2VpZ2h0T2Zmc2V0KHRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGgpIHx8IDE7XG4gICAgfVxufVxuXG5jbGFzcyBMaW5lQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAnbGluZSc7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6ICdsaW5lJyxcbiAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiAncG9pbnQnLFxuICAgICAgICBzaG93TGluZTogdHJ1ZSxcbiAgICAgICAgc3BhbkdhcHM6IGZhbHNlXG4gICAgfTtcbiBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIF9pbmRleF86IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnY2F0ZWdvcnknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgX3ZhbHVlXzoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlT3B0aW9uU2hhcmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuc3VwcG9ydHNEZWNpbWF0aW9uID0gdHJ1ZTtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgIH1cbiAgICB1cGRhdGUobW9kZSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgeyBkYXRhc2V0OiBsaW5lICwgZGF0YTogcG9pbnRzID0gW10gLCBfZGF0YXNldCAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnNEaXNhYmxlZCA9IHRoaXMuY2hhcnQuX2FuaW1hdGlvbnNEaXNhYmxlZDtcbiAgICAgICAgbGV0IHsgc3RhcnQgLCBjb3VudCAgfSA9IF9nZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzKG1ldGEsIHBvaW50cywgYW5pbWF0aW9uc0Rpc2FibGVkKTtcbiAgICAgICAgdGhpcy5fZHJhd1N0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2RyYXdDb3VudCA9IGNvdW50O1xuICAgICAgICBpZiAoX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSkge1xuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgbGluZS5fZGF0YXNldEluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgICAgbGluZS5fZGVjaW1hdGVkID0gISFfZGF0YXNldC5fZGVjaW1hdGVkO1xuICAgICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMucmVzb2x2ZURhdGFzZXRFbGVtZW50T3B0aW9ucyhtb2RlKTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2hvd0xpbmUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMuc2VnbWVudCA9IHRoaXMub3B0aW9ucy5zZWdtZW50O1xuICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQobGluZSwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgfSwgbW9kZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpO1xuICAgIH1cbiAgICB1cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICwgX3N0YWNrZWQgLCBfZGF0YXNldCAgfSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHsgc2hhcmVkT3B0aW9ucyAsIGluY2x1ZGVPcHRpb25zICB9ID0gdGhpcy5fZ2V0U2hhcmVkT3B0aW9ucyhzdGFydCwgbW9kZSk7XG4gICAgICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgICAgIGNvbnN0IHsgc3BhbkdhcHMgLCBzZWdtZW50ICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICAgICAgY29uc3QgZW5kID0gc3RhcnQgKyBjb3VudDtcbiAgICAgICAgY29uc3QgcG9pbnRzQ291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICBsZXQgcHJldlBhcnNlZCA9IHN0YXJ0ID4gMCAmJiB0aGlzLmdldFBhcnNlZChzdGFydCAtIDEpO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzQ291bnQ7ICsraSl7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgICAgICAgaWYgKGkgPCBzdGFydCB8fCBpID49IGVuZCkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMuc2tpcCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgICAgICAgIGNvbnN0IG51bGxEYXRhID0gaXNOdWxsT3JVbmRlZihwYXJzZWRbdkF4aXNdKTtcbiAgICAgICAgICAgIGNvbnN0IGlQaXhlbCA9IHByb3BlcnRpZXNbaUF4aXNdID0gaVNjYWxlLmdldFBpeGVsRm9yVmFsdWUocGFyc2VkW2lBeGlzXSwgaSk7XG4gICAgICAgICAgICBjb25zdCB2UGl4ZWwgPSBwcm9wZXJ0aWVzW3ZBeGlzXSA9IHJlc2V0IHx8IG51bGxEYXRhID8gdlNjYWxlLmdldEJhc2VQaXhlbCgpIDogdlNjYWxlLmdldFBpeGVsRm9yVmFsdWUoX3N0YWNrZWQgPyB0aGlzLmFwcGx5U3RhY2sodlNjYWxlLCBwYXJzZWQsIF9zdGFja2VkKSA6IHBhcnNlZFt2QXhpc10sIGkpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5za2lwID0gaXNOYU4oaVBpeGVsKSB8fCBpc05hTih2UGl4ZWwpIHx8IG51bGxEYXRhO1xuICAgICAgICAgICAgcHJvcGVydGllcy5zdG9wID0gaSA+IDAgJiYgTWF0aC5hYnMocGFyc2VkW2lBeGlzXSAtIHByZXZQYXJzZWRbaUF4aXNdKSA+IG1heEdhcExlbmd0aDtcbiAgICAgICAgICAgIGlmIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5wYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5yYXcgPSBfZGF0YXNldC5kYXRhW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluY2x1ZGVPcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcHJvcGVydGllcy5vcHRpb25zID0gc2hhcmVkT3B0aW9ucyB8fCB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGlyZWN0VXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KHBvaW50LCBpLCBwcm9wZXJ0aWVzLCBtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZQYXJzZWQgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gbWV0YS5kYXRhc2V0O1xuICAgICAgICBjb25zdCBib3JkZXIgPSBkYXRhc2V0Lm9wdGlvbnMgJiYgZGF0YXNldC5vcHRpb25zLmJvcmRlcldpZHRoIHx8IDA7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBtZXRhLmRhdGEgfHwgW107XG4gICAgICAgIGlmICghZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBib3JkZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IGRhdGFbMF0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoMCkpO1xuICAgICAgICBjb25zdCBsYXN0UG9pbnQgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoZGF0YS5sZW5ndGggLSAxKSk7XG4gICAgICAgIHJldHVybiBNYXRoLm1heChib3JkZXIsIGZpcnN0UG9pbnQsIGxhc3RQb2ludCkgLyAyO1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgbWV0YS5kYXRhc2V0LnVwZGF0ZUNvbnRyb2xQb2ludHModGhpcy5jaGFydC5jaGFydEFyZWEsIG1ldGEuaVNjYWxlLmF4aXMpO1xuICAgICAgICBzdXBlci5kcmF3KCk7XG4gICAgfVxufVxuXG5jbGFzcyBQb2xhckFyZWFDb250cm9sbGVyIGV4dGVuZHMgRGF0YXNldENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBpZCA9ICdwb2xhckFyZWEnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiAnYXJjJyxcbiAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICBhbmltYXRlUm90YXRlOiB0cnVlLFxuICAgICAgICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgIG51bWJlcnM6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICAgICAgICAgJ3knLFxuICAgICAgICAgICAgICAgICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICdlbmRBbmdsZScsXG4gICAgICAgICAgICAgICAgICAgICdpbm5lclJhZGl1cycsXG4gICAgICAgICAgICAgICAgICAgICdvdXRlclJhZGl1cydcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGluZGV4QXhpczogJ3InLFxuICAgICAgICBzdGFydEFuZ2xlOiAwXG4gICAgfTtcbiBzdGF0aWMgb3ZlcnJpZGVzID0ge1xuICAgICAgICBhc3BlY3RSYXRpbzogMSxcbiAgICAgICAgcGx1Z2luczoge1xuICAgICAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIGdlbmVyYXRlTGFiZWxzIChjaGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5sYWJlbHMubGVuZ3RoICYmIGRhdGEuZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBsYWJlbHM6IHsgcG9pbnRTdHlsZSAsIGNvbG9yICB9ICB9ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGEubGFiZWxzLm1hcCgobGFiZWwsIGkpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBjaGFydC5nZXREYXRhc2V0TWV0YSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxTdHlsZTogc3R5bGUuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9udENvbG9yOiBjb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aDogc3R5bGUuYm9yZGVyV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiBwb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuOiAhY2hhcnQuZ2V0RGF0YVZpc2liaWxpdHkoaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNsaWNrIChlLCBsZWdlbmRJdGVtLCBsZWdlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVnZW5kLmNoYXJ0LnRvZ2dsZURhdGFWaXNpYmlsaXR5KGxlZ2VuZEl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBsZWdlbmQuY2hhcnQudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzY2FsZXM6IHtcbiAgICAgICAgICAgIHI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAncmFkaWFsTGluZWFyJyxcbiAgICAgICAgICAgICAgICBhbmdsZUxpbmVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBiZWdpbkF0WmVybzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICAgICAgICAgIGNpcmN1bGFyOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5OiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc3RhcnRBbmdsZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjaGFydCwgZGF0YXNldEluZGV4KXtcbiAgICAgICAgc3VwZXIoY2hhcnQsIGRhdGFzZXRJbmRleCk7XG4gICAgICAgIHRoaXMuaW5uZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3V0ZXJSYWRpdXMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0TnVtYmVyKG1ldGEuX3BhcnNlZFtpbmRleF0uciwgY2hhcnQub3B0aW9ucy5sb2NhbGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZU9iamVjdERhdGEobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIHJldHVybiBfcGFyc2VPYmplY3REYXRhUmFkaWFsU2NhbGUuYmluZCh0aGlzKShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpO1xuICAgIH1cbiAgICB1cGRhdGUobW9kZSkge1xuICAgICAgICBjb25zdCBhcmNzID0gdGhpcy5fY2FjaGVkTWV0YS5kYXRhO1xuICAgICAgICB0aGlzLl91cGRhdGVSYWRpdXMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhhcmNzLCAwLCBhcmNzLmxlbmd0aCwgbW9kZSk7XG4gICAgfVxuIGdldE1pbk1heCgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICAgICAgbWluOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksXG4gICAgICAgICAgICBtYXg6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgICB9O1xuICAgICAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpPT57XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpbmRleCkucjtcbiAgICAgICAgICAgIGlmICghaXNOYU4ocGFyc2VkKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZWQgPCByYW5nZS5taW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubWluID0gcGFyc2VkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkID4gcmFuZ2UubWF4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLm1heCA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuIF91cGRhdGVSYWRpdXMoKSB7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3QgY2hhcnRBcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgICAgICBjb25zdCBvcHRzID0gY2hhcnQub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWluU2l6ZSA9IE1hdGgubWluKGNoYXJ0QXJlYS5yaWdodCAtIGNoYXJ0QXJlYS5sZWZ0LCBjaGFydEFyZWEuYm90dG9tIC0gY2hhcnRBcmVhLnRvcCk7XG4gICAgICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgobWluU2l6ZSAvIDIsIDApO1xuICAgICAgICBjb25zdCBpbm5lclJhZGl1cyA9IE1hdGgubWF4KG9wdHMuY3V0b3V0UGVyY2VudGFnZSA/IG91dGVyUmFkaXVzIC8gMTAwICogb3B0cy5jdXRvdXRQZXJjZW50YWdlIDogMSwgMCk7XG4gICAgICAgIGNvbnN0IHJhZGl1c0xlbmd0aCA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIGNoYXJ0LmdldFZpc2libGVEYXRhc2V0Q291bnQoKTtcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IG91dGVyUmFkaXVzIC0gcmFkaXVzTGVuZ3RoICogdGhpcy5pbmRleDtcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IHRoaXMub3V0ZXJSYWRpdXMgLSByYWRpdXNMZW5ndGg7XG4gICAgfVxuICAgIHVwZGF0ZUVsZW1lbnRzKGFyY3MsIHN0YXJ0LCBjb3VudCwgbW9kZSkge1xuICAgICAgICBjb25zdCByZXNldCA9IG1vZGUgPT09ICdyZXNldCc7XG4gICAgICAgIGNvbnN0IGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGNoYXJ0Lm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbk9wdHMgPSBvcHRzLmFuaW1hdGlvbjtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICAgICAgY29uc3QgY2VudGVyWCA9IHNjYWxlLnhDZW50ZXI7XG4gICAgICAgIGNvbnN0IGNlbnRlclkgPSBzY2FsZS55Q2VudGVyO1xuICAgICAgICBjb25zdCBkYXRhc2V0U3RhcnRBbmdsZSA9IHNjYWxlLmdldEluZGV4QW5nbGUoMCkgLSAwLjUgKiBQSTtcbiAgICAgICAgbGV0IGFuZ2xlID0gZGF0YXNldFN0YXJ0QW5nbGU7XG4gICAgICAgIGxldCBpO1xuICAgICAgICBjb25zdCBkZWZhdWx0QW5nbGUgPSAzNjAgLyB0aGlzLmNvdW50VmlzaWJsZUVsZW1lbnRzKCk7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IHN0YXJ0OyArK2kpe1xuICAgICAgICAgICAgYW5nbGUgKz0gdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBhcmMgPSBhcmNzW2ldO1xuICAgICAgICAgICAgbGV0IHN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICAgIGxldCBlbmRBbmdsZSA9IGFuZ2xlICsgdGhpcy5fY29tcHV0ZUFuZ2xlKGksIG1vZGUsIGRlZmF1bHRBbmdsZSk7XG4gICAgICAgICAgICBsZXQgb3V0ZXJSYWRpdXMgPSBjaGFydC5nZXREYXRhVmlzaWJpbGl0eShpKSA/IHNjYWxlLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRoaXMuZ2V0UGFyc2VkKGkpLnIpIDogMDtcbiAgICAgICAgICAgIGFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgICBpZiAocmVzZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlU2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJSYWRpdXMgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uT3B0cy5hbmltYXRlUm90YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUgPSBlbmRBbmdsZSA9IGRhdGFzZXRTdGFydEFuZ2xlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgeDogY2VudGVyWCxcbiAgICAgICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgIGlubmVyUmFkaXVzOiAwLFxuICAgICAgICAgICAgICAgIG91dGVyUmFkaXVzLFxuICAgICAgICAgICAgICAgIHN0YXJ0QW5nbGUsXG4gICAgICAgICAgICAgICAgZW5kQW5nbGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGksIGFyYy5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50KGFyYywgaSwgcHJvcGVydGllcywgbW9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY291bnRWaXNpYmxlRWxlbWVudHMoKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBtZXRhLmRhdGEuZm9yRWFjaCgoZWxlbWVudCwgaW5kZXgpPT57XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHRoaXMuZ2V0UGFyc2VkKGluZGV4KS5yKSAmJiB0aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGNvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuIF9jb21wdXRlQW5nbGUoaW5kZXgsIG1vZGUsIGRlZmF1bHRBbmdsZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFydC5nZXREYXRhVmlzaWJpbGl0eShpbmRleCkgPyB0b1JhZGlhbnModGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGluZGV4LCBtb2RlKS5hbmdsZSB8fCBkZWZhdWx0QW5nbGUpIDogMDtcbiAgICB9XG59XG5cbmNsYXNzIFBpZUNvbnRyb2xsZXIgZXh0ZW5kcyBEb3VnaG51dENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyBpZCA9ICdwaWUnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgY3V0b3V0OiAwLFxuICAgICAgICByb3RhdGlvbjogMCxcbiAgICAgICAgY2lyY3VtZmVyZW5jZTogMzYwLFxuICAgICAgICByYWRpdXM6ICcxMDAlJ1xuICAgIH07XG59XG5cbmNsYXNzIFJhZGFyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAncmFkYXInO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgZGF0YXNldEVsZW1lbnRUeXBlOiAnbGluZScsXG4gICAgICAgIGRhdGFFbGVtZW50VHlwZTogJ3BvaW50JyxcbiAgICAgICAgaW5kZXhBeGlzOiAncicsXG4gICAgICAgIHNob3dMaW5lOiB0cnVlLFxuICAgICAgICBlbGVtZW50czoge1xuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGZpbGw6ICdzdGFydCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gc3RhdGljIG92ZXJyaWRlcyA9IHtcbiAgICAgICAgYXNwZWN0UmF0aW86IDEsXG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdyYWRpYWxMaW5lYXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgdlNjYWxlID0gdGhpcy5fY2FjaGVkTWV0YS52U2NhbGU7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuZ2V0UGFyc2VkKGluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhYmVsOiB2U2NhbGUuZ2V0TGFiZWxzKClbaW5kZXhdLFxuICAgICAgICAgICAgdmFsdWU6ICcnICsgdlNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkW3ZTY2FsZS5heGlzXSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcGFyc2VPYmplY3REYXRhKG1ldGEsIGRhdGEsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICByZXR1cm4gX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLmJpbmQodGhpcykobWV0YSwgZGF0YSwgc3RhcnQsIGNvdW50KTtcbiAgICB9XG4gICAgdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBtZXRhLmRhdGFzZXQ7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IG1ldGEuZGF0YSB8fCBbXTtcbiAgICAgICAgY29uc3QgbGFiZWxzID0gbWV0YS5pU2NhbGUuZ2V0TGFiZWxzKCk7XG4gICAgICAgIGxpbmUucG9pbnRzID0gcG9pbnRzO1xuICAgICAgICBpZiAobW9kZSAhPT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYm9yZGVyV2lkdGggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICBfbG9vcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBfZnVsbExvb3A6IGxhYmVscy5sZW5ndGggPT09IHBvaW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudHMocG9pbnRzLCAwLCBwb2ludHMubGVuZ3RoLCBtb2RlKTtcbiAgICB9XG4gICAgdXBkYXRlRWxlbWVudHMocG9pbnRzLCBzdGFydCwgY291bnQsIG1vZGUpIHtcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0aGlzLl9jYWNoZWRNZXRhLnJTY2FsZTtcbiAgICAgICAgY29uc3QgcmVzZXQgPSBtb2RlID09PSAncmVzZXQnO1xuICAgICAgICBmb3IobGV0IGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSwgcG9pbnQuYWN0aXZlID8gJ2FjdGl2ZScgOiBtb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50UG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoaSwgdGhpcy5nZXRQYXJzZWQoaSkucik7XG4gICAgICAgICAgICBjb25zdCB4ID0gcmVzZXQgPyBzY2FsZS54Q2VudGVyIDogcG9pbnRQb3NpdGlvbi54O1xuICAgICAgICAgICAgY29uc3QgeSA9IHJlc2V0ID8gc2NhbGUueUNlbnRlciA6IHBvaW50UG9zaXRpb24ueTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgIGFuZ2xlOiBwb2ludFBvc2l0aW9uLmFuZ2xlLFxuICAgICAgICAgICAgICAgIHNraXA6IGlzTmFOKHgpIHx8IGlzTmFOKHkpLFxuICAgICAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBTY2F0dGVyQ29udHJvbGxlciBleHRlbmRzIERhdGFzZXRDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgaWQgPSAnc2NhdHRlcic7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBkYXRhc2V0RWxlbWVudFR5cGU6IGZhbHNlLFxuICAgICAgICBkYXRhRWxlbWVudFR5cGU6ICdwb2ludCcsXG4gICAgICAgIHNob3dMaW5lOiBmYWxzZSxcbiAgICAgICAgZmlsbDogZmFsc2VcbiAgICB9O1xuIHN0YXRpYyBvdmVycmlkZXMgPSB7XG4gICAgICAgIGludGVyYWN0aW9uOiB7XG4gICAgICAgICAgICBtb2RlOiAncG9pbnQnXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlczoge1xuICAgICAgICAgICAgeDoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgeToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lYXInXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuIGdldExhYmVsQW5kVmFsdWUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX2NhY2hlZE1ldGE7XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuY2hhcnQuZGF0YS5sYWJlbHMgfHwgW107XG4gICAgICAgIGNvbnN0IHsgeFNjYWxlICwgeVNjYWxlICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5nZXRQYXJzZWQoaW5kZXgpO1xuICAgICAgICBjb25zdCB4ID0geFNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLngpO1xuICAgICAgICBjb25zdCB5ID0geVNjYWxlLmdldExhYmVsRm9yVmFsdWUocGFyc2VkLnkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWw6IGxhYmVsc1tpbmRleF0gfHwgJycsXG4gICAgICAgICAgICB2YWx1ZTogJygnICsgeCArICcsICcgKyB5ICsgJyknXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZShtb2RlKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCB7IGRhdGE6IHBvaW50cyA9IFtdICB9ID0gbWV0YTtcbiAgICAgICAgY29uc3QgYW5pbWF0aW9uc0Rpc2FibGVkID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkO1xuICAgICAgICBsZXQgeyBzdGFydCAsIGNvdW50ICB9ID0gX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMobWV0YSwgcG9pbnRzLCBhbmltYXRpb25zRGlzYWJsZWQpO1xuICAgICAgICB0aGlzLl9kcmF3U3RhcnQgPSBzdGFydDtcbiAgICAgICAgdGhpcy5fZHJhd0NvdW50ID0gY291bnQ7XG4gICAgICAgIGlmIChfc2NhbGVSYW5nZXNDaGFuZ2VkKG1ldGEpKSB7XG4gICAgICAgICAgICBzdGFydCA9IDA7XG4gICAgICAgICAgICBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YXNldDogbGluZSAsIF9kYXRhc2V0ICB9ID0gbWV0YTtcbiAgICAgICAgICAgIGxpbmUuX2NoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICAgICAgICAgIGxpbmUuX2RhdGFzZXRJbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgICAgICBsaW5lLl9kZWNpbWF0ZWQgPSAhIV9kYXRhc2V0Ll9kZWNpbWF0ZWQ7XG4gICAgICAgICAgICBsaW5lLnBvaW50cyA9IHBvaW50cztcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLnJlc29sdmVEYXRhc2V0RWxlbWVudE9wdGlvbnMobW9kZSk7XG4gICAgICAgICAgICBvcHRpb25zLnNlZ21lbnQgPSB0aGlzLm9wdGlvbnMuc2VnbWVudDtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudChsaW5lLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICBhbmltYXRlZDogIWFuaW1hdGlvbnNEaXNhYmxlZCxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9LCBtb2RlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgZGVsZXRlIG1ldGEuZGF0YXNldDtcbiAgICAgICAgICAgIHRoaXMuZGF0YXNldEVsZW1lbnRUeXBlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVFbGVtZW50cyhwb2ludHMsIHN0YXJ0LCBjb3VudCwgbW9kZSk7XG4gICAgfVxuICAgIGFkZEVsZW1lbnRzKCkge1xuICAgICAgICBjb25zdCB7IHNob3dMaW5lICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMuZGF0YXNldEVsZW1lbnRUeXBlICYmIHNob3dMaW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFzZXRFbGVtZW50VHlwZSA9IHRoaXMuY2hhcnQucmVnaXN0cnkuZ2V0RWxlbWVudCgnbGluZScpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmFkZEVsZW1lbnRzKCk7XG4gICAgfVxuICAgIHVwZGF0ZUVsZW1lbnRzKHBvaW50cywgc3RhcnQsIGNvdW50LCBtb2RlKSB7XG4gICAgICAgIGNvbnN0IHJlc2V0ID0gbW9kZSA9PT0gJ3Jlc2V0JztcbiAgICAgICAgY29uc3QgeyBpU2NhbGUgLCB2U2NhbGUgLCBfc3RhY2tlZCAsIF9kYXRhc2V0ICB9ID0gdGhpcy5fY2FjaGVkTWV0YTtcbiAgICAgICAgY29uc3QgZmlyc3RPcHRzID0gdGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKHN0YXJ0LCBtb2RlKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkT3B0aW9ucyA9IHRoaXMuZ2V0U2hhcmVkT3B0aW9ucyhmaXJzdE9wdHMpO1xuICAgICAgICBjb25zdCBpbmNsdWRlT3B0aW9ucyA9IHRoaXMuaW5jbHVkZU9wdGlvbnMobW9kZSwgc2hhcmVkT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGlBeGlzID0gaVNjYWxlLmF4aXM7XG4gICAgICAgIGNvbnN0IHZBeGlzID0gdlNjYWxlLmF4aXM7XG4gICAgICAgIGNvbnN0IHsgc3BhbkdhcHMgLCBzZWdtZW50ICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBtYXhHYXBMZW5ndGggPSBpc051bWJlcihzcGFuR2FwcykgPyBzcGFuR2FwcyA6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgY29uc3QgZGlyZWN0VXBkYXRlID0gdGhpcy5jaGFydC5fYW5pbWF0aW9uc0Rpc2FibGVkIHx8IHJlc2V0IHx8IG1vZGUgPT09ICdub25lJztcbiAgICAgICAgbGV0IHByZXZQYXJzZWQgPSBzdGFydCA+IDAgJiYgdGhpcy5nZXRQYXJzZWQoc3RhcnQgLSAxKTtcbiAgICAgICAgZm9yKGxldCBpID0gc3RhcnQ7IGkgPCBzdGFydCArIGNvdW50OyArK2kpe1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLmdldFBhcnNlZChpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBkaXJlY3RVcGRhdGUgPyBwb2ludCA6IHt9O1xuICAgICAgICAgICAgY29uc3QgbnVsbERhdGEgPSBpc051bGxPclVuZGVmKHBhcnNlZFt2QXhpc10pO1xuICAgICAgICAgICAgY29uc3QgaVBpeGVsID0gcHJvcGVydGllc1tpQXhpc10gPSBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShwYXJzZWRbaUF4aXNdLCBpKTtcbiAgICAgICAgICAgIGNvbnN0IHZQaXhlbCA9IHByb3BlcnRpZXNbdkF4aXNdID0gcmVzZXQgfHwgbnVsbERhdGEgPyB2U2NhbGUuZ2V0QmFzZVBpeGVsKCkgOiB2U2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShfc3RhY2tlZCA/IHRoaXMuYXBwbHlTdGFjayh2U2NhbGUsIHBhcnNlZCwgX3N0YWNrZWQpIDogcGFyc2VkW3ZBeGlzXSwgaSk7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnNraXAgPSBpc05hTihpUGl4ZWwpIHx8IGlzTmFOKHZQaXhlbCkgfHwgbnVsbERhdGE7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzLnN0b3AgPSBpID4gMCAmJiBNYXRoLmFicyhwYXJzZWRbaUF4aXNdIC0gcHJldlBhcnNlZFtpQXhpc10pID4gbWF4R2FwTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnJhdyA9IF9kYXRhc2V0LmRhdGFbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5jbHVkZU9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLm9wdGlvbnMgPSBzaGFyZWRPcHRpb25zIHx8IHRoaXMucmVzb2x2ZURhdGFFbGVtZW50T3B0aW9ucyhpLCBwb2ludC5hY3RpdmUgPyAnYWN0aXZlJyA6IG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkaXJlY3RVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVsZW1lbnQocG9pbnQsIGksIHByb3BlcnRpZXMsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldlBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVNoYXJlZE9wdGlvbnMoc2hhcmVkT3B0aW9ucywgbW9kZSwgZmlyc3RPcHRzKTtcbiAgICB9XG4gZ2V0TWF4T3ZlcmZsb3coKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9jYWNoZWRNZXRhO1xuICAgICAgICBjb25zdCBkYXRhID0gbWV0YS5kYXRhIHx8IFtdO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zaG93TGluZSkge1xuICAgICAgICAgICAgbGV0IG1heCA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKXtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIGRhdGFbaV0uc2l6ZSh0aGlzLnJlc29sdmVEYXRhRWxlbWVudE9wdGlvbnMoaSkpIC8gMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWF4ID4gMCAmJiBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YXNldCA9IG1ldGEuZGF0YXNldDtcbiAgICAgICAgY29uc3QgYm9yZGVyID0gZGF0YXNldC5vcHRpb25zICYmIGRhdGFzZXQub3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICBpZiAoIWRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBkYXRhWzBdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKDApKTtcbiAgICAgICAgY29uc3QgbGFzdFBvaW50ID0gZGF0YVtkYXRhLmxlbmd0aCAtIDFdLnNpemUodGhpcy5yZXNvbHZlRGF0YUVsZW1lbnRPcHRpb25zKGRhdGEubGVuZ3RoIC0gMSkpO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoYm9yZGVyLCBmaXJzdFBvaW50LCBsYXN0UG9pbnQpIC8gMjtcbiAgICB9XG59XG5cbnZhciBjb250cm9sbGVycyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkJhckNvbnRyb2xsZXI6IEJhckNvbnRyb2xsZXIsXG5CdWJibGVDb250cm9sbGVyOiBCdWJibGVDb250cm9sbGVyLFxuRG91Z2hudXRDb250cm9sbGVyOiBEb3VnaG51dENvbnRyb2xsZXIsXG5MaW5lQ29udHJvbGxlcjogTGluZUNvbnRyb2xsZXIsXG5QaWVDb250cm9sbGVyOiBQaWVDb250cm9sbGVyLFxuUG9sYXJBcmVhQ29udHJvbGxlcjogUG9sYXJBcmVhQ29udHJvbGxlcixcblJhZGFyQ29udHJvbGxlcjogUmFkYXJDb250cm9sbGVyLFxuU2NhdHRlckNvbnRyb2xsZXI6IFNjYXR0ZXJDb250cm9sbGVyXG59KTtcblxuLyoqXG4gKiBAbmFtZXNwYWNlIENoYXJ0Ll9hZGFwdGVyc1xuICogQHNpbmNlIDIuOC4wXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIGFic3RyYWN0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkOiBDaGVjayB0aGF0IGEgY29tcGxldGUgZGF0ZSBhZGFwdGVyIGlzIHByb3ZpZGVkLicpO1xufVxuLyoqXG4gKiBEYXRlIGFkYXB0ZXIgKGN1cnJlbnQgdXNlZCBieSB0aGUgdGltZSBzY2FsZSlcbiAqIEBuYW1lc3BhY2UgQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlXG4gKiBAbWVtYmVyb2YgQ2hhcnQuX2FkYXB0ZXJzXG4gKiBAcHJpdmF0ZVxuICovIGNsYXNzIERhdGVBZGFwdGVyQmFzZSB7XG4gICAgLyoqXG4gICAqIE92ZXJyaWRlIGRlZmF1bHQgZGF0ZSBhZGFwdGVyIG1ldGhvZHMuXG4gICAqIEFjY2VwdHMgdHlwZSBwYXJhbWV0ZXIgdG8gZGVmaW5lIG9wdGlvbnMgdHlwZS5cbiAgICogQGV4YW1wbGVcbiAgICogQ2hhcnQuX2FkYXB0ZXJzLl9kYXRlLm92ZXJyaWRlPHtteUFkYXB0ZXJPcHRpb246IHN0cmluZ30+KHtcbiAgICogICBpbml0KCkge1xuICAgKiAgICAgY29uc29sZS5sb2codGhpcy5vcHRpb25zLm15QWRhcHRlck9wdGlvbik7XG4gICAqICAgfVxuICAgKiB9KVxuICAgKi8gc3RhdGljIG92ZXJyaWRlKG1lbWJlcnMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihEYXRlQWRhcHRlckJhc2UucHJvdG90eXBlLCBtZW1iZXJzKTtcbiAgICB9XG4gICAgb3B0aW9ucztcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKXtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGluaXQoKSB7fVxuICAgIGZvcm1hdHMoKSB7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICAgIH1cbiAgICBwYXJzZSgpIHtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gICAgfVxuICAgIGZvcm1hdCgpIHtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gICAgfVxuICAgIGFkZCgpIHtcbiAgICAgICAgcmV0dXJuIGFic3RyYWN0KCk7XG4gICAgfVxuICAgIGRpZmYoKSB7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICAgIH1cbiAgICBzdGFydE9mKCkge1xuICAgICAgICByZXR1cm4gYWJzdHJhY3QoKTtcbiAgICB9XG4gICAgZW5kT2YoKSB7XG4gICAgICAgIHJldHVybiBhYnN0cmFjdCgpO1xuICAgIH1cbn1cbnZhciBhZGFwdGVycyA9IHtcbiAgICBfZGF0ZTogRGF0ZUFkYXB0ZXJCYXNlXG59O1xuXG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobWV0YXNldCwgYXhpcywgdmFsdWUsIGludGVyc2VjdCkge1xuICAgIGNvbnN0IHsgY29udHJvbGxlciAsIGRhdGEgLCBfc29ydGVkICB9ID0gbWV0YXNldDtcbiAgICBjb25zdCBpU2NhbGUgPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhLmlTY2FsZTtcbiAgICBjb25zdCBzcGFuR2FwcyA9IG1ldGFzZXQuZGF0YXNldCA/IG1ldGFzZXQuZGF0YXNldC5vcHRpb25zID8gbWV0YXNldC5kYXRhc2V0Lm9wdGlvbnMuc3BhbkdhcHMgOiBudWxsIDogbnVsbDtcbiAgICBpZiAoaVNjYWxlICYmIGF4aXMgPT09IGlTY2FsZS5heGlzICYmIGF4aXMgIT09ICdyJyAmJiBfc29ydGVkICYmIGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGxvb2t1cE1ldGhvZCA9IGlTY2FsZS5fcmV2ZXJzZVBpeGVscyA/IF9ybG9va3VwQnlLZXkgOiBfbG9va3VwQnlLZXk7XG4gICAgICAgIGlmICghaW50ZXJzZWN0KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBsb29rdXBNZXRob2QoZGF0YSwgYXhpcywgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKHNwYW5HYXBzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2U2NhbGUgIH0gPSBjb250cm9sbGVyLl9jYWNoZWRNZXRhO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX3BhcnNlZCAgfSA9IG1ldGFzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRMbyA9IF9wYXJzZWQuc2xpY2UoMCwgcmVzdWx0LmxvICsgMSkucmV2ZXJzZSgpLmZpbmRJbmRleCgocG9pbnQpPT4haXNOdWxsT3JVbmRlZihwb2ludFt2U2NhbGUuYXhpc10pKTtcbiAgICAgICAgICAgICAgICByZXN1bHQubG8gLT0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRMbyk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VUb0RlZmluZWRIaSA9IF9wYXJzZWQuc2xpY2UocmVzdWx0LmhpKS5maW5kSW5kZXgoKHBvaW50KT0+IWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmhpICs9IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkSGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSBlbHNlIGlmIChjb250cm9sbGVyLl9zaGFyZWRPcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGRhdGFbMF07XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHR5cGVvZiBlbC5nZXRSYW5nZSA9PT0gJ2Z1bmN0aW9uJyAmJiBlbC5nZXRSYW5nZShheGlzKTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbG9va3VwTWV0aG9kKGRhdGEsIGF4aXMsIHZhbHVlIC0gcmFuZ2UpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IGxvb2t1cE1ldGhvZChkYXRhLCBheGlzLCB2YWx1ZSArIHJhbmdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBsbzogc3RhcnQubG8sXG4gICAgICAgICAgICAgICAgICAgIGhpOiBlbmQuaGlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGxvOiAwLFxuICAgICAgICBoaTogZGF0YS5sZW5ndGggLSAxXG4gICAgfTtcbn1cbiBmdW5jdGlvbiBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBoYW5kbGVyLCBpbnRlcnNlY3QpIHtcbiAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW2F4aXNdO1xuICAgIGZvcihsZXQgaSA9IDAsIGlsZW4gPSBtZXRhc2V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBjb25zdCB7IGluZGV4ICwgZGF0YSAgfSA9IG1ldGFzZXRzW2ldO1xuICAgICAgICBjb25zdCB7IGxvICwgaGkgIH0gPSBiaW5hcnlTZWFyY2gobWV0YXNldHNbaV0sIGF4aXMsIHZhbHVlLCBpbnRlcnNlY3QpO1xuICAgICAgICBmb3IobGV0IGogPSBsbzsgaiA8PSBoaTsgKytqKXtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkYXRhW2pdO1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGVsZW1lbnQsIGluZGV4LCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiBmdW5jdGlvbiBnZXREaXN0YW5jZU1ldHJpY0ZvckF4aXMoYXhpcykge1xuICAgIGNvbnN0IHVzZVggPSBheGlzLmluZGV4T2YoJ3gnKSAhPT0gLTE7XG4gICAgY29uc3QgdXNlWSA9IGF4aXMuaW5kZXhPZigneScpICE9PSAtMTtcbiAgICByZXR1cm4gZnVuY3Rpb24ocHQxLCBwdDIpIHtcbiAgICAgICAgY29uc3QgZGVsdGFYID0gdXNlWCA/IE1hdGguYWJzKHB0MS54IC0gcHQyLngpIDogMDtcbiAgICAgICAgY29uc3QgZGVsdGFZID0gdXNlWSA/IE1hdGguYWJzKHB0MS55IC0gcHQyLnkpIDogMDtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhkZWx0YVgsIDIpICsgTWF0aC5wb3coZGVsdGFZLCAyKSk7XG4gICAgfTtcbn1cbiBmdW5jdGlvbiBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGlmICghaW5jbHVkZUludmlzaWJsZSAmJiAhY2hhcnQuaXNQb2ludEluQXJlYShwb3NpdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBjb25zdCBldmFsdWF0aW9uRnVuYyA9IGZ1bmN0aW9uKGVsZW1lbnQsIGRhdGFzZXRJbmRleCwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFpbmNsdWRlSW52aXNpYmxlICYmICFfaXNQb2ludEluQXJlYShlbGVtZW50LCBjaGFydC5jaGFydEFyZWEsIDApKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuaW5SYW5nZShwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYywgdHJ1ZSk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuIGZ1bmN0aW9uIGdldE5lYXJlc3RSYWRpYWxJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRBbmdsZSAsIGVuZEFuZ2xlICB9ID0gZWxlbWVudC5nZXRQcm9wcyhbXG4gICAgICAgICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAgICAgICAnZW5kQW5nbGUnXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBjb25zdCB7IGFuZ2xlICB9ID0gZ2V0QW5nbGVGcm9tUG9pbnQoZWxlbWVudCwge1xuICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgIHk6IHBvc2l0aW9uLnlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSkpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCBldmFsdWF0aW9uRnVuYyk7XG4gICAgcmV0dXJuIGl0ZW1zO1xufVxuIGZ1bmN0aW9uIGdldE5lYXJlc3RDYXJ0ZXNpYW5JdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkge1xuICAgIGxldCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IGRpc3RhbmNlTWV0cmljID0gZ2V0RGlzdGFuY2VNZXRyaWNGb3JBeGlzKGF4aXMpO1xuICAgIGxldCBtaW5EaXN0YW5jZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICBmdW5jdGlvbiBldmFsdWF0aW9uRnVuYyhlbGVtZW50LCBkYXRhc2V0SW5kZXgsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGluUmFuZ2UgPSBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIGlmIChpbnRlcnNlY3QgJiYgIWluUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZW50ZXIgPSBlbGVtZW50LmdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBwb2ludEluQXJlYSA9ICEhaW5jbHVkZUludmlzaWJsZSB8fCBjaGFydC5pc1BvaW50SW5BcmVhKGNlbnRlcik7XG4gICAgICAgIGlmICghcG9pbnRJbkFyZWEgJiYgIWluUmFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGRpc3RhbmNlTWV0cmljKHBvc2l0aW9uLCBjZW50ZXIpO1xuICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgaXRlbXMgPSBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleCxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zKGNoYXJ0LCBheGlzLCBwb3NpdGlvbiwgZXZhbHVhdGlvbkZ1bmMpO1xuICAgIHJldHVybiBpdGVtcztcbn1cbiBmdW5jdGlvbiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIHtcbiAgICBpZiAoIWluY2x1ZGVJbnZpc2libGUgJiYgIWNoYXJ0LmlzUG9pbnRJbkFyZWEocG9zaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIGF4aXMgPT09ICdyJyAmJiAhaW50ZXJzZWN0ID8gZ2V0TmVhcmVzdFJhZGlhbEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbikgOiBnZXROZWFyZXN0Q2FydGVzaWFuSXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBpbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xufVxuIGZ1bmN0aW9uIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIGludGVyc2VjdCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3QgcmFuZ2VNZXRob2QgPSBheGlzID09PSAneCcgPyAnaW5YUmFuZ2UnIDogJ2luWVJhbmdlJztcbiAgICBsZXQgaW50ZXJzZWN0c0l0ZW0gPSBmYWxzZTtcbiAgICBldmFsdWF0ZUludGVyYWN0aW9uSXRlbXMoY2hhcnQsIGF4aXMsIHBvc2l0aW9uLCAoZWxlbWVudCwgZGF0YXNldEluZGV4LCBpbmRleCk9PntcbiAgICAgICAgaWYgKGVsZW1lbnRbcmFuZ2VNZXRob2RdICYmIGVsZW1lbnRbcmFuZ2VNZXRob2RdKHBvc2l0aW9uW2F4aXNdLCB1c2VGaW5hbFBvc2l0aW9uKSkge1xuICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW50ZXJzZWN0c0l0ZW0gPSBpbnRlcnNlY3RzSXRlbSB8fCBlbGVtZW50LmluUmFuZ2UocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoaW50ZXJzZWN0ICYmICFpbnRlcnNlY3RzSXRlbSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbn1cbiB2YXIgSW50ZXJhY3Rpb24gPSB7XG4gICAgZXZhbHVhdGVJbnRlcmFjdGlvbkl0ZW1zLFxuICAgIG1vZGVzOiB7XG4gaW5kZXggKGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IG9wdGlvbnMuYXhpcyB8fCAneCc7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBvcHRpb25zLmludGVyc2VjdCA/IGdldEludGVyc2VjdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSkgOiBnZXROZWFyZXN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCBmYWxzZSwgdXNlRmluYWxQb3NpdGlvbiwgaW5jbHVkZUludmlzaWJsZSk7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFydC5nZXRTb3J0ZWRWaXNpYmxlRGF0YXNldE1ldGFzKCkuZm9yRWFjaCgobWV0YSk9PntcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGl0ZW1zWzBdLmluZGV4O1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBtZXRhLmRhdGFbaW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICYmICFlbGVtZW50LnNraXApIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldEluZGV4OiBtZXRhLmluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgICAgIH0sXG4gZGF0YXNldCAoY2hhcnQsIGUsIG9wdGlvbnMsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2V0UmVsYXRpdmVQb3NpdGlvbihlLCBjaGFydCk7XG4gICAgICAgICAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8ICd4eSc7XG4gICAgICAgICAgICBjb25zdCBpbmNsdWRlSW52aXNpYmxlID0gb3B0aW9ucy5pbmNsdWRlSW52aXNpYmxlIHx8IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGl0ZW1zID0gb3B0aW9ucy5pbnRlcnNlY3QgPyBnZXRJbnRlcnNlY3RJdGVtcyhjaGFydCwgcG9zaXRpb24sIGF4aXMsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpIDogZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgZmFsc2UsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhc2V0SW5kZXggPSBpdGVtc1swXS5kYXRhc2V0SW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuZGF0YTtcbiAgICAgICAgICAgICAgICBpdGVtcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50OiBkYXRhW2ldLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YXNldEluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICB9LFxuIHBvaW50IChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW50ZXJzZWN0SXRlbXMoY2hhcnQsIHBvc2l0aW9uLCBheGlzLCB1c2VGaW5hbFBvc2l0aW9uLCBpbmNsdWRlSW52aXNpYmxlKTtcbiAgICAgICAgfSxcbiBuZWFyZXN0IChjaGFydCwgZSwgb3B0aW9ucywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGUsIGNoYXJ0KTtcbiAgICAgICAgICAgIGNvbnN0IGF4aXMgPSBvcHRpb25zLmF4aXMgfHwgJ3h5JztcbiAgICAgICAgICAgIGNvbnN0IGluY2x1ZGVJbnZpc2libGUgPSBvcHRpb25zLmluY2x1ZGVJbnZpc2libGUgfHwgZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TmVhcmVzdEl0ZW1zKGNoYXJ0LCBwb3NpdGlvbiwgYXhpcywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24sIGluY2x1ZGVJbnZpc2libGUpO1xuICAgICAgICB9LFxuIHggKGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd4Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICB9LFxuIHkgKGNoYXJ0LCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IGdldFJlbGF0aXZlUG9zaXRpb24oZSwgY2hhcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGdldEF4aXNJdGVtcyhjaGFydCwgcG9zaXRpb24sICd5Jywgb3B0aW9ucy5pbnRlcnNlY3QsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuY29uc3QgU1RBVElDX1BPU0lUSU9OUyA9IFtcbiAgICAnbGVmdCcsXG4gICAgJ3RvcCcsXG4gICAgJ3JpZ2h0JyxcbiAgICAnYm90dG9tJ1xuXTtcbmZ1bmN0aW9uIGZpbHRlckJ5UG9zaXRpb24oYXJyYXksIHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcigodik9PnYucG9zID09PSBwb3NpdGlvbik7XG59XG5mdW5jdGlvbiBmaWx0ZXJEeW5hbWljUG9zaXRpb25CeUF4aXMoYXJyYXksIGF4aXMpIHtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKCh2KT0+U1RBVElDX1BPU0lUSU9OUy5pbmRleE9mKHYucG9zKSA9PT0gLTEgJiYgdi5ib3guYXhpcyA9PT0gYXhpcyk7XG59XG5mdW5jdGlvbiBzb3J0QnlXZWlnaHQoYXJyYXksIHJldmVyc2UpIHtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgoYSwgYik9PntcbiAgICAgICAgY29uc3QgdjAgPSByZXZlcnNlID8gYiA6IGE7XG4gICAgICAgIGNvbnN0IHYxID0gcmV2ZXJzZSA/IGEgOiBiO1xuICAgICAgICByZXR1cm4gdjAud2VpZ2h0ID09PSB2MS53ZWlnaHQgPyB2MC5pbmRleCAtIHYxLmluZGV4IDogdjAud2VpZ2h0IC0gdjEud2VpZ2h0O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gd3JhcEJveGVzKGJveGVzKSB7XG4gICAgY29uc3QgbGF5b3V0Qm94ZXMgPSBbXTtcbiAgICBsZXQgaSwgaWxlbiwgYm94LCBwb3MsIHN0YWNrLCBzdGFja1dlaWdodDtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSAoYm94ZXMgfHwgW10pLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGJveCA9IGJveGVzW2ldO1xuICAgICAgICAoeyBwb3NpdGlvbjogcG9zICwgb3B0aW9uczogeyBzdGFjayAsIHN0YWNrV2VpZ2h0ID0xICB9ICB9ID0gYm94KTtcbiAgICAgICAgbGF5b3V0Qm94ZXMucHVzaCh7XG4gICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgIGJveCxcbiAgICAgICAgICAgIHBvcyxcbiAgICAgICAgICAgIGhvcml6b250YWw6IGJveC5pc0hvcml6b250YWwoKSxcbiAgICAgICAgICAgIHdlaWdodDogYm94LndlaWdodCxcbiAgICAgICAgICAgIHN0YWNrOiBzdGFjayAmJiBwb3MgKyBzdGFjayxcbiAgICAgICAgICAgIHN0YWNrV2VpZ2h0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGF5b3V0Qm94ZXM7XG59XG5mdW5jdGlvbiBidWlsZFN0YWNrcyhsYXlvdXRzKSB7XG4gICAgY29uc3Qgc3RhY2tzID0ge307XG4gICAgZm9yIChjb25zdCB3cmFwIG9mIGxheW91dHMpe1xuICAgICAgICBjb25zdCB7IHN0YWNrICwgcG9zICwgc3RhY2tXZWlnaHQgIH0gPSB3cmFwO1xuICAgICAgICBpZiAoIXN0YWNrIHx8ICFTVEFUSUNfUE9TSVRJT05TLmluY2x1ZGVzKHBvcykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9zdGFjayA9IHN0YWNrc1tzdGFja10gfHwgKHN0YWNrc1tzdGFja10gPSB7XG4gICAgICAgICAgICBjb3VudDogMCxcbiAgICAgICAgICAgIHBsYWNlZDogMCxcbiAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgIHNpemU6IDBcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdGFjay5jb3VudCsrO1xuICAgICAgICBfc3RhY2sud2VpZ2h0ICs9IHN0YWNrV2VpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2tzO1xufVxuIGZ1bmN0aW9uIHNldExheW91dERpbXMobGF5b3V0cywgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYnVpbGRTdGFja3MobGF5b3V0cyk7XG4gICAgY29uc3QgeyB2Qm94TWF4V2lkdGggLCBoQm94TWF4SGVpZ2h0ICB9ID0gcGFyYW1zO1xuICAgIGxldCBpLCBpbGVuLCBsYXlvdXQ7XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gbGF5b3V0cy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBsYXlvdXQgPSBsYXlvdXRzW2ldO1xuICAgICAgICBjb25zdCB7IGZ1bGxTaXplICB9ID0gbGF5b3V0LmJveDtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBzdGFja3NbbGF5b3V0LnN0YWNrXTtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gc3RhY2sgJiYgbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0O1xuICAgICAgICBpZiAobGF5b3V0Lmhvcml6b250YWwpIHtcbiAgICAgICAgICAgIGxheW91dC53aWR0aCA9IGZhY3RvciA/IGZhY3RvciAqIHZCb3hNYXhXaWR0aCA6IGZ1bGxTaXplICYmIHBhcmFtcy5hdmFpbGFibGVXaWR0aDtcbiAgICAgICAgICAgIGxheW91dC5oZWlnaHQgPSBoQm94TWF4SGVpZ2h0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGF5b3V0LndpZHRoID0gdkJveE1heFdpZHRoO1xuICAgICAgICAgICAgbGF5b3V0LmhlaWdodCA9IGZhY3RvciA/IGZhY3RvciAqIGhCb3hNYXhIZWlnaHQgOiBmdWxsU2l6ZSAmJiBwYXJhbXMuYXZhaWxhYmxlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGFja3M7XG59XG5mdW5jdGlvbiBidWlsZExheW91dEJveGVzKGJveGVzKSB7XG4gICAgY29uc3QgbGF5b3V0Qm94ZXMgPSB3cmFwQm94ZXMoYm94ZXMpO1xuICAgIGNvbnN0IGZ1bGxTaXplID0gc29ydEJ5V2VpZ2h0KGxheW91dEJveGVzLmZpbHRlcigod3JhcCk9PndyYXAuYm94LmZ1bGxTaXplKSwgdHJ1ZSk7XG4gICAgY29uc3QgbGVmdCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAnbGVmdCcpLCB0cnVlKTtcbiAgICBjb25zdCByaWdodCA9IHNvcnRCeVdlaWdodChmaWx0ZXJCeVBvc2l0aW9uKGxheW91dEJveGVzLCAncmlnaHQnKSk7XG4gICAgY29uc3QgdG9wID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICd0b3AnKSwgdHJ1ZSk7XG4gICAgY29uc3QgYm90dG9tID0gc29ydEJ5V2VpZ2h0KGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdib3R0b20nKSk7XG4gICAgY29uc3QgY2VudGVySG9yaXpvbnRhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3gnKTtcbiAgICBjb25zdCBjZW50ZXJWZXJ0aWNhbCA9IGZpbHRlckR5bmFtaWNQb3NpdGlvbkJ5QXhpcyhsYXlvdXRCb3hlcywgJ3knKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmdWxsU2l6ZSxcbiAgICAgICAgbGVmdEFuZFRvcDogbGVmdC5jb25jYXQodG9wKSxcbiAgICAgICAgcmlnaHRBbmRCb3R0b206IHJpZ2h0LmNvbmNhdChjZW50ZXJWZXJ0aWNhbCkuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpLFxuICAgICAgICBjaGFydEFyZWE6IGZpbHRlckJ5UG9zaXRpb24obGF5b3V0Qm94ZXMsICdjaGFydEFyZWEnKSxcbiAgICAgICAgdmVydGljYWw6IGxlZnQuY29uY2F0KHJpZ2h0KS5jb25jYXQoY2VudGVyVmVydGljYWwpLFxuICAgICAgICBob3Jpem9udGFsOiB0b3AuY29uY2F0KGJvdHRvbSkuY29uY2F0KGNlbnRlckhvcml6b250YWwpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldENvbWJpbmVkTWF4KG1heFBhZGRpbmcsIGNoYXJ0QXJlYSwgYSwgYikge1xuICAgIHJldHVybiBNYXRoLm1heChtYXhQYWRkaW5nW2FdLCBjaGFydEFyZWFbYV0pICsgTWF0aC5tYXgobWF4UGFkZGluZ1tiXSwgY2hhcnRBcmVhW2JdKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgYm94UGFkZGluZykge1xuICAgIG1heFBhZGRpbmcudG9wID0gTWF0aC5tYXgobWF4UGFkZGluZy50b3AsIGJveFBhZGRpbmcudG9wKTtcbiAgICBtYXhQYWRkaW5nLmxlZnQgPSBNYXRoLm1heChtYXhQYWRkaW5nLmxlZnQsIGJveFBhZGRpbmcubGVmdCk7XG4gICAgbWF4UGFkZGluZy5ib3R0b20gPSBNYXRoLm1heChtYXhQYWRkaW5nLmJvdHRvbSwgYm94UGFkZGluZy5ib3R0b20pO1xuICAgIG1heFBhZGRpbmcucmlnaHQgPSBNYXRoLm1heChtYXhQYWRkaW5nLnJpZ2h0LCBib3hQYWRkaW5nLnJpZ2h0KTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZURpbXMoY2hhcnRBcmVhLCBwYXJhbXMsIGxheW91dCwgc3RhY2tzKSB7XG4gICAgY29uc3QgeyBwb3MgLCBib3ggIH0gPSBsYXlvdXQ7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICAgIGlmICghaXNPYmplY3QocG9zKSkge1xuICAgICAgICBpZiAobGF5b3V0LnNpemUpIHtcbiAgICAgICAgICAgIGNoYXJ0QXJlYVtwb3NdIC09IGxheW91dC5zaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge1xuICAgICAgICAgICAgc2l6ZTogMCxcbiAgICAgICAgICAgIGNvdW50OiAxXG4gICAgICAgIH07XG4gICAgICAgIHN0YWNrLnNpemUgPSBNYXRoLm1heChzdGFjay5zaXplLCBsYXlvdXQuaG9yaXpvbnRhbCA/IGJveC5oZWlnaHQgOiBib3gud2lkdGgpO1xuICAgICAgICBsYXlvdXQuc2l6ZSA9IHN0YWNrLnNpemUgLyBzdGFjay5jb3VudDtcbiAgICAgICAgY2hhcnRBcmVhW3Bvc10gKz0gbGF5b3V0LnNpemU7XG4gICAgfVxuICAgIGlmIChib3guZ2V0UGFkZGluZykge1xuICAgICAgICB1cGRhdGVNYXhQYWRkaW5nKG1heFBhZGRpbmcsIGJveC5nZXRQYWRkaW5nKCkpO1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KDAsIHBhcmFtcy5vdXRlcldpZHRoIC0gZ2V0Q29tYmluZWRNYXgobWF4UGFkZGluZywgY2hhcnRBcmVhLCAnbGVmdCcsICdyaWdodCcpKTtcbiAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heCgwLCBwYXJhbXMub3V0ZXJIZWlnaHQgLSBnZXRDb21iaW5lZE1heChtYXhQYWRkaW5nLCBjaGFydEFyZWEsICd0b3AnLCAnYm90dG9tJykpO1xuICAgIGNvbnN0IHdpZHRoQ2hhbmdlZCA9IG5ld1dpZHRoICE9PSBjaGFydEFyZWEudztcbiAgICBjb25zdCBoZWlnaHRDaGFuZ2VkID0gbmV3SGVpZ2h0ICE9PSBjaGFydEFyZWEuaDtcbiAgICBjaGFydEFyZWEudyA9IG5ld1dpZHRoO1xuICAgIGNoYXJ0QXJlYS5oID0gbmV3SGVpZ2h0O1xuICAgIHJldHVybiBsYXlvdXQuaG9yaXpvbnRhbCA/IHtcbiAgICAgICAgc2FtZTogd2lkdGhDaGFuZ2VkLFxuICAgICAgICBvdGhlcjogaGVpZ2h0Q2hhbmdlZFxuICAgIH0gOiB7XG4gICAgICAgIHNhbWU6IGhlaWdodENoYW5nZWQsXG4gICAgICAgIG90aGVyOiB3aWR0aENoYW5nZWRcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpIHtcbiAgICBjb25zdCBtYXhQYWRkaW5nID0gY2hhcnRBcmVhLm1heFBhZGRpbmc7XG4gICAgZnVuY3Rpb24gdXBkYXRlUG9zKHBvcykge1xuICAgICAgICBjb25zdCBjaGFuZ2UgPSBNYXRoLm1heChtYXhQYWRkaW5nW3Bvc10gLSBjaGFydEFyZWFbcG9zXSwgMCk7XG4gICAgICAgIGNoYXJ0QXJlYVtwb3NdICs9IGNoYW5nZTtcbiAgICAgICAgcmV0dXJuIGNoYW5nZTtcbiAgICB9XG4gICAgY2hhcnRBcmVhLnkgKz0gdXBkYXRlUG9zKCd0b3AnKTtcbiAgICBjaGFydEFyZWEueCArPSB1cGRhdGVQb3MoJ2xlZnQnKTtcbiAgICB1cGRhdGVQb3MoJ3JpZ2h0Jyk7XG4gICAgdXBkYXRlUG9zKCdib3R0b20nKTtcbn1cbmZ1bmN0aW9uIGdldE1hcmdpbnMoaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSB7XG4gICAgY29uc3QgbWF4UGFkZGluZyA9IGNoYXJ0QXJlYS5tYXhQYWRkaW5nO1xuICAgIGZ1bmN0aW9uIG1hcmdpbkZvclBvc2l0aW9ucyhwb3NpdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWFyZ2luID0ge1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH07XG4gICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKChwb3MpPT57XG4gICAgICAgICAgICBtYXJnaW5bcG9zXSA9IE1hdGgubWF4KGNoYXJ0QXJlYVtwb3NdLCBtYXhQYWRkaW5nW3Bvc10pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9XG4gICAgcmV0dXJuIGhvcml6b250YWwgPyBtYXJnaW5Gb3JQb3NpdGlvbnMoW1xuICAgICAgICAnbGVmdCcsXG4gICAgICAgICdyaWdodCdcbiAgICBdKSA6IG1hcmdpbkZvclBvc2l0aW9ucyhbXG4gICAgICAgICd0b3AnLFxuICAgICAgICAnYm90dG9tJ1xuICAgIF0pO1xufVxuZnVuY3Rpb24gZml0Qm94ZXMoYm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpIHtcbiAgICBjb25zdCByZWZpdEJveGVzID0gW107XG4gICAgbGV0IGksIGlsZW4sIGxheW91dCwgYm94LCByZWZpdCwgY2hhbmdlZDtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBib3hlcy5sZW5ndGgsIHJlZml0ID0gMDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGxheW91dCA9IGJveGVzW2ldO1xuICAgICAgICBib3ggPSBsYXlvdXQuYm94O1xuICAgICAgICBib3gudXBkYXRlKGxheW91dC53aWR0aCB8fCBjaGFydEFyZWEudywgbGF5b3V0LmhlaWdodCB8fCBjaGFydEFyZWEuaCwgZ2V0TWFyZ2lucyhsYXlvdXQuaG9yaXpvbnRhbCwgY2hhcnRBcmVhKSk7XG4gICAgICAgIGNvbnN0IHsgc2FtZSAsIG90aGVyICB9ID0gdXBkYXRlRGltcyhjaGFydEFyZWEsIHBhcmFtcywgbGF5b3V0LCBzdGFja3MpO1xuICAgICAgICByZWZpdCB8PSBzYW1lICYmIHJlZml0Qm94ZXMubGVuZ3RoO1xuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBvdGhlcjtcbiAgICAgICAgaWYgKCFib3guZnVsbFNpemUpIHtcbiAgICAgICAgICAgIHJlZml0Qm94ZXMucHVzaChsYXlvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWZpdCAmJiBmaXRCb3hlcyhyZWZpdEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB8fCBjaGFuZ2VkO1xufVxuZnVuY3Rpb24gc2V0Qm94RGltcyhib3gsIGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgIGJveC50b3AgPSB0b3A7XG4gICAgYm94LmxlZnQgPSBsZWZ0O1xuICAgIGJveC5yaWdodCA9IGxlZnQgKyB3aWR0aDtcbiAgICBib3guYm90dG9tID0gdG9wICsgaGVpZ2h0O1xuICAgIGJveC53aWR0aCA9IHdpZHRoO1xuICAgIGJveC5oZWlnaHQgPSBoZWlnaHQ7XG59XG5mdW5jdGlvbiBwbGFjZUJveGVzKGJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSB7XG4gICAgY29uc3QgdXNlclBhZGRpbmcgPSBwYXJhbXMucGFkZGluZztcbiAgICBsZXQgeyB4ICwgeSAgfSA9IGNoYXJ0QXJlYTtcbiAgICBmb3IgKGNvbnN0IGxheW91dCBvZiBib3hlcyl7XG4gICAgICAgIGNvbnN0IGJveCA9IGxheW91dC5ib3g7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gc3RhY2tzW2xheW91dC5zdGFja10gfHwge1xuICAgICAgICAgICAgY291bnQ6IDEsXG4gICAgICAgICAgICBwbGFjZWQ6IDAsXG4gICAgICAgICAgICB3ZWlnaHQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgd2VpZ2h0ID0gbGF5b3V0LnN0YWNrV2VpZ2h0IC8gc3RhY2sud2VpZ2h0IHx8IDE7XG4gICAgICAgIGlmIChsYXlvdXQuaG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBjaGFydEFyZWEudyAqIHdlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHN0YWNrLnNpemUgfHwgYm94LmhlaWdodDtcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHkgPSBzdGFjay5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgICAgICAgICBzZXRCb3hEaW1zKGJveCwgdXNlclBhZGRpbmcubGVmdCwgeSwgcGFyYW1zLm91dGVyV2lkdGggLSB1c2VyUGFkZGluZy5yaWdodCAtIHVzZXJQYWRkaW5nLmxlZnQsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEJveERpbXMoYm94LCBjaGFydEFyZWEubGVmdCArIHN0YWNrLnBsYWNlZCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5zdGFydCA9IHk7XG4gICAgICAgICAgICBzdGFjay5wbGFjZWQgKz0gd2lkdGg7XG4gICAgICAgICAgICB5ID0gYm94LmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGNoYXJ0QXJlYS5oICogd2VpZ2h0O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSBzdGFjay5zaXplIHx8IGJveC53aWR0aDtcbiAgICAgICAgICAgIGlmIChkZWZpbmVkKHN0YWNrLnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHggPSBzdGFjay5zdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib3guZnVsbFNpemUpIHtcbiAgICAgICAgICAgICAgICBzZXRCb3hEaW1zKGJveCwgeCwgdXNlclBhZGRpbmcudG9wLCB3aWR0aCwgcGFyYW1zLm91dGVySGVpZ2h0IC0gdXNlclBhZGRpbmcuYm90dG9tIC0gdXNlclBhZGRpbmcudG9wKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0Qm94RGltcyhib3gsIHgsIGNoYXJ0QXJlYS50b3AgKyBzdGFjay5wbGFjZWQsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhY2suc3RhcnQgPSB4O1xuICAgICAgICAgICAgc3RhY2sucGxhY2VkICs9IGhlaWdodDtcbiAgICAgICAgICAgIHggPSBib3gucmlnaHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hhcnRBcmVhLnggPSB4O1xuICAgIGNoYXJ0QXJlYS55ID0geTtcbn1cbnZhciBsYXlvdXRzID0ge1xuIGFkZEJveCAoY2hhcnQsIGl0ZW0pIHtcbiAgICAgICAgaWYgKCFjaGFydC5ib3hlcykge1xuICAgICAgICAgICAgY2hhcnQuYm94ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtLmZ1bGxTaXplID0gaXRlbS5mdWxsU2l6ZSB8fCBmYWxzZTtcbiAgICAgICAgaXRlbS5wb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24gfHwgJ3RvcCc7XG4gICAgICAgIGl0ZW0ud2VpZ2h0ID0gaXRlbS53ZWlnaHQgfHwgMDtcbiAgICAgICAgaXRlbS5fbGF5ZXJzID0gaXRlbS5fbGF5ZXJzIHx8IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICAgICAgICAgIGRyYXcgKGNoYXJ0QXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9O1xuICAgICAgICBjaGFydC5ib3hlcy5wdXNoKGl0ZW0pO1xuICAgIH0sXG4gcmVtb3ZlQm94IChjaGFydCwgbGF5b3V0SXRlbSkge1xuICAgICAgICBjb25zdCBpbmRleCA9IGNoYXJ0LmJveGVzID8gY2hhcnQuYm94ZXMuaW5kZXhPZihsYXlvdXRJdGVtKSA6IC0xO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBjaGFydC5ib3hlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgfSxcbiBjb25maWd1cmUgKGNoYXJ0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGl0ZW0uZnVsbFNpemUgPSBvcHRpb25zLmZ1bGxTaXplO1xuICAgICAgICBpdGVtLnBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgaXRlbS53ZWlnaHQgPSBvcHRpb25zLndlaWdodDtcbiAgICB9LFxuIHVwZGF0ZSAoY2hhcnQsIHdpZHRoLCBoZWlnaHQsIG1pblBhZGRpbmcpIHtcbiAgICAgICAgaWYgKCFjaGFydCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcoY2hhcnQub3B0aW9ucy5sYXlvdXQucGFkZGluZyk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVdpZHRoID0gTWF0aC5tYXgod2lkdGggLSBwYWRkaW5nLndpZHRoLCAwKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlSGVpZ2h0ID0gTWF0aC5tYXgoaGVpZ2h0IC0gcGFkZGluZy5oZWlnaHQsIDApO1xuICAgICAgICBjb25zdCBib3hlcyA9IGJ1aWxkTGF5b3V0Qm94ZXMoY2hhcnQuYm94ZXMpO1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbEJveGVzID0gYm94ZXMudmVydGljYWw7XG4gICAgICAgIGNvbnN0IGhvcml6b250YWxCb3hlcyA9IGJveGVzLmhvcml6b250YWw7XG4gICAgICAgIGVhY2goY2hhcnQuYm94ZXMsIChib3gpPT57XG4gICAgICAgICAgICBpZiAodHlwZW9mIGJveC5iZWZvcmVMYXlvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBib3guYmVmb3JlTGF5b3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB2aXNpYmxlVmVydGljYWxCb3hDb3VudCA9IHZlcnRpY2FsQm94ZXMucmVkdWNlKCh0b3RhbCwgd3JhcCk9PndyYXAuYm94Lm9wdGlvbnMgJiYgd3JhcC5ib3gub3B0aW9ucy5kaXNwbGF5ID09PSBmYWxzZSA/IHRvdGFsIDogdG90YWwgKyAxLCAwKSB8fCAxO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIG91dGVyV2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgb3V0ZXJIZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgIHBhZGRpbmcsXG4gICAgICAgICAgICBhdmFpbGFibGVXaWR0aCxcbiAgICAgICAgICAgIGF2YWlsYWJsZUhlaWdodCxcbiAgICAgICAgICAgIHZCb3hNYXhXaWR0aDogYXZhaWxhYmxlV2lkdGggLyAyIC8gdmlzaWJsZVZlcnRpY2FsQm94Q291bnQsXG4gICAgICAgICAgICBoQm94TWF4SGVpZ2h0OiBhdmFpbGFibGVIZWlnaHQgLyAyXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBtYXhQYWRkaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgcGFkZGluZyk7XG4gICAgICAgIHVwZGF0ZU1heFBhZGRpbmcobWF4UGFkZGluZywgdG9QYWRkaW5nKG1pblBhZGRpbmcpKTtcbiAgICAgICAgY29uc3QgY2hhcnRBcmVhID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICBtYXhQYWRkaW5nLFxuICAgICAgICAgICAgdzogYXZhaWxhYmxlV2lkdGgsXG4gICAgICAgICAgICBoOiBhdmFpbGFibGVIZWlnaHQsXG4gICAgICAgICAgICB4OiBwYWRkaW5nLmxlZnQsXG4gICAgICAgICAgICB5OiBwYWRkaW5nLnRvcFxuICAgICAgICB9LCBwYWRkaW5nKTtcbiAgICAgICAgY29uc3Qgc3RhY2tzID0gc2V0TGF5b3V0RGltcyh2ZXJ0aWNhbEJveGVzLmNvbmNhdChob3Jpem9udGFsQm94ZXMpLCBwYXJhbXMpO1xuICAgICAgICBmaXRCb3hlcyhib3hlcy5mdWxsU2l6ZSwgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgICAgIGZpdEJveGVzKHZlcnRpY2FsQm94ZXMsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgICAgICBpZiAoZml0Qm94ZXMoaG9yaXpvbnRhbEJveGVzLCBjaGFydEFyZWEsIHBhcmFtcywgc3RhY2tzKSkge1xuICAgICAgICAgICAgZml0Qm94ZXModmVydGljYWxCb3hlcywgY2hhcnRBcmVhLCBwYXJhbXMsIHN0YWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlTWF4UGFkZGluZyhjaGFydEFyZWEpO1xuICAgICAgICBwbGFjZUJveGVzKGJveGVzLmxlZnRBbmRUb3AsIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgICAgICBjaGFydEFyZWEueCArPSBjaGFydEFyZWEudztcbiAgICAgICAgY2hhcnRBcmVhLnkgKz0gY2hhcnRBcmVhLmg7XG4gICAgICAgIHBsYWNlQm94ZXMoYm94ZXMucmlnaHRBbmRCb3R0b20sIGNoYXJ0QXJlYSwgcGFyYW1zLCBzdGFja3MpO1xuICAgICAgICBjaGFydC5jaGFydEFyZWEgPSB7XG4gICAgICAgICAgICBsZWZ0OiBjaGFydEFyZWEubGVmdCxcbiAgICAgICAgICAgIHRvcDogY2hhcnRBcmVhLnRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiBjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS53LFxuICAgICAgICAgICAgYm90dG9tOiBjaGFydEFyZWEudG9wICsgY2hhcnRBcmVhLmgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNoYXJ0QXJlYS5oLFxuICAgICAgICAgICAgd2lkdGg6IGNoYXJ0QXJlYS53XG4gICAgICAgIH07XG4gICAgICAgIGVhY2goYm94ZXMuY2hhcnRBcmVhLCAobGF5b3V0KT0+e1xuICAgICAgICAgICAgY29uc3QgYm94ID0gbGF5b3V0LmJveDtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oYm94LCBjaGFydC5jaGFydEFyZWEpO1xuICAgICAgICAgICAgYm94LnVwZGF0ZShjaGFydEFyZWEudywgY2hhcnRBcmVhLmgsIHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICBib3R0b206IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5jbGFzcyBCYXNlUGxhdGZvcm0ge1xuIGFjcXVpcmVDb250ZXh0KGNhbnZhcywgYXNwZWN0UmF0aW8pIHt9XG4gcmVsZWFzZUNvbnRleHQoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuIGFkZEV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7fVxuIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiBnZXRNYXhpbXVtU2l6ZShlbGVtZW50LCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgICAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoIHx8IGVsZW1lbnQud2lkdGgpO1xuICAgICAgICBoZWlnaHQgPSBoZWlnaHQgfHwgZWxlbWVudC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5tYXgoMCwgYXNwZWN0UmF0aW8gPyBNYXRoLmZsb29yKHdpZHRoIC8gYXNwZWN0UmF0aW8pIDogaGVpZ2h0KVxuICAgICAgICB9O1xuICAgIH1cbiBpc0F0dGFjaGVkKGNhbnZhcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gdXBkYXRlQ29uZmlnKGNvbmZpZykge1xuICAgIH1cbn1cblxuY2xhc3MgQmFzaWNQbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gICAgYWNxdWlyZUNvbnRleHQoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAmJiBpdGVtLmdldENvbnRleHQgJiYgaXRlbS5nZXRDb250ZXh0KCcyZCcpIHx8IG51bGw7XG4gICAgfVxuICAgIHVwZGF0ZUNvbmZpZyhjb25maWcpIHtcbiAgICAgICAgY29uZmlnLm9wdGlvbnMuYW5pbWF0aW9uID0gZmFsc2U7XG4gICAgfVxufVxuXG5jb25zdCBFWFBBTkRPX0tFWSA9ICckY2hhcnRqcyc7XG4gY29uc3QgRVZFTlRfVFlQRVMgPSB7XG4gICAgdG91Y2hzdGFydDogJ21vdXNlZG93bicsXG4gICAgdG91Y2htb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgICB0b3VjaGVuZDogJ21vdXNldXAnLFxuICAgIHBvaW50ZXJlbnRlcjogJ21vdXNlZW50ZXInLFxuICAgIHBvaW50ZXJkb3duOiAnbW91c2Vkb3duJyxcbiAgICBwb2ludGVybW92ZTogJ21vdXNlbW92ZScsXG4gICAgcG9pbnRlcnVwOiAnbW91c2V1cCcsXG4gICAgcG9pbnRlcmxlYXZlOiAnbW91c2VvdXQnLFxuICAgIHBvaW50ZXJvdXQ6ICdtb3VzZW91dCdcbn07XG5jb25zdCBpc051bGxPckVtcHR5ID0gKHZhbHVlKT0+dmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09ICcnO1xuIGZ1bmN0aW9uIGluaXRDYW52YXMoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgIGNvbnN0IHN0eWxlID0gY2FudmFzLnN0eWxlO1xuICAgIGNvbnN0IHJlbmRlckhlaWdodCA9IGNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICAgIGNvbnN0IHJlbmRlcldpZHRoID0gY2FudmFzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKTtcbiAgICBjYW52YXNbRVhQQU5ET19LRVldID0ge1xuICAgICAgICBpbml0aWFsOiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHJlbmRlckhlaWdodCxcbiAgICAgICAgICAgIHdpZHRoOiByZW5kZXJXaWR0aCxcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogc3R5bGUuZGlzcGxheSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHN0eWxlLmhlaWdodCxcbiAgICAgICAgICAgICAgICB3aWR0aDogc3R5bGUud2lkdGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgc3R5bGUuZGlzcGxheSA9IHN0eWxlLmRpc3BsYXkgfHwgJ2Jsb2NrJztcbiAgICBzdHlsZS5ib3hTaXppbmcgPSBzdHlsZS5ib3hTaXppbmcgfHwgJ2JvcmRlci1ib3gnO1xuICAgIGlmIChpc051bGxPckVtcHR5KHJlbmRlcldpZHRoKSkge1xuICAgICAgICBjb25zdCBkaXNwbGF5V2lkdGggPSByZWFkVXNlZFNpemUoY2FudmFzLCAnd2lkdGgnKTtcbiAgICAgICAgaWYgKGRpc3BsYXlXaWR0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBkaXNwbGF5V2lkdGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzTnVsbE9yRW1wdHkocmVuZGVySGVpZ2h0KSkge1xuICAgICAgICBpZiAoY2FudmFzLnN0eWxlLmhlaWdodCA9PT0gJycpIHtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGggLyAoYXNwZWN0UmF0aW8gfHwgMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5SGVpZ2h0ID0gcmVhZFVzZWRTaXplKGNhbnZhcywgJ2hlaWdodCcpO1xuICAgICAgICAgICAgaWYgKGRpc3BsYXlIZWlnaHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBkaXNwbGF5SGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYW52YXM7XG59XG5jb25zdCBldmVudExpc3RlbmVyT3B0aW9ucyA9IHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgPyB7XG4gICAgcGFzc2l2ZTogdHJ1ZVxufSA6IGZhbHNlO1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIobm9kZSwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAobm9kZSkge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZiAoY2hhcnQgJiYgY2hhcnQuY2FudmFzKSB7XG4gICAgICAgIGNoYXJ0LmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBldmVudExpc3RlbmVyT3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICAgIGNvbnN0IHR5cGUgPSBFVkVOVF9UWVBFU1tldmVudC50eXBlXSB8fCBldmVudC50eXBlO1xuICAgIGNvbnN0IHsgeCAsIHkgIH0gPSBnZXRSZWxhdGl2ZVBvc2l0aW9uKGV2ZW50LCBjaGFydCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2hhcnQsXG4gICAgICAgIG5hdGl2ZTogZXZlbnQsXG4gICAgICAgIHg6IHggIT09IHVuZGVmaW5lZCA/IHggOiBudWxsLFxuICAgICAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbFxuICAgIH07XG59XG5mdW5jdGlvbiBub2RlTGlzdENvbnRhaW5zKG5vZGVMaXN0LCBjYW52YXMpIHtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxpc3Qpe1xuICAgICAgICBpZiAobm9kZSA9PT0gY2FudmFzIHx8IG5vZGUuY29udGFpbnMoY2FudmFzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVBdHRhY2hPYnNlcnZlcihjaGFydCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjb25zdCBjYW52YXMgPSBjaGFydC5jYW52YXM7XG4gICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgbGV0IHRyaWdnZXIgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKXtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyIHx8IG5vZGVMaXN0Q29udGFpbnMoZW50cnkuYWRkZWROb2RlcywgY2FudmFzKTtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHJpZ2dlcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ic2VydmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRGV0YWNoT2JzZXJ2ZXIoY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKGVudHJpZXMpPT57XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcyl7XG4gICAgICAgICAgICB0cmlnZ2VyID0gdHJpZ2dlciB8fCBub2RlTGlzdENvbnRhaW5zKGVudHJ5LnJlbW92ZWROb2RlcywgY2FudmFzKTtcbiAgICAgICAgICAgIHRyaWdnZXIgPSB0cmlnZ2VyICYmICFub2RlTGlzdENvbnRhaW5zKGVudHJ5LmFkZGVkTm9kZXMsIGNhbnZhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBvYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmNvbnN0IGRycExpc3RlbmluZ0NoYXJ0cyA9IG5ldyBNYXAoKTtcbmxldCBvbGREZXZpY2VQaXhlbFJhdGlvID0gMDtcbmZ1bmN0aW9uIG9uV2luZG93UmVzaXplKCkge1xuICAgIGNvbnN0IGRwciA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIGlmIChkcHIgPT09IG9sZERldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvbGREZXZpY2VQaXhlbFJhdGlvID0gZHByO1xuICAgIGRycExpc3RlbmluZ0NoYXJ0cy5mb3JFYWNoKChyZXNpemUsIGNoYXJ0KT0+e1xuICAgICAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IGRwcikge1xuICAgICAgICAgICAgcmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpIHtcbiAgICBpZiAoIWRycExpc3RlbmluZ0NoYXJ0cy5zaXplKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvbldpbmRvd1Jlc2l6ZSk7XG4gICAgfVxuICAgIGRycExpc3RlbmluZ0NoYXJ0cy5zZXQoY2hhcnQsIHJlc2l6ZSk7XG59XG5mdW5jdGlvbiB1bmxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0KSB7XG4gICAgZHJwTGlzdGVuaW5nQ2hhcnRzLmRlbGV0ZShjaGFydCk7XG4gICAgaWYgKCFkcnBMaXN0ZW5pbmdDaGFydHMuc2l6ZSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25XaW5kb3dSZXNpemUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc2l6ZU9ic2VydmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICBpZiAoIWNvbnRhaW5lcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlc2l6ZSA9IHRocm90dGxlZCgod2lkdGgsIGhlaWdodCk9PntcbiAgICAgICAgY29uc3QgdyA9IGNvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICAgICAgbGlzdGVuZXIod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGlmICh3IDwgY29udGFpbmVyLmNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcigpO1xuICAgICAgICB9XG4gICAgfSwgd2luZG93KTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcyk9PntcbiAgICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgICAgICBjb25zdCB3aWR0aCA9IGVudHJ5LmNvbnRlbnRSZWN0LndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBlbnRyeS5jb250ZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfSk7XG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZShjb250YWluZXIpO1xuICAgIGxpc3RlbkRldmljZVBpeGVsUmF0aW9DaGFuZ2VzKGNoYXJ0LCByZXNpemUpO1xuICAgIHJldHVybiBvYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIHJlbGVhc2VPYnNlcnZlcihjaGFydCwgdHlwZSwgb2JzZXJ2ZXIpIHtcbiAgICBpZiAob2JzZXJ2ZXIpIHtcbiAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgdW5saXN0ZW5EZXZpY2VQaXhlbFJhdGlvQ2hhbmdlcyhjaGFydCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUHJveHlBbmRMaXN0ZW4oY2hhcnQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY29uc3QgY2FudmFzID0gY2hhcnQuY2FudmFzO1xuICAgIGNvbnN0IHByb3h5ID0gdGhyb3R0bGVkKChldmVudCk9PntcbiAgICAgICAgaWYgKGNoYXJ0LmN0eCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGlzdGVuZXIoZnJvbU5hdGl2ZUV2ZW50KGV2ZW50LCBjaGFydCkpO1xuICAgICAgICB9XG4gICAgfSwgY2hhcnQpO1xuICAgIGFkZExpc3RlbmVyKGNhbnZhcywgdHlwZSwgcHJveHkpO1xuICAgIHJldHVybiBwcm94eTtcbn1cbiBjbGFzcyBEb21QbGF0Zm9ybSBleHRlbmRzIEJhc2VQbGF0Zm9ybSB7XG4gYWNxdWlyZUNvbnRleHQoY2FudmFzLCBhc3BlY3RSYXRpbykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0ICYmIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0LmNhbnZhcyA9PT0gY2FudmFzKSB7XG4gICAgICAgICAgICBpbml0Q2FudmFzKGNhbnZhcywgYXNwZWN0UmF0aW8pO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuIHJlbGVhc2VDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgICAgIGlmICghY2FudmFzW0VYUEFORE9fS0VZXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluaXRpYWwgPSBjYW52YXNbRVhQQU5ET19LRVldLmluaXRpYWw7XG4gICAgICAgIFtcbiAgICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICAgICAgJ3dpZHRoJ1xuICAgICAgICBdLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxbcHJvcF07XG4gICAgICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKHByb3ApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKHByb3AsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gaW5pdGlhbC5zdHlsZSB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoc3R5bGUpLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNhbnZhcy5zdHlsZVtrZXldID0gc3R5bGVba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgZGVsZXRlIGNhbnZhc1tFWFBBTkRPX0tFWV07XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiBhZGRFdmVudExpc3RlbmVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpO1xuICAgICAgICBjb25zdCBwcm94aWVzID0gY2hhcnQuJHByb3hpZXMgfHwgKGNoYXJ0LiRwcm94aWVzID0ge30pO1xuICAgICAgICBjb25zdCBoYW5kbGVycyA9IHtcbiAgICAgICAgICAgIGF0dGFjaDogY3JlYXRlQXR0YWNoT2JzZXJ2ZXIsXG4gICAgICAgICAgICBkZXRhY2g6IGNyZWF0ZURldGFjaE9ic2VydmVyLFxuICAgICAgICAgICAgcmVzaXplOiBjcmVhdGVSZXNpemVPYnNlcnZlclxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gaGFuZGxlcnNbdHlwZV0gfHwgY3JlYXRlUHJveHlBbmRMaXN0ZW47XG4gICAgICAgIHByb3hpZXNbdHlwZV0gPSBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgfVxuIHJlbW92ZUV2ZW50TGlzdGVuZXIoY2hhcnQsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgcHJveGllcyA9IGNoYXJ0LiRwcm94aWVzIHx8IChjaGFydC4kcHJveGllcyA9IHt9KTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBwcm94aWVzW3R5cGVdO1xuICAgICAgICBpZiAoIXByb3h5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBhdHRhY2g6IHJlbGVhc2VPYnNlcnZlcixcbiAgICAgICAgICAgIGRldGFjaDogcmVsZWFzZU9ic2VydmVyLFxuICAgICAgICAgICAgcmVzaXplOiByZWxlYXNlT2JzZXJ2ZXJcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW3R5cGVdIHx8IHJlbW92ZUxpc3RlbmVyO1xuICAgICAgICBoYW5kbGVyKGNoYXJ0LCB0eXBlLCBwcm94eSk7XG4gICAgICAgIHByb3hpZXNbdHlwZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldERldmljZVBpeGVsUmF0aW8oKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbykge1xuICAgICAgICByZXR1cm4gZ2V0TWF4aW11bVNpemUoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBhc3BlY3RSYXRpbyk7XG4gICAgfVxuIGlzQXR0YWNoZWQoY2FudmFzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IGNhbnZhcyAmJiBfZ2V0UGFyZW50Tm9kZShjYW52YXMpO1xuICAgICAgICByZXR1cm4gISEoY29udGFpbmVyICYmIGNvbnRhaW5lci5pc0Nvbm5lY3RlZCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBfZGV0ZWN0UGxhdGZvcm0oY2FudmFzKSB7XG4gICAgaWYgKCFfaXNEb21TdXBwb3J0ZWQoKSB8fCB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJyAmJiBjYW52YXMgaW5zdGFuY2VvZiBPZmZzY3JlZW5DYW52YXMpIHtcbiAgICAgICAgcmV0dXJuIEJhc2ljUGxhdGZvcm07XG4gICAgfVxuICAgIHJldHVybiBEb21QbGF0Zm9ybTtcbn1cblxuY2xhc3MgRWxlbWVudCB7XG4gICAgc3RhdGljIGRlZmF1bHRzID0ge307XG4gICAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB1bmRlZmluZWQ7XG4gICAgeDtcbiAgICB5O1xuICAgIGFjdGl2ZSA9IGZhbHNlO1xuICAgIG9wdGlvbnM7XG4gICAgJGFuaW1hdGlvbnM7XG4gICAgdG9vbHRpcFBvc2l0aW9uKHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgJ3knXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaGFzVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBpc051bWJlcih0aGlzLngpICYmIGlzTnVtYmVyKHRoaXMueSk7XG4gICAgfVxuICAgIGdldFByb3BzKHByb3BzLCBmaW5hbCkge1xuICAgICAgICBjb25zdCBhbmltcyA9IHRoaXMuJGFuaW1hdGlvbnM7XG4gICAgICAgIGlmICghZmluYWwgfHwgIWFuaW1zKSB7XG4gICAgICAgICAgICAvLyBsZXQncyBub3QgY3JlYXRlIGFuIG9iamVjdCwgaWYgbm90IG5lZWRlZFxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0ge307XG4gICAgICAgIHByb3BzLmZvckVhY2goKHByb3ApPT57XG4gICAgICAgICAgICByZXRbcHJvcF0gPSBhbmltc1twcm9wXSAmJiBhbmltc1twcm9wXS5hY3RpdmUoKSA/IGFuaW1zW3Byb3BdLl90byA6IHRoaXNbcHJvcF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYXV0b1NraXAoc2NhbGUsIHRpY2tzKSB7XG4gICAgY29uc3QgdGlja09wdHMgPSBzY2FsZS5vcHRpb25zLnRpY2tzO1xuICAgIGNvbnN0IGRldGVybWluZWRNYXhUaWNrcyA9IGRldGVybWluZU1heFRpY2tzKHNjYWxlKTtcbiAgICBjb25zdCB0aWNrc0xpbWl0ID0gTWF0aC5taW4odGlja09wdHMubWF4VGlja3NMaW1pdCB8fCBkZXRlcm1pbmVkTWF4VGlja3MsIGRldGVybWluZWRNYXhUaWNrcyk7XG4gICAgY29uc3QgbWFqb3JJbmRpY2VzID0gdGlja09wdHMubWFqb3IuZW5hYmxlZCA/IGdldE1ham9ySW5kaWNlcyh0aWNrcykgOiBbXTtcbiAgICBjb25zdCBudW1NYWpvckluZGljZXMgPSBtYWpvckluZGljZXMubGVuZ3RoO1xuICAgIGNvbnN0IGZpcnN0ID0gbWFqb3JJbmRpY2VzWzBdO1xuICAgIGNvbnN0IGxhc3QgPSBtYWpvckluZGljZXNbbnVtTWFqb3JJbmRpY2VzIC0gMV07XG4gICAgY29uc3QgbmV3VGlja3MgPSBbXTtcbiAgICBpZiAobnVtTWFqb3JJbmRpY2VzID4gdGlja3NMaW1pdCkge1xuICAgICAgICBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBudW1NYWpvckluZGljZXMgLyB0aWNrc0xpbWl0KTtcbiAgICAgICAgcmV0dXJuIG5ld1RpY2tzO1xuICAgIH1cbiAgICBjb25zdCBzcGFjaW5nID0gY2FsY3VsYXRlU3BhY2luZyhtYWpvckluZGljZXMsIHRpY2tzLCB0aWNrc0xpbWl0KTtcbiAgICBpZiAobnVtTWFqb3JJbmRpY2VzID4gMCkge1xuICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgY29uc3QgYXZnTWFqb3JTcGFjaW5nID0gbnVtTWFqb3JJbmRpY2VzID4gMSA/IE1hdGgucm91bmQoKGxhc3QgLSBmaXJzdCkgLyAobnVtTWFqb3JJbmRpY2VzIC0gMSkpIDogbnVsbDtcbiAgICAgICAgc2tpcCh0aWNrcywgbmV3VGlja3MsIHNwYWNpbmcsIGlzTnVsbE9yVW5kZWYoYXZnTWFqb3JTcGFjaW5nKSA/IDAgOiBmaXJzdCAtIGF2Z01ham9yU3BhY2luZywgZmlyc3QpO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBudW1NYWpvckluZGljZXMgLSAxOyBpIDwgaWxlbjsgaSsrKXtcbiAgICAgICAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBtYWpvckluZGljZXNbaV0sIG1ham9ySW5kaWNlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHNraXAodGlja3MsIG5ld1RpY2tzLCBzcGFjaW5nLCBsYXN0LCBpc051bGxPclVuZGVmKGF2Z01ham9yU3BhY2luZykgPyB0aWNrcy5sZW5ndGggOiBsYXN0ICsgYXZnTWFqb3JTcGFjaW5nKTtcbiAgICAgICAgcmV0dXJuIG5ld1RpY2tzO1xuICAgIH1cbiAgICBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZyk7XG4gICAgcmV0dXJuIG5ld1RpY2tzO1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTWF4VGlja3Moc2NhbGUpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBzY2FsZS5vcHRpb25zLm9mZnNldDtcbiAgICBjb25zdCB0aWNrTGVuZ3RoID0gc2NhbGUuX3RpY2tTaXplKCk7XG4gICAgY29uc3QgbWF4U2NhbGUgPSBzY2FsZS5fbGVuZ3RoIC8gdGlja0xlbmd0aCArIChvZmZzZXQgPyAwIDogMSk7XG4gICAgY29uc3QgbWF4Q2hhcnQgPSBzY2FsZS5fbWF4TGVuZ3RoIC8gdGlja0xlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLm1pbihtYXhTY2FsZSwgbWF4Q2hhcnQpKTtcbn1cbiBmdW5jdGlvbiBjYWxjdWxhdGVTcGFjaW5nKG1ham9ySW5kaWNlcywgdGlja3MsIHRpY2tzTGltaXQpIHtcbiAgICBjb25zdCBldmVuTWFqb3JTcGFjaW5nID0gZ2V0RXZlblNwYWNpbmcobWFqb3JJbmRpY2VzKTtcbiAgICBjb25zdCBzcGFjaW5nID0gdGlja3MubGVuZ3RoIC8gdGlja3NMaW1pdDtcbiAgICBpZiAoIWV2ZW5NYWpvclNwYWNpbmcpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xuICAgIH1cbiAgICBjb25zdCBmYWN0b3JzID0gX2ZhY3Rvcml6ZShldmVuTWFqb3JTcGFjaW5nKTtcbiAgICBmb3IobGV0IGkgPSAwLCBpbGVuID0gZmFjdG9ycy5sZW5ndGggLSAxOyBpIDwgaWxlbjsgaSsrKXtcbiAgICAgICAgY29uc3QgZmFjdG9yID0gZmFjdG9yc1tpXTtcbiAgICAgICAgaWYgKGZhY3RvciA+IHNwYWNpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwYWNpbmcsIDEpO1xufVxuIGZ1bmN0aW9uIGdldE1ham9ySW5kaWNlcyh0aWNrcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGZvcihpID0gMCwgaWxlbiA9IHRpY2tzLmxlbmd0aDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgIGlmICh0aWNrc1tpXS5tYWpvcikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbiBmdW5jdGlvbiBza2lwTWFqb3JzKHRpY2tzLCBuZXdUaWNrcywgbWFqb3JJbmRpY2VzLCBzcGFjaW5nKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBsZXQgbmV4dCA9IG1ham9ySW5kaWNlc1swXTtcbiAgICBsZXQgaTtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICAgIGZvcihpID0gMDsgaSA8IHRpY2tzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYgKGkgPT09IG5leHQpIHtcbiAgICAgICAgICAgIG5ld1RpY2tzLnB1c2godGlja3NbaV0pO1xuICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgIG5leHQgPSBtYWpvckluZGljZXNbY291bnQgKiBzcGFjaW5nXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiBmdW5jdGlvbiBza2lwKHRpY2tzLCBuZXdUaWNrcywgc3BhY2luZywgbWFqb3JTdGFydCwgbWFqb3JFbmQpIHtcbiAgICBjb25zdCBzdGFydCA9IHZhbHVlT3JEZWZhdWx0KG1ham9yU3RhcnQsIDApO1xuICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKHZhbHVlT3JEZWZhdWx0KG1ham9yRW5kLCB0aWNrcy5sZW5ndGgpLCB0aWNrcy5sZW5ndGgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IGxlbmd0aCwgaSwgbmV4dDtcbiAgICBzcGFjaW5nID0gTWF0aC5jZWlsKHNwYWNpbmcpO1xuICAgIGlmIChtYWpvckVuZCkge1xuICAgICAgICBsZW5ndGggPSBtYWpvckVuZCAtIG1ham9yU3RhcnQ7XG4gICAgICAgIHNwYWNpbmcgPSBsZW5ndGggLyBNYXRoLmZsb29yKGxlbmd0aCAvIHNwYWNpbmcpO1xuICAgIH1cbiAgICBuZXh0ID0gc3RhcnQ7XG4gICAgd2hpbGUobmV4dCA8IDApe1xuICAgICAgICBjb3VudCsrO1xuICAgICAgICBuZXh0ID0gTWF0aC5yb3VuZChzdGFydCArIGNvdW50ICogc3BhY2luZyk7XG4gICAgfVxuICAgIGZvcihpID0gTWF0aC5tYXgoc3RhcnQsIDApOyBpIDwgZW5kOyBpKyspe1xuICAgICAgICBpZiAoaSA9PT0gbmV4dCkge1xuICAgICAgICAgICAgbmV3VGlja3MucHVzaCh0aWNrc1tpXSk7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbmV4dCA9IE1hdGgucm91bmQoc3RhcnQgKyBjb3VudCAqIHNwYWNpbmcpO1xuICAgICAgICB9XG4gICAgfVxufVxuIGZ1bmN0aW9uIGdldEV2ZW5TcGFjaW5nKGFycikge1xuICAgIGNvbnN0IGxlbiA9IGFyci5sZW5ndGg7XG4gICAgbGV0IGksIGRpZmY7XG4gICAgaWYgKGxlbiA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IoZGlmZiA9IGFyclswXSwgaSA9IDE7IGkgPCBsZW47ICsraSl7XG4gICAgICAgIGlmIChhcnJbaV0gLSBhcnJbaSAtIDFdICE9PSBkaWZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmY7XG59XG5cbmNvbnN0IHJldmVyc2VBbGlnbiA9IChhbGlnbik9PmFsaWduID09PSAnbGVmdCcgPyAncmlnaHQnIDogYWxpZ24gPT09ICdyaWdodCcgPyAnbGVmdCcgOiBhbGlnbjtcbmNvbnN0IG9mZnNldEZyb21FZGdlID0gKHNjYWxlLCBlZGdlLCBvZmZzZXQpPT5lZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnbGVmdCcgPyBzY2FsZVtlZGdlXSArIG9mZnNldCA6IHNjYWxlW2VkZ2VdIC0gb2Zmc2V0O1xuY29uc3QgZ2V0VGlja3NMaW1pdCA9ICh0aWNrc0xlbmd0aCwgbWF4VGlja3NMaW1pdCk9Pk1hdGgubWluKG1heFRpY2tzTGltaXQgfHwgdGlja3NMZW5ndGgsIHRpY2tzTGVuZ3RoKTtcbiBmdW5jdGlvbiBzYW1wbGUoYXJyLCBudW1JdGVtcykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGluY3JlbWVudCA9IGFyci5sZW5ndGggLyBudW1JdGVtcztcbiAgICBjb25zdCBsZW4gPSBhcnIubGVuZ3RoO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IoOyBpIDwgbGVuOyBpICs9IGluY3JlbWVudCl7XG4gICAgICAgIHJlc3VsdC5wdXNoKGFycltNYXRoLmZsb29yKGkpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4gZnVuY3Rpb24gZ2V0UGl4ZWxGb3JHcmlkTGluZShzY2FsZSwgaW5kZXgsIG9mZnNldEdyaWRMaW5lcykge1xuICAgIGNvbnN0IGxlbmd0aCA9IHNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgICBjb25zdCB2YWxpZEluZGV4ID0gTWF0aC5taW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgIGNvbnN0IHN0YXJ0ID0gc2NhbGUuX3N0YXJ0UGl4ZWw7XG4gICAgY29uc3QgZW5kID0gc2NhbGUuX2VuZFBpeGVsO1xuICAgIGNvbnN0IGVwc2lsb24gPSAxZS02O1xuICAgIGxldCBsaW5lVmFsdWUgPSBzY2FsZS5nZXRQaXhlbEZvclRpY2sodmFsaWRJbmRleCk7XG4gICAgbGV0IG9mZnNldDtcbiAgICBpZiAob2Zmc2V0R3JpZExpbmVzKSB7XG4gICAgICAgIGlmIChsZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IE1hdGgubWF4KGxpbmVWYWx1ZSAtIHN0YXJ0LCBlbmQgLSBsaW5lVmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAoc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKDEpIC0gbGluZVZhbHVlKSAvIDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAobGluZVZhbHVlIC0gc2NhbGUuZ2V0UGl4ZWxGb3JUaWNrKHZhbGlkSW5kZXggLSAxKSkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVWYWx1ZSArPSB2YWxpZEluZGV4IDwgaW5kZXggPyBvZmZzZXQgOiAtb2Zmc2V0O1xuICAgICAgICBpZiAobGluZVZhbHVlIDwgc3RhcnQgLSBlcHNpbG9uIHx8IGxpbmVWYWx1ZSA+IGVuZCArIGVwc2lsb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZVZhbHVlO1xufVxuIGZ1bmN0aW9uIGdhcmJhZ2VDb2xsZWN0KGNhY2hlcywgbGVuZ3RoKSB7XG4gICAgZWFjaChjYWNoZXMsIChjYWNoZSk9PntcbiAgICAgICAgY29uc3QgZ2MgPSBjYWNoZS5nYztcbiAgICAgICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgICAgICBsZXQgaTtcbiAgICAgICAgaWYgKGdjTGVuID4gbGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBnY0xlbjsgKytpKXtcbiAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGUuZGF0YVtnY1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5zcGxpY2UoMCwgZ2NMZW4pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4gZnVuY3Rpb24gZ2V0VGlja01hcmtMZW5ndGgob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zLmRyYXdUaWNrcyA/IG9wdGlvbnMudGlja0xlbmd0aCA6IDA7XG59XG4gZnVuY3Rpb24gZ2V0VGl0bGVIZWlnaHQob3B0aW9ucywgZmFsbGJhY2spIHtcbiAgICBpZiAoIW9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHRvRm9udChvcHRpb25zLmZvbnQsIGZhbGxiYWNrKTtcbiAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdGlvbnMucGFkZGluZyk7XG4gICAgY29uc3QgbGluZXMgPSBpc0FycmF5KG9wdGlvbnMudGV4dCkgPyBvcHRpb25zLnRleHQubGVuZ3RoIDogMTtcbiAgICByZXR1cm4gbGluZXMgKiBmb250LmxpbmVIZWlnaHQgKyBwYWRkaW5nLmhlaWdodDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVNjYWxlQ29udGV4dChwYXJlbnQsIHNjYWxlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIHNjYWxlLFxuICAgICAgICB0eXBlOiAnc2NhbGUnXG4gICAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUaWNrQ29udGV4dChwYXJlbnQsIGluZGV4LCB0aWNrKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIHRpY2ssXG4gICAgICAgIGluZGV4LFxuICAgICAgICB0eXBlOiAndGljaydcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSB7XG4gICAgIGxldCByZXQgPSBfdG9MZWZ0UmlnaHRDZW50ZXIoYWxpZ24pO1xuICAgIGlmIChyZXZlcnNlICYmIHBvc2l0aW9uICE9PSAncmlnaHQnIHx8ICFyZXZlcnNlICYmIHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldCA9IHJldmVyc2VBbGlnbihyZXQpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZnVuY3Rpb24gdGl0bGVBcmdzKHNjYWxlLCBvZmZzZXQsIHBvc2l0aW9uLCBhbGlnbikge1xuICAgIGNvbnN0IHsgdG9wICwgbGVmdCAsIGJvdHRvbSAsIHJpZ2h0ICwgY2hhcnQgIH0gPSBzY2FsZTtcbiAgICBjb25zdCB7IGNoYXJ0QXJlYSAsIHNjYWxlcyAgfSA9IGNoYXJ0O1xuICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgbGV0IG1heFdpZHRoLCB0aXRsZVgsIHRpdGxlWTtcbiAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgY29uc3Qgd2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgaWYgKHNjYWxlLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgIHRpdGxlWCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCBsZWZ0LCByaWdodCk7XG4gICAgICAgIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgICAgICB0aXRsZVkgPSBzY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpICsgaGVpZ2h0IC0gb2Zmc2V0O1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgdGl0bGVZID0gKGNoYXJ0QXJlYS5ib3R0b20gKyBjaGFydEFyZWEudG9wKSAvIDIgKyBoZWlnaHQgLSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aXRsZVkgPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgICAgIHRpdGxlWCA9IHNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkgLSB3aWR0aCArIG9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHRpdGxlWCA9IChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyIC0gd2lkdGggKyBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aXRsZVggPSBvZmZzZXRGcm9tRWRnZShzY2FsZSwgcG9zaXRpb24sIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGl0bGVZID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIGJvdHRvbSwgdG9wKTtcbiAgICAgICAgcm90YXRpb24gPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gLUhBTEZfUEkgOiBIQUxGX1BJO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZVgsXG4gICAgICAgIHRpdGxlWSxcbiAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgIHJvdGF0aW9uXG4gICAgfTtcbn1cbmNsYXNzIFNjYWxlIGV4dGVuZHMgRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoY2ZnKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgIHRoaXMuaWQgPSBjZmcuaWQ7XG4gICAgICAgICB0aGlzLnR5cGUgPSBjZmcudHlwZTtcbiAgICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuY3R4ID0gY2ZnLmN0eDtcbiAgICAgICAgIHRoaXMuY2hhcnQgPSBjZmcuY2hhcnQ7XG4gICAgICAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5sZWZ0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLmhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fbWFyZ2lucyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMFxuICAgICAgICB9O1xuICAgICAgICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5wYWRkaW5nQm90dG9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5heGlzID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5sYWJlbFJvdGF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1pbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy50aWNrcyA9IFtdO1xuICAgICAgICAgdGhpcy5fZ3JpZExpbmVJdGVtcyA9IG51bGw7XG4gICAgICAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9tYXhMZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9sb25nZXN0VGV4dENhY2hlID0ge307XG4gICAgICAgICB0aGlzLl9zdGFydFBpeGVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5fZW5kUGl4ZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3JldmVyc2VQaXhlbHMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fdXNlck1heCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdXNlck1pbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fYm9yZGVyVmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9jYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLl9kYXRhTGltaXRzQ2FjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuIGluaXQob3B0aW9ucykge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICB0aGlzLmF4aXMgPSBvcHRpb25zLmF4aXM7XG4gICAgICAgIHRoaXMuX3VzZXJNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMubWluKTtcbiAgICAgICAgdGhpcy5fdXNlck1heCA9IHRoaXMucGFyc2Uob3B0aW9ucy5tYXgpO1xuICAgICAgICB0aGlzLl9zdWdnZXN0ZWRNaW4gPSB0aGlzLnBhcnNlKG9wdGlvbnMuc3VnZ2VzdGVkTWluKTtcbiAgICAgICAgdGhpcy5fc3VnZ2VzdGVkTWF4ID0gdGhpcy5wYXJzZShvcHRpb25zLnN1Z2dlc3RlZE1heCk7XG4gICAgfVxuIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHJhdztcbiAgICB9XG4gZ2V0VXNlckJvdW5kcygpIHtcbiAgICAgICAgbGV0IHsgX3VzZXJNaW4gLCBfdXNlck1heCAsIF9zdWdnZXN0ZWRNaW4gLCBfc3VnZ2VzdGVkTWF4ICB9ID0gdGhpcztcbiAgICAgICAgX3VzZXJNaW4gPSBmaW5pdGVPckRlZmF1bHQoX3VzZXJNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIF91c2VyTWF4ID0gZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBfc3VnZ2VzdGVkTWluID0gZmluaXRlT3JEZWZhdWx0KF9zdWdnZXN0ZWRNaW4sIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIF9zdWdnZXN0ZWRNYXggPSBmaW5pdGVPckRlZmF1bHQoX3N1Z2dlc3RlZE1heCwgTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbjogZmluaXRlT3JEZWZhdWx0KF91c2VyTWluLCBfc3VnZ2VzdGVkTWluKSxcbiAgICAgICAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KF91c2VyTWF4LCBfc3VnZ2VzdGVkTWF4KSxcbiAgICAgICAgICAgIG1pbkRlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWluKSxcbiAgICAgICAgICAgIG1heERlZmluZWQ6IGlzTnVtYmVyRmluaXRlKF91c2VyTWF4KVxuICAgICAgICB9O1xuICAgIH1cbiBnZXRNaW5NYXgoY2FuU3RhY2spIHtcbiAgICAgICAgbGV0IHsgbWluICwgbWF4ICwgbWluRGVmaW5lZCAsIG1heERlZmluZWQgIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgICBtYXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWV0YXMgPSB0aGlzLmdldE1hdGNoaW5nVmlzaWJsZU1ldGFzKCk7XG4gICAgICAgIGZvcihsZXQgaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgcmFuZ2UgPSBtZXRhc1tpXS5jb250cm9sbGVyLmdldE1pbk1heCh0aGlzLCBjYW5TdGFjayk7XG4gICAgICAgICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHJhbmdlLm1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1heERlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHJhbmdlLm1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWluID0gbWF4RGVmaW5lZCAmJiBtaW4gPiBtYXggPyBtYXggOiBtaW47XG4gICAgICAgIG1heCA9IG1pbkRlZmluZWQgJiYgbWluID4gbWF4ID8gbWluIDogbWF4O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiBmaW5pdGVPckRlZmF1bHQobWluLCBmaW5pdGVPckRlZmF1bHQobWF4LCBtaW4pKSxcbiAgICAgICAgICAgIG1heDogZmluaXRlT3JEZWZhdWx0KG1heCwgZmluaXRlT3JEZWZhdWx0KG1pbiwgbWF4KSlcbiAgICAgICAgfTtcbiAgICB9XG4gZ2V0UGFkZGluZygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHRoaXMucGFkZGluZ0xlZnQgfHwgMCxcbiAgICAgICAgICAgIHRvcDogdGhpcy5wYWRkaW5nVG9wIHx8IDAsXG4gICAgICAgICAgICByaWdodDogdGhpcy5wYWRkaW5nUmlnaHQgfHwgMCxcbiAgICAgICAgICAgIGJvdHRvbTogdGhpcy5wYWRkaW5nQm90dG9tIHx8IDBcbiAgICAgICAgfTtcbiAgICB9XG4gZ2V0VGlja3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2tzO1xuICAgIH1cbiBnZXRMYWJlbHMoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWxzIHx8ICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gZGF0YS54TGFiZWxzIDogZGF0YS55TGFiZWxzKSB8fCBkYXRhLmxhYmVscyB8fCBbXTtcbiAgICB9XG4gZ2V0TGFiZWxJdGVtcyhjaGFydEFyZWEgPSB0aGlzLmNoYXJ0LmNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2xhYmVsSXRlbXMgfHwgKHRoaXMuX2xhYmVsSXRlbXMgPSB0aGlzLl9jb21wdXRlTGFiZWxJdGVtcyhjaGFydEFyZWEpKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH1cbiAgICBiZWZvcmVMYXlvdXQoKSB7XG4gICAgICAgIHRoaXMuX2NhY2hlID0ge307XG4gICAgICAgIHRoaXMuX2RhdGFMaW1pdHNDYWNoZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYmVmb3JlVXBkYXRlKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVXBkYXRlLCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCwgbWFyZ2lucykge1xuICAgICAgICBjb25zdCB7IGJlZ2luQXRaZXJvICwgZ3JhY2UgLCB0aWNrczogdGlja09wdHMgIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aWNrT3B0cy5zYW1wbGVTaXplO1xuICAgICAgICB0aGlzLmJlZm9yZVVwZGF0ZSgpO1xuICAgICAgICB0aGlzLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgICAgIHRoaXMubWF4SGVpZ2h0ID0gbWF4SGVpZ2h0O1xuICAgICAgICB0aGlzLl9tYXJnaW5zID0gbWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwXG4gICAgICAgIH0sIG1hcmdpbnMpO1xuICAgICAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFiZWxTaXplcyA9IG51bGw7XG4gICAgICAgIHRoaXMuX2dyaWRMaW5lSXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLl9sYWJlbEl0ZW1zID0gbnVsbDtcbiAgICAgICAgdGhpcy5iZWZvcmVTZXREaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLmFmdGVyU2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl9tYXhMZW5ndGggPSB0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCArIG1hcmdpbnMubGVmdCArIG1hcmdpbnMucmlnaHQgOiB0aGlzLmhlaWdodCArIG1hcmdpbnMudG9wICsgbWFyZ2lucy5ib3R0b207XG4gICAgICAgIGlmICghdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVEYXRhTGltaXRzKCk7XG4gICAgICAgICAgICB0aGlzLmRldGVybWluZURhdGFMaW1pdHMoKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJEYXRhTGltaXRzKCk7XG4gICAgICAgICAgICB0aGlzLl9yYW5nZSA9IF9hZGRHcmFjZSh0aGlzLCBncmFjZSwgYmVnaW5BdFplcm8pO1xuICAgICAgICAgICAgdGhpcy5fZGF0YUxpbWl0c0NhY2hlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWZvcmVCdWlsZFRpY2tzKCk7XG4gICAgICAgIHRoaXMudGlja3MgPSB0aGlzLmJ1aWxkVGlja3MoKSB8fCBbXTtcbiAgICAgICAgdGhpcy5hZnRlckJ1aWxkVGlja3MoKTtcbiAgICAgICAgY29uc3Qgc2FtcGxpbmdFbmFibGVkID0gc2FtcGxlU2l6ZSA8IHRoaXMudGlja3MubGVuZ3RoO1xuICAgICAgICB0aGlzLl9jb252ZXJ0VGlja3NUb0xhYmVscyhzYW1wbGluZ0VuYWJsZWQgPyBzYW1wbGUodGhpcy50aWNrcywgc2FtcGxlU2l6ZSkgOiB0aGlzLnRpY2tzKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmUoKTtcbiAgICAgICAgdGhpcy5iZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCk7XG4gICAgICAgIHRoaXMuY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgICAgICB0aGlzLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpO1xuICAgICAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiAodGlja09wdHMuYXV0b1NraXAgfHwgdGlja09wdHMuc291cmNlID09PSAnYXV0bycpKSB7XG4gICAgICAgICAgICB0aGlzLnRpY2tzID0gYXV0b1NraXAodGhpcywgdGhpcy50aWNrcyk7XG4gICAgICAgICAgICB0aGlzLl9sYWJlbFNpemVzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJBdXRvU2tpcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzYW1wbGluZ0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnZlcnRUaWNrc1RvTGFiZWxzKHRoaXMudGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVmb3JlRml0KCk7XG4gICAgICAgIHRoaXMuZml0KCk7XG4gICAgICAgIHRoaXMuYWZ0ZXJGaXQoKTtcbiAgICAgICAgdGhpcy5hZnRlclVwZGF0ZSgpO1xuICAgIH1cbiBjb25maWd1cmUoKSB7XG4gICAgICAgIGxldCByZXZlcnNlUGl4ZWxzID0gdGhpcy5vcHRpb25zLnJldmVyc2U7XG4gICAgICAgIGxldCBzdGFydFBpeGVsLCBlbmRQaXhlbDtcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0UGl4ZWwgPSB0aGlzLmxlZnQ7XG4gICAgICAgICAgICBlbmRQaXhlbCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGFydFBpeGVsID0gdGhpcy50b3A7XG4gICAgICAgICAgICBlbmRQaXhlbCA9IHRoaXMuYm90dG9tO1xuICAgICAgICAgICAgcmV2ZXJzZVBpeGVscyA9ICFyZXZlcnNlUGl4ZWxzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0YXJ0UGl4ZWwgPSBzdGFydFBpeGVsO1xuICAgICAgICB0aGlzLl9lbmRQaXhlbCA9IGVuZFBpeGVsO1xuICAgICAgICB0aGlzLl9yZXZlcnNlUGl4ZWxzID0gcmV2ZXJzZVBpeGVscztcbiAgICAgICAgdGhpcy5fbGVuZ3RoID0gZW5kUGl4ZWwgLSBzdGFydFBpeGVsO1xuICAgICAgICB0aGlzLl9hbGlnblRvUGl4ZWxzID0gdGhpcy5vcHRpb25zLmFsaWduVG9QaXhlbHM7XG4gICAgfVxuICAgIGFmdGVyVXBkYXRlKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYWZ0ZXJVcGRhdGUsIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGJlZm9yZVNldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5iZWZvcmVTZXREaW1lbnNpb25zLCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBzZXREaW1lbnNpb25zKCkge1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubWF4V2lkdGg7XG4gICAgICAgICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHRoaXMud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy50b3AgPSAwO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nVG9wID0gMDtcbiAgICAgICAgdGhpcy5wYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICB0aGlzLnBhZGRpbmdCb3R0b20gPSAwO1xuICAgIH1cbiAgICBhZnRlclNldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIGNhbGxiYWNrKHRoaXMub3B0aW9ucy5hZnRlclNldERpbWVuc2lvbnMsIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIF9jYWxsSG9va3MobmFtZSkge1xuICAgICAgICB0aGlzLmNoYXJ0Lm5vdGlmeVBsdWdpbnMobmFtZSwgdGhpcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnNbbmFtZV0sIFtcbiAgICAgICAgICAgIHRoaXNcbiAgICAgICAgXSk7XG4gICAgfVxuICAgIGJlZm9yZURhdGFMaW1pdHMoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlRGF0YUxpbWl0cycpO1xuICAgIH1cbiAgICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge31cbiAgICBhZnRlckRhdGFMaW1pdHMoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxIb29rcygnYWZ0ZXJEYXRhTGltaXRzJyk7XG4gICAgfVxuICAgIGJlZm9yZUJ1aWxkVGlja3MoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxIb29rcygnYmVmb3JlQnVpbGRUaWNrcycpO1xuICAgIH1cbiBidWlsZFRpY2tzKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGFmdGVyQnVpbGRUaWNrcygpIHtcbiAgICAgICAgdGhpcy5fY2FsbEhvb2tzKCdhZnRlckJ1aWxkVGlja3MnKTtcbiAgICB9XG4gICAgYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiBnZW5lcmF0ZVRpY2tMYWJlbHModGlja3MpIHtcbiAgICAgICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgdGljay5sYWJlbCA9IGNhbGxiYWNrKHRpY2tPcHRzLmNhbGxiYWNrLCBbXG4gICAgICAgICAgICAgICAgdGljay52YWx1ZSxcbiAgICAgICAgICAgICAgICBpLFxuICAgICAgICAgICAgICAgIHRpY2tzXG4gICAgICAgICAgICBdLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyVGlja1RvTGFiZWxDb252ZXJzaW9uLCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBiZWZvcmVDYWxjdWxhdGVMYWJlbFJvdGF0aW9uKCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgY2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgICAgICBjb25zdCBudW1UaWNrcyA9IGdldFRpY2tzTGltaXQodGhpcy50aWNrcy5sZW5ndGgsIG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCk7XG4gICAgICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdGlja09wdHMubWluUm90YXRpb24gfHwgMDtcbiAgICAgICAgY29uc3QgbWF4Um90YXRpb24gPSB0aWNrT3B0cy5tYXhSb3RhdGlvbjtcbiAgICAgICAgbGV0IGxhYmVsUm90YXRpb24gPSBtaW5Sb3RhdGlvbjtcbiAgICAgICAgbGV0IHRpY2tXaWR0aCwgbWF4SGVpZ2h0LCBtYXhMYWJlbERpYWdvbmFsO1xuICAgICAgICBpZiAoIXRoaXMuX2lzVmlzaWJsZSgpIHx8ICF0aWNrT3B0cy5kaXNwbGF5IHx8IG1pblJvdGF0aW9uID49IG1heFJvdGF0aW9uIHx8IG51bVRpY2tzIDw9IDEgfHwgIXRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IG1pblJvdGF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSB0aGlzLl9nZXRMYWJlbFNpemVzKCk7XG4gICAgICAgIGNvbnN0IG1heExhYmVsV2lkdGggPSBsYWJlbFNpemVzLndpZGVzdC53aWR0aDtcbiAgICAgICAgY29uc3QgbWF4TGFiZWxIZWlnaHQgPSBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0O1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IF9saW1pdFZhbHVlKHRoaXMuY2hhcnQud2lkdGggLSBtYXhMYWJlbFdpZHRoLCAwLCB0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgdGlja1dpZHRoID0gb3B0aW9ucy5vZmZzZXQgPyB0aGlzLm1heFdpZHRoIC8gbnVtVGlja3MgOiBtYXhXaWR0aCAvIChudW1UaWNrcyAtIDEpO1xuICAgICAgICBpZiAobWF4TGFiZWxXaWR0aCArIDYgPiB0aWNrV2lkdGgpIHtcbiAgICAgICAgICAgIHRpY2tXaWR0aCA9IG1heFdpZHRoIC8gKG51bVRpY2tzIC0gKG9wdGlvbnMub2Zmc2V0ID8gMC41IDogMSkpO1xuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpIC0gdGlja09wdHMucGFkZGluZyAtIGdldFRpdGxlSGVpZ2h0KG9wdGlvbnMudGl0bGUsIHRoaXMuY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgICAgICAgIG1heExhYmVsRGlhZ29uYWwgPSBNYXRoLnNxcnQobWF4TGFiZWxXaWR0aCAqIG1heExhYmVsV2lkdGggKyBtYXhMYWJlbEhlaWdodCAqIG1heExhYmVsSGVpZ2h0KTtcbiAgICAgICAgICAgIGxhYmVsUm90YXRpb24gPSB0b0RlZ3JlZXMoTWF0aC5taW4oTWF0aC5hc2luKF9saW1pdFZhbHVlKChsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgNikgLyB0aWNrV2lkdGgsIC0xLCAxKSksIE1hdGguYXNpbihfbGltaXRWYWx1ZShtYXhIZWlnaHQgLyBtYXhMYWJlbERpYWdvbmFsLCAtMSwgMSkpIC0gTWF0aC5hc2luKF9saW1pdFZhbHVlKG1heExhYmVsSGVpZ2h0IC8gbWF4TGFiZWxEaWFnb25hbCwgLTEsIDEpKSkpO1xuICAgICAgICAgICAgbGFiZWxSb3RhdGlvbiA9IE1hdGgubWF4KG1pblJvdGF0aW9uLCBNYXRoLm1pbihtYXhSb3RhdGlvbiwgbGFiZWxSb3RhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFiZWxSb3RhdGlvbiA9IGxhYmVsUm90YXRpb247XG4gICAgfVxuICAgIGFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbigpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyQ2FsY3VsYXRlTGFiZWxSb3RhdGlvbiwgW1xuICAgICAgICAgICAgdGhpc1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgYWZ0ZXJBdXRvU2tpcCgpIHt9XG4gICAgYmVmb3JlRml0KCkge1xuICAgICAgICBjYWxsYmFjayh0aGlzLm9wdGlvbnMuYmVmb3JlRml0LCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBmaXQoKSB7XG4gICAgICAgIGNvbnN0IG1pblNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGNoYXJ0ICwgb3B0aW9uczogeyB0aWNrczogdGlja09wdHMgLCB0aXRsZTogdGl0bGVPcHRzICwgZ3JpZDogZ3JpZE9wdHMgIH0gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkaXNwbGF5ID0gdGhpcy5faXNWaXNpYmxlKCk7XG4gICAgICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIGlmIChkaXNwbGF5KSB7XG4gICAgICAgICAgICBjb25zdCB0aXRsZUhlaWdodCA9IGdldFRpdGxlSGVpZ2h0KHRpdGxlT3B0cywgY2hhcnQub3B0aW9ucy5mb250KTtcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBtaW5TaXplLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IGdldFRpY2tNYXJrTGVuZ3RoKGdyaWRPcHRzKSArIHRpdGxlSGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5TaXplLmhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICAgICAgICAgIG1pblNpemUud2lkdGggPSBnZXRUaWNrTWFya0xlbmd0aChncmlkT3B0cykgKyB0aXRsZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aWNrT3B0cy5kaXNwbGF5ICYmIHRoaXMudGlja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmaXJzdCAsIGxhc3QgLCB3aWRlc3QgLCBoaWdoZXN0ICB9ID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tQYWRkaW5nID0gdGlja09wdHMucGFkZGluZyAqIDI7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY29zID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaW4gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xuICAgICAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxIZWlnaHQgPSB0aWNrT3B0cy5taXJyb3IgPyAwIDogc2luICogd2lkZXN0LndpZHRoICsgY29zICogaGlnaGVzdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIG1pblNpemUuaGVpZ2h0ID0gTWF0aC5taW4odGhpcy5tYXhIZWlnaHQsIG1pblNpemUuaGVpZ2h0ICsgbGFiZWxIZWlnaHQgKyB0aWNrUGFkZGluZyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFiZWxXaWR0aCA9IHRpY2tPcHRzLm1pcnJvciA/IDAgOiBjb3MgKiB3aWRlc3Qud2lkdGggKyBzaW4gKiBoaWdoZXN0LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbWluU2l6ZS53aWR0aCA9IE1hdGgubWluKHRoaXMubWF4V2lkdGgsIG1pblNpemUud2lkdGggKyBsYWJlbFdpZHRoICsgdGlja1BhZGRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faGFuZGxlTWFyZ2lucygpO1xuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5fbGVuZ3RoID0gY2hhcnQud2lkdGggLSB0aGlzLl9tYXJnaW5zLmxlZnQgLSB0aGlzLl9tYXJnaW5zLnJpZ2h0O1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBtaW5TaXplLmhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBtaW5TaXplLndpZHRoO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9sZW5ndGggPSBjaGFydC5oZWlnaHQgLSB0aGlzLl9tYXJnaW5zLnRvcCAtIHRoaXMuX21hcmdpbnMuYm90dG9tO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9jYWxjdWxhdGVQYWRkaW5nKGZpcnN0LCBsYXN0LCBzaW4sIGNvcykge1xuICAgICAgICBjb25zdCB7IHRpY2tzOiB7IGFsaWduICwgcGFkZGluZyAgfSAsIHBvc2l0aW9uICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBpc1JvdGF0ZWQgPSB0aGlzLmxhYmVsUm90YXRpb24gIT09IDA7XG4gICAgICAgIGNvbnN0IGxhYmVsc0JlbG93VGlja3MgPSBwb3NpdGlvbiAhPT0gJ3RvcCcgJiYgdGhpcy5heGlzID09PSAneCc7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRMZWZ0ID0gdGhpcy5nZXRQaXhlbEZvclRpY2soMCkgLSB0aGlzLmxlZnQ7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXRSaWdodCA9IHRoaXMucmlnaHQgLSB0aGlzLmdldFBpeGVsRm9yVGljayh0aGlzLnRpY2tzLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgbGV0IHBhZGRpbmdMZWZ0ID0gMDtcbiAgICAgICAgICAgIGxldCBwYWRkaW5nUmlnaHQgPSAwO1xuICAgICAgICAgICAgaWYgKGlzUm90YXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbHNCZWxvd1RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gY29zICogZmlyc3Qud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IHNpbiAqIGxhc3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gc2luICogZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBjb3MgKiBsYXN0LndpZHRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nUmlnaHQgPSBsYXN0LndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nTGVmdCA9IGZpcnN0LndpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiAhPT0gJ2lubmVyJykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdMZWZ0ID0gZmlyc3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgIHBhZGRpbmdSaWdodCA9IGxhc3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wYWRkaW5nTGVmdCA9IE1hdGgubWF4KChwYWRkaW5nTGVmdCAtIG9mZnNldExlZnQgKyBwYWRkaW5nKSAqIHRoaXMud2lkdGggLyAodGhpcy53aWR0aCAtIG9mZnNldExlZnQpLCAwKTtcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ1JpZ2h0ID0gTWF0aC5tYXgoKHBhZGRpbmdSaWdodCAtIG9mZnNldFJpZ2h0ICsgcGFkZGluZykgKiB0aGlzLndpZHRoIC8gKHRoaXMud2lkdGggLSBvZmZzZXRSaWdodCksIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IHBhZGRpbmdUb3AgPSBsYXN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICBsZXQgcGFkZGluZ0JvdHRvbSA9IGZpcnN0LmhlaWdodCAvIDI7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wID0gMDtcbiAgICAgICAgICAgICAgICBwYWRkaW5nQm90dG9tID0gZmlyc3QuaGVpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICBwYWRkaW5nVG9wID0gbGFzdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgcGFkZGluZ0JvdHRvbSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhZGRpbmdUb3AgPSBwYWRkaW5nVG9wICsgcGFkZGluZztcbiAgICAgICAgICAgIHRoaXMucGFkZGluZ0JvdHRvbSA9IHBhZGRpbmdCb3R0b20gKyBwYWRkaW5nO1xuICAgICAgICB9XG4gICAgfVxuIF9oYW5kbGVNYXJnaW5zKCkge1xuICAgICAgICBpZiAodGhpcy5fbWFyZ2lucykge1xuICAgICAgICAgICAgdGhpcy5fbWFyZ2lucy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nTGVmdCwgdGhpcy5fbWFyZ2lucy5sZWZ0KTtcbiAgICAgICAgICAgIHRoaXMuX21hcmdpbnMudG9wID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nVG9wLCB0aGlzLl9tYXJnaW5zLnRvcCk7XG4gICAgICAgICAgICB0aGlzLl9tYXJnaW5zLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5wYWRkaW5nUmlnaHQsIHRoaXMuX21hcmdpbnMucmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fbWFyZ2lucy5ib3R0b20gPSBNYXRoLm1heCh0aGlzLnBhZGRpbmdCb3R0b20sIHRoaXMuX21hcmdpbnMuYm90dG9tKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZnRlckZpdCgpIHtcbiAgICAgICAgY2FsbGJhY2sodGhpcy5vcHRpb25zLmFmdGVyRml0LCBbXG4gICAgICAgICAgICB0aGlzXG4gICAgICAgIF0pO1xuICAgIH1cbiBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIGNvbnN0IHsgYXhpcyAsIHBvc2l0aW9uICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBheGlzID09PSAneCc7XG4gICAgfVxuIGlzRnVsbFNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZnVsbFNpemU7XG4gICAgfVxuIF9jb252ZXJ0VGlja3NUb0xhYmVscyh0aWNrcykge1xuICAgICAgICB0aGlzLmJlZm9yZVRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgICAgICB0aGlzLmdlbmVyYXRlVGlja0xhYmVscyh0aWNrcyk7XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYodGlja3NbaV0ubGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgdGlja3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIGlsZW4tLTtcbiAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZnRlclRpY2tUb0xhYmVsQ29udmVyc2lvbigpO1xuICAgIH1cbiBfZ2V0TGFiZWxTaXplcygpIHtcbiAgICAgICAgbGV0IGxhYmVsU2l6ZXMgPSB0aGlzLl9sYWJlbFNpemVzO1xuICAgICAgICBpZiAoIWxhYmVsU2l6ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbXBsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlja3Muc2FtcGxlU2l6ZTtcbiAgICAgICAgICAgIGxldCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICAgICAgICBpZiAoc2FtcGxlU2l6ZSA8IHRpY2tzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRpY2tzID0gc2FtcGxlKHRpY2tzLCBzYW1wbGVTaXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2xhYmVsU2l6ZXMgPSBsYWJlbFNpemVzID0gdGhpcy5fY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIHRpY2tzLmxlbmd0aCwgdGhpcy5vcHRpb25zLnRpY2tzLm1heFRpY2tzTGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbFNpemVzO1xuICAgIH1cbiBfY29tcHV0ZUxhYmVsU2l6ZXModGlja3MsIGxlbmd0aCwgbWF4VGlja3NMaW1pdCkge1xuICAgICAgICBjb25zdCB7IGN0eCAsIF9sb25nZXN0VGV4dENhY2hlOiBjYWNoZXMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB3aWR0aHMgPSBbXTtcbiAgICAgICAgY29uc3QgaGVpZ2h0cyA9IFtdO1xuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBNYXRoLmZsb29yKGxlbmd0aCAvIGdldFRpY2tzTGltaXQobGVuZ3RoLCBtYXhUaWNrc0xpbWl0KSk7XG4gICAgICAgIGxldCB3aWRlc3RMYWJlbFNpemUgPSAwO1xuICAgICAgICBsZXQgaGlnaGVzdExhYmVsU2l6ZSA9IDA7XG4gICAgICAgIGxldCBpLCBqLCBqbGVuLCBsYWJlbCwgdGlja0ZvbnQsIGZvbnRTdHJpbmcsIGNhY2hlLCBsaW5lSGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBuZXN0ZWRMYWJlbDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IGluY3JlbWVudCl7XG4gICAgICAgICAgICBsYWJlbCA9IHRpY2tzW2ldLmxhYmVsO1xuICAgICAgICAgICAgdGlja0ZvbnQgPSB0aGlzLl9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGkpO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb250U3RyaW5nID0gdGlja0ZvbnQuc3RyaW5nO1xuICAgICAgICAgICAgY2FjaGUgPSBjYWNoZXNbZm9udFN0cmluZ10gPSBjYWNoZXNbZm9udFN0cmluZ10gfHwge1xuICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgIGdjOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSB0aWNrRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSBoZWlnaHQgPSAwO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKGxhYmVsKSAmJiAhaXNBcnJheShsYWJlbCkpIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbGFiZWwpO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkobGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgZm9yKGogPSAwLCBqbGVuID0gbGFiZWwubGVuZ3RoOyBqIDwgamxlbjsgKytqKXtcbiAgICAgICAgICAgICAgICAgICAgbmVzdGVkTGFiZWwgPSAgbGFiZWxbal07XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihuZXN0ZWRMYWJlbCkgJiYgIWlzQXJyYXkobmVzdGVkTGFiZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aCA9IF9tZWFzdXJlVGV4dChjdHgsIGNhY2hlLmRhdGEsIGNhY2hlLmdjLCB3aWR0aCwgbmVzdGVkTGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aWR0aHMucHVzaCh3aWR0aCk7XG4gICAgICAgICAgICBoZWlnaHRzLnB1c2goaGVpZ2h0KTtcbiAgICAgICAgICAgIHdpZGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KHdpZHRoLCB3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgICAgICAgaGlnaGVzdExhYmVsU2l6ZSA9IE1hdGgubWF4KGhlaWdodCwgaGlnaGVzdExhYmVsU2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2FyYmFnZUNvbGxlY3QoY2FjaGVzLCBsZW5ndGgpO1xuICAgICAgICBjb25zdCB3aWRlc3QgPSB3aWR0aHMuaW5kZXhPZih3aWRlc3RMYWJlbFNpemUpO1xuICAgICAgICBjb25zdCBoaWdoZXN0ID0gaGVpZ2h0cy5pbmRleE9mKGhpZ2hlc3RMYWJlbFNpemUpO1xuICAgICAgICBjb25zdCB2YWx1ZUF0ID0gKGlkeCk9Pih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoc1tpZHhdIHx8IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRzW2lkeF0gfHwgMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdDogdmFsdWVBdCgwKSxcbiAgICAgICAgICAgIGxhc3Q6IHZhbHVlQXQobGVuZ3RoIC0gMSksXG4gICAgICAgICAgICB3aWRlc3Q6IHZhbHVlQXQod2lkZXN0KSxcbiAgICAgICAgICAgIGhpZ2hlc3Q6IHZhbHVlQXQoaGlnaGVzdCksXG4gICAgICAgICAgICB3aWR0aHMsXG4gICAgICAgICAgICBoZWlnaHRzXG4gICAgICAgIH07XG4gICAgfVxuIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiBnZXRQaXhlbEZvclZhbHVlKHZhbHVlLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7fVxuIGdldFBpeGVsRm9yVGljayhpbmRleCkge1xuICAgICAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiB0aWNrcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvclZhbHVlKHRpY2tzW2luZGV4XS52YWx1ZSk7XG4gICAgfVxuIGdldFBpeGVsRm9yRGVjaW1hbChkZWNpbWFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZXZlcnNlUGl4ZWxzKSB7XG4gICAgICAgICAgICBkZWNpbWFsID0gMSAtIGRlY2ltYWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGl4ZWwgPSB0aGlzLl9zdGFydFBpeGVsICsgZGVjaW1hbCAqIHRoaXMuX2xlbmd0aDtcbiAgICAgICAgcmV0dXJuIF9pbnQxNlJhbmdlKHRoaXMuX2FsaWduVG9QaXhlbHMgPyBfYWxpZ25QaXhlbCh0aGlzLmNoYXJ0LCBwaXhlbCwgMCkgOiBwaXhlbCk7XG4gICAgfVxuIGdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkge1xuICAgICAgICBjb25zdCBkZWNpbWFsID0gKHBpeGVsIC0gdGhpcy5fc3RhcnRQaXhlbCkgLyB0aGlzLl9sZW5ndGg7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXZlcnNlUGl4ZWxzID8gMSAtIGRlY2ltYWwgOiBkZWNpbWFsO1xuICAgIH1cbiBnZXRCYXNlUGl4ZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGhpcy5nZXRCYXNlVmFsdWUoKSk7XG4gICAgfVxuIGdldEJhc2VWYWx1ZSgpIHtcbiAgICAgICAgY29uc3QgeyBtaW4gLCBtYXggIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gbWluIDwgMCAmJiBtYXggPCAwID8gbWF4IDogbWluID4gMCAmJiBtYXggPiAwID8gbWluIDogMDtcbiAgICB9XG4gZ2V0Q29udGV4dChpbmRleCkge1xuICAgICAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3MgfHwgW107XG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCB0aWNrID0gdGlja3NbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuIHRpY2suJGNvbnRleHQgfHwgKHRpY2suJGNvbnRleHQgPSBjcmVhdGVUaWNrQ29udGV4dCh0aGlzLmdldENvbnRleHQoKSwgaW5kZXgsIHRpY2spKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZVNjYWxlQ29udGV4dCh0aGlzLmNoYXJ0LmdldENvbnRleHQoKSwgdGhpcykpO1xuICAgIH1cbiBfdGlja1NpemUoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvblRpY2tzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgICAgICBjb25zdCByb3QgPSB0b1JhZGlhbnModGhpcy5sYWJlbFJvdGF0aW9uKTtcbiAgICAgICAgY29uc3QgY29zID0gTWF0aC5hYnMoTWF0aC5jb3Mocm90KSk7XG4gICAgICAgIGNvbnN0IHNpbiA9IE1hdGguYWJzKE1hdGguc2luKHJvdCkpO1xuICAgICAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gb3B0aW9uVGlja3MuYXV0b1NraXBQYWRkaW5nIHx8IDA7XG4gICAgICAgIGNvbnN0IHcgPSBsYWJlbFNpemVzID8gbGFiZWxTaXplcy53aWRlc3Qud2lkdGggKyBwYWRkaW5nIDogMDtcbiAgICAgICAgY29uc3QgaCA9IGxhYmVsU2l6ZXMgPyBsYWJlbFNpemVzLmhpZ2hlc3QuaGVpZ2h0ICsgcGFkZGluZyA6IDA7XG4gICAgICAgIHJldHVybiB0aGlzLmlzSG9yaXpvbnRhbCgpID8gaCAqIGNvcyA+IHcgKiBzaW4gPyB3IC8gY29zIDogaCAvIHNpbiA6IGggKiBzaW4gPCB3ICogY29zID8gaCAvIGNvcyA6IHcgLyBzaW47XG4gICAgfVxuIF9pc1Zpc2libGUoKSB7XG4gICAgICAgIGNvbnN0IGRpc3BsYXkgPSB0aGlzLm9wdGlvbnMuZGlzcGxheTtcbiAgICAgICAgaWYgKGRpc3BsYXkgIT09ICdhdXRvJykge1xuICAgICAgICAgICAgcmV0dXJuICEhZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygpLmxlbmd0aCA+IDA7XG4gICAgfVxuIF9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpIHtcbiAgICAgICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcztcbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB7IGdyaWQgLCBwb3NpdGlvbiAsIGJvcmRlciAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGdyaWQub2Zmc2V0O1xuICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSB0aGlzLmlzSG9yaXpvbnRhbCgpO1xuICAgICAgICBjb25zdCB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgICAgIGNvbnN0IHRpY2tzTGVuZ3RoID0gdGlja3MubGVuZ3RoICsgKG9mZnNldCA/IDEgOiAwKTtcbiAgICAgICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChncmlkKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICAgICAgY29uc3QgYm9yZGVyT3B0cyA9IGJvcmRlci5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgY29uc3QgYXhpc1dpZHRoID0gYm9yZGVyT3B0cy5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgICAgIGNvbnN0IGF4aXNIYWxmV2lkdGggPSBheGlzV2lkdGggLyAyO1xuICAgICAgICBjb25zdCBhbGlnbkJvcmRlclZhbHVlID0gZnVuY3Rpb24ocGl4ZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIGF4aXNXaWR0aCk7XG4gICAgICAgIH07XG4gICAgICAgIGxldCBib3JkZXJWYWx1ZSwgaSwgbGluZVZhbHVlLCBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgICBsZXQgdHgxLCB0eTEsIHR4MiwgdHkyLCB4MSwgeTEsIHgyLCB5MjtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAndG9wJykge1xuICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuYm90dG9tKTtcbiAgICAgICAgICAgIHR5MSA9IHRoaXMuYm90dG9tIC0gdGw7XG4gICAgICAgICAgICB0eTIgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB5MSA9IGFsaWduQm9yZGVyVmFsdWUoY2hhcnRBcmVhLnRvcCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMudG9wKTtcbiAgICAgICAgICAgIHkxID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgICAgICAgIHkyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEuYm90dG9tKSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB0eTEgPSBib3JkZXJWYWx1ZSArIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB0eTIgPSB0aGlzLnRvcCArIHRsO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLnJpZ2h0KTtcbiAgICAgICAgICAgIHR4MSA9IHRoaXMucmlnaHQgLSB0bDtcbiAgICAgICAgICAgIHR4MiA9IGJvcmRlclZhbHVlIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHgxID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEubGVmdCkgKyBheGlzSGFsZldpZHRoO1xuICAgICAgICAgICAgeDIgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmxlZnQpO1xuICAgICAgICAgICAgeDEgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgICAgICAgIHgyID0gYWxpZ25Cb3JkZXJWYWx1ZShjaGFydEFyZWEucmlnaHQpIC0gYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHR4MSA9IGJvcmRlclZhbHVlICsgYXhpc0hhbGZXaWR0aDtcbiAgICAgICAgICAgIHR4MiA9IHRoaXMubGVmdCArIHRsO1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd4Jykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSgoY2hhcnRBcmVhLnRvcCArIGNoYXJ0QXJlYS5ib3R0b20pIC8gMiArIDAuNSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQXhpc0lEID0gT2JqZWN0LmtleXMocG9zaXRpb24pWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcG9zaXRpb25bcG9zaXRpb25BeGlzSURdO1xuICAgICAgICAgICAgICAgIGJvcmRlclZhbHVlID0gYWxpZ25Cb3JkZXJWYWx1ZSh0aGlzLmNoYXJ0LnNjYWxlc1twb3NpdGlvbkF4aXNJRF0uZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeTEgPSBjaGFydEFyZWEudG9wO1xuICAgICAgICAgICAgeTIgPSBjaGFydEFyZWEuYm90dG9tO1xuICAgICAgICAgICAgdHkxID0gYm9yZGVyVmFsdWUgKyBheGlzSGFsZldpZHRoO1xuICAgICAgICAgICAgdHkyID0gdHkxICsgdGw7XG4gICAgICAgIH0gZWxzZSBpZiAoYXhpcyA9PT0gJ3knKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKChjaGFydEFyZWEubGVmdCArIGNoYXJ0QXJlYS5yaWdodCkgLyAyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgICAgICAgICAgYm9yZGVyVmFsdWUgPSBhbGlnbkJvcmRlclZhbHVlKHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0eDEgPSBib3JkZXJWYWx1ZSAtIGF4aXNIYWxmV2lkdGg7XG4gICAgICAgICAgICB0eDIgPSB0eDEgLSB0bDtcbiAgICAgICAgICAgIHgxID0gY2hhcnRBcmVhLmxlZnQ7XG4gICAgICAgICAgICB4MiA9IGNoYXJ0QXJlYS5yaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaW1pdCA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMudGlja3MubWF4VGlja3NMaW1pdCwgdGlja3NMZW5ndGgpO1xuICAgICAgICBjb25zdCBzdGVwID0gTWF0aC5tYXgoMSwgTWF0aC5jZWlsKHRpY2tzTGVuZ3RoIC8gbGltaXQpKTtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgdGlja3NMZW5ndGg7IGkgKz0gc3RlcCl7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGkpO1xuICAgICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleEJvcmRlciA9IGJvcmRlci5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3QgbGluZVdpZHRoID0gb3B0c0F0SW5kZXgubGluZVdpZHRoO1xuICAgICAgICAgICAgY29uc3QgbGluZUNvbG9yID0gb3B0c0F0SW5kZXguY29sb3I7XG4gICAgICAgICAgICBjb25zdCBib3JkZXJEYXNoID0gb3B0c0F0SW5kZXhCb3JkZXIuZGFzaCB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IGJvcmRlckRhc2hPZmZzZXQgPSBvcHRzQXRJbmRleEJvcmRlci5kYXNoT2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgdGlja1dpZHRoID0gb3B0c0F0SW5kZXgudGlja1dpZHRoO1xuICAgICAgICAgICAgY29uc3QgdGlja0NvbG9yID0gb3B0c0F0SW5kZXgudGlja0NvbG9yO1xuICAgICAgICAgICAgY29uc3QgdGlja0JvcmRlckRhc2ggPSBvcHRzQXRJbmRleC50aWNrQm9yZGVyRGFzaCB8fCBbXTtcbiAgICAgICAgICAgIGNvbnN0IHRpY2tCb3JkZXJEYXNoT2Zmc2V0ID0gb3B0c0F0SW5kZXgudGlja0JvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgICAgICBsaW5lVmFsdWUgPSBnZXRQaXhlbEZvckdyaWRMaW5lKHRoaXMsIGksIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAobGluZVZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFsaWduZWRMaW5lVmFsdWUgPSBfYWxpZ25QaXhlbChjaGFydCwgbGluZVZhbHVlLCBsaW5lV2lkdGgpO1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIHR4MSA9IHR4MiA9IHgxID0geDIgPSBhbGlnbmVkTGluZVZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0eTEgPSB0eTIgPSB5MSA9IHkyID0gYWxpZ25lZExpbmVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR4MSxcbiAgICAgICAgICAgICAgICB0eTEsXG4gICAgICAgICAgICAgICAgdHgyLFxuICAgICAgICAgICAgICAgIHR5MixcbiAgICAgICAgICAgICAgICB4MSxcbiAgICAgICAgICAgICAgICB5MSxcbiAgICAgICAgICAgICAgICB4MixcbiAgICAgICAgICAgICAgICB5MixcbiAgICAgICAgICAgICAgICB3aWR0aDogbGluZVdpZHRoLFxuICAgICAgICAgICAgICAgIGNvbG9yOiBsaW5lQ29sb3IsXG4gICAgICAgICAgICAgICAgYm9yZGVyRGFzaCxcbiAgICAgICAgICAgICAgICBib3JkZXJEYXNoT2Zmc2V0LFxuICAgICAgICAgICAgICAgIHRpY2tXaWR0aCxcbiAgICAgICAgICAgICAgICB0aWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgdGlja0JvcmRlckRhc2gsXG4gICAgICAgICAgICAgICAgdGlja0JvcmRlckRhc2hPZmZzZXRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RpY2tzTGVuZ3RoID0gdGlja3NMZW5ndGg7XG4gICAgICAgIHRoaXMuX2JvcmRlclZhbHVlID0gYm9yZGVyVmFsdWU7XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gX2NvbXB1dGVMYWJlbEl0ZW1zKGNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBheGlzID0gdGhpcy5heGlzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB7IHBvc2l0aW9uICwgdGlja3M6IG9wdGlvblRpY2tzICB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgICBjb25zdCB7IGFsaWduICwgY3Jvc3NBbGlnbiAsIHBhZGRpbmcgLCBtaXJyb3IgIH0gPSBvcHRpb25UaWNrcztcbiAgICAgICAgY29uc3QgdGwgPSBnZXRUaWNrTWFya0xlbmd0aChvcHRpb25zLmdyaWQpO1xuICAgICAgICBjb25zdCB0aWNrQW5kUGFkZGluZyA9IHRsICsgcGFkZGluZztcbiAgICAgICAgY29uc3QgaFRpY2tBbmRQYWRkaW5nID0gbWlycm9yID8gLXBhZGRpbmcgOiB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuLCB0aWNrLCBsYWJlbCwgeCwgeSwgdGV4dEFsaWduLCBwaXhlbCwgZm9udCwgbGluZUhlaWdodCwgbGluZUNvdW50LCB0ZXh0T2Zmc2V0O1xuICAgICAgICBsZXQgdGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLmJvdHRvbSAtIGhUaWNrQW5kUGFkZGluZztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgIHkgPSB0aGlzLnRvcCArIGhUaWNrQW5kUGFkZGluZztcbiAgICAgICAgICAgIHRleHRBbGlnbiA9IHRoaXMuX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSB0aGlzLl9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKTtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9IHJldC50ZXh0QWxpZ247XG4gICAgICAgICAgICB4ID0gcmV0Lng7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHRoaXMuX2dldFlBeGlzTGFiZWxBbGlnbm1lbnQodGwpO1xuICAgICAgICAgICAgdGV4dEFsaWduID0gcmV0LnRleHRBbGlnbjtcbiAgICAgICAgICAgIHggPSByZXQueDtcbiAgICAgICAgfSBlbHNlIGlmIChheGlzID09PSAneCcpIHtcbiAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICB5ID0gKGNoYXJ0QXJlYS50b3AgKyBjaGFydEFyZWEuYm90dG9tKSAvIDIgKyB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QocG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25BeGlzSUQgPSBPYmplY3Qua2V5cyhwb3NpdGlvbilbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwb3NpdGlvbltwb3NpdGlvbkF4aXNJRF07XG4gICAgICAgICAgICAgICAgeSA9IHRoaXMuY2hhcnQuc2NhbGVzW3Bvc2l0aW9uQXhpc0lEXS5nZXRQaXhlbEZvclZhbHVlKHZhbHVlKSArIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WEF4aXNMYWJlbEFsaWdubWVudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIHggPSAoY2hhcnRBcmVhLmxlZnQgKyBjaGFydEFyZWEucmlnaHQpIC8gMiAtIHRpY2tBbmRQYWRkaW5nO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdChwb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbkF4aXNJRCA9IE9iamVjdC5rZXlzKHBvc2l0aW9uKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBvc2l0aW9uW3Bvc2l0aW9uQXhpc0lEXTtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5jaGFydC5zY2FsZXNbcG9zaXRpb25BeGlzSURdLmdldFBpeGVsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4dEFsaWduID0gdGhpcy5fZ2V0WUF4aXNMYWJlbEFsaWdubWVudCh0bCkudGV4dEFsaWduO1xuICAgICAgICB9XG4gICAgICAgIGlmIChheGlzID09PSAneScpIHtcbiAgICAgICAgICAgIGlmIChhbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIHRleHRCYXNlbGluZSA9ICd0b3AnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUgPSAnYm90dG9tJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYWJlbFNpemVzID0gdGhpcy5fZ2V0TGFiZWxTaXplcygpO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgbGFiZWwgPSB0aWNrLmxhYmVsO1xuICAgICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBvcHRpb25UaWNrcy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dChpKSk7XG4gICAgICAgICAgICBwaXhlbCA9IHRoaXMuZ2V0UGl4ZWxGb3JUaWNrKGkpICsgb3B0aW9uVGlja3MubGFiZWxPZmZzZXQ7XG4gICAgICAgICAgICBmb250ID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucyhpKTtcbiAgICAgICAgICAgIGxpbmVIZWlnaHQgPSBmb250LmxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBsaW5lQ291bnQgPSBpc0FycmF5KGxhYmVsKSA/IGxhYmVsLmxlbmd0aCA6IDE7XG4gICAgICAgICAgICBjb25zdCBoYWxmQ291bnQgPSBsaW5lQ291bnQgLyAyO1xuICAgICAgICAgICAgY29uc3QgY29sb3IgPSBvcHRzQXRJbmRleC5jb2xvcjtcbiAgICAgICAgICAgIGNvbnN0IHN0cm9rZUNvbG9yID0gb3B0c0F0SW5kZXgudGV4dFN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgY29uc3Qgc3Ryb2tlV2lkdGggPSBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICBsZXQgdGlja1RleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICB4ID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRBbGlnbiA9PT0gJ2lubmVyJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpY2tUZXh0QWxpZ24gPSAhdGhpcy5vcHRpb25zLnJldmVyc2UgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlja1RleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9IC1saW5lQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3Jvc3NBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0ICsgbGluZUhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPZmZzZXQgPSAtbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCArIGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJyB8fCByb3RhdGlvbiAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxpbmVIZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNyb3NzQWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2Zmc2V0ID0gbGFiZWxTaXplcy5oaWdoZXN0LmhlaWdodCAvIDIgLSBoYWxmQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCA9IGxhYmVsU2l6ZXMuaGlnaGVzdC5oZWlnaHQgLSBsaW5lQ291bnQgKiBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE9mZnNldCAqPSAtMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdGF0aW9uICE9PSAwICYmICFvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgICAgICAgICAgICB4ICs9IGxpbmVIZWlnaHQgLyAyICogTWF0aC5zaW4ocm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeSA9IHBpeGVsO1xuICAgICAgICAgICAgICAgIHRleHRPZmZzZXQgPSAoMSAtIGxpbmVDb3VudCkgKiBsaW5lSGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBiYWNrZHJvcDtcbiAgICAgICAgICAgIGlmIChvcHRzQXRJbmRleC5zaG93TGFiZWxCYWNrZHJvcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsUGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGxhYmVsU2l6ZXMuaGVpZ2h0c1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWR0aCA9IGxhYmVsU2l6ZXMud2lkdGhzW2ldO1xuICAgICAgICAgICAgICAgIGxldCB0b3AgPSB0ZXh0T2Zmc2V0IC0gbGFiZWxQYWRkaW5nLnRvcDtcbiAgICAgICAgICAgICAgICBsZXQgbGVmdCA9IDAgLSBsYWJlbFBhZGRpbmcubGVmdDtcbiAgICAgICAgICAgICAgICBzd2l0Y2godGV4dEJhc2VsaW5lKXtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCAtPSBoZWlnaHQgLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AgLT0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN3aXRjaCh0ZXh0QWxpZ24pe1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSB3aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCAtPSB3aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpbm5lcic6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaWxlbiAtIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZWZ0IC09IHdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQgLT0gd2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJhY2tkcm9wID0ge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aWR0aCArIGxhYmVsUGFkZGluZy53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyBsYWJlbFBhZGRpbmcuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguYmFja2Ryb3BDb2xvclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBmb250LFxuICAgICAgICAgICAgICAgIHRleHRPZmZzZXQsXG4gICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgY29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yLFxuICAgICAgICAgICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEFsaWduOiB0aWNrVGV4dEFsaWduLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0QmFzZWxpbmUsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBiYWNrZHJvcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtcztcbiAgICB9XG4gICAgX2dldFhBeGlzTGFiZWxBbGlnbm1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gLCB0aWNrcyAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSAtdG9SYWRpYW5zKHRoaXMubGFiZWxSb3RhdGlvbik7XG4gICAgICAgIGlmIChyb3RhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHBvc2l0aW9uID09PSAndG9wJyA/ICdsZWZ0JyA6ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGlmICh0aWNrcy5hbGlnbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICBhbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja3MuYWxpZ24gPT09ICdpbm5lcicpIHtcbiAgICAgICAgICAgIGFsaWduID0gJ2lubmVyJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgfVxuICAgIF9nZXRZQXhpc0xhYmVsQWxpZ25tZW50KHRsKSB7XG4gICAgICAgIGNvbnN0IHsgcG9zaXRpb24gLCB0aWNrczogeyBjcm9zc0FsaWduICwgbWlycm9yICwgcGFkZGluZyAgfSAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbGFiZWxTaXplcyA9IHRoaXMuX2dldExhYmVsU2l6ZXMoKTtcbiAgICAgICAgY29uc3QgdGlja0FuZFBhZGRpbmcgPSB0bCArIHBhZGRpbmc7XG4gICAgICAgIGNvbnN0IHdpZGVzdCA9IGxhYmVsU2l6ZXMud2lkZXN0LndpZHRoO1xuICAgICAgICBsZXQgdGV4dEFsaWduO1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5yaWdodCArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIHggKz0gd2lkZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeCA9IHRoaXMucmlnaHQgLSB0aWNrQW5kUGFkZGluZztcbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgeCA9IHRoaXMubGVmdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICBpZiAoY3Jvc3NBbGlnbiA9PT0gJ25lYXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgeCAtPSB3aWRlc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ID0gdGhpcy5sZWZ0ICsgdGlja0FuZFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgaWYgKGNyb3NzQWxpZ24gPT09ICduZWFyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjcm9zc0FsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgICAgICAgICAgICAgICAgeCArPSB3aWRlc3QgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIHggPSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgICAgIHhcbiAgICAgICAgfTtcbiAgICB9XG4gX2NvbXB1dGVMYWJlbEFyZWEoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudGlja3MubWlycm9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgfHwgcG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHRoaXMubGVmdCxcbiAgICAgICAgICAgICAgICBib3R0b206IGNoYXJ0LmhlaWdodCxcbiAgICAgICAgICAgICAgICByaWdodDogdGhpcy5yaWdodFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLmJvdHRvbSxcbiAgICAgICAgICAgICAgICByaWdodDogY2hhcnQud2lkdGhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gZHJhd0JhY2tncm91bmQoKSB7XG4gICAgICAgIGNvbnN0IHsgY3R4ICwgb3B0aW9uczogeyBiYWNrZ3JvdW5kQ29sb3IgIH0gLCBsZWZ0ICwgdG9wICwgd2lkdGggLCBoZWlnaHQgIH0gPSB0aGlzO1xuICAgICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdChsZWZ0LCB0b3AsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRMaW5lV2lkdGhGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgIWdyaWQuZGlzcGxheSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRpY2tzLmZpbmRJbmRleCgodCk9PnQudmFsdWUgPT09IHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBncmlkLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICAgICAgICByZXR1cm4gb3B0cy5saW5lV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuIGRyYXdHcmlkKGNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBncmlkID0gdGhpcy5vcHRpb25zLmdyaWQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dyaWRMaW5lSXRlbXMgfHwgKHRoaXMuX2dyaWRMaW5lSXRlbXMgPSB0aGlzLl9jb21wdXRlR3JpZExpbmVJdGVtcyhjaGFydEFyZWEpKTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGNvbnN0IGRyYXdMaW5lID0gKHAxLCBwMiwgc3R5bGUpPT57XG4gICAgICAgICAgICBpZiAoIXN0eWxlLndpZHRoIHx8ICFzdHlsZS5jb2xvcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgubGluZVdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHlsZS5jb2xvcjtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChzdHlsZS5ib3JkZXJEYXNoIHx8IFtdKTtcbiAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHAxLngsIHAxLnkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhwMi54LCBwMi55KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIGZvcihpID0gMCwgaWxlbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIGlmIChncmlkLmRyYXdPbkNoYXJ0QXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBkcmF3TGluZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLngxLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS55MVxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpdGVtLngyLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS55MlxuICAgICAgICAgICAgICAgICAgICB9LCBpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdyaWQuZHJhd1RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdMaW5lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGl0ZW0udHgxLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaXRlbS50eTFcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogaXRlbS50eDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBpdGVtLnR5MlxuICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogaXRlbS50aWNrQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogaXRlbS50aWNrV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJEYXNoOiBpdGVtLnRpY2tCb3JkZXJEYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9yZGVyRGFzaE9mZnNldDogaXRlbS50aWNrQm9yZGVyRGFzaE9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gZHJhd0JvcmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGFydCAsIGN0eCAsIG9wdGlvbnM6IHsgYm9yZGVyICwgZ3JpZCAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGJvcmRlck9wdHMgPSBib3JkZXIuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIGNvbnN0IGF4aXNXaWR0aCA9IGJvcmRlci5kaXNwbGF5ID8gYm9yZGVyT3B0cy53aWR0aCA6IDA7XG4gICAgICAgIGlmICghYXhpc1dpZHRoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdExpbmVXaWR0aCA9IGdyaWQuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoMCkpLmxpbmVXaWR0aDtcbiAgICAgICAgY29uc3QgYm9yZGVyVmFsdWUgPSB0aGlzLl9ib3JkZXJWYWx1ZTtcbiAgICAgICAgbGV0IHgxLCB4MiwgeTEsIHkyO1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgeDEgPSBfYWxpZ25QaXhlbChjaGFydCwgdGhpcy5sZWZ0LCBheGlzV2lkdGgpIC0gYXhpc1dpZHRoIC8gMjtcbiAgICAgICAgICAgIHgyID0gX2FsaWduUGl4ZWwoY2hhcnQsIHRoaXMucmlnaHQsIGxhc3RMaW5lV2lkdGgpICsgbGFzdExpbmVXaWR0aCAvIDI7XG4gICAgICAgICAgICB5MSA9IHkyID0gYm9yZGVyVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5MSA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLnRvcCwgYXhpc1dpZHRoKSAtIGF4aXNXaWR0aCAvIDI7XG4gICAgICAgICAgICB5MiA9IF9hbGlnblBpeGVsKGNoYXJ0LCB0aGlzLmJvdHRvbSwgbGFzdExpbmVXaWR0aCkgKyBsYXN0TGluZVdpZHRoIC8gMjtcbiAgICAgICAgICAgIHgxID0geDIgPSBib3JkZXJWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gYm9yZGVyT3B0cy53aWR0aDtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyT3B0cy5jb2xvcjtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiBkcmF3TGFiZWxzKGNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBvcHRpb25UaWNrcyA9IHRoaXMub3B0aW9ucy50aWNrcztcbiAgICAgICAgaWYgKCFvcHRpb25UaWNrcy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IGFyZWEgPSB0aGlzLl9jb21wdXRlTGFiZWxBcmVhKCk7XG4gICAgICAgIGlmIChhcmVhKSB7XG4gICAgICAgICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRMYWJlbEl0ZW1zKGNoYXJ0QXJlYSk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcyl7XG4gICAgICAgICAgICBjb25zdCByZW5kZXJUZXh0T3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHRpY2tGb250ID0gaXRlbS5mb250O1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgY29uc3QgeSA9IGl0ZW0udGV4dE9mZnNldDtcbiAgICAgICAgICAgIHJlbmRlclRleHQoY3R4LCBsYWJlbCwgMCwgeSwgdGlja0ZvbnQsIHJlbmRlclRleHRPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJlYSkge1xuICAgICAgICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuIGRyYXdUaXRsZSgpIHtcbiAgICAgICAgY29uc3QgeyBjdHggLCBvcHRpb25zOiB7IHBvc2l0aW9uICwgdGl0bGUgLCByZXZlcnNlICB9ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCF0aXRsZS5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9udCA9IHRvRm9udCh0aXRsZS5mb250KTtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZS5wYWRkaW5nKTtcbiAgICAgICAgY29uc3QgYWxpZ24gPSB0aXRsZS5hbGlnbjtcbiAgICAgICAgbGV0IG9mZnNldCA9IGZvbnQubGluZUhlaWdodCAvIDI7XG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gJ2JvdHRvbScgfHwgcG9zaXRpb24gPT09ICdjZW50ZXInIHx8IGlzT2JqZWN0KHBvc2l0aW9uKSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHBhZGRpbmcuYm90dG9tO1xuICAgICAgICAgICAgaWYgKGlzQXJyYXkodGl0bGUudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gZm9udC5saW5lSGVpZ2h0ICogKHRpdGxlLnRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzZXQgKz0gcGFkZGluZy50b3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB0aXRsZVggLCB0aXRsZVkgLCBtYXhXaWR0aCAsIHJvdGF0aW9uICB9ID0gdGl0bGVBcmdzKHRoaXMsIG9mZnNldCwgcG9zaXRpb24sIGFsaWduKTtcbiAgICAgICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlLnRleHQsIDAsIDAsIGZvbnQsIHtcbiAgICAgICAgICAgIGNvbG9yOiB0aXRsZS5jb2xvcixcbiAgICAgICAgICAgIG1heFdpZHRoLFxuICAgICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRpdGxlQWxpZ24oYWxpZ24sIHBvc2l0aW9uLCByZXZlcnNlKSxcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICAgICAgICB0cmFuc2xhdGlvbjogW1xuICAgICAgICAgICAgICAgIHRpdGxlWCxcbiAgICAgICAgICAgICAgICB0aXRsZVlcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRyYXcoY2hhcnRBcmVhKSB7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKCk7XG4gICAgICAgIHRoaXMuZHJhd0dyaWQoY2hhcnRBcmVhKTtcbiAgICAgICAgdGhpcy5kcmF3Qm9yZGVyKCk7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgIH1cbiBfbGF5ZXJzKCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0eiA9IG9wdHMudGlja3MgJiYgb3B0cy50aWNrcy56IHx8IDA7XG4gICAgICAgIGNvbnN0IGd6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ncmlkICYmIG9wdHMuZ3JpZC56LCAtMSk7XG4gICAgICAgIGNvbnN0IGJ6ID0gdmFsdWVPckRlZmF1bHQob3B0cy5ib3JkZXIgJiYgb3B0cy5ib3JkZXIueiwgMCk7XG4gICAgICAgIGlmICghdGhpcy5faXNWaXNpYmxlKCkgfHwgdGhpcy5kcmF3ICE9PSBTY2FsZS5wcm90b3R5cGUuZHJhdykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHo6IHR6LFxuICAgICAgICAgICAgICAgICAgICBkcmF3OiAoY2hhcnRBcmVhKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KGNoYXJ0QXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgejogZ3osXG4gICAgICAgICAgICAgICAgZHJhdzogKGNoYXJ0QXJlYSk9PntcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3QmFja2dyb3VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdHcmlkKGNoYXJ0QXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB6OiBieixcbiAgICAgICAgICAgICAgICBkcmF3OiAoKT0+e1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdCb3JkZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHo6IHR6LFxuICAgICAgICAgICAgICAgIGRyYXc6IChjaGFydEFyZWEpPT57XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0xhYmVscyhjaGFydEFyZWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICB9XG4gZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXModHlwZSkge1xuICAgICAgICBjb25zdCBtZXRhcyA9IHRoaXMuY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgICAgICBjb25zdCBheGlzSUQgPSB0aGlzLmF4aXMgKyAnQXhpc0lEJztcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBtZXRhcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IG1ldGFzW2ldO1xuICAgICAgICAgICAgaWYgKG1ldGFbYXhpc0lEXSA9PT0gdGhpcy5pZCAmJiAoIXR5cGUgfHwgbWV0YS50eXBlID09PSB0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1ldGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuIF9yZXNvbHZlVGlja0ZvbnRPcHRpb25zKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnMudGlja3Muc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoaW5kZXgpKTtcbiAgICAgICAgcmV0dXJuIHRvRm9udChvcHRzLmZvbnQpO1xuICAgIH1cbiBfbWF4RGlnaXRzKCkge1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCkubGluZUhlaWdodDtcbiAgICAgICAgcmV0dXJuICh0aGlzLmlzSG9yaXpvbnRhbCgpID8gdGhpcy53aWR0aCA6IHRoaXMuaGVpZ2h0KSAvIGZvbnRTaXplO1xuICAgIH1cbn1cblxuY2xhc3MgVHlwZWRSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgc2NvcGUsIG92ZXJyaWRlKXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlO1xuICAgICAgICB0aGlzLm92ZXJyaWRlID0gb3ZlcnJpZGU7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBpc0ZvclR5cGUodHlwZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5pc1Byb3RvdHlwZU9mLmNhbGwodGhpcy50eXBlLnByb3RvdHlwZSwgdHlwZS5wcm90b3R5cGUpO1xuICAgIH1cbiByZWdpc3RlcihpdGVtKSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGl0ZW0pO1xuICAgICAgICBsZXQgcGFyZW50U2NvcGU7XG4gICAgICAgIGlmIChpc0lDaGFydENvbXBvbmVudChwcm90bykpIHtcbiAgICAgICAgICAgIHBhcmVudFNjb3BlID0gdGhpcy5yZWdpc3Rlcihwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZSArICcuJyArIGlkO1xuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsYXNzIGRvZXMgbm90IGhhdmUgaWQ6ICcgKyBpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWQgaW4gaXRlbXMpIHtcbiAgICAgICAgICAgIHJldHVybiBzY29wZTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtc1tpZF0gPSBpdGVtO1xuICAgICAgICByZWdpc3RlckRlZmF1bHRzKGl0ZW0sIHNjb3BlLCBwYXJlbnRTY29wZSk7XG4gICAgICAgIGlmICh0aGlzLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5vdmVycmlkZShpdGVtLmlkLCBpdGVtLm92ZXJyaWRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiBnZXQoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXRlbXNbaWRdO1xuICAgIH1cbiB1bnJlZ2lzdGVyKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSB0aGlzLml0ZW1zO1xuICAgICAgICBjb25zdCBpZCA9IGl0ZW0uaWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZTtcbiAgICAgICAgaWYgKGlkIGluIGl0ZW1zKSB7XG4gICAgICAgICAgICBkZWxldGUgaXRlbXNbaWRdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY29wZSAmJiBpZCBpbiBkZWZhdWx0c1tzY29wZV0pIHtcbiAgICAgICAgICAgIGRlbGV0ZSBkZWZhdWx0c1tzY29wZV1baWRdO1xuICAgICAgICAgICAgaWYgKHRoaXMub3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb3ZlcnJpZGVzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdHMoaXRlbSwgc2NvcGUsIHBhcmVudFNjb3BlKSB7XG4gICAgY29uc3QgaXRlbURlZmF1bHRzID0gbWVyZ2UoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgICAgICBwYXJlbnRTY29wZSA/IGRlZmF1bHRzLmdldChwYXJlbnRTY29wZSkgOiB7fSxcbiAgICAgICAgZGVmYXVsdHMuZ2V0KHNjb3BlKSxcbiAgICAgICAgaXRlbS5kZWZhdWx0c1xuICAgIF0pO1xuICAgIGRlZmF1bHRzLnNldChzY29wZSwgaXRlbURlZmF1bHRzKTtcbiAgICBpZiAoaXRlbS5kZWZhdWx0Um91dGVzKSB7XG4gICAgICAgIHJvdXRlRGVmYXVsdHMoc2NvcGUsIGl0ZW0uZGVmYXVsdFJvdXRlcyk7XG4gICAgfVxuICAgIGlmIChpdGVtLmRlc2NyaXB0b3JzKSB7XG4gICAgICAgIGRlZmF1bHRzLmRlc2NyaWJlKHNjb3BlLCBpdGVtLmRlc2NyaXB0b3JzKTtcbiAgICB9XG59XG5mdW5jdGlvbiByb3V0ZURlZmF1bHRzKHNjb3BlLCByb3V0ZXMpIHtcbiAgICBPYmplY3Qua2V5cyhyb3V0ZXMpLmZvckVhY2goKHByb3BlcnR5KT0+e1xuICAgICAgICBjb25zdCBwcm9wZXJ0eVBhcnRzID0gcHJvcGVydHkuc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3Qgc291cmNlTmFtZSA9IHByb3BlcnR5UGFydHMucG9wKCk7XG4gICAgICAgIGNvbnN0IHNvdXJjZVNjb3BlID0gW1xuICAgICAgICAgICAgc2NvcGVcbiAgICAgICAgXS5jb25jYXQocHJvcGVydHlQYXJ0cykuam9pbignLicpO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHJvdXRlc1twcm9wZXJ0eV0uc3BsaXQoJy4nKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0TmFtZSA9IHBhcnRzLnBvcCgpO1xuICAgICAgICBjb25zdCB0YXJnZXRTY29wZSA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgZGVmYXVsdHMucm91dGUoc291cmNlU2NvcGUsIHNvdXJjZU5hbWUsIHRhcmdldFNjb3BlLCB0YXJnZXROYW1lKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzSUNoYXJ0Q29tcG9uZW50KHByb3RvKSB7XG4gICAgcmV0dXJuICdpZCcgaW4gcHJvdG8gJiYgJ2RlZmF1bHRzJyBpbiBwcm90bztcbn1cblxuY2xhc3MgUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMuY29udHJvbGxlcnMgPSBuZXcgVHlwZWRSZWdpc3RyeShEYXRhc2V0Q29udHJvbGxlciwgJ2RhdGFzZXRzJywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgVHlwZWRSZWdpc3RyeShFbGVtZW50LCAnZWxlbWVudHMnKTtcbiAgICAgICAgdGhpcy5wbHVnaW5zID0gbmV3IFR5cGVkUmVnaXN0cnkoT2JqZWN0LCAncGx1Z2lucycpO1xuICAgICAgICB0aGlzLnNjYWxlcyA9IG5ldyBUeXBlZFJlZ2lzdHJ5KFNjYWxlLCAnc2NhbGVzJyk7XG4gICAgICAgIHRoaXMuX3R5cGVkUmVnaXN0cmllcyA9IFtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcnMsXG4gICAgICAgICAgICB0aGlzLnNjYWxlcyxcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHNcbiAgICAgICAgXTtcbiAgICB9XG4gYWRkKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzKTtcbiAgICB9XG4gICAgcmVtb3ZlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MpO1xuICAgIH1cbiBhZGRDb250cm9sbGVycyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gICAgfVxuIGFkZEVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLmVsZW1lbnRzKTtcbiAgICB9XG4gYWRkUGx1Z2lucyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VhY2goJ3JlZ2lzdGVyJywgYXJncywgdGhpcy5wbHVnaW5zKTtcbiAgICB9XG4gYWRkU2NhbGVzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgncmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gICAgfVxuIGdldENvbnRyb2xsZXIoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5jb250cm9sbGVycywgJ2NvbnRyb2xsZXInKTtcbiAgICB9XG4gZ2V0RWxlbWVudChpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KGlkLCB0aGlzLmVsZW1lbnRzLCAnZWxlbWVudCcpO1xuICAgIH1cbiBnZXRQbHVnaW4oaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldChpZCwgdGhpcy5wbHVnaW5zLCAncGx1Z2luJyk7XG4gICAgfVxuIGdldFNjYWxlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQoaWQsIHRoaXMuc2NhbGVzLCAnc2NhbGUnKTtcbiAgICB9XG4gcmVtb3ZlQ29udHJvbGxlcnMoLi4uYXJncykge1xuICAgICAgICB0aGlzLl9lYWNoKCd1bnJlZ2lzdGVyJywgYXJncywgdGhpcy5jb250cm9sbGVycyk7XG4gICAgfVxuIHJlbW92ZUVsZW1lbnRzKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiByZW1vdmVQbHVnaW5zKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fZWFjaCgndW5yZWdpc3RlcicsIGFyZ3MsIHRoaXMucGx1Z2lucyk7XG4gICAgfVxuIHJlbW92ZVNjYWxlcyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2VhY2goJ3VucmVnaXN0ZXInLCBhcmdzLCB0aGlzLnNjYWxlcyk7XG4gICAgfVxuIF9lYWNoKG1ldGhvZCwgYXJncywgdHlwZWRSZWdpc3RyeSkge1xuICAgICAgICBbXG4gICAgICAgICAgICAuLi5hcmdzXG4gICAgICAgIF0uZm9yRWFjaCgoYXJnKT0+e1xuICAgICAgICAgICAgY29uc3QgcmVnID0gdHlwZWRSZWdpc3RyeSB8fCB0aGlzLl9nZXRSZWdpc3RyeUZvclR5cGUoYXJnKTtcbiAgICAgICAgICAgIGlmICh0eXBlZFJlZ2lzdHJ5IHx8IHJlZy5pc0ZvclR5cGUoYXJnKSB8fCByZWcgPT09IHRoaXMucGx1Z2lucyAmJiBhcmcuaWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leGVjKG1ldGhvZCwgcmVnLCBhcmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlYWNoKGFyZywgKGl0ZW0pPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1SZWcgPSB0eXBlZFJlZ2lzdHJ5IHx8IHRoaXMuX2dldFJlZ2lzdHJ5Rm9yVHlwZShpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXhlYyhtZXRob2QsIGl0ZW1SZWcsIGl0ZW0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gX2V4ZWMobWV0aG9kLCByZWdpc3RyeSwgY29tcG9uZW50KSB7XG4gICAgICAgIGNvbnN0IGNhbWVsTWV0aG9kID0gX2NhcGl0YWxpemUobWV0aG9kKTtcbiAgICAgICAgY2FsbGJhY2soY29tcG9uZW50WydiZWZvcmUnICsgY2FtZWxNZXRob2RdLCBbXSwgY29tcG9uZW50KTtcbiAgICAgICAgcmVnaXN0cnlbbWV0aG9kXShjb21wb25lbnQpO1xuICAgICAgICBjYWxsYmFjayhjb21wb25lbnRbJ2FmdGVyJyArIGNhbWVsTWV0aG9kXSwgW10sIGNvbXBvbmVudCk7XG4gICAgfVxuIF9nZXRSZWdpc3RyeUZvclR5cGUodHlwZSkge1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5fdHlwZWRSZWdpc3RyaWVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IHJlZyA9IHRoaXMuX3R5cGVkUmVnaXN0cmllc1tpXTtcbiAgICAgICAgICAgIGlmIChyZWcuaXNGb3JUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wbHVnaW5zO1xuICAgIH1cbiBfZ2V0KGlkLCB0eXBlZFJlZ2lzdHJ5LCB0eXBlKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0eXBlZFJlZ2lzdHJ5LmdldChpZCk7XG4gICAgICAgIGlmIChpdGVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignXCInICsgaWQgKyAnXCIgaXMgbm90IGEgcmVnaXN0ZXJlZCAnICsgdHlwZSArICcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxufVxudmFyIHJlZ2lzdHJ5ID0gLyogI19fUFVSRV9fICovIG5ldyBSZWdpc3RyeSgpO1xuXG5jbGFzcyBQbHVnaW5TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLl9pbml0ID0gW107XG4gICAgfVxuIG5vdGlmeShjaGFydCwgaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgICAgIGlmIChob29rID09PSAnYmVmb3JlSW5pdCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXQgPSB0aGlzLl9jcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICdpbnN0YWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBmaWx0ZXIgPyB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCkuZmlsdGVyKGZpbHRlcikgOiB0aGlzLl9kZXNjcmlwdG9ycyhjaGFydCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsIGhvb2ssIGFyZ3MpO1xuICAgICAgICBpZiAoaG9vayA9PT0gJ2FmdGVyRGVzdHJveScpIHtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeShkZXNjcmlwdG9ycywgY2hhcnQsICdzdG9wJyk7XG4gICAgICAgICAgICB0aGlzLl9ub3RpZnkodGhpcy5faW5pdCwgY2hhcnQsICd1bmluc3RhbGwnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiBfbm90aWZ5KGRlc2NyaXB0b3JzLCBjaGFydCwgaG9vaywgYXJncykge1xuICAgICAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICAgICAgZm9yIChjb25zdCBkZXNjcmlwdG9yIG9mIGRlc2NyaXB0b3JzKXtcbiAgICAgICAgICAgIGNvbnN0IHBsdWdpbiA9IGRlc2NyaXB0b3IucGx1Z2luO1xuICAgICAgICAgICAgY29uc3QgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gW1xuICAgICAgICAgICAgICAgIGNoYXJ0LFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5vcHRpb25zXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG1ldGhvZCwgcGFyYW1zLCBwbHVnaW4pID09PSBmYWxzZSAmJiBhcmdzLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGludmFsaWRhdGUoKSB7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih0aGlzLl9jYWNoZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX29sZENhY2hlID0gdGhpcy5fY2FjaGU7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiBfZGVzY3JpcHRvcnMoY2hhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSB0aGlzLl9jYWNoZSA9IHRoaXMuX2NyZWF0ZURlc2NyaXB0b3JzKGNoYXJ0KTtcbiAgICAgICAgdGhpcy5fbm90aWZ5U3RhdGVDaGFuZ2VzKGNoYXJ0KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICAgIH1cbiAgICBfY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIGFsbCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSBjaGFydCAmJiBjaGFydC5jb25maWc7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB2YWx1ZU9yRGVmYXVsdChjb25maWcub3B0aW9ucyAmJiBjb25maWcub3B0aW9ucy5wbHVnaW5zLCB7fSk7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBhbGxQbHVnaW5zKGNvbmZpZyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zID09PSBmYWxzZSAmJiAhYWxsID8gW10gOiBjcmVhdGVEZXNjcmlwdG9ycyhjaGFydCwgcGx1Z2lucywgb3B0aW9ucywgYWxsKTtcbiAgICB9XG4gX25vdGlmeVN0YXRlQ2hhbmdlcyhjaGFydCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c0Rlc2NyaXB0b3JzID0gdGhpcy5fb2xkQ2FjaGUgfHwgW107XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gdGhpcy5fY2FjaGU7XG4gICAgICAgIGNvbnN0IGRpZmYgPSAoYSwgYik9PmEuZmlsdGVyKCh4KT0+IWIuc29tZSgoeSk9PngucGx1Z2luLmlkID09PSB5LnBsdWdpbi5pZCkpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoZGlmZihwcmV2aW91c0Rlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RvcCcpO1xuICAgICAgICB0aGlzLl9ub3RpZnkoZGlmZihkZXNjcmlwdG9ycywgcHJldmlvdXNEZXNjcmlwdG9ycyksIGNoYXJ0LCAnc3RhcnQnKTtcbiAgICB9XG59XG4gZnVuY3Rpb24gYWxsUGx1Z2lucyhjb25maWcpIHtcbiAgICBjb25zdCBsb2NhbElkcyA9IHt9O1xuICAgIGNvbnN0IHBsdWdpbnMgPSBbXTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocmVnaXN0cnkucGx1Z2lucy5pdGVtcyk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspe1xuICAgICAgICBwbHVnaW5zLnB1c2gocmVnaXN0cnkuZ2V0UGx1Z2luKGtleXNbaV0pKTtcbiAgICB9XG4gICAgY29uc3QgbG9jYWwgPSBjb25maWcucGx1Z2lucyB8fCBbXTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBsb2NhbFtpXTtcbiAgICAgICAgaWYgKHBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICBsb2NhbElkc1twbHVnaW4uaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwbHVnaW5zLFxuICAgICAgICBsb2NhbElkc1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRPcHRzKG9wdGlvbnMsIGFsbCkge1xuICAgIGlmICghYWxsICYmIG9wdGlvbnMgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVzY3JpcHRvcnMoY2hhcnQsIHsgcGx1Z2lucyAsIGxvY2FsSWRzICB9LCBvcHRpb25zLCBhbGwpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBjb250ZXh0ID0gY2hhcnQuZ2V0Q29udGV4dCgpO1xuICAgIGZvciAoY29uc3QgcGx1Z2luIG9mIHBsdWdpbnMpe1xuICAgICAgICBjb25zdCBpZCA9IHBsdWdpbi5pZDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGdldE9wdHMob3B0aW9uc1tpZF0sIGFsbCk7XG4gICAgICAgIGlmIChvcHRzID09PSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICBvcHRpb25zOiBwbHVnaW5PcHRzKGNoYXJ0LmNvbmZpZywge1xuICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICBsb2NhbDogbG9jYWxJZHNbaWRdXG4gICAgICAgICAgICB9LCBvcHRzLCBjb250ZXh0KVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHBsdWdpbk9wdHMoY29uZmlnLCB7IHBsdWdpbiAsIGxvY2FsICB9LCBvcHRzLCBjb250ZXh0KSB7XG4gICAgY29uc3Qga2V5cyA9IGNvbmZpZy5wbHVnaW5TY29wZUtleXMocGx1Z2luKTtcbiAgICBjb25zdCBzY29wZXMgPSBjb25maWcuZ2V0T3B0aW9uU2NvcGVzKG9wdHMsIGtleXMpO1xuICAgIGlmIChsb2NhbCAmJiBwbHVnaW4uZGVmYXVsdHMpIHtcbiAgICAgICAgc2NvcGVzLnB1c2gocGx1Z2luLmRlZmF1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZpZy5jcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIFtcbiAgICAgICAgJydcbiAgICBdLCB7XG4gICAgICAgIHNjcmlwdGFibGU6IGZhbHNlLFxuICAgICAgICBpbmRleGFibGU6IGZhbHNlLFxuICAgICAgICBhbGxLZXlzOiB0cnVlXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV0gfHwge307XG4gICAgY29uc3QgZGF0YXNldE9wdGlvbnMgPSAob3B0aW9ucy5kYXRhc2V0cyB8fCB7fSlbdHlwZV0gfHwge307XG4gICAgcmV0dXJuIGRhdGFzZXRPcHRpb25zLmluZGV4QXhpcyB8fCBvcHRpb25zLmluZGV4QXhpcyB8fCBkYXRhc2V0RGVmYXVsdHMuaW5kZXhBeGlzIHx8ICd4Jztcbn1cbmZ1bmN0aW9uIGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoaWQsIGluZGV4QXhpcykge1xuICAgIGxldCBheGlzID0gaWQ7XG4gICAgaWYgKGlkID09PSAnX2luZGV4XycpIHtcbiAgICAgICAgYXhpcyA9IGluZGV4QXhpcztcbiAgICB9IGVsc2UgaWYgKGlkID09PSAnX3ZhbHVlXycpIHtcbiAgICAgICAgYXhpcyA9IGluZGV4QXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICAgIH1cbiAgICByZXR1cm4gYXhpcztcbn1cbmZ1bmN0aW9uIGdldERlZmF1bHRTY2FsZUlERnJvbUF4aXMoYXhpcywgaW5kZXhBeGlzKSB7XG4gICAgcmV0dXJuIGF4aXMgPT09IGluZGV4QXhpcyA/ICdfaW5kZXhfJyA6ICdfdmFsdWVfJztcbn1cbmZ1bmN0aW9uIGlkTWF0Y2hlc0F4aXMoaWQpIHtcbiAgICBpZiAoaWQgPT09ICd4JyB8fCBpZCA9PT0gJ3knIHx8IGlkID09PSAncicpIHtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF4aXNGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICByZXR1cm4gJ3gnO1xuICAgIH1cbiAgICBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyB8fCBwb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICByZXR1cm4gJ3knO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZUF4aXMoaWQsIC4uLnNjYWxlT3B0aW9ucykge1xuICAgIGlmIChpZE1hdGNoZXNBeGlzKGlkKSkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb3B0cyBvZiBzY2FsZU9wdGlvbnMpe1xuICAgICAgICBjb25zdCBheGlzID0gb3B0cy5heGlzIHx8IGF4aXNGcm9tUG9zaXRpb24ob3B0cy5wb3NpdGlvbikgfHwgaWQubGVuZ3RoID4gMSAmJiBpZE1hdGNoZXNBeGlzKGlkWzBdLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoYXhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGF4aXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGV0ZXJtaW5lIHR5cGUgb2YgJyR7aWR9JyBheGlzLiBQbGVhc2UgcHJvdmlkZSAnYXhpcycgb3IgJ3Bvc2l0aW9uJyBvcHRpb24uYCk7XG59XG5mdW5jdGlvbiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsIGF4aXMsIGRhdGFzZXQpIHtcbiAgICBpZiAoZGF0YXNldFtheGlzICsgJ0F4aXNJRCddID09PSBpZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYXhpc1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJldHJpZXZlQXhpc0Zyb21EYXRhc2V0cyhpZCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZy5kYXRhICYmIGNvbmZpZy5kYXRhLmRhdGFzZXRzKSB7XG4gICAgICAgIGNvbnN0IGJvdW5kRHMgPSBjb25maWcuZGF0YS5kYXRhc2V0cy5maWx0ZXIoKGQpPT5kLnhBeGlzSUQgPT09IGlkIHx8IGQueUF4aXNJRCA9PT0gaWQpO1xuICAgICAgICBpZiAoYm91bmREcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBeGlzRnJvbURhdGFzZXQoaWQsICd4JywgYm91bmREc1swXSkgfHwgZ2V0QXhpc0Zyb21EYXRhc2V0KGlkLCAneScsIGJvdW5kRHNbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7fTtcbn1cbmZ1bmN0aW9uIG1lcmdlU2NhbGVDb25maWcoY29uZmlnLCBvcHRpb25zKSB7XG4gICAgY29uc3QgY2hhcnREZWZhdWx0cyA9IG92ZXJyaWRlc1tjb25maWcudHlwZV0gfHwge1xuICAgICAgICBzY2FsZXM6IHt9XG4gICAgfTtcbiAgICBjb25zdCBjb25maWdTY2FsZXMgPSBvcHRpb25zLnNjYWxlcyB8fCB7fTtcbiAgICBjb25zdCBjaGFydEluZGV4QXhpcyA9IGdldEluZGV4QXhpcyhjb25maWcudHlwZSwgb3B0aW9ucyk7XG4gICAgY29uc3Qgc2NhbGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBPYmplY3Qua2V5cyhjb25maWdTY2FsZXMpLmZvckVhY2goKGlkKT0+e1xuICAgICAgICBjb25zdCBzY2FsZUNvbmYgPSBjb25maWdTY2FsZXNbaWRdO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHNjYWxlQ29uZikpIHtcbiAgICAgICAgICAgIHJldHVybiBjb25zb2xlLmVycm9yKGBJbnZhbGlkIHNjYWxlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlOiAke2lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2FsZUNvbmYuX3Byb3h5KSB7XG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGBJZ25vcmluZyByZXNvbHZlciBwYXNzZWQgYXMgb3B0aW9ucyBmb3Igc2NhbGU6ICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlQ29uZiwgcmV0cmlldmVBeGlzRnJvbURhdGFzZXRzKGlkLCBjb25maWcpLCBkZWZhdWx0cy5zY2FsZXNbc2NhbGVDb25mLnR5cGVdKTtcbiAgICAgICAgY29uc3QgZGVmYXVsdElkID0gZ2V0RGVmYXVsdFNjYWxlSURGcm9tQXhpcyhheGlzLCBjaGFydEluZGV4QXhpcyk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTY2FsZU9wdGlvbnMgPSBjaGFydERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICAgICAgc2NhbGVzW2lkXSA9IG1lcmdlSWYoT2JqZWN0LmNyZWF0ZShudWxsKSwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2FsZUNvbmYsXG4gICAgICAgICAgICBkZWZhdWx0U2NhbGVPcHRpb25zW2F4aXNdLFxuICAgICAgICAgICAgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SWRdXG4gICAgICAgIF0pO1xuICAgIH0pO1xuICAgIGNvbmZpZy5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQpPT57XG4gICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgY29uZmlnLnR5cGU7XG4gICAgICAgIGNvbnN0IGluZGV4QXhpcyA9IGRhdGFzZXQuaW5kZXhBeGlzIHx8IGdldEluZGV4QXhpcyh0eXBlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YXNldERlZmF1bHRzID0gb3ZlcnJpZGVzW3R5cGVdIHx8IHt9O1xuICAgICAgICBjb25zdCBkZWZhdWx0U2NhbGVPcHRpb25zID0gZGF0YXNldERlZmF1bHRzLnNjYWxlcyB8fCB7fTtcbiAgICAgICAgT2JqZWN0LmtleXMoZGVmYXVsdFNjYWxlT3B0aW9ucykuZm9yRWFjaCgoZGVmYXVsdElEKT0+e1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IGdldEF4aXNGcm9tRGVmYXVsdFNjYWxlSUQoZGVmYXVsdElELCBpbmRleEF4aXMpO1xuICAgICAgICAgICAgY29uc3QgaWQgPSBkYXRhc2V0W2F4aXMgKyAnQXhpc0lEJ10gfHwgYXhpcztcbiAgICAgICAgICAgIHNjYWxlc1tpZF0gPSBzY2FsZXNbaWRdIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBtZXJnZUlmKHNjYWxlc1tpZF0sIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGF4aXNcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvbmZpZ1NjYWxlc1tpZF0sXG4gICAgICAgICAgICAgICAgZGVmYXVsdFNjYWxlT3B0aW9uc1tkZWZhdWx0SURdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgT2JqZWN0LmtleXMoc2NhbGVzKS5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGNvbnN0IHNjYWxlID0gc2NhbGVzW2tleV07XG4gICAgICAgIG1lcmdlSWYoc2NhbGUsIFtcbiAgICAgICAgICAgIGRlZmF1bHRzLnNjYWxlc1tzY2FsZS50eXBlXSxcbiAgICAgICAgICAgIGRlZmF1bHRzLnNjYWxlXG4gICAgICAgIF0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzY2FsZXM7XG59XG5mdW5jdGlvbiBpbml0T3B0aW9ucyhjb25maWcpIHtcbiAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLm9wdGlvbnMgfHwgKGNvbmZpZy5vcHRpb25zID0ge30pO1xuICAgIG9wdGlvbnMucGx1Z2lucyA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMucGx1Z2lucywge30pO1xuICAgIG9wdGlvbnMuc2NhbGVzID0gbWVyZ2VTY2FsZUNvbmZpZyhjb25maWcsIG9wdGlvbnMpO1xufVxuZnVuY3Rpb24gaW5pdERhdGEoZGF0YSkge1xuICAgIGRhdGEgPSBkYXRhIHx8IHt9O1xuICAgIGRhdGEuZGF0YXNldHMgPSBkYXRhLmRhdGFzZXRzIHx8IFtdO1xuICAgIGRhdGEubGFiZWxzID0gZGF0YS5sYWJlbHMgfHwgW107XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBpbml0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25maWcuZGF0YSA9IGluaXREYXRhKGNvbmZpZy5kYXRhKTtcbiAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG59XG5jb25zdCBrZXlDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IGtleXNDYWNoZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBjYWNoZWRLZXlzKGNhY2hlS2V5LCBnZW5lcmF0ZSkge1xuICAgIGxldCBrZXlzID0ga2V5Q2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWtleXMpIHtcbiAgICAgICAga2V5cyA9IGdlbmVyYXRlKCk7XG4gICAgICAgIGtleUNhY2hlLnNldChjYWNoZUtleSwga2V5cyk7XG4gICAgICAgIGtleXNDYWNoZWQuYWRkKGtleXMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmNvbnN0IGFkZElmRm91bmQgPSAoc2V0LCBvYmosIGtleSk9PntcbiAgICBjb25zdCBvcHRzID0gcmVzb2x2ZU9iamVjdEtleShvYmosIGtleSk7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXQuYWRkKG9wdHMpO1xuICAgIH1cbn07XG5jbGFzcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XG4gICAgICAgIHRoaXMuX2NvbmZpZyA9IGluaXRDb25maWcoY29uZmlnKTtcbiAgICAgICAgdGhpcy5fc2NvcGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fcmVzb2x2ZXJDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgZ2V0IHBsYXRmb3JtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnBsYXRmb3JtO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy50eXBlO1xuICAgIH1cbiAgICBzZXQgdHlwZSh0eXBlKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcuZGF0YTtcbiAgICB9XG4gICAgc2V0IGRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLl9jb25maWcuZGF0YSA9IGluaXREYXRhKGRhdGEpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbmZpZy5vcHRpb25zO1xuICAgIH1cbiAgICBzZXQgb3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IHBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWcucGx1Z2lucztcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBjb25zdCBjb25maWcgPSB0aGlzLl9jb25maWc7XG4gICAgICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICAgICAgICBpbml0T3B0aW9ucyhjb25maWcpO1xuICAgIH1cbiAgICBjbGVhckNhY2hlKCkge1xuICAgICAgICB0aGlzLl9zY29wZUNhY2hlLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX3Jlc29sdmVyQ2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gZGF0YXNldFNjb3BlS2V5cyhkYXRhc2V0VHlwZSkge1xuICAgICAgICByZXR1cm4gY2FjaGVkS2V5cyhkYXRhc2V0VHlwZSwgKCk9PltcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSk7XG4gICAgfVxuIGRhdGFzZXRBbmltYXRpb25TY29wZUtleXMoZGF0YXNldFR5cGUsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LnRyYW5zaXRpb24uJHt0cmFuc2l0aW9ufWAsICgpPT5bXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX0udHJhbnNpdGlvbnMuJHt0cmFuc2l0aW9ufWAsXG4gICAgICAgICAgICAgICAgICAgIGB0cmFuc2l0aW9ucy4ke3RyYW5zaXRpb259YFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBgZGF0YXNldHMuJHtkYXRhc2V0VHlwZX1gLFxuICAgICAgICAgICAgICAgICAgICAnJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIF0pO1xuICAgIH1cbiBkYXRhc2V0RWxlbWVudFNjb3BlS2V5cyhkYXRhc2V0VHlwZSwgZWxlbWVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNhY2hlZEtleXMoYCR7ZGF0YXNldFR5cGV9LSR7ZWxlbWVudFR5cGV9YCwgKCk9PltcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfS5lbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIGBkYXRhc2V0cy4ke2RhdGFzZXRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgIGBlbGVtZW50cy4ke2VsZW1lbnRUeXBlfWAsXG4gICAgICAgICAgICAgICAgICAgICcnXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSk7XG4gICAgfVxuIHBsdWdpblNjb3BlS2V5cyhwbHVnaW4pIHtcbiAgICAgICAgY29uc3QgaWQgPSBwbHVnaW4uaWQ7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIHJldHVybiBjYWNoZWRLZXlzKGAke3R5cGV9LXBsdWdpbi0ke2lkfWAsICgpPT5bXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBgcGx1Z2lucy4ke2lkfWAsXG4gICAgICAgICAgICAgICAgICAgIC4uLnBsdWdpbi5hZGRpdGlvbmFsT3B0aW9uU2NvcGVzIHx8IFtdXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXSk7XG4gICAgfVxuIF9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKSB7XG4gICAgICAgIGNvbnN0IF9zY29wZUNhY2hlID0gdGhpcy5fc2NvcGVDYWNoZTtcbiAgICAgICAgbGV0IGNhY2hlID0gX3Njb3BlQ2FjaGUuZ2V0KG1haW5TY29wZSk7XG4gICAgICAgIGlmICghY2FjaGUgfHwgcmVzZXRDYWNoZSkge1xuICAgICAgICAgICAgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBfc2NvcGVDYWNoZS5zZXQobWFpblNjb3BlLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlO1xuICAgIH1cbiBnZXRPcHRpb25TY29wZXMobWFpblNjb3BlLCBrZXlMaXN0cywgcmVzZXRDYWNoZSkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgLCB0eXBlICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgY2FjaGUgPSB0aGlzLl9jYWNoZWRTY29wZXMobWFpblNjb3BlLCByZXNldENhY2hlKTtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gY2FjaGUuZ2V0KGtleUxpc3RzKTtcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY29wZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGtleUxpc3RzLmZvckVhY2goKGtleXMpPT57XG4gICAgICAgICAgICBpZiAobWFpblNjb3BlKSB7XG4gICAgICAgICAgICAgICAgc2NvcGVzLmFkZChtYWluU2NvcGUpO1xuICAgICAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KT0+YWRkSWZGb3VuZChzY29wZXMsIG1haW5TY29wZSwga2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKGtleSk9PmFkZElmRm91bmQoc2NvcGVzLCBvcHRpb25zLCBrZXkpKTtcbiAgICAgICAgICAgIGtleXMuZm9yRWFjaCgoa2V5KT0+YWRkSWZGb3VuZChzY29wZXMsIG92ZXJyaWRlc1t0eXBlXSB8fCB7fSwga2V5KSk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKGtleSk9PmFkZElmRm91bmQoc2NvcGVzLCBkZWZhdWx0cywga2V5KSk7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKGtleSk9PmFkZElmRm91bmQoc2NvcGVzLCBkZXNjcmlwdG9ycywga2V5KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhcnJheSA9IEFycmF5LmZyb20oc2NvcGVzKTtcbiAgICAgICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYXJyYXkucHVzaChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5c0NhY2hlZC5oYXMoa2V5TGlzdHMpKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQoa2V5TGlzdHMsIGFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuIGNoYXJ0T3B0aW9uU2NvcGVzKCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnMgLCB0eXBlICB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvdmVycmlkZXNbdHlwZV0gfHwge30sXG4gICAgICAgICAgICBkZWZhdWx0cy5kYXRhc2V0c1t0eXBlXSB8fCB7fSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgICAgICBkZXNjcmlwdG9yc1xuICAgICAgICBdO1xuICAgIH1cbiByZXNvbHZlTmFtZWRPcHRpb25zKHNjb3BlcywgbmFtZXMsIGNvbnRleHQsIHByZWZpeGVzID0gW1xuICAgICAgICAnJ1xuICAgIF0pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgJHNoYXJlZDogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHJlc29sdmVyICwgc3ViUHJlZml4ZXMgIH0gPSBnZXRSZXNvbHZlcih0aGlzLl9yZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKTtcbiAgICAgICAgbGV0IG9wdGlvbnMgPSByZXNvbHZlcjtcbiAgICAgICAgaWYgKG5lZWRDb250ZXh0KHJlc29sdmVyLCBuYW1lcykpIHtcbiAgICAgICAgICAgIHJlc3VsdC4kc2hhcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb250ZXh0ID0gaXNGdW5jdGlvbihjb250ZXh0KSA/IGNvbnRleHQoKSA6IGNvbnRleHQ7XG4gICAgICAgICAgICBjb25zdCBzdWJSZXNvbHZlciA9IHRoaXMuY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBjb250ZXh0LCBzdWJQcmVmaXhlcyk7XG4gICAgICAgICAgICBvcHRpb25zID0gX2F0dGFjaENvbnRleHQocmVzb2x2ZXIsIGNvbnRleHQsIHN1YlJlc29sdmVyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2YgbmFtZXMpe1xuICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb3B0aW9uc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiBjcmVhdGVSZXNvbHZlcihzY29wZXMsIGNvbnRleHQsIHByZWZpeGVzID0gW1xuICAgICAgICAnJ1xuICAgIF0sIGRlc2NyaXB0b3JEZWZhdWx0cykge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVyICB9ID0gZ2V0UmVzb2x2ZXIodGhpcy5fcmVzb2x2ZXJDYWNoZSwgc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgICAgIHJldHVybiBpc09iamVjdChjb250ZXh0KSA/IF9hdHRhY2hDb250ZXh0KHJlc29sdmVyLCBjb250ZXh0LCB1bmRlZmluZWQsIGRlc2NyaXB0b3JEZWZhdWx0cykgOiByZXNvbHZlcjtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSZXNvbHZlcihyZXNvbHZlckNhY2hlLCBzY29wZXMsIHByZWZpeGVzKSB7XG4gICAgbGV0IGNhY2hlID0gcmVzb2x2ZXJDYWNoZS5nZXQoc2NvcGVzKTtcbiAgICBpZiAoIWNhY2hlKSB7XG4gICAgICAgIGNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICByZXNvbHZlckNhY2hlLnNldChzY29wZXMsIGNhY2hlKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGVLZXkgPSBwcmVmaXhlcy5qb2luKCk7XG4gICAgbGV0IGNhY2hlZCA9IGNhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKCFjYWNoZWQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXIgPSBfY3JlYXRlUmVzb2x2ZXIoc2NvcGVzLCBwcmVmaXhlcyk7XG4gICAgICAgIGNhY2hlZCA9IHtcbiAgICAgICAgICAgIHJlc29sdmVyLFxuICAgICAgICAgICAgc3ViUHJlZml4ZXM6IHByZWZpeGVzLmZpbHRlcigocCk9PiFwLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2hvdmVyJykpXG4gICAgICAgIH07XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgY2FjaGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhY2hlZDtcbn1cbmNvbnN0IGhhc0Z1bmN0aW9uID0gKHZhbHVlKT0+aXNPYmplY3QodmFsdWUpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKS5zb21lKChrZXkpPT5pc0Z1bmN0aW9uKHZhbHVlW2tleV0pKTtcbmZ1bmN0aW9uIG5lZWRDb250ZXh0KHByb3h5LCBuYW1lcykge1xuICAgIGNvbnN0IHsgaXNTY3JpcHRhYmxlICwgaXNJbmRleGFibGUgIH0gPSBfZGVzY3JpcHRvcnMocHJveHkpO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBuYW1lcyl7XG4gICAgICAgIGNvbnN0IHNjcmlwdGFibGUgPSBpc1NjcmlwdGFibGUocHJvcCk7XG4gICAgICAgIGNvbnN0IGluZGV4YWJsZSA9IGlzSW5kZXhhYmxlKHByb3ApO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IChpbmRleGFibGUgfHwgc2NyaXB0YWJsZSkgJiYgcHJveHlbcHJvcF07XG4gICAgICAgIGlmIChzY3JpcHRhYmxlICYmIChpc0Z1bmN0aW9uKHZhbHVlKSB8fCBoYXNGdW5jdGlvbih2YWx1ZSkpIHx8IGluZGV4YWJsZSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiNC40LjlcIjtcblxuY29uc3QgS05PV05fUE9TSVRJT05TID0gW1xuICAgICd0b3AnLFxuICAgICdib3R0b20nLFxuICAgICdsZWZ0JyxcbiAgICAncmlnaHQnLFxuICAgICdjaGFydEFyZWEnXG5dO1xuZnVuY3Rpb24gcG9zaXRpb25Jc0hvcml6b250YWwocG9zaXRpb24sIGF4aXMpIHtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJyB8fCBLTk9XTl9QT1NJVElPTlMuaW5kZXhPZihwb3NpdGlvbikgPT09IC0xICYmIGF4aXMgPT09ICd4Jztcbn1cbmZ1bmN0aW9uIGNvbXBhcmUyTGV2ZWwobDEsIGwyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbbDFdID09PSBiW2wxXSA/IGFbbDJdIC0gYltsMl0gOiBhW2wxXSAtIGJbbDFdO1xuICAgIH07XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvbnNDb21wbGV0ZShjb250ZXh0KSB7XG4gICAgY29uc3QgY2hhcnQgPSBjb250ZXh0LmNoYXJ0O1xuICAgIGNvbnN0IGFuaW1hdGlvbk9wdGlvbnMgPSBjaGFydC5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICBjaGFydC5ub3RpZnlQbHVnaW5zKCdhZnRlclJlbmRlcicpO1xuICAgIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vbkNvbXBsZXRlLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdLCBjaGFydCk7XG59XG5mdW5jdGlvbiBvbkFuaW1hdGlvblByb2dyZXNzKGNvbnRleHQpIHtcbiAgICBjb25zdCBjaGFydCA9IGNvbnRleHQuY2hhcnQ7XG4gICAgY29uc3QgYW5pbWF0aW9uT3B0aW9ucyA9IGNoYXJ0Lm9wdGlvbnMuYW5pbWF0aW9uO1xuICAgIGNhbGxiYWNrKGFuaW1hdGlvbk9wdGlvbnMgJiYgYW5pbWF0aW9uT3B0aW9ucy5vblByb2dyZXNzLCBbXG4gICAgICAgIGNvbnRleHRcbiAgICBdLCBjaGFydCk7XG59XG4gZnVuY3Rpb24gZ2V0Q2FudmFzKGl0ZW0pIHtcbiAgICBpZiAoX2lzRG9tU3VwcG9ydGVkKCkgJiYgdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGl0ZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpdGVtKTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0gJiYgaXRlbS5sZW5ndGgpIHtcbiAgICAgICAgaXRlbSA9IGl0ZW1bMF07XG4gICAgfVxuICAgIGlmIChpdGVtICYmIGl0ZW0uY2FudmFzKSB7XG4gICAgICAgIGl0ZW0gPSBpdGVtLmNhbnZhcztcbiAgICB9XG4gICAgcmV0dXJuIGl0ZW07XG59XG5jb25zdCBpbnN0YW5jZXMgPSB7fTtcbmNvbnN0IGdldENoYXJ0ID0gKGtleSk9PntcbiAgICBjb25zdCBjYW52YXMgPSBnZXRDYW52YXMoa2V5KTtcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhpbnN0YW5jZXMpLmZpbHRlcigoYyk9PmMuY2FudmFzID09PSBjYW52YXMpLnBvcCgpO1xufTtcbmZ1bmN0aW9uIG1vdmVOdW1lcmljS2V5cyhvYmosIHN0YXJ0LCBtb3ZlKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cyl7XG4gICAgICAgIGNvbnN0IGludEtleSA9ICtrZXk7XG4gICAgICAgIGlmIChpbnRLZXkgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqW2tleV07XG4gICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICBpZiAobW92ZSA+IDAgfHwgaW50S2V5ID4gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBvYmpbaW50S2V5ICsgbW92ZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljaykge1xuICAgIGlmICghaW5DaGFydEFyZWEgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNDbGljaykge1xuICAgICAgICByZXR1cm4gbGFzdEV2ZW50O1xuICAgIH1cbiAgICByZXR1cm4gZTtcbn1cbmNsYXNzIENoYXJ0IHtcbiAgICBzdGF0aWMgZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBzdGF0aWMgaW5zdGFuY2VzID0gaW5zdGFuY2VzO1xuICAgIHN0YXRpYyBvdmVycmlkZXMgPSBvdmVycmlkZXM7XG4gICAgc3RhdGljIHJlZ2lzdHJ5ID0gcmVnaXN0cnk7XG4gICAgc3RhdGljIHZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIHN0YXRpYyBnZXRDaGFydCA9IGdldENoYXJ0O1xuICAgIHN0YXRpYyByZWdpc3RlciguLi5pdGVtcykge1xuICAgICAgICByZWdpc3RyeS5hZGQoLi4uaXRlbXMpO1xuICAgICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgICBzdGF0aWMgdW5yZWdpc3RlciguLi5pdGVtcykge1xuICAgICAgICByZWdpc3RyeS5yZW1vdmUoLi4uaXRlbXMpO1xuICAgICAgICBpbnZhbGlkYXRlUGx1Z2lucygpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihpdGVtLCB1c2VyQ29uZmlnKXtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWcgPSBuZXcgQ29uZmlnKHVzZXJDb25maWcpO1xuICAgICAgICBjb25zdCBpbml0aWFsQ2FudmFzID0gZ2V0Q2FudmFzKGl0ZW0pO1xuICAgICAgICBjb25zdCBleGlzdGluZ0NoYXJ0ID0gZ2V0Q2hhcnQoaW5pdGlhbENhbnZhcyk7XG4gICAgICAgIGlmIChleGlzdGluZ0NoYXJ0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbnZhcyBpcyBhbHJlYWR5IGluIHVzZS4gQ2hhcnQgd2l0aCBJRCBcXCcnICsgZXhpc3RpbmdDaGFydC5pZCArICdcXCcnICsgJyBtdXN0IGJlIGRlc3Ryb3llZCBiZWZvcmUgdGhlIGNhbnZhcyB3aXRoIElEIFxcJycgKyBleGlzdGluZ0NoYXJ0LmNhbnZhcy5pZCArICdcXCcgY2FuIGJlIHJldXNlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gY29uZmlnLmNyZWF0ZVJlc29sdmVyKGNvbmZpZy5jaGFydE9wdGlvblNjb3BlcygpLCB0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0gPSBuZXcgKGNvbmZpZy5wbGF0Zm9ybSB8fCBfZGV0ZWN0UGxhdGZvcm0oaW5pdGlhbENhbnZhcykpKCk7XG4gICAgICAgIHRoaXMucGxhdGZvcm0udXBkYXRlQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnBsYXRmb3JtLmFjcXVpcmVDb250ZXh0KGluaXRpYWxDYW52YXMsIG9wdGlvbnMuYXNwZWN0UmF0aW8pO1xuICAgICAgICBjb25zdCBjYW52YXMgPSBjb250ZXh0ICYmIGNvbnRleHQuY2FudmFzO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBjYW52YXMgJiYgY2FudmFzLmhlaWdodDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBjYW52YXMgJiYgY2FudmFzLndpZHRoO1xuICAgICAgICB0aGlzLmlkID0gdWlkKCk7XG4gICAgICAgIHRoaXMuY3R4ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLl9hc3BlY3RSYXRpbyA9IHRoaXMuYXNwZWN0UmF0aW87XG4gICAgICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgICAgICB0aGlzLl9tZXRhc2V0cyA9IFtdO1xuICAgICAgICB0aGlzLl9zdGFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYm94ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaGFydEFyZWEgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLl9sYXN0RXZlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBbXTtcbiAgICAgICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IG5ldyBQbHVnaW5TZXJ2aWNlKCk7XG4gICAgICAgIHRoaXMuJHByb3hpZXMgPSB7fTtcbiAgICAgICAgdGhpcy5faGlkZGVuSW5kaWNlcyA9IHt9O1xuICAgICAgICB0aGlzLmF0dGFjaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZG9SZXNpemUgPSBkZWJvdW5jZSgobW9kZSk9PnRoaXMudXBkYXRlKG1vZGUpLCBvcHRpb25zLnJlc2l6ZURlbGF5IHx8IDApO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbmdlcyA9IFtdO1xuICAgICAgICBpbnN0YW5jZXNbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICBpZiAoIWNvbnRleHQgfHwgIWNhbnZhcykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBjcmVhdGUgY2hhcnQ6IGNhbid0IGFjcXVpcmUgY29udGV4dCBmcm9tIHRoZSBnaXZlbiBpdGVtXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAnY29tcGxldGUnLCBvbkFuaW1hdGlvbnNDb21wbGV0ZSk7XG4gICAgICAgIGFuaW1hdG9yLmxpc3Rlbih0aGlzLCAncHJvZ3Jlc3MnLCBvbkFuaW1hdGlvblByb2dyZXNzKTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICAgICAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XG4gICAgICAgIGNvbnN0IHsgb3B0aW9uczogeyBhc3BlY3RSYXRpbyAsIG1haW50YWluQXNwZWN0UmF0aW8gIH0gLCB3aWR0aCAsIGhlaWdodCAsIF9hc3BlY3RSYXRpbyAgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZihhc3BlY3RSYXRpbykpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3BlY3RSYXRpbztcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiBfYXNwZWN0UmF0aW8pIHtcbiAgICAgICAgICAgIHJldHVybiBfYXNwZWN0UmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5kYXRhO1xuICAgIH1cbiAgICBzZXQgZGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxuICAgIHNldCBvcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGdldCByZWdpc3RyeSgpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJ5O1xuICAgIH1cbiBfaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVJbml0Jyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldGluYVNjYWxlKHRoaXMsIHRoaXMub3B0aW9ucy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckluaXQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICBjbGVhckNhbnZhcyh0aGlzLmNhbnZhcywgdGhpcy5jdHgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgYW5pbWF0b3Iuc3RvcCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuIHJlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGlmICghYW5pbWF0b3IucnVubmluZyh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplQmVmb3JlRHJhdyA9IHtcbiAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuICAgICAgICBjb25zdCBhc3BlY3RSYXRpbyA9IG9wdGlvbnMubWFpbnRhaW5Bc3BlY3RSYXRpbyAmJiB0aGlzLmFzcGVjdFJhdGlvO1xuICAgICAgICBjb25zdCBuZXdTaXplID0gdGhpcy5wbGF0Zm9ybS5nZXRNYXhpbXVtU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQsIGFzcGVjdFJhdGlvKTtcbiAgICAgICAgY29uc3QgbmV3UmF0aW8gPSBvcHRpb25zLmRldmljZVBpeGVsUmF0aW8gfHwgdGhpcy5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLndpZHRoID8gJ3Jlc2l6ZScgOiAnYXR0YWNoJztcbiAgICAgICAgdGhpcy53aWR0aCA9IG5ld1NpemUud2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gbmV3U2l6ZS5oZWlnaHQ7XG4gICAgICAgIHRoaXMuX2FzcGVjdFJhdGlvID0gdGhpcy5hc3BlY3RSYXRpbztcbiAgICAgICAgaWYgKCFyZXRpbmFTY2FsZSh0aGlzLCBuZXdSYXRpbywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ3Jlc2l6ZScsIHtcbiAgICAgICAgICAgIHNpemU6IG5ld1NpemVcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25SZXNpemUsIFtcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBuZXdTaXplXG4gICAgICAgIF0sIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5hdHRhY2hlZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RvUmVzaXplKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbnN1cmVTY2FsZXNIYXZlSURzKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBzY2FsZXNPcHRpb25zID0gb3B0aW9ucy5zY2FsZXMgfHwge307XG4gICAgICAgIGVhY2goc2NhbGVzT3B0aW9ucywgKGF4aXNPcHRpb25zLCBheGlzSUQpPT57XG4gICAgICAgICAgICBheGlzT3B0aW9ucy5pZCA9IGF4aXNJRDtcbiAgICAgICAgfSk7XG4gICAgfVxuIGJ1aWxkT3JVcGRhdGVTY2FsZXMoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHNjYWxlT3B0cyA9IG9wdGlvbnMuc2NhbGVzO1xuICAgICAgICBjb25zdCBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICAgICAgY29uc3QgdXBkYXRlZCA9IE9iamVjdC5rZXlzKHNjYWxlcykucmVkdWNlKChvYmosIGlkKT0+e1xuICAgICAgICAgICAgb2JqW2lkXSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSwge30pO1xuICAgICAgICBsZXQgaXRlbXMgPSBbXTtcbiAgICAgICAgaWYgKHNjYWxlT3B0cykge1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoT2JqZWN0LmtleXMoc2NhbGVPcHRzKS5tYXAoKGlkKT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IHNjYWxlT3B0c1tpZF07XG4gICAgICAgICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSYWRpYWwgPSBheGlzID09PSAncic7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gYXhpcyA9PT0gJ3gnO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHNjYWxlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgZHBvc2l0aW9uOiBpc1JhZGlhbCA/ICdjaGFydEFyZWEnIDogaXNIb3Jpem9udGFsID8gJ2JvdHRvbScgOiAnbGVmdCcsXG4gICAgICAgICAgICAgICAgICAgIGR0eXBlOiBpc1JhZGlhbCA/ICdyYWRpYWxMaW5lYXInIDogaXNIb3Jpem9udGFsID8gJ2NhdGVnb3J5JyA6ICdsaW5lYXInXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKGl0ZW1zLCAoaXRlbSk9PntcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlT3B0aW9ucyA9IGl0ZW0ub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IGlkID0gc2NhbGVPcHRpb25zLmlkO1xuICAgICAgICAgICAgY29uc3QgYXhpcyA9IGRldGVybWluZUF4aXMoaWQsIHNjYWxlT3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBzY2FsZVR5cGUgPSB2YWx1ZU9yRGVmYXVsdChzY2FsZU9wdGlvbnMudHlwZSwgaXRlbS5kdHlwZSk7XG4gICAgICAgICAgICBpZiAoc2NhbGVPcHRpb25zLnBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb25Jc0hvcml6b250YWwoc2NhbGVPcHRpb25zLnBvc2l0aW9uLCBheGlzKSAhPT0gcG9zaXRpb25Jc0hvcml6b250YWwoaXRlbS5kcG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVPcHRpb25zLnBvc2l0aW9uID0gaXRlbS5kcG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVkW2lkXSA9IHRydWU7XG4gICAgICAgICAgICBsZXQgc2NhbGUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGlkIGluIHNjYWxlcyAmJiBzY2FsZXNbaWRdLnR5cGUgPT09IHNjYWxlVHlwZSkge1xuICAgICAgICAgICAgICAgIHNjYWxlID0gc2NhbGVzW2lkXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGVDbGFzcyA9IHJlZ2lzdHJ5LmdldFNjYWxlKHNjYWxlVHlwZSk7XG4gICAgICAgICAgICAgICAgc2NhbGUgPSBuZXcgc2NhbGVDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzY2FsZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGN0eDogdGhpcy5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNoYXJ0OiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2NhbGVzW3NjYWxlLmlkXSA9IHNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2NhbGUuaW5pdChzY2FsZU9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWFjaCh1cGRhdGVkLCAoaGFzVXBkYXRlZCwgaWQpPT57XG4gICAgICAgICAgICBpZiAoIWhhc1VwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2NhbGVzW2lkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGVhY2goc2NhbGVzLCAoc2NhbGUpPT57XG4gICAgICAgICAgICBsYXlvdXRzLmNvbmZpZ3VyZSh0aGlzLCBzY2FsZSwgc2NhbGUub3B0aW9ucyk7XG4gICAgICAgICAgICBsYXlvdXRzLmFkZEJveCh0aGlzLCBzY2FsZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiBfdXBkYXRlTWV0YXNldHMoKSB7XG4gICAgICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgICAgIGNvbnN0IG51bURhdGEgPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoO1xuICAgICAgICBjb25zdCBudW1NZXRhID0gbWV0YXNldHMubGVuZ3RoO1xuICAgICAgICBtZXRhc2V0cy5zb3J0KChhLCBiKT0+YS5pbmRleCAtIGIuaW5kZXgpO1xuICAgICAgICBpZiAobnVtTWV0YSA+IG51bURhdGEpIHtcbiAgICAgICAgICAgIGZvcihsZXQgaSA9IG51bURhdGE7IGkgPCBudW1NZXRhOyArK2kpe1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGFzZXRzLnNwbGljZShudW1EYXRhLCBudW1NZXRhIC0gbnVtRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc29ydGVkTWV0YXNldHMgPSBtZXRhc2V0cy5zbGljZSgwKS5zb3J0KGNvbXBhcmUyTGV2ZWwoJ29yZGVyJywgJ2luZGV4JykpO1xuICAgIH1cbiBfcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKSB7XG4gICAgICAgIGNvbnN0IHsgX21ldGFzZXRzOiBtZXRhc2V0cyAsIGRhdGE6IHsgZGF0YXNldHMgIH0gIH0gPSB0aGlzO1xuICAgICAgICBpZiAobWV0YXNldHMubGVuZ3RoID4gZGF0YXNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3RhY2tzO1xuICAgICAgICB9XG4gICAgICAgIG1ldGFzZXRzLmZvckVhY2goKG1ldGEsIGluZGV4KT0+e1xuICAgICAgICAgICAgaWYgKGRhdGFzZXRzLmZpbHRlcigoeCk9PnggPT09IG1ldGEuX2RhdGFzZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBidWlsZE9yVXBkYXRlQ29udHJvbGxlcnMoKSB7XG4gICAgICAgIGNvbnN0IG5ld0NvbnRyb2xsZXJzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gdGhpcy5kYXRhLmRhdGFzZXRzO1xuICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgdGhpcy5fcmVtb3ZlVW5yZWZlcmVuY2VkTWV0YXNldHMoKTtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFzZXQgPSBkYXRhc2V0c1tpXTtcbiAgICAgICAgICAgIGxldCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShpKTtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBkYXRhc2V0LnR5cGUgfHwgdGhpcy5jb25maWcudHlwZTtcbiAgICAgICAgICAgIGlmIChtZXRhLnR5cGUgJiYgbWV0YS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGVzdHJveURhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgIG1ldGEuaW5kZXhBeGlzID0gZGF0YXNldC5pbmRleEF4aXMgfHwgZ2V0SW5kZXhBeGlzKHR5cGUsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICBtZXRhLm9yZGVyID0gZGF0YXNldC5vcmRlciB8fCAwO1xuICAgICAgICAgICAgbWV0YS5pbmRleCA9IGk7XG4gICAgICAgICAgICBtZXRhLmxhYmVsID0gJycgKyBkYXRhc2V0LmxhYmVsO1xuICAgICAgICAgICAgbWV0YS52aXNpYmxlID0gdGhpcy5pc0RhdGFzZXRWaXNpYmxlKGkpO1xuICAgICAgICAgICAgaWYgKG1ldGEuY29udHJvbGxlcikge1xuICAgICAgICAgICAgICAgIG1ldGEuY29udHJvbGxlci51cGRhdGVJbmRleChpKTtcbiAgICAgICAgICAgICAgICBtZXRhLmNvbnRyb2xsZXIubGlua1NjYWxlcygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBDb250cm9sbGVyQ2xhc3MgPSByZWdpc3RyeS5nZXRDb250cm9sbGVyKHR5cGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZGF0YXNldEVsZW1lbnRUeXBlICwgZGF0YUVsZW1lbnRUeXBlICB9ID0gZGVmYXVsdHMuZGF0YXNldHNbdHlwZV07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihDb250cm9sbGVyQ2xhc3MsIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUVsZW1lbnRUeXBlOiByZWdpc3RyeS5nZXRFbGVtZW50KGRhdGFFbGVtZW50VHlwZSksXG4gICAgICAgICAgICAgICAgICAgIGRhdGFzZXRFbGVtZW50VHlwZTogZGF0YXNldEVsZW1lbnRUeXBlICYmIHJlZ2lzdHJ5LmdldEVsZW1lbnQoZGF0YXNldEVsZW1lbnRUeXBlKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG1ldGEuY29udHJvbGxlciA9IG5ldyBDb250cm9sbGVyQ2xhc3ModGhpcywgaSk7XG4gICAgICAgICAgICAgICAgbmV3Q29udHJvbGxlcnMucHVzaChtZXRhLmNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3VwZGF0ZU1ldGFzZXRzKCk7XG4gICAgICAgIHJldHVybiBuZXdDb250cm9sbGVycztcbiAgICB9XG4gX3Jlc2V0RWxlbWVudHMoKSB7XG4gICAgICAgIGVhY2godGhpcy5kYXRhLmRhdGFzZXRzLCAoZGF0YXNldCwgZGF0YXNldEluZGV4KT0+e1xuICAgICAgICAgICAgdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpLmNvbnRyb2xsZXIucmVzZXQoKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxuIHJlc2V0KCkge1xuICAgICAgICB0aGlzLl9yZXNldEVsZW1lbnRzKCk7XG4gICAgICAgIHRoaXMubm90aWZ5UGx1Z2lucygncmVzZXQnKTtcbiAgICB9XG4gICAgdXBkYXRlKG1vZGUpIHtcbiAgICAgICAgY29uc3QgY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgIGNvbmZpZy51cGRhdGUoKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX29wdGlvbnMgPSBjb25maWcuY3JlYXRlUmVzb2x2ZXIoY29uZmlnLmNoYXJ0T3B0aW9uU2NvcGVzKCksIHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgY29uc3QgYW5pbXNEaXNhYmxlZCA9IHRoaXMuX2FuaW1hdGlvbnNEaXNhYmxlZCA9ICFvcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgdGhpcy5fdXBkYXRlU2NhbGVzKCk7XG4gICAgICAgIHRoaXMuX2NoZWNrRXZlbnRCaW5kaW5ncygpO1xuICAgICAgICB0aGlzLl91cGRhdGVIaWRkZW5JbmRpY2VzKCk7XG4gICAgICAgIHRoaXMuX3BsdWdpbnMuaW52YWxpZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVVcGRhdGUnLCB7XG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdDb250cm9sbGVycyA9IHRoaXMuYnVpbGRPclVwZGF0ZUNvbnRyb2xsZXJzKCk7XG4gICAgICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRWxlbWVudHNVcGRhdGUnKTtcbiAgICAgICAgbGV0IG1pblBhZGRpbmcgPSAwO1xuICAgICAgICBmb3IobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXIgIH0gPSB0aGlzLmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgY29uc3QgcmVzZXQgPSAhYW5pbXNEaXNhYmxlZCAmJiBuZXdDb250cm9sbGVycy5pbmRleE9mKGNvbnRyb2xsZXIpID09PSAtMTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYnVpbGRPclVwZGF0ZUVsZW1lbnRzKHJlc2V0KTtcbiAgICAgICAgICAgIG1pblBhZGRpbmcgPSBNYXRoLm1heCgrY29udHJvbGxlci5nZXRNYXhPdmVyZmxvdygpLCBtaW5QYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBtaW5QYWRkaW5nID0gdGhpcy5fbWluUGFkZGluZyA9IG9wdGlvbnMubGF5b3V0LmF1dG9QYWRkaW5nID8gbWluUGFkZGluZyA6IDA7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKTtcbiAgICAgICAgaWYgKCFhbmltc0Rpc2FibGVkKSB7XG4gICAgICAgICAgICBlYWNoKG5ld0NvbnRyb2xsZXJzLCAoY29udHJvbGxlcik9PntcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnJlc2V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl91cGRhdGVEYXRhc2V0cyhtb2RlKTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlclVwZGF0ZScsIHtcbiAgICAgICAgICAgIG1vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2xheWVycy5zb3J0KGNvbXBhcmUyTGV2ZWwoJ3onLCAnX2lkeCcpKTtcbiAgICAgICAgY29uc3QgeyBfYWN0aXZlICwgX2xhc3RFdmVudCAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChfbGFzdEV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXIoX2xhc3RFdmVudCwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2FjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKF9hY3RpdmUsIF9hY3RpdmUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuIF91cGRhdGVTY2FsZXMoKSB7XG4gICAgICAgIGVhY2godGhpcy5zY2FsZXMsIChzY2FsZSk9PntcbiAgICAgICAgICAgIGxheW91dHMucmVtb3ZlQm94KHRoaXMsIHNjYWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW5zdXJlU2NhbGVzSGF2ZUlEcygpO1xuICAgICAgICB0aGlzLmJ1aWxkT3JVcGRhdGVTY2FsZXMoKTtcbiAgICB9XG4gX2NoZWNrRXZlbnRCaW5kaW5ncygpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgZXhpc3RpbmdFdmVudHMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuX2xpc3RlbmVycykpO1xuICAgICAgICBjb25zdCBuZXdFdmVudHMgPSBuZXcgU2V0KG9wdGlvbnMuZXZlbnRzKTtcbiAgICAgICAgaWYgKCFzZXRzRXF1YWwoZXhpc3RpbmdFdmVudHMsIG5ld0V2ZW50cykgfHwgISF0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzICE9PSBvcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudW5iaW5kRXZlbnRzKCk7XG4gICAgICAgICAgICB0aGlzLmJpbmRFdmVudHMoKTtcbiAgICAgICAgfVxuICAgIH1cbiBfdXBkYXRlSGlkZGVuSW5kaWNlcygpIHtcbiAgICAgICAgY29uc3QgeyBfaGlkZGVuSW5kaWNlcyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLl9nZXRVbmlmb3JtRGF0YUNoYW5nZXMoKSB8fCBbXTtcbiAgICAgICAgZm9yIChjb25zdCB7IG1ldGhvZCAsIHN0YXJ0ICwgY291bnQgIH0gb2YgY2hhbmdlcyl7XG4gICAgICAgICAgICBjb25zdCBtb3ZlID0gbWV0aG9kID09PSAnX3JlbW92ZUVsZW1lbnRzJyA/IC1jb3VudCA6IGNvdW50O1xuICAgICAgICAgICAgbW92ZU51bWVyaWNLZXlzKF9oaWRkZW5JbmRpY2VzLCBzdGFydCwgbW92ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gX2dldFVuaWZvcm1EYXRhQ2hhbmdlcygpIHtcbiAgICAgICAgY29uc3QgX2RhdGFDaGFuZ2VzID0gdGhpcy5fZGF0YUNoYW5nZXM7XG4gICAgICAgIGlmICghX2RhdGFDaGFuZ2VzIHx8ICFfZGF0YUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YUNoYW5nZXMgPSBbXTtcbiAgICAgICAgY29uc3QgZGF0YXNldENvdW50ID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgbWFrZVNldCA9IChpZHgpPT5uZXcgU2V0KF9kYXRhQ2hhbmdlcy5maWx0ZXIoKGMpPT5jWzBdID09PSBpZHgpLm1hcCgoYywgaSk9PmkgKyAnLCcgKyBjLnNwbGljZSgxKS5qb2luKCcsJykpKTtcbiAgICAgICAgY29uc3QgY2hhbmdlU2V0ID0gbWFrZVNldCgwKTtcbiAgICAgICAgZm9yKGxldCBpID0gMTsgaSA8IGRhdGFzZXRDb3VudDsgaSsrKXtcbiAgICAgICAgICAgIGlmICghc2V0c0VxdWFsKGNoYW5nZVNldCwgbWFrZVNldChpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oY2hhbmdlU2V0KS5tYXAoKGMpPT5jLnNwbGl0KCcsJykpLm1hcCgoYSk9Pih7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBhWzFdLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiArYVsyXSxcbiAgICAgICAgICAgICAgICBjb3VudDogK2FbM11cbiAgICAgICAgICAgIH0pKTtcbiAgICB9XG4gX3VwZGF0ZUxheW91dChtaW5QYWRkaW5nKSB7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZUxheW91dCcsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGF5b3V0cy51cGRhdGUodGhpcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIG1pblBhZGRpbmcpO1xuICAgICAgICBjb25zdCBhcmVhID0gdGhpcy5jaGFydEFyZWE7XG4gICAgICAgIGNvbnN0IG5vQXJlYSA9IGFyZWEud2lkdGggPD0gMCB8fCBhcmVhLmhlaWdodCA8PSAwO1xuICAgICAgICB0aGlzLl9sYXllcnMgPSBbXTtcbiAgICAgICAgZWFjaCh0aGlzLmJveGVzLCAoYm94KT0+e1xuICAgICAgICAgICAgaWYgKG5vQXJlYSAmJiBib3gucG9zaXRpb24gPT09ICdjaGFydEFyZWEnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGJveC5jb25maWd1cmUpIHtcbiAgICAgICAgICAgICAgICBib3guY29uZmlndXJlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9sYXllcnMucHVzaCguLi5ib3guX2xheWVycygpKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKChpdGVtLCBpbmRleCk9PntcbiAgICAgICAgICAgIGl0ZW0uX2lkeCA9IGluZGV4O1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckxheW91dCcpO1xuICAgIH1cbiBfdXBkYXRlRGF0YXNldHMobW9kZSkge1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVEYXRhc2V0c1VwZGF0ZScsIHtcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcihsZXQgaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIHRoaXMuZ2V0RGF0YXNldE1ldGEoaSkuY29udHJvbGxlci5jb25maWd1cmUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwLCBpbGVuID0gdGhpcy5kYXRhLmRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEYXRhc2V0KGksIGlzRnVuY3Rpb24obW9kZSkgPyBtb2RlKHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGlcbiAgICAgICAgICAgIH0pIDogbW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzVXBkYXRlJywge1xuICAgICAgICAgICAgbW9kZVxuICAgICAgICB9KTtcbiAgICB9XG4gX3VwZGF0ZURhdGFzZXQoaW5kZXgsIG1vZGUpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldFVwZGF0ZScsIGFyZ3MpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG1ldGEuY29udHJvbGxlci5fdXBkYXRlKG1vZGUpO1xuICAgICAgICBhcmdzLmNhbmNlbGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRVcGRhdGUnLCBhcmdzKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVSZW5kZXInLCB7XG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhbmltYXRvci5oYXModGhpcykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmF0dGFjaGVkICYmICFhbmltYXRvci5ydW5uaW5nKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3Iuc3RhcnQodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYXcoKTtcbiAgICAgICAgICAgIG9uQW5pbWF0aW9uc0NvbXBsZXRlKHtcbiAgICAgICAgICAgICAgICBjaGFydDogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhdygpIHtcbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGlmICh0aGlzLl9yZXNpemVCZWZvcmVEcmF3KSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoICwgaGVpZ2h0ICB9ID0gdGhpcy5fcmVzaXplQmVmb3JlRHJhdztcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUJlZm9yZURyYXcgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgaWYgKHRoaXMud2lkdGggPD0gMCB8fCB0aGlzLmhlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRHJhdycsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgICAgICBmb3IoaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoICYmIGxheWVyc1tpXS56IDw9IDA7ICsraSl7XG4gICAgICAgICAgICBsYXllcnNbaV0uZHJhdyh0aGlzLmNoYXJ0QXJlYSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZHJhd0RhdGFzZXRzKCk7XG4gICAgICAgIGZvcig7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpe1xuICAgICAgICAgICAgbGF5ZXJzW2ldLmRyYXcodGhpcy5jaGFydEFyZWEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJEcmF3Jyk7XG4gICAgfVxuIF9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoZmlsdGVyVmlzaWJsZSkge1xuICAgICAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuX3NvcnRlZE1ldGFzZXRzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IG1ldGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gbWV0YXNldHNbaV07XG4gICAgICAgICAgICBpZiAoIWZpbHRlclZpc2libGUgfHwgbWV0YS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWV0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFNvcnRlZERhdGFzZXRNZXRhcyh0cnVlKTtcbiAgICB9XG4gX2RyYXdEYXRhc2V0cygpIHtcbiAgICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldHNEcmF3Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgICB9KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhc2V0cyA9IHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgICAgICBmb3IobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSl7XG4gICAgICAgICAgICB0aGlzLl9kcmF3RGF0YXNldChtZXRhc2V0c1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub3RpZnlQbHVnaW5zKCdhZnRlckRhdGFzZXRzRHJhdycpO1xuICAgIH1cbiBfZHJhd0RhdGFzZXQobWV0YSkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29uc3QgYXJncyA9IHtcbiAgICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgICBpbmRleDogbWV0YS5pbmRleCxcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xpcCA9IGdldERhdGFzZXRDbGlwQXJlYSh0aGlzLCBtZXRhKTtcbiAgICAgICAgaWYgKHRoaXMubm90aWZ5UGx1Z2lucygnYmVmb3JlRGF0YXNldERyYXcnLCBhcmdzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgY2xpcEFyZWEoY3R4LCBjbGlwKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRhLmNvbnRyb2xsZXIuZHJhdygpO1xuICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MuY2FuY2VsYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGF0YXNldERyYXcnLCBhcmdzKTtcbiAgICB9XG4gaXNQb2ludEluQXJlYShwb2ludCkge1xuICAgICAgICByZXR1cm4gX2lzUG9pbnRJbkFyZWEocG9pbnQsIHRoaXMuY2hhcnRBcmVhLCB0aGlzLl9taW5QYWRkaW5nKTtcbiAgICB9XG4gICAgZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBtb2RlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IEludGVyYWN0aW9uLm1vZGVzW21vZGVdO1xuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZCh0aGlzLCBlLCBvcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgICAgICBjb25zdCBkYXRhc2V0ID0gdGhpcy5kYXRhLmRhdGFzZXRzW2RhdGFzZXRJbmRleF07XG4gICAgICAgIGNvbnN0IG1ldGFzZXRzID0gdGhpcy5fbWV0YXNldHM7XG4gICAgICAgIGxldCBtZXRhID0gbWV0YXNldHMuZmlsdGVyKCh4KT0+eCAmJiB4Ll9kYXRhc2V0ID09PSBkYXRhc2V0KS5wb3AoKTtcbiAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICBtZXRhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICAgICAgZGF0YXNldDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgICAgICAgICAgIGhpZGRlbjogbnVsbCxcbiAgICAgICAgICAgICAgICB4QXhpc0lEOiBudWxsLFxuICAgICAgICAgICAgICAgIHlBeGlzSUQ6IG51bGwsXG4gICAgICAgICAgICAgICAgb3JkZXI6IGRhdGFzZXQgJiYgZGF0YXNldC5vcmRlciB8fCAwLFxuICAgICAgICAgICAgICAgIGluZGV4OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgX2RhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgICAgICAgICAgX3BhcnNlZDogW10sXG4gICAgICAgICAgICAgICAgX3NvcnRlZDogZmFsc2VcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBtZXRhc2V0cy5wdXNoKG1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXRhO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCwge1xuICAgICAgICAgICAgY2hhcnQ6IHRoaXMsXG4gICAgICAgICAgICB0eXBlOiAnY2hhcnQnXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZ2V0VmlzaWJsZURhdGFzZXRDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpLmxlbmd0aDtcbiAgICB9XG4gICAgaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgZGF0YXNldCA9IHRoaXMuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgICAgICBpZiAoIWRhdGFzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIG1ldGEuaGlkZGVuID09PSAnYm9vbGVhbicgPyAhbWV0YS5oaWRkZW4gOiAhZGF0YXNldC5oaWRkZW47XG4gICAgfVxuICAgIHNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgICBtZXRhLmhpZGRlbiA9ICF2aXNpYmxlO1xuICAgIH1cbiAgICB0b2dnbGVEYXRhVmlzaWJpbGl0eShpbmRleCkge1xuICAgICAgICB0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XSA9ICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgICB9XG4gICAgZ2V0RGF0YVZpc2liaWxpdHkoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oaWRkZW5JbmRpY2VzW2luZGV4XTtcbiAgICB9XG4gX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbW9kZSA9IHZpc2libGUgPyAnc2hvdycgOiAnaGlkZSc7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IGFuaW1zID0gbWV0YS5jb250cm9sbGVyLl9yZXNvbHZlQW5pbWF0aW9ucyh1bmRlZmluZWQsIG1vZGUpO1xuICAgICAgICBpZiAoZGVmaW5lZChkYXRhSW5kZXgpKSB7XG4gICAgICAgICAgICBtZXRhLmRhdGFbZGF0YUluZGV4XS5oaWRkZW4gPSAhdmlzaWJsZTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldERhdGFzZXRWaXNpYmlsaXR5KGRhdGFzZXRJbmRleCwgdmlzaWJsZSk7XG4gICAgICAgICAgICBhbmltcy51cGRhdGUobWV0YSwge1xuICAgICAgICAgICAgICAgIHZpc2libGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoKGN0eCk9PmN0eC5kYXRhc2V0SW5kZXggPT09IGRhdGFzZXRJbmRleCA/IG1vZGUgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShkYXRhc2V0SW5kZXgsIGRhdGFJbmRleCwgZmFsc2UpO1xuICAgIH1cbiAgICBzaG93KGRhdGFzZXRJbmRleCwgZGF0YUluZGV4KSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpc2liaWxpdHkoZGF0YXNldEluZGV4LCBkYXRhSW5kZXgsIHRydWUpO1xuICAgIH1cbiBfZGVzdHJveURhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICAgICAgaWYgKG1ldGEgJiYgbWV0YS5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBtZXRhLmNvbnRyb2xsZXIuX2Rlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5fbWV0YXNldHNbZGF0YXNldEluZGV4XTtcbiAgICB9XG4gICAgX3N0b3AoKSB7XG4gICAgICAgIGxldCBpLCBpbGVuO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgYW5pbWF0b3IucmVtb3ZlKHRoaXMpO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aGlzLmRhdGEuZGF0YXNldHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIHRoaXMuX2Rlc3Ryb3lEYXRhc2V0TWV0YShpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2JlZm9yZURlc3Ryb3knKTtcbiAgICAgICAgY29uc3QgeyBjYW52YXMgLCBjdHggIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLl9zdG9wKCk7XG4gICAgICAgIHRoaXMuY29uZmlnLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgdGhpcy51bmJpbmRFdmVudHMoKTtcbiAgICAgICAgICAgIGNsZWFyQ2FudmFzKGNhbnZhcywgY3R4KTtcbiAgICAgICAgICAgIHRoaXMucGxhdGZvcm0ucmVsZWFzZUNvbnRleHQoY3R4KTtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgaW5zdGFuY2VzW3RoaXMuaWRdO1xuICAgICAgICB0aGlzLm5vdGlmeVBsdWdpbnMoJ2FmdGVyRGVzdHJveScpO1xuICAgIH1cbiAgICB0b0Jhc2U2NEltYWdlKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLnRvRGF0YVVSTCguLi5hcmdzKTtcbiAgICB9XG4gYmluZEV2ZW50cygpIHtcbiAgICAgICAgdGhpcy5iaW5kVXNlckV2ZW50cygpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmUpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZFJlc3BvbnNpdmVFdmVudHMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuIGJpbmRVc2VyRXZlbnRzKCkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnM7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcik9PntcbiAgICAgICAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGUsIHgsIHkpPT57XG4gICAgICAgICAgICBlLm9mZnNldFggPSB4O1xuICAgICAgICAgICAgZS5vZmZzZXRZID0geTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcihlKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWFjaCh0aGlzLm9wdGlvbnMuZXZlbnRzLCAodHlwZSk9Pl9hZGQodHlwZSwgbGlzdGVuZXIpKTtcbiAgICB9XG4gYmluZFJlc3BvbnNpdmVFdmVudHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycykge1xuICAgICAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX3Jlc3BvbnNpdmVMaXN0ZW5lcnM7XG4gICAgICAgIGNvbnN0IHBsYXRmb3JtID0gdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgY29uc3QgX2FkZCA9ICh0eXBlLCBsaXN0ZW5lcik9PntcbiAgICAgICAgICAgIHBsYXRmb3JtLmFkZEV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgbGlzdGVuZXJzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IF9yZW1vdmUgPSAodHlwZSwgbGlzdGVuZXIpPT57XG4gICAgICAgICAgICBpZiAobGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxpc3RlbmVyc1t0eXBlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXIgPSAod2lkdGgsIGhlaWdodCk9PntcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBsZXQgZGV0YWNoZWQ7XG4gICAgICAgIGNvbnN0IGF0dGFjaGVkID0gKCk9PntcbiAgICAgICAgICAgIF9yZW1vdmUoJ2F0dGFjaCcsIGF0dGFjaGVkKTtcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgICAgIF9hZGQoJ3Jlc2l6ZScsIGxpc3RlbmVyKTtcbiAgICAgICAgICAgIF9hZGQoJ2RldGFjaCcsIGRldGFjaGVkKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGV0YWNoZWQgPSAoKT0+e1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgX3JlbW92ZSgncmVzaXplJywgbGlzdGVuZXIpO1xuICAgICAgICAgICAgdGhpcy5fc3RvcCgpO1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplKDAsIDApO1xuICAgICAgICAgICAgX2FkZCgnYXR0YWNoJywgYXR0YWNoZWQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGxhdGZvcm0uaXNBdHRhY2hlZCh0aGlzLmNhbnZhcykpIHtcbiAgICAgICAgICAgIGF0dGFjaGVkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZXRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgfVxuIHVuYmluZEV2ZW50cygpIHtcbiAgICAgICAgZWFjaCh0aGlzLl9saXN0ZW5lcnMsIChsaXN0ZW5lciwgdHlwZSk9PntcbiAgICAgICAgICAgIHRoaXMucGxhdGZvcm0ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgZWFjaCh0aGlzLl9yZXNwb25zaXZlTGlzdGVuZXJzLCAobGlzdGVuZXIsIHR5cGUpPT57XG4gICAgICAgICAgICB0aGlzLnBsYXRmb3JtLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcmVzcG9uc2l2ZUxpc3RlbmVycyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdXBkYXRlSG92ZXJTdHlsZShpdGVtcywgbW9kZSwgZW5hYmxlZCkge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBlbmFibGVkID8gJ3NldCcgOiAncmVtb3ZlJztcbiAgICAgICAgbGV0IG1ldGEsIGl0ZW0sIGksIGlsZW47XG4gICAgICAgIGlmIChtb2RlID09PSAnZGF0YXNldCcpIHtcbiAgICAgICAgICAgIG1ldGEgPSB0aGlzLmdldERhdGFzZXRNZXRhKGl0ZW1zWzBdLmRhdGFzZXRJbmRleCk7XG4gICAgICAgICAgICBtZXRhLmNvbnRyb2xsZXJbJ18nICsgcHJlZml4ICsgJ0RhdGFzZXRIb3ZlclN0eWxlJ10oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGl0ZW0gJiYgdGhpcy5nZXREYXRhc2V0TWV0YShpdGVtLmRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcltwcmVmaXggKyAnSG92ZXJTdHlsZSddKGl0ZW0uZWxlbWVudCwgaXRlbS5kYXRhc2V0SW5kZXgsIGl0ZW0uaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuIGdldEFjdGl2ZUVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgIH1cbiBzZXRBY3RpdmVFbGVtZW50cyhhY3RpdmVFbGVtZW50cykge1xuICAgICAgICBjb25zdCBsYXN0QWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IFtdO1xuICAgICAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50cy5tYXAoKHsgZGF0YXNldEluZGV4ICwgaW5kZXggIH0pPT57XG4gICAgICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5nZXREYXRhc2V0TWV0YShkYXRhc2V0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKCFtZXRhKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhc2V0IGZvdW5kIGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwoYWN0aXZlLCBsYXN0QWN0aXZlKTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RFdmVudCA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVIb3ZlclN0eWxlcyhhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgICAgICB9XG4gICAgfVxuIG5vdGlmeVBsdWdpbnMoaG9vaywgYXJncywgZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zLm5vdGlmeSh0aGlzLCBob29rLCBhcmdzLCBmaWx0ZXIpO1xuICAgIH1cbiBpc1BsdWdpbkVuYWJsZWQocGx1Z2luSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsdWdpbnMuX2NhY2hlLmZpbHRlcigocCk9PnAucGx1Z2luLmlkID09PSBwbHVnaW5JZCkubGVuZ3RoID09PSAxO1xuICAgIH1cbiBfdXBkYXRlSG92ZXJTdHlsZXMoYWN0aXZlLCBsYXN0QWN0aXZlLCByZXBsYXkpIHtcbiAgICAgICAgY29uc3QgaG92ZXJPcHRpb25zID0gdGhpcy5vcHRpb25zLmhvdmVyO1xuICAgICAgICBjb25zdCBkaWZmID0gKGEsIGIpPT5hLmZpbHRlcigoeCk9PiFiLnNvbWUoKHkpPT54LmRhdGFzZXRJbmRleCA9PT0geS5kYXRhc2V0SW5kZXggJiYgeC5pbmRleCA9PT0geS5pbmRleCkpO1xuICAgICAgICBjb25zdCBkZWFjdGl2YXRlZCA9IGRpZmYobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICAgICAgY29uc3QgYWN0aXZhdGVkID0gcmVwbGF5ID8gYWN0aXZlIDogZGlmZihhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgICAgICBpZiAoZGVhY3RpdmF0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhvdmVyU3R5bGUoZGVhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2YXRlZC5sZW5ndGggJiYgaG92ZXJPcHRpb25zLm1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSG92ZXJTdHlsZShhY3RpdmF0ZWQsIGhvdmVyT3B0aW9ucy5tb2RlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cbiBfZXZlbnRIYW5kbGVyKGUsIHJlcGxheSkge1xuICAgICAgICBjb25zdCBhcmdzID0ge1xuICAgICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgICByZXBsYXksXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgaW5DaGFydEFyZWE6IHRoaXMuaXNQb2ludEluQXJlYShlKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBldmVudEZpbHRlciA9IChwbHVnaW4pPT4ocGx1Z2luLm9wdGlvbnMuZXZlbnRzIHx8IHRoaXMub3B0aW9ucy5ldmVudHMpLmluY2x1ZGVzKGUubmF0aXZlLnR5cGUpO1xuICAgICAgICBpZiAodGhpcy5ub3RpZnlQbHVnaW5zKCdiZWZvcmVFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5faGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBhcmdzLmluQ2hhcnRBcmVhKTtcbiAgICAgICAgYXJncy5jYW5jZWxhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubm90aWZ5UGx1Z2lucygnYWZ0ZXJFdmVudCcsIGFyZ3MsIGV2ZW50RmlsdGVyKTtcbiAgICAgICAgaWYgKGNoYW5nZWQgfHwgYXJncy5jaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiBfaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCB7IF9hY3RpdmU6IGxhc3RBY3RpdmUgPSBbXSAsIG9wdGlvbnMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB1c2VGaW5hbFBvc2l0aW9uID0gcmVwbGF5O1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9nZXRBY3RpdmVFbGVtZW50cyhlLCBsYXN0QWN0aXZlLCBpbkNoYXJ0QXJlYSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IGlzQ2xpY2sgPSBfaXNDbGlja0V2ZW50KGUpO1xuICAgICAgICBjb25zdCBsYXN0RXZlbnQgPSBkZXRlcm1pbmVMYXN0RXZlbnQoZSwgdGhpcy5fbGFzdEV2ZW50LCBpbkNoYXJ0QXJlYSwgaXNDbGljayk7XG4gICAgICAgIGlmIChpbkNoYXJ0QXJlYSkge1xuICAgICAgICAgICAgdGhpcy5fbGFzdEV2ZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKG9wdGlvbnMub25Ib3ZlciwgW1xuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzQ2xpY2spIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhvcHRpb25zLm9uQ2xpY2ssIFtcbiAgICAgICAgICAgICAgICAgICAgZSxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hhbmdlZCA9ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpO1xuICAgICAgICBpZiAoY2hhbmdlZCB8fCByZXBsYXkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUhvdmVyU3R5bGVzKGFjdGl2ZSwgbGFzdEFjdGl2ZSwgcmVwbGF5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0RXZlbnQgPSBsYXN0RXZlbnQ7XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgaW5DaGFydEFyZWEsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlb3V0Jykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5DaGFydEFyZWEpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXN0QWN0aXZlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5ob3ZlcjtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNBdEV2ZW50Rm9yTW9kZShlLCBob3Zlck9wdGlvbnMubW9kZSwgaG92ZXJPcHRpb25zLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnZhbGlkYXRlUGx1Z2lucygpIHtcbiAgICByZXR1cm4gZWFjaChDaGFydC5pbnN0YW5jZXMsIChjaGFydCk9PmNoYXJ0Ll9wbHVnaW5zLmludmFsaWRhdGUoKSk7XG59XG5cbmZ1bmN0aW9uIGNsaXBBcmMoY3R4LCBlbGVtZW50LCBlbmRBbmdsZSkge1xuICAgIGNvbnN0IHsgc3RhcnRBbmdsZSAsIHBpeGVsTWFyZ2luICwgeCAsIHkgLCBvdXRlclJhZGl1cyAsIGlubmVyUmFkaXVzICB9ID0gZWxlbWVudDtcbiAgICBsZXQgYW5nbGVNYXJnaW4gPSBwaXhlbE1hcmdpbiAvIG91dGVyUmFkaXVzO1xuICAgIC8vIERyYXcgYW4gaW5uZXIgYm9yZGVyIGJ5IGNsaXBwaW5nIHRoZSBhcmMgYW5kIGRyYXdpbmcgYSBkb3VibGUtd2lkdGggYm9yZGVyXG4gICAgLy8gRW5sYXJnZSB0aGUgY2xpcHBpbmcgYXJjIGJ5IDAuMzMgcGl4ZWxzIHRvIGVsaW1pbmF0ZSBnbGl0Y2hlcyBiZXR3ZWVuIGJvcmRlcnNcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgc3RhcnRBbmdsZSAtIGFuZ2xlTWFyZ2luLCBlbmRBbmdsZSArIGFuZ2xlTWFyZ2luKTtcbiAgICBpZiAoaW5uZXJSYWRpdXMgPiBwaXhlbE1hcmdpbikge1xuICAgICAgICBhbmdsZU1hcmdpbiA9IHBpeGVsTWFyZ2luIC8gaW5uZXJSYWRpdXM7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGVuZEFuZ2xlICsgYW5nbGVNYXJnaW4sIHN0YXJ0QW5nbGUgLSBhbmdsZU1hcmdpbiwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCBwaXhlbE1hcmdpbiwgZW5kQW5nbGUgKyBIQUxGX1BJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgfVxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdG9SYWRpdXNDb3JuZXJzKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCBbXG4gICAgICAgICdvdXRlclN0YXJ0JyxcbiAgICAgICAgJ291dGVyRW5kJyxcbiAgICAgICAgJ2lubmVyU3RhcnQnLFxuICAgICAgICAnaW5uZXJFbmQnXG4gICAgXSk7XG59XG4vKipcbiAqIFBhcnNlIGJvcmRlciByYWRpdXMgZnJvbSB0aGUgcHJvdmlkZWQgb3B0aW9uc1xuICovIGZ1bmN0aW9uIHBhcnNlQm9yZGVyUmFkaXVzJDEoYXJjLCBpbm5lclJhZGl1cywgb3V0ZXJSYWRpdXMsIGFuZ2xlRGVsdGEpIHtcbiAgICBjb25zdCBvID0gdG9SYWRpdXNDb3JuZXJzKGFyYy5vcHRpb25zLmJvcmRlclJhZGl1cyk7XG4gICAgY29uc3QgaGFsZlRoaWNrbmVzcyA9IChvdXRlclJhZGl1cyAtIGlubmVyUmFkaXVzKSAvIDI7XG4gICAgY29uc3QgaW5uZXJMaW1pdCA9IE1hdGgubWluKGhhbGZUaGlja25lc3MsIGFuZ2xlRGVsdGEgKiBpbm5lclJhZGl1cyAvIDIpO1xuICAgIC8vIE91dGVyIGxpbWl0cyBhcmUgY29tcGxpY2F0ZWQuIFdlIHdhbnQgdG8gY29tcHV0ZSB0aGUgYXZhaWxhYmxlIGFuZ3VsYXIgZGlzdGFuY2UgYXRcbiAgICAvLyBhIHJhZGl1cyBvZiBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIGZvciBzbWFsbCBhbmd1bGFyIGRpc3RhbmNlcywgdGhpcyB0ZXJtIGxpbWl0cy5cbiAgICAvLyBXZSBjb21wdXRlIGF0IHIgPSBvdXRlclJhZGl1cyAtIGJvcmRlclJhZGl1cyBiZWNhdXNlIHRoaXMgY2lyY2xlIGRlZmluZXMgdGhlIGNlbnRlciBvZiB0aGUgYm9yZGVyIGNvcm5lcnMuXG4gICAgLy9cbiAgICAvLyBJZiB0aGUgYm9yZGVyUmFkaXVzIGlzIGxhcmdlLCB0aGF0IHZhbHVlIGNhbiBiZWNvbWUgbmVnYXRpdmUuXG4gICAgLy8gVGhpcyBjYXVzZXMgdGhlIG91dGVyIGJvcmRlcnMgdG8gbG9zZSB0aGVpciByYWRpdXMgZW50aXJlbHksIHdoaWNoIGlzIHJhdGhlciB1bmV4cGVjdGVkLiBUbyBzb2x2ZSB0aGF0LCBpZiBib3JkZXJSYWRpdXMgPiBvdXRlclJhZGl1c1xuICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgdGhpY2tuZXNzIHRlcm0gd2lsbCBkb21pbmF0ZSBhbmQgY29tcHV0ZSB0aGUgbGltaXRzIGF0IHRoYXQgcG9pbnRcbiAgICBjb25zdCBjb21wdXRlT3V0ZXJMaW1pdCA9ICh2YWwpPT57XG4gICAgICAgIGNvbnN0IG91dGVyQXJjTGltaXQgPSAob3V0ZXJSYWRpdXMgLSBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCB2YWwpKSAqIGFuZ2xlRGVsdGEgLyAyO1xuICAgICAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsLCAwLCBNYXRoLm1pbihoYWxmVGhpY2tuZXNzLCBvdXRlckFyY0xpbWl0KSk7XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBvdXRlclN0YXJ0OiBjb21wdXRlT3V0ZXJMaW1pdChvLm91dGVyU3RhcnQpLFxuICAgICAgICBvdXRlckVuZDogY29tcHV0ZU91dGVyTGltaXQoby5vdXRlckVuZCksXG4gICAgICAgIGlubmVyU3RhcnQ6IF9saW1pdFZhbHVlKG8uaW5uZXJTdGFydCwgMCwgaW5uZXJMaW1pdCksXG4gICAgICAgIGlubmVyRW5kOiBfbGltaXRWYWx1ZShvLmlubmVyRW5kLCAwLCBpbm5lckxpbWl0KVxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnQgKHIsIPCdnIMpIHRvICh4LCB5KVxuICovIGZ1bmN0aW9uIHJUaGV0YVRvWFkociwgdGhldGEsIHgsIHkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICsgciAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgICAgeTogeSArIHIgKiBNYXRoLnNpbih0aGV0YSlcbiAgICB9O1xufVxuLyoqXG4gKiBQYXRoIHRoZSBhcmMsIHJlc3BlY3RpbmcgYm9yZGVyIHJhZGl1cyBieSBzZXBhcmF0aW5nIGludG8gbGVmdCBhbmQgcmlnaHQgaGFsdmVzLlxuICpcbiAqICAgU3RhcnQgICAgICBFbmRcbiAqXG4gKiAgICAxLS0tPmEtLS0+MiAgICBPdXRlclxuICogICAvICAgICAgICAgICBcXFxuICogICA4ICAgICAgICAgICAzXG4gKiAgIHwgICAgICAgICAgIHxcbiAqICAgfCAgICAgICAgICAgfFxuICogICA3ICAgICAgICAgICA0XG4gKiAgIFxcICAgICAgICAgICAvXG4gKiAgICA2PC0tLWI8LS0tNSAgICBJbm5lclxuICovIGZ1bmN0aW9uIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZCwgY2lyY3VsYXIpIHtcbiAgICBjb25zdCB7IHggLCB5ICwgc3RhcnRBbmdsZTogc3RhcnQgLCBwaXhlbE1hcmdpbiAsIGlubmVyUmFkaXVzOiBpbm5lclIgIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IG91dGVyUmFkaXVzID0gTWF0aC5tYXgoZWxlbWVudC5vdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQgLSBwaXhlbE1hcmdpbiwgMCk7XG4gICAgY29uc3QgaW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSICsgc3BhY2luZyArIG9mZnNldCArIHBpeGVsTWFyZ2luIDogMDtcbiAgICBsZXQgc3BhY2luZ09mZnNldCA9IDA7XG4gICAgY29uc3QgYWxwaGEgPSBlbmQgLSBzdGFydDtcbiAgICBpZiAoc3BhY2luZykge1xuICAgICAgICAvLyBXaGVuIHNwYWNpbmcgaXMgcHJlc2VudCwgaXQgaXMgdGhlIHNhbWUgZm9yIGFsbCBpdGVtc1xuICAgICAgICAvLyBTbyB3ZSBhZGp1c3QgdGhlIHN0YXJ0IGFuZCBlbmQgYW5nbGUgb2YgdGhlIGFyYyBzdWNoIHRoYXRcbiAgICAgICAgLy8gdGhlIGRpc3RhbmNlIGlzIHRoZSBzYW1lIGFzIGl0IHdvdWxkIGJlIHdpdGhvdXQgdGhlIHNwYWNpbmdcbiAgICAgICAgY29uc3Qgbm9TcGFjaW5nSW5uZXJSYWRpdXMgPSBpbm5lclIgPiAwID8gaW5uZXJSIC0gc3BhY2luZyA6IDA7XG4gICAgICAgIGNvbnN0IG5vU3BhY2luZ091dGVyUmFkaXVzID0gb3V0ZXJSYWRpdXMgPiAwID8gb3V0ZXJSYWRpdXMgLSBzcGFjaW5nIDogMDtcbiAgICAgICAgY29uc3QgYXZOb2dTcGFjaW5nUmFkaXVzID0gKG5vU3BhY2luZ0lubmVyUmFkaXVzICsgbm9TcGFjaW5nT3V0ZXJSYWRpdXMpIC8gMjtcbiAgICAgICAgY29uc3QgYWRqdXN0ZWRBbmdsZSA9IGF2Tm9nU3BhY2luZ1JhZGl1cyAhPT0gMCA/IGFscGhhICogYXZOb2dTcGFjaW5nUmFkaXVzIC8gKGF2Tm9nU3BhY2luZ1JhZGl1cyArIHNwYWNpbmcpIDogYWxwaGE7XG4gICAgICAgIHNwYWNpbmdPZmZzZXQgPSAoYWxwaGEgLSBhZGp1c3RlZEFuZ2xlKSAvIDI7XG4gICAgfVxuICAgIGNvbnN0IGJldGEgPSBNYXRoLm1heCgwLjAwMSwgYWxwaGEgKiBvdXRlclJhZGl1cyAtIG9mZnNldCAvIFBJKSAvIG91dGVyUmFkaXVzO1xuICAgIGNvbnN0IGFuZ2xlT2Zmc2V0ID0gKGFscGhhIC0gYmV0YSkgLyAyO1xuICAgIGNvbnN0IHN0YXJ0QW5nbGUgPSBzdGFydCArIGFuZ2xlT2Zmc2V0ICsgc3BhY2luZ09mZnNldDtcbiAgICBjb25zdCBlbmRBbmdsZSA9IGVuZCAtIGFuZ2xlT2Zmc2V0IC0gc3BhY2luZ09mZnNldDtcbiAgICBjb25zdCB7IG91dGVyU3RhcnQgLCBvdXRlckVuZCAsIGlubmVyU3RhcnQgLCBpbm5lckVuZCAgfSA9IHBhcnNlQm9yZGVyUmFkaXVzJDEoZWxlbWVudCwgaW5uZXJSYWRpdXMsIG91dGVyUmFkaXVzLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgIGNvbnN0IG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IG91dGVyUmFkaXVzIC0gb3V0ZXJTdGFydDtcbiAgICBjb25zdCBvdXRlckVuZEFkanVzdGVkUmFkaXVzID0gb3V0ZXJSYWRpdXMgLSBvdXRlckVuZDtcbiAgICBjb25zdCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBvdXRlclN0YXJ0IC8gb3V0ZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICAgIGNvbnN0IG91dGVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gb3V0ZXJFbmQgLyBvdXRlckVuZEFkanVzdGVkUmFkaXVzO1xuICAgIGNvbnN0IGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cyA9IGlubmVyUmFkaXVzICsgaW5uZXJTdGFydDtcbiAgICBjb25zdCBpbm5lckVuZEFkanVzdGVkUmFkaXVzID0gaW5uZXJSYWRpdXMgKyBpbm5lckVuZDtcbiAgICBjb25zdCBpbm5lclN0YXJ0QWRqdXN0ZWRBbmdsZSA9IHN0YXJ0QW5nbGUgKyBpbm5lclN0YXJ0IC8gaW5uZXJTdGFydEFkanVzdGVkUmFkaXVzO1xuICAgIGNvbnN0IGlubmVyRW5kQWRqdXN0ZWRBbmdsZSA9IGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lckVuZEFkanVzdGVkUmFkaXVzO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGFyYyBzZWdtZW50cyBmcm9tIHBvaW50IDEgdG8gcG9pbnQgYSB0byBwb2ludCAyXG4gICAgICAgIGNvbnN0IG91dGVyTWlkQWRqdXN0ZWRBbmdsZSA9IChvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSArIG91dGVyRW5kQWRqdXN0ZWRBbmdsZSkgLyAyO1xuICAgICAgICBjdHguYXJjKHgsIHksIG91dGVyUmFkaXVzLCBvdXRlclN0YXJ0QWRqdXN0ZWRBbmdsZSwgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlKTtcbiAgICAgICAgY3R4LmFyYyh4LCB5LCBvdXRlclJhZGl1cywgb3V0ZXJNaWRBZGp1c3RlZEFuZ2xlLCBvdXRlckVuZEFkanVzdGVkQW5nbGUpO1xuICAgICAgICAvLyBUaGUgY29ybmVyIHNlZ21lbnQgZnJvbSBwb2ludCAyIHRvIHBvaW50IDNcbiAgICAgICAgaWYgKG91dGVyRW5kID4gMCkge1xuICAgICAgICAgICAgY29uc3QgcENlbnRlciA9IHJUaGV0YVRvWFkob3V0ZXJFbmRBZGp1c3RlZFJhZGl1cywgb3V0ZXJFbmRBZGp1c3RlZEFuZ2xlLCB4LCB5KTtcbiAgICAgICAgICAgIGN0eC5hcmMocENlbnRlci54LCBwQ2VudGVyLnksIG91dGVyRW5kLCBvdXRlckVuZEFkanVzdGVkQW5nbGUsIGVuZEFuZ2xlICsgSEFMRl9QSSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCAzIHRvIHBvaW50IDRcbiAgICAgICAgY29uc3QgcDQgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGVuZEFuZ2xlLCB4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyhwNC54LCBwNC55KTtcbiAgICAgICAgLy8gVGhlIGNvcm5lciBzZWdtZW50IGZyb20gcG9pbnQgNCB0byBwb2ludCA1XG4gICAgICAgIGlmIChpbm5lckVuZCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyRW5kQWRqdXN0ZWRSYWRpdXMsIGlubmVyRW5kQWRqdXN0ZWRBbmdsZSwgeCwgeSk7XG4gICAgICAgICAgICBjdHguYXJjKHBDZW50ZXIueCwgcENlbnRlci55LCBpbm5lckVuZCwgZW5kQW5nbGUgKyBIQUxGX1BJLCBpbm5lckVuZEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgaW5uZXIgYXJjIGZyb20gcG9pbnQgNSB0byBwb2ludCBiIHRvIHBvaW50IDZcbiAgICAgICAgY29uc3QgaW5uZXJNaWRBZGp1c3RlZEFuZ2xlID0gKGVuZEFuZ2xlIC0gaW5uZXJFbmQgLyBpbm5lclJhZGl1cyArIChzdGFydEFuZ2xlICsgaW5uZXJTdGFydCAvIGlubmVyUmFkaXVzKSkgLyAyO1xuICAgICAgICBjdHguYXJjKHgsIHksIGlubmVyUmFkaXVzLCBlbmRBbmdsZSAtIGlubmVyRW5kIC8gaW5uZXJSYWRpdXMsIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgdHJ1ZSk7XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgaW5uZXJSYWRpdXMsIGlubmVyTWlkQWRqdXN0ZWRBbmdsZSwgc3RhcnRBbmdsZSArIGlubmVyU3RhcnQgLyBpbm5lclJhZGl1cywgdHJ1ZSk7XG4gICAgICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDYgdG8gcG9pbnQgN1xuICAgICAgICBpZiAoaW5uZXJTdGFydCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKGlubmVyU3RhcnRBZGp1c3RlZFJhZGl1cywgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgaW5uZXJTdGFydCwgaW5uZXJTdGFydEFkanVzdGVkQW5nbGUgKyBNYXRoLlBJLCBzdGFydEFuZ2xlIC0gSEFMRl9QSSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIGxpbmUgZnJvbSBwb2ludCA3IHRvIHBvaW50IDhcbiAgICAgICAgY29uc3QgcDggPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgc3RhcnRBbmdsZSwgeCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8ocDgueCwgcDgueSk7XG4gICAgICAgIC8vIFRoZSBjb3JuZXIgc2VnbWVudCBmcm9tIHBvaW50IDggdG8gcG9pbnQgMVxuICAgICAgICBpZiAob3V0ZXJTdGFydCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IHBDZW50ZXIgPSByVGhldGFUb1hZKG91dGVyU3RhcnRBZGp1c3RlZFJhZGl1cywgb3V0ZXJTdGFydEFkanVzdGVkQW5nbGUsIHgsIHkpO1xuICAgICAgICAgICAgY3R4LmFyYyhwQ2VudGVyLngsIHBDZW50ZXIueSwgb3V0ZXJTdGFydCwgc3RhcnRBbmdsZSAtIEhBTEZfUEksIG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgIGNvbnN0IG91dGVyU3RhcnRYID0gTWF0aC5jb3Mob3V0ZXJTdGFydEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgICAgICBjb25zdCBvdXRlclN0YXJ0WSA9IE1hdGguc2luKG91dGVyU3RhcnRBZGp1c3RlZEFuZ2xlKSAqIG91dGVyUmFkaXVzICsgeTtcbiAgICAgICAgY3R4LmxpbmVUbyhvdXRlclN0YXJ0WCwgb3V0ZXJTdGFydFkpO1xuICAgICAgICBjb25zdCBvdXRlckVuZFggPSBNYXRoLmNvcyhvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB4O1xuICAgICAgICBjb25zdCBvdXRlckVuZFkgPSBNYXRoLnNpbihvdXRlckVuZEFkanVzdGVkQW5nbGUpICogb3V0ZXJSYWRpdXMgKyB5O1xuICAgICAgICBjdHgubGluZVRvKG91dGVyRW5kWCwgb3V0ZXJFbmRZKTtcbiAgICB9XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xufVxuZnVuY3Rpb24gZHJhd0FyYyhjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpIHtcbiAgICBjb25zdCB7IGZ1bGxDaXJjbGVzICwgc3RhcnRBbmdsZSAsIGNpcmN1bWZlcmVuY2UgIH0gPSBlbGVtZW50O1xuICAgIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gICAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKXtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc05hTihjaXJjdW1mZXJlbmNlKSkge1xuICAgICAgICAgICAgZW5kQW5nbGUgPSBzdGFydEFuZ2xlICsgKGNpcmN1bWZlcmVuY2UgJSBUQVUgfHwgVEFVKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXRoQXJjKGN0eCwgZWxlbWVudCwgb2Zmc2V0LCBzcGFjaW5nLCBlbmRBbmdsZSwgY2lyY3VsYXIpO1xuICAgIGN0eC5maWxsKCk7XG4gICAgcmV0dXJuIGVuZEFuZ2xlO1xufVxuZnVuY3Rpb24gZHJhd0JvcmRlcihjdHgsIGVsZW1lbnQsIG9mZnNldCwgc3BhY2luZywgY2lyY3VsYXIpIHtcbiAgICBjb25zdCB7IGZ1bGxDaXJjbGVzICwgc3RhcnRBbmdsZSAsIGNpcmN1bWZlcmVuY2UgLCBvcHRpb25zICB9ID0gZWxlbWVudDtcbiAgICBjb25zdCB7IGJvcmRlcldpZHRoICwgYm9yZGVySm9pblN0eWxlICwgYm9yZGVyRGFzaCAsIGJvcmRlckRhc2hPZmZzZXQgIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGlubmVyID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJztcbiAgICBpZiAoIWJvcmRlcldpZHRoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNldExpbmVEYXNoKGJvcmRlckRhc2ggfHwgW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlckRhc2hPZmZzZXQ7XG4gICAgaWYgKGlubmVyKSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aCAqIDI7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IGJvcmRlckpvaW5TdHlsZSB8fCAncm91bmQnO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGN0eC5saW5lV2lkdGggPSBib3JkZXJXaWR0aDtcbiAgICAgICAgY3R4LmxpbmVKb2luID0gYm9yZGVySm9pblN0eWxlIHx8ICdiZXZlbCc7XG4gICAgfVxuICAgIGxldCBlbmRBbmdsZSA9IGVsZW1lbnQuZW5kQW5nbGU7XG4gICAgaWYgKGZ1bGxDaXJjbGVzKSB7XG4gICAgICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBmdWxsQ2lyY2xlczsgKytpKXtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzTmFOKGNpcmN1bWZlcmVuY2UpKSB7XG4gICAgICAgICAgICBlbmRBbmdsZSA9IHN0YXJ0QW5nbGUgKyAoY2lyY3VtZmVyZW5jZSAlIFRBVSB8fCBUQVUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpbm5lcikge1xuICAgICAgICBjbGlwQXJjKGN0eCwgZWxlbWVudCwgZW5kQW5nbGUpO1xuICAgIH1cbiAgICBpZiAoIWZ1bGxDaXJjbGVzKSB7XG4gICAgICAgIHBhdGhBcmMoY3R4LCBlbGVtZW50LCBvZmZzZXQsIHNwYWNpbmcsIGVuZEFuZ2xlLCBjaXJjdWxhcik7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG5jbGFzcyBBcmNFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgc3RhdGljIGlkID0gJ2FyYyc7XG4gICAgc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBib3JkZXJBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICAgIGJvcmRlckRhc2g6IFtdLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiAwLFxuICAgICAgICBib3JkZXJKb2luU3R5bGU6IHVuZGVmaW5lZCxcbiAgICAgICAgYm9yZGVyUmFkaXVzOiAwLFxuICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICBzcGFjaW5nOiAwLFxuICAgICAgICBhbmdsZTogdW5kZWZpbmVkLFxuICAgICAgICBjaXJjdWxhcjogdHJ1ZVxuICAgIH07XG4gICAgc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcidcbiAgICB9O1xuICAgIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICAgICAgX3NjcmlwdGFibGU6IHRydWUsXG4gICAgICAgIF9pbmRleGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ2JvcmRlckRhc2gnXG4gICAgfTtcbiAgICBjaXJjdW1mZXJlbmNlO1xuICAgIGVuZEFuZ2xlO1xuICAgIGZ1bGxDaXJjbGVzO1xuICAgIGlubmVyUmFkaXVzO1xuICAgIG91dGVyUmFkaXVzO1xuICAgIHBpeGVsTWFyZ2luO1xuICAgIHN0YXJ0QW5nbGU7XG4gICAgY29uc3RydWN0b3IoY2ZnKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNpcmN1bWZlcmVuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RhcnRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbmRBbmdsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5pbm5lclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5vdXRlclJhZGl1cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5waXhlbE1hcmdpbiA9IDA7XG4gICAgICAgIHRoaXMuZnVsbENpcmNsZXMgPSAwO1xuICAgICAgICBpZiAoY2ZnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5SYW5nZShjaGFydFgsIGNoYXJ0WSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgJ3knXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICBjb25zdCB7IGFuZ2xlICwgZGlzdGFuY2UgIH0gPSBnZXRBbmdsZUZyb21Qb2ludChwb2ludCwge1xuICAgICAgICAgICAgeDogY2hhcnRYLFxuICAgICAgICAgICAgeTogY2hhcnRZXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHN0YXJ0QW5nbGUgLCBlbmRBbmdsZSAsIGlubmVyUmFkaXVzICwgb3V0ZXJSYWRpdXMgLCBjaXJjdW1mZXJlbmNlICB9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAgICAgICAnc3RhcnRBbmdsZScsXG4gICAgICAgICAgICAnZW5kQW5nbGUnLFxuICAgICAgICAgICAgJ2lubmVyUmFkaXVzJyxcbiAgICAgICAgICAgICdvdXRlclJhZGl1cycsXG4gICAgICAgICAgICAnY2lyY3VtZmVyZW5jZSdcbiAgICAgICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IHJBZGp1c3QgPSAodGhpcy5vcHRpb25zLnNwYWNpbmcgKyB0aGlzLm9wdGlvbnMuYm9yZGVyV2lkdGgpIC8gMjtcbiAgICAgICAgY29uc3QgX2NpcmN1bWZlcmVuY2UgPSB2YWx1ZU9yRGVmYXVsdChjaXJjdW1mZXJlbmNlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpO1xuICAgICAgICBjb25zdCBub25aZXJvQmV0d2VlbiA9IF9hbmdsZUJldHdlZW4oYW5nbGUsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKSAmJiBzdGFydEFuZ2xlICE9PSBlbmRBbmdsZTtcbiAgICAgICAgY29uc3QgYmV0d2VlbkFuZ2xlcyA9IF9jaXJjdW1mZXJlbmNlID49IFRBVSB8fCBub25aZXJvQmV0d2VlbjtcbiAgICAgICAgY29uc3Qgd2l0aGluUmFkaXVzID0gX2lzQmV0d2VlbihkaXN0YW5jZSwgaW5uZXJSYWRpdXMgKyByQWRqdXN0LCBvdXRlclJhZGl1cyArIHJBZGp1c3QpO1xuICAgICAgICByZXR1cm4gYmV0d2VlbkFuZ2xlcyAmJiB3aXRoaW5SYWRpdXM7XG4gICAgfVxuICAgIGdldENlbnRlclBvaW50KHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAsIHN0YXJ0QW5nbGUgLCBlbmRBbmdsZSAsIGlubmVyUmFkaXVzICwgb3V0ZXJSYWRpdXMgIH0gPSB0aGlzLmdldFByb3BzKFtcbiAgICAgICAgICAgICd4JyxcbiAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICdzdGFydEFuZ2xlJyxcbiAgICAgICAgICAgICdlbmRBbmdsZScsXG4gICAgICAgICAgICAnaW5uZXJSYWRpdXMnLFxuICAgICAgICAgICAgJ291dGVyUmFkaXVzJ1xuICAgICAgICBdLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICAgICAgY29uc3QgeyBvZmZzZXQgLCBzcGFjaW5nICB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBoYWxmQW5nbGUgPSAoc3RhcnRBbmdsZSArIGVuZEFuZ2xlKSAvIDI7XG4gICAgICAgIGNvbnN0IGhhbGZSYWRpdXMgPSAoaW5uZXJSYWRpdXMgKyBvdXRlclJhZGl1cyArIHNwYWNpbmcgKyBvZmZzZXQpIC8gMjtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHggKyBNYXRoLmNvcyhoYWxmQW5nbGUpICogaGFsZlJhZGl1cyxcbiAgICAgICAgICAgIHk6IHkgKyBNYXRoLnNpbihoYWxmQW5nbGUpICogaGFsZlJhZGl1c1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0b29sdGlwUG9zaXRpb24odXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDZW50ZXJQb2ludCh1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgZHJhdyhjdHgpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zICwgY2lyY3VtZmVyZW5jZSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IChvcHRpb25zLm9mZnNldCB8fCAwKSAvIDQ7XG4gICAgICAgIGNvbnN0IHNwYWNpbmcgPSAob3B0aW9ucy5zcGFjaW5nIHx8IDApIC8gMjtcbiAgICAgICAgY29uc3QgY2lyY3VsYXIgPSBvcHRpb25zLmNpcmN1bGFyO1xuICAgICAgICB0aGlzLnBpeGVsTWFyZ2luID0gb3B0aW9ucy5ib3JkZXJBbGlnbiA9PT0gJ2lubmVyJyA/IDAuMzMgOiAwO1xuICAgICAgICB0aGlzLmZ1bGxDaXJjbGVzID0gY2lyY3VtZmVyZW5jZSA+IFRBVSA/IE1hdGguZmxvb3IoY2lyY3VtZmVyZW5jZSAvIFRBVSkgOiAwO1xuICAgICAgICBpZiAoY2lyY3VtZmVyZW5jZSA9PT0gMCB8fCB0aGlzLmlubmVyUmFkaXVzIDwgMCB8fCB0aGlzLm91dGVyUmFkaXVzIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGNvbnN0IGhhbGZBbmdsZSA9ICh0aGlzLnN0YXJ0QW5nbGUgKyB0aGlzLmVuZEFuZ2xlKSAvIDI7XG4gICAgICAgIGN0eC50cmFuc2xhdGUoTWF0aC5jb3MoaGFsZkFuZ2xlKSAqIG9mZnNldCwgTWF0aC5zaW4oaGFsZkFuZ2xlKSAqIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGZpeCA9IDEgLSBNYXRoLnNpbihNYXRoLm1pbihQSSwgY2lyY3VtZmVyZW5jZSB8fCAwKSk7XG4gICAgICAgIGNvbnN0IHJhZGl1c09mZnNldCA9IG9mZnNldCAqIGZpeDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRpb25zLmJvcmRlckNvbG9yO1xuICAgICAgICBkcmF3QXJjKGN0eCwgdGhpcywgcmFkaXVzT2Zmc2V0LCBzcGFjaW5nLCBjaXJjdWxhcik7XG4gICAgICAgIGRyYXdCb3JkZXIoY3R4LCB0aGlzLCByYWRpdXNPZmZzZXQsIHNwYWNpbmcsIGNpcmN1bGFyKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKGN0eCwgb3B0aW9ucywgc3R5bGUgPSBvcHRpb25zKSB7XG4gICAgY3R4LmxpbmVDYXAgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDYXBTdHlsZSwgb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSk7XG4gICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2gsIG9wdGlvbnMuYm9yZGVyRGFzaCkpO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsIG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCk7XG4gICAgY3R4LmxpbmVKb2luID0gdmFsdWVPckRlZmF1bHQoc3R5bGUuYm9yZGVySm9pblN0eWxlLCBvcHRpb25zLmJvcmRlckpvaW5TdHlsZSk7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KHN0eWxlLmJvcmRlcldpZHRoLCBvcHRpb25zLmJvcmRlcldpZHRoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChzdHlsZS5ib3JkZXJDb2xvciwgb3B0aW9ucy5ib3JkZXJDb2xvcik7XG59XG5mdW5jdGlvbiBsaW5lVG8oY3R4LCBwcmV2aW91cywgdGFyZ2V0KSB7XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgdGFyZ2V0LnkpO1xufVxuIGZ1bmN0aW9uIGdldExpbmVNZXRob2Qob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnN0ZXBwZWQpIHtcbiAgICAgICAgcmV0dXJuIF9zdGVwcGVkTGluZVRvO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgICAgICByZXR1cm4gX2JlemllckN1cnZlVG87XG4gICAgfVxuICAgIHJldHVybiBsaW5lVG87XG59XG5mdW5jdGlvbiBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgY291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHsgc3RhcnQ6IHBhcmFtc1N0YXJ0ID0gMCAsIGVuZDogcGFyYW1zRW5kID0gY291bnQgLSAxICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHsgc3RhcnQ6IHNlZ21lbnRTdGFydCAsIGVuZDogc2VnbWVudEVuZCAgfSA9IHNlZ21lbnQ7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heChwYXJhbXNTdGFydCwgc2VnbWVudFN0YXJ0KTtcbiAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihwYXJhbXNFbmQsIHNlZ21lbnRFbmQpO1xuICAgIGNvbnN0IG91dHNpZGUgPSBwYXJhbXNTdGFydCA8IHNlZ21lbnRTdGFydCAmJiBwYXJhbXNFbmQgPCBzZWdtZW50U3RhcnQgfHwgcGFyYW1zU3RhcnQgPiBzZWdtZW50RW5kICYmIHBhcmFtc0VuZCA+IHNlZ21lbnRFbmQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY291bnQsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBsb29wOiBzZWdtZW50Lmxvb3AsXG4gICAgICAgIGlsZW46IGVuZCA8IHN0YXJ0ICYmICFvdXRzaWRlID8gY291bnQgKyBlbmQgLSBzdGFydCA6IGVuZCAtIHN0YXJ0XG4gICAgfTtcbn1cbiBmdW5jdGlvbiBwYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHsgcG9pbnRzICwgb3B0aW9ucyAgfSA9IGxpbmU7XG4gICAgY29uc3QgeyBjb3VudCAsIHN0YXJ0ICwgbG9vcCAsIGlsZW4gIH0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gICAgY29uc3QgbGluZU1ldGhvZCA9IGdldExpbmVNZXRob2Qob3B0aW9ucyk7XG4gICAgbGV0IHsgbW92ZSA9dHJ1ZSAsIHJldmVyc2UgIH0gPSBwYXJhbXMgfHwge307XG4gICAgbGV0IGksIHBvaW50LCBwcmV2O1xuICAgIGZvcihpID0gMDsgaSA8PSBpbGVuOyArK2kpe1xuICAgICAgICBwb2ludCA9IHBvaW50c1soc3RhcnQgKyAocmV2ZXJzZSA/IGlsZW4gLSBpIDogaSkpICUgY291bnRdO1xuICAgICAgICBpZiAocG9pbnQuc2tpcCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAobW92ZSkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgICAgICAgIG1vdmUgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVNZXRob2QoY3R4LCBwcmV2LCBwb2ludCwgcmV2ZXJzZSwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2ID0gcG9pbnQ7XG4gICAgfVxuICAgIGlmIChsb29wKSB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzWyhzdGFydCArIChyZXZlcnNlID8gaWxlbiA6IDApKSAlIGNvdW50XTtcbiAgICAgICAgbGluZU1ldGhvZChjdHgsIHByZXYsIHBvaW50LCByZXZlcnNlLCBvcHRpb25zLnN0ZXBwZWQpO1xuICAgIH1cbiAgICByZXR1cm4gISFsb29wO1xufVxuIGZ1bmN0aW9uIGZhc3RQYXRoU2VnbWVudChjdHgsIGxpbmUsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICAgIGNvbnN0IHsgY291bnQgLCBzdGFydCAsIGlsZW4gIH0gPSBwYXRoVmFycyhwb2ludHMsIHNlZ21lbnQsIHBhcmFtcyk7XG4gICAgY29uc3QgeyBtb3ZlID10cnVlICwgcmV2ZXJzZSAgfSA9IHBhcmFtcyB8fCB7fTtcbiAgICBsZXQgYXZnWCA9IDA7XG4gICAgbGV0IGNvdW50WCA9IDA7XG4gICAgbGV0IGksIHBvaW50LCBwcmV2WCwgbWluWSwgbWF4WSwgbGFzdFk7XG4gICAgY29uc3QgcG9pbnRJbmRleCA9IChpbmRleCk9PihzdGFydCArIChyZXZlcnNlID8gaWxlbiAtIGluZGV4IDogaW5kZXgpKSAlIGNvdW50O1xuICAgIGNvbnN0IGRyYXdYID0gKCk9PntcbiAgICAgICAgaWYgKG1pblkgIT09IG1heFkpIHtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oYXZnWCwgbWF4WSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKGF2Z1gsIG1pblkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhhdmdYLCBsYXN0WSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChtb3ZlKSB7XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW3BvaW50SW5kZXgoMCldO1xuICAgICAgICBjdHgubW92ZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgIH1cbiAgICBmb3IoaSA9IDA7IGkgPD0gaWxlbjsgKytpKXtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbcG9pbnRJbmRleChpKV07XG4gICAgICAgIGlmIChwb2ludC5za2lwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4ID0gcG9pbnQueDtcbiAgICAgICAgY29uc3QgeSA9IHBvaW50Lnk7XG4gICAgICAgIGNvbnN0IHRydW5jWCA9IHggfCAwO1xuICAgICAgICBpZiAodHJ1bmNYID09PSBwcmV2WCkge1xuICAgICAgICAgICAgaWYgKHkgPCBtaW5ZKSB7XG4gICAgICAgICAgICAgICAgbWluWSA9IHk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdmdYID0gKGNvdW50WCAqIGF2Z1ggKyB4KSAvICsrY291bnRYO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1goKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgICAgICAgIGNvdW50WCA9IDA7XG4gICAgICAgICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFkgPSB5O1xuICAgIH1cbiAgICBkcmF3WCgpO1xufVxuIGZ1bmN0aW9uIF9nZXRTZWdtZW50TWV0aG9kKGxpbmUpIHtcbiAgICBjb25zdCBvcHRzID0gbGluZS5vcHRpb25zO1xuICAgIGNvbnN0IGJvcmRlckRhc2ggPSBvcHRzLmJvcmRlckRhc2ggJiYgb3B0cy5ib3JkZXJEYXNoLmxlbmd0aDtcbiAgICBjb25zdCB1c2VGYXN0UGF0aCA9ICFsaW5lLl9kZWNpbWF0ZWQgJiYgIWxpbmUuX2xvb3AgJiYgIW9wdHMudGVuc2lvbiAmJiBvcHRzLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgIT09ICdtb25vdG9uZScgJiYgIW9wdHMuc3RlcHBlZCAmJiAhYm9yZGVyRGFzaDtcbiAgICByZXR1cm4gdXNlRmFzdFBhdGggPyBmYXN0UGF0aFNlZ21lbnQgOiBwYXRoU2VnbWVudDtcbn1cbiBmdW5jdGlvbiBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMuc3RlcHBlZCkge1xuICAgICAgICByZXR1cm4gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZW5zaW9uIHx8IG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgICAgICByZXR1cm4gX2JlemllckludGVycG9sYXRpb247XG4gICAgfVxuICAgIHJldHVybiBfcG9pbnRJbkxpbmU7XG59XG5mdW5jdGlvbiBzdHJva2VQYXRoV2l0aENhY2hlKGN0eCwgbGluZSwgc3RhcnQsIGNvdW50KSB7XG4gICAgbGV0IHBhdGggPSBsaW5lLl9wYXRoO1xuICAgIGlmICghcGF0aCkge1xuICAgICAgICBwYXRoID0gbGluZS5fcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgICAgICAgaWYgKGxpbmUucGF0aChwYXRoLCBzdGFydCwgY291bnQpKSB7XG4gICAgICAgICAgICBwYXRoLmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFN0eWxlKGN0eCwgbGluZS5vcHRpb25zKTtcbiAgICBjdHguc3Ryb2tlKHBhdGgpO1xufVxuZnVuY3Rpb24gc3Ryb2tlUGF0aERpcmVjdChjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICAgIGNvbnN0IHsgc2VnbWVudHMgLCBvcHRpb25zICB9ID0gbGluZTtcbiAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QobGluZSk7XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKXtcbiAgICAgICAgc2V0U3R5bGUoY3R4LCBvcHRpb25zLCBzZWdtZW50LnN0eWxlKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoc2VnbWVudE1ldGhvZChjdHgsIGxpbmUsIHNlZ21lbnQsIHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBzdGFydCArIGNvdW50IC0gMVxuICAgICAgICB9KSkge1xuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG59XG5jb25zdCB1c2VQYXRoMkQgPSB0eXBlb2YgUGF0aDJEID09PSAnZnVuY3Rpb24nO1xuZnVuY3Rpb24gZHJhdyhjdHgsIGxpbmUsIHN0YXJ0LCBjb3VudCkge1xuICAgIGlmICh1c2VQYXRoMkQgJiYgIWxpbmUub3B0aW9ucy5zZWdtZW50KSB7XG4gICAgICAgIHN0cm9rZVBhdGhXaXRoQ2FjaGUoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHN0cm9rZVBhdGhEaXJlY3QoY3R4LCBsaW5lLCBzdGFydCwgY291bnQpO1xuICAgIH1cbn1cbmNsYXNzIExpbmVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgc3RhdGljIGlkID0gJ2xpbmUnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgYm9yZGVyQ2FwU3R5bGU6ICdidXR0JyxcbiAgICAgICAgYm9yZGVyRGFzaDogW10sXG4gICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAsXG4gICAgICAgIGJvcmRlckpvaW5TdHlsZTogJ21pdGVyJyxcbiAgICAgICAgYm9yZGVyV2lkdGg6IDMsXG4gICAgICAgIGNhcEJlemllclBvaW50czogdHJ1ZSxcbiAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ2RlZmF1bHQnLFxuICAgICAgICBmaWxsOiBmYWxzZSxcbiAgICAgICAgc3BhbkdhcHM6IGZhbHNlLFxuICAgICAgICBzdGVwcGVkOiBmYWxzZSxcbiAgICAgICAgdGVuc2lvbjogMFxuICAgIH07XG4gc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gICAgfTtcbiAgICBzdGF0aWMgZGVzY3JpcHRvcnMgPSB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgICAgICBfaW5kZXhhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdib3JkZXJEYXNoJyAmJiBuYW1lICE9PSAnZmlsbCdcbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKGNmZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2NoYXJ0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9sb29wID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9mdWxsTG9vcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zZWdtZW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fZGVjaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZGF0YXNldEluZGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY2ZnKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGNmZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQ29udHJvbFBvaW50cyhjaGFydEFyZWEsIGluZGV4QXhpcykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoKG9wdGlvbnMudGVuc2lvbiB8fCBvcHRpb25zLmN1YmljSW50ZXJwb2xhdGlvbk1vZGUgPT09ICdtb25vdG9uZScpICYmICFvcHRpb25zLnN0ZXBwZWQgJiYgIXRoaXMuX3BvaW50c1VwZGF0ZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvb3AgPSBvcHRpb25zLnNwYW5HYXBzID8gdGhpcy5fbG9vcCA6IHRoaXMuX2Z1bGxMb29wO1xuICAgICAgICAgICAgX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHModGhpcy5fcG9pbnRzLCBvcHRpb25zLCBjaGFydEFyZWEsIGxvb3AsIGluZGV4QXhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQgcG9pbnRzKHBvaW50cykge1xuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zZWdtZW50cztcbiAgICAgICAgZGVsZXRlIHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuX3BvaW50c1VwZGF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBvaW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50cztcbiAgICB9XG4gICAgZ2V0IHNlZ21lbnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VnbWVudHMgfHwgKHRoaXMuX3NlZ21lbnRzID0gX2NvbXB1dGVTZWdtZW50cyh0aGlzLCB0aGlzLm9wdGlvbnMuc2VnbWVudCkpO1xuICAgIH1cbiBmaXJzdCgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSB0aGlzLnNlZ21lbnRzO1xuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzLmxlbmd0aCAmJiBwb2ludHNbc2VnbWVudHNbMF0uc3RhcnRdO1xuICAgIH1cbiBsYXN0KCkge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuICAgICAgICBjb25zdCBjb3VudCA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGNvdW50ICYmIHBvaW50c1tzZWdtZW50c1tjb3VudCAtIDFdLmVuZF07XG4gICAgfVxuIGludGVycG9sYXRlKHBvaW50LCBwcm9wZXJ0eSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBvaW50W3Byb3BlcnR5XTtcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGhpcywge1xuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBzdGFydDogdmFsdWUsXG4gICAgICAgICAgICBlbmQ6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNlZ21lbnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBfaW50ZXJwb2xhdGUgPSBfZ2V0SW50ZXJwb2xhdGlvbk1ldGhvZChvcHRpb25zKTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0ICwgZW5kICB9ID0gc2VnbWVudHNbaV07XG4gICAgICAgICAgICBjb25zdCBwMSA9IHBvaW50c1tzdGFydF07XG4gICAgICAgICAgICBjb25zdCBwMiA9IHBvaW50c1tlbmRdO1xuICAgICAgICAgICAgaWYgKHAxID09PSBwMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSBNYXRoLmFicygodmFsdWUgLSBwMVtwcm9wZXJ0eV0pIC8gKHAyW3Byb3BlcnR5XSAtIHAxW3Byb3BlcnR5XSkpO1xuICAgICAgICAgICAgY29uc3QgaW50ZXJwb2xhdGVkID0gX2ludGVycG9sYXRlKHAxLCBwMiwgdCwgb3B0aW9ucy5zdGVwcGVkKTtcbiAgICAgICAgICAgIGludGVycG9sYXRlZFtwcm9wZXJ0eV0gPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgICAgICAgICByZXN1bHQucHVzaChpbnRlcnBvbGF0ZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQubGVuZ3RoID09PSAxID8gcmVzdWx0WzBdIDogcmVzdWx0O1xuICAgIH1cbiBwYXRoU2VnbWVudChjdHgsIHNlZ21lbnQsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBzZWdtZW50TWV0aG9kID0gX2dldFNlZ21lbnRNZXRob2QodGhpcyk7XG4gICAgICAgIHJldHVybiBzZWdtZW50TWV0aG9kKGN0eCwgdGhpcywgc2VnbWVudCwgcGFyYW1zKTtcbiAgICB9XG4gcGF0aChjdHgsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICBjb25zdCBzZWdtZW50cyA9IHRoaXMuc2VnbWVudHM7XG4gICAgICAgIGNvbnN0IHNlZ21lbnRNZXRob2QgPSBfZ2V0U2VnbWVudE1ldGhvZCh0aGlzKTtcbiAgICAgICAgbGV0IGxvb3AgPSB0aGlzLl9sb29wO1xuICAgICAgICBzdGFydCA9IHN0YXJ0IHx8IDA7XG4gICAgICAgIGNvdW50ID0gY291bnQgfHwgdGhpcy5wb2ludHMubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICAgIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cyl7XG4gICAgICAgICAgICBsb29wICY9IHNlZ21lbnRNZXRob2QoY3R4LCB0aGlzLCBzZWdtZW50LCB7XG4gICAgICAgICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgICAgICAgZW5kOiBzdGFydCArIGNvdW50IC0gMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEhbG9vcDtcbiAgICB9XG4gZHJhdyhjdHgsIGNoYXJ0QXJlYSwgc3RhcnQsIGNvdW50KSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMgfHwge307XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzIHx8IFtdO1xuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCAmJiBvcHRpb25zLmJvcmRlcldpZHRoKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgZHJhdyhjdHgsIHRoaXMsIHN0YXJ0LCBjb3VudCk7XG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2ludHNVcGRhdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9wYXRoID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpblJhbmdlJDEoZWwsIHBvcywgYXhpcywgdXNlRmluYWxQb3NpdGlvbikge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBlbC5vcHRpb25zO1xuICAgIGNvbnN0IHsgW2F4aXNdOiB2YWx1ZSAgfSA9IGVsLmdldFByb3BzKFtcbiAgICAgICAgYXhpc1xuICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIHJldHVybiBNYXRoLmFicyhwb3MgLSB2YWx1ZSkgPCBvcHRpb25zLnJhZGl1cyArIG9wdGlvbnMuaGl0UmFkaXVzO1xufVxuY2xhc3MgUG9pbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgc3RhdGljIGlkID0gJ3BvaW50JztcbiAgICBwYXJzZWQ7XG4gICAgc2tpcDtcbiAgICBzdG9wO1xuICAgIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi8gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBib3JkZXJXaWR0aDogMSxcbiAgICAgICAgaGl0UmFkaXVzOiAxLFxuICAgICAgICBob3ZlckJvcmRlcldpZHRoOiAxLFxuICAgICAgICBob3ZlclJhZGl1czogNCxcbiAgICAgICAgcG9pbnRTdHlsZTogJ2NpcmNsZScsXG4gICAgICAgIHJhZGl1czogMyxcbiAgICAgICAgcm90YXRpb246IDBcbiAgICB9O1xuICAgIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi8gc3RhdGljIGRlZmF1bHRSb3V0ZXMgPSB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JhY2tncm91bmRDb2xvcicsXG4gICAgICAgIGJvcmRlckNvbG9yOiAnYm9yZGVyQ29sb3InXG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucGFyc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnNraXAgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuc3RvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNmZykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBjZmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluUmFuZ2UobW91c2VYLCBtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHRoaXMuZ2V0UHJvcHMoW1xuICAgICAgICAgICAgJ3gnLFxuICAgICAgICAgICAgJ3knXG4gICAgICAgIF0sIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3cobW91c2VYIC0geCwgMikgKyBNYXRoLnBvdyhtb3VzZVkgLSB5LCAyKSA8IE1hdGgucG93KG9wdGlvbnMuaGl0UmFkaXVzICsgb3B0aW9ucy5yYWRpdXMsIDIpO1xuICAgIH1cbiAgICBpblhSYW5nZShtb3VzZVgsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UkMSh0aGlzLCBtb3VzZVgsICd4JywgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIGluWVJhbmdlKG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gaW5SYW5nZSQxKHRoaXMsIG1vdXNlWSwgJ3knLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7IHggLCB5ICB9ID0gdGhpcy5nZXRQcm9wcyhbXG4gICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAneSdcbiAgICAgICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzaXplKG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgdGhpcy5vcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcbiAgICAgICAgcmFkaXVzID0gTWF0aC5tYXgocmFkaXVzLCByYWRpdXMgJiYgb3B0aW9ucy5ob3ZlclJhZGl1cyB8fCAwKTtcbiAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSByYWRpdXMgJiYgb3B0aW9ucy5ib3JkZXJXaWR0aCB8fCAwO1xuICAgICAgICByZXR1cm4gKHJhZGl1cyArIGJvcmRlcldpZHRoKSAqIDI7XG4gICAgfVxuICAgIGRyYXcoY3R4LCBhcmVhKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICh0aGlzLnNraXAgfHwgb3B0aW9ucy5yYWRpdXMgPCAwLjEgfHwgIV9pc1BvaW50SW5BcmVhKHRoaXMsIGFyZWEsIHRoaXMuc2l6ZShvcHRpb25zKSAvIDIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgdGhpcy54LCB0aGlzLnkpO1xuICAgIH1cbiAgICBnZXRSYW5nZSgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBGYWxsYmFja3Mgc2hvdWxkIG5ldmVyIGJlIGhpdCBpbiBwcmFjdGljZVxuICAgICAgICByZXR1cm4gb3B0aW9ucy5yYWRpdXMgKyBvcHRpb25zLmhpdFJhZGl1cztcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEJhckJvdW5kcyhiYXIsIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICBjb25zdCB7IHggLCB5ICwgYmFzZSAsIHdpZHRoICwgaGVpZ2h0ICB9ID0gIGJhci5nZXRQcm9wcyhbXG4gICAgICAgICd4JyxcbiAgICAgICAgJ3knLFxuICAgICAgICAnYmFzZScsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdoZWlnaHQnXG4gICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgbGV0IGxlZnQsIHJpZ2h0LCB0b3AsIGJvdHRvbSwgaGFsZjtcbiAgICBpZiAoYmFyLmhvcml6b250YWwpIHtcbiAgICAgICAgaGFsZiA9IGhlaWdodCAvIDI7XG4gICAgICAgIGxlZnQgPSBNYXRoLm1pbih4LCBiYXNlKTtcbiAgICAgICAgcmlnaHQgPSBNYXRoLm1heCh4LCBiYXNlKTtcbiAgICAgICAgdG9wID0geSAtIGhhbGY7XG4gICAgICAgIGJvdHRvbSA9IHkgKyBoYWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGhhbGYgPSB3aWR0aCAvIDI7XG4gICAgICAgIGxlZnQgPSB4IC0gaGFsZjtcbiAgICAgICAgcmlnaHQgPSB4ICsgaGFsZjtcbiAgICAgICAgdG9wID0gTWF0aC5taW4oeSwgYmFzZSk7XG4gICAgICAgIGJvdHRvbSA9IE1hdGgubWF4KHksIGJhc2UpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICB0b3AsXG4gICAgICAgIHJpZ2h0LFxuICAgICAgICBib3R0b21cbiAgICB9O1xufVxuZnVuY3Rpb24gc2tpcE9yTGltaXQoc2tpcCwgdmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHNraXAgPyAwIDogX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KTtcbn1cbmZ1bmN0aW9uIHBhcnNlQm9yZGVyV2lkdGgoYmFyLCBtYXhXLCBtYXhIKSB7XG4gICAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJXaWR0aDtcbiAgICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gICAgY29uc3QgbyA9IHRvVFJCTCh2YWx1ZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdDogc2tpcE9yTGltaXQoc2tpcC50b3AsIG8udG9wLCAwLCBtYXhIKSxcbiAgICAgICAgcjogc2tpcE9yTGltaXQoc2tpcC5yaWdodCwgby5yaWdodCwgMCwgbWF4VyksXG4gICAgICAgIGI6IHNraXBPckxpbWl0KHNraXAuYm90dG9tLCBvLmJvdHRvbSwgMCwgbWF4SCksXG4gICAgICAgIGw6IHNraXBPckxpbWl0KHNraXAubGVmdCwgby5sZWZ0LCAwLCBtYXhXKVxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUJvcmRlclJhZGl1cyhiYXIsIG1heFcsIG1heEgpIHtcbiAgICBjb25zdCB7IGVuYWJsZUJvcmRlclJhZGl1cyAgfSA9IGJhci5nZXRQcm9wcyhbXG4gICAgICAgICdlbmFibGVCb3JkZXJSYWRpdXMnXG4gICAgXSk7XG4gICAgY29uc3QgdmFsdWUgPSBiYXIub3B0aW9ucy5ib3JkZXJSYWRpdXM7XG4gICAgY29uc3QgbyA9IHRvVFJCTENvcm5lcnModmFsdWUpO1xuICAgIGNvbnN0IG1heFIgPSBNYXRoLm1pbihtYXhXLCBtYXhIKTtcbiAgICBjb25zdCBza2lwID0gYmFyLmJvcmRlclNraXBwZWQ7XG4gICAgY29uc3QgZW5hYmxlQm9yZGVyID0gZW5hYmxlQm9yZGVyUmFkaXVzIHx8IGlzT2JqZWN0KHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3BMZWZ0OiBza2lwT3JMaW1pdCghZW5hYmxlQm9yZGVyIHx8IHNraXAudG9wIHx8IHNraXAubGVmdCwgby50b3BMZWZ0LCAwLCBtYXhSKSxcbiAgICAgICAgdG9wUmlnaHQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC50b3AgfHwgc2tpcC5yaWdodCwgby50b3BSaWdodCwgMCwgbWF4UiksXG4gICAgICAgIGJvdHRvbUxlZnQ6IHNraXBPckxpbWl0KCFlbmFibGVCb3JkZXIgfHwgc2tpcC5ib3R0b20gfHwgc2tpcC5sZWZ0LCBvLmJvdHRvbUxlZnQsIDAsIG1heFIpLFxuICAgICAgICBib3R0b21SaWdodDogc2tpcE9yTGltaXQoIWVuYWJsZUJvcmRlciB8fCBza2lwLmJvdHRvbSB8fCBza2lwLnJpZ2h0LCBvLmJvdHRvbVJpZ2h0LCAwLCBtYXhSKVxuICAgIH07XG59XG5mdW5jdGlvbiBib3VuZGluZ1JlY3RzKGJhcikge1xuICAgIGNvbnN0IGJvdW5kcyA9IGdldEJhckJvdW5kcyhiYXIpO1xuICAgIGNvbnN0IHdpZHRoID0gYm91bmRzLnJpZ2h0IC0gYm91bmRzLmxlZnQ7XG4gICAgY29uc3QgaGVpZ2h0ID0gYm91bmRzLmJvdHRvbSAtIGJvdW5kcy50b3A7XG4gICAgY29uc3QgYm9yZGVyID0gcGFyc2VCb3JkZXJXaWR0aChiYXIsIHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG4gICAgY29uc3QgcmFkaXVzID0gcGFyc2VCb3JkZXJSYWRpdXMoYmFyLCB3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG91dGVyOiB7XG4gICAgICAgICAgICB4OiBib3VuZHMubGVmdCxcbiAgICAgICAgICAgIHk6IGJvdW5kcy50b3AsXG4gICAgICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgICAgIGg6IGhlaWdodCxcbiAgICAgICAgICAgIHJhZGl1c1xuICAgICAgICB9LFxuICAgICAgICBpbm5lcjoge1xuICAgICAgICAgICAgeDogYm91bmRzLmxlZnQgKyBib3JkZXIubCxcbiAgICAgICAgICAgIHk6IGJvdW5kcy50b3AgKyBib3JkZXIudCxcbiAgICAgICAgICAgIHc6IHdpZHRoIC0gYm9yZGVyLmwgLSBib3JkZXIucixcbiAgICAgICAgICAgIGg6IGhlaWdodCAtIGJvcmRlci50IC0gYm9yZGVyLmIsXG4gICAgICAgICAgICByYWRpdXM6IHtcbiAgICAgICAgICAgICAgICB0b3BMZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wTGVmdCAtIE1hdGgubWF4KGJvcmRlci50LCBib3JkZXIubCkpLFxuICAgICAgICAgICAgICAgIHRvcFJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMudG9wUmlnaHQgLSBNYXRoLm1heChib3JkZXIudCwgYm9yZGVyLnIpKSxcbiAgICAgICAgICAgICAgICBib3R0b21MZWZ0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tTGVmdCAtIE1hdGgubWF4KGJvcmRlci5iLCBib3JkZXIubCkpLFxuICAgICAgICAgICAgICAgIGJvdHRvbVJpZ2h0OiBNYXRoLm1heCgwLCByYWRpdXMuYm90dG9tUmlnaHQgLSBNYXRoLm1heChib3JkZXIuYiwgYm9yZGVyLnIpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluUmFuZ2UoYmFyLCB4LCB5LCB1c2VGaW5hbFBvc2l0aW9uKSB7XG4gICAgY29uc3Qgc2tpcFggPSB4ID09PSBudWxsO1xuICAgIGNvbnN0IHNraXBZID0geSA9PT0gbnVsbDtcbiAgICBjb25zdCBza2lwQm90aCA9IHNraXBYICYmIHNraXBZO1xuICAgIGNvbnN0IGJvdW5kcyA9IGJhciAmJiAhc2tpcEJvdGggJiYgZ2V0QmFyQm91bmRzKGJhciwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgcmV0dXJuIGJvdW5kcyAmJiAoc2tpcFggfHwgX2lzQmV0d2Vlbih4LCBib3VuZHMubGVmdCwgYm91bmRzLnJpZ2h0KSkgJiYgKHNraXBZIHx8IF9pc0JldHdlZW4oeSwgYm91bmRzLnRvcCwgYm91bmRzLmJvdHRvbSkpO1xufVxuZnVuY3Rpb24gaGFzUmFkaXVzKHJhZGl1cykge1xuICAgIHJldHVybiByYWRpdXMudG9wTGVmdCB8fCByYWRpdXMudG9wUmlnaHQgfHwgcmFkaXVzLmJvdHRvbUxlZnQgfHwgcmFkaXVzLmJvdHRvbVJpZ2h0O1xufVxuIGZ1bmN0aW9uIGFkZE5vcm1hbFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICAgIGN0eC5yZWN0KHJlY3QueCwgcmVjdC55LCByZWN0LncsIHJlY3QuaCk7XG59XG5mdW5jdGlvbiBpbmZsYXRlUmVjdChyZWN0LCBhbW91bnQsIHJlZlJlY3QgPSB7fSkge1xuICAgIGNvbnN0IHggPSByZWN0LnggIT09IHJlZlJlY3QueCA/IC1hbW91bnQgOiAwO1xuICAgIGNvbnN0IHkgPSByZWN0LnkgIT09IHJlZlJlY3QueSA/IC1hbW91bnQgOiAwO1xuICAgIGNvbnN0IHcgPSAocmVjdC54ICsgcmVjdC53ICE9PSByZWZSZWN0LnggKyByZWZSZWN0LncgPyBhbW91bnQgOiAwKSAtIHg7XG4gICAgY29uc3QgaCA9IChyZWN0LnkgKyByZWN0LmggIT09IHJlZlJlY3QueSArIHJlZlJlY3QuaCA/IGFtb3VudCA6IDApIC0geTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByZWN0LnggKyB4LFxuICAgICAgICB5OiByZWN0LnkgKyB5LFxuICAgICAgICB3OiByZWN0LncgKyB3LFxuICAgICAgICBoOiByZWN0LmggKyBoLFxuICAgICAgICByYWRpdXM6IHJlY3QucmFkaXVzXG4gICAgfTtcbn1cbmNsYXNzIEJhckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBzdGF0aWMgaWQgPSAnYmFyJztcbiBzdGF0aWMgZGVmYXVsdHMgPSB7XG4gICAgICAgIGJvcmRlclNraXBwZWQ6ICdzdGFydCcsXG4gICAgICAgIGJvcmRlcldpZHRoOiAwLFxuICAgICAgICBib3JkZXJSYWRpdXM6IDAsXG4gICAgICAgIGluZmxhdGVBbW91bnQ6ICdhdXRvJyxcbiAgICAgICAgcG9pbnRTdHlsZTogdW5kZWZpbmVkXG4gICAgfTtcbiBzdGF0aWMgZGVmYXVsdFJvdXRlcyA9IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnYmFja2dyb3VuZENvbG9yJyxcbiAgICAgICAgYm9yZGVyQ29sb3I6ICdib3JkZXJDb2xvcidcbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKGNmZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJhc2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmluZmxhdGVBbW91bnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChjZmcpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgY2ZnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KGN0eCkge1xuICAgICAgICBjb25zdCB7IGluZmxhdGVBbW91bnQgLCBvcHRpb25zOiB7IGJvcmRlckNvbG9yICwgYmFja2dyb3VuZENvbG9yICB9ICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBpbm5lciAsIG91dGVyICB9ID0gYm91bmRpbmdSZWN0cyh0aGlzKTtcbiAgICAgICAgY29uc3QgYWRkUmVjdFBhdGggPSBoYXNSYWRpdXMob3V0ZXIucmFkaXVzKSA/IGFkZFJvdW5kZWRSZWN0UGF0aCA6IGFkZE5vcm1hbFJlY3RQYXRoO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBpZiAob3V0ZXIudyAhPT0gaW5uZXIudyB8fCBvdXRlci5oICE9PSBpbm5lci5oKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBhZGRSZWN0UGF0aChjdHgsIGluZmxhdGVSZWN0KG91dGVyLCBpbmZsYXRlQW1vdW50LCBpbm5lcikpO1xuICAgICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIC1pbmZsYXRlQW1vdW50LCBvdXRlcikpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGwoJ2V2ZW5vZGQnKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFJlY3RQYXRoKGN0eCwgaW5mbGF0ZVJlY3QoaW5uZXIsIGluZmxhdGVBbW91bnQpKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgaW5SYW5nZShtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG1vdXNlWSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgfVxuICAgIGluWFJhbmdlKG1vdXNlWCwgdXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICByZXR1cm4gaW5SYW5nZSh0aGlzLCBtb3VzZVgsIG51bGwsIHVzZUZpbmFsUG9zaXRpb24pO1xuICAgIH1cbiAgICBpbllSYW5nZShtb3VzZVksIHVzZUZpbmFsUG9zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGluUmFuZ2UodGhpcywgbnVsbCwgbW91c2VZLCB1c2VGaW5hbFBvc2l0aW9uKTtcbiAgICB9XG4gICAgZ2V0Q2VudGVyUG9pbnQodXNlRmluYWxQb3NpdGlvbikge1xuICAgICAgICBjb25zdCB7IHggLCB5ICwgYmFzZSAsIGhvcml6b250YWwgIH0gPSAgdGhpcy5nZXRQcm9wcyhbXG4gICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAneScsXG4gICAgICAgICAgICAnYmFzZScsXG4gICAgICAgICAgICAnaG9yaXpvbnRhbCdcbiAgICAgICAgXSwgdXNlRmluYWxQb3NpdGlvbik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4OiBob3Jpem9udGFsID8gKHggKyBiYXNlKSAvIDIgOiB4LFxuICAgICAgICAgICAgeTogaG9yaXpvbnRhbCA/IHkgOiAoeSArIGJhc2UpIC8gMlxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRSYW5nZShheGlzKSB7XG4gICAgICAgIHJldHVybiBheGlzID09PSAneCcgPyB0aGlzLndpZHRoIC8gMiA6IHRoaXMuaGVpZ2h0IC8gMjtcbiAgICB9XG59XG5cbnZhciBlbGVtZW50cyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkFyY0VsZW1lbnQ6IEFyY0VsZW1lbnQsXG5CYXJFbGVtZW50OiBCYXJFbGVtZW50LFxuTGluZUVsZW1lbnQ6IExpbmVFbGVtZW50LFxuUG9pbnRFbGVtZW50OiBQb2ludEVsZW1lbnRcbn0pO1xuXG5jb25zdCBCT1JERVJfQ09MT1JTID0gW1xuICAgICdyZ2IoNTQsIDE2MiwgMjM1KScsXG4gICAgJ3JnYigyNTUsIDk5LCAxMzIpJyxcbiAgICAncmdiKDI1NSwgMTU5LCA2NCknLFxuICAgICdyZ2IoMjU1LCAyMDUsIDg2KScsXG4gICAgJ3JnYig3NSwgMTkyLCAxOTIpJyxcbiAgICAncmdiKDE1MywgMTAyLCAyNTUpJyxcbiAgICAncmdiKDIwMSwgMjAzLCAyMDcpJyAvLyBncmV5XG5dO1xuLy8gQm9yZGVyIGNvbG9ycyB3aXRoIDUwJSB0cmFuc3BhcmVuY3lcbmNvbnN0IEJBQ0tHUk9VTkRfQ09MT1JTID0gLyogI19fUFVSRV9fICovIEJPUkRFUl9DT0xPUlMubWFwKChjb2xvcik9PmNvbG9yLnJlcGxhY2UoJ3JnYignLCAncmdiYSgnKS5yZXBsYWNlKCcpJywgJywgMC41KScpKTtcbmZ1bmN0aW9uIGdldEJvcmRlckNvbG9yKGkpIHtcbiAgICByZXR1cm4gQk9SREVSX0NPTE9SU1tpICUgQk9SREVSX0NPTE9SUy5sZW5ndGhdO1xufVxuZnVuY3Rpb24gZ2V0QmFja2dyb3VuZENvbG9yKGkpIHtcbiAgICByZXR1cm4gQkFDS0dST1VORF9DT0xPUlNbaSAlIEJBQ0tHUk9VTkRfQ09MT1JTLmxlbmd0aF07XG59XG5mdW5jdGlvbiBjb2xvcml6ZURlZmF1bHREYXRhc2V0KGRhdGFzZXQsIGkpIHtcbiAgICBkYXRhc2V0LmJvcmRlckNvbG9yID0gZ2V0Qm9yZGVyQ29sb3IoaSk7XG4gICAgZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3IgPSBnZXRCYWNrZ3JvdW5kQ29sb3IoaSk7XG4gICAgcmV0dXJuICsraTtcbn1cbmZ1bmN0aW9uIGNvbG9yaXplRG91Z2hudXREYXRhc2V0KGRhdGFzZXQsIGkpIHtcbiAgICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCk9PmdldEJvcmRlckNvbG9yKGkrKykpO1xuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gY29sb3JpemVQb2xhckFyZWFEYXRhc2V0KGRhdGFzZXQsIGkpIHtcbiAgICBkYXRhc2V0LmJhY2tncm91bmRDb2xvciA9IGRhdGFzZXQuZGF0YS5tYXAoKCk9PmdldEJhY2tncm91bmRDb2xvcihpKyspKTtcbiAgICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIGdldENvbG9yaXplcihjaGFydCkge1xuICAgIGxldCBpID0gMDtcbiAgICByZXR1cm4gKGRhdGFzZXQsIGRhdGFzZXRJbmRleCk9PntcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIgaW5zdGFuY2VvZiBEb3VnaG51dENvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgIGkgPSBjb2xvcml6ZURvdWdobnV0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250cm9sbGVyIGluc3RhbmNlb2YgUG9sYXJBcmVhQ29udHJvbGxlcikge1xuICAgICAgICAgICAgaSA9IGNvbG9yaXplUG9sYXJBcmVhRGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpID0gY29sb3JpemVEZWZhdWx0RGF0YXNldChkYXRhc2V0LCBpKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb25zKGRlc2NyaXB0b3JzKSB7XG4gICAgbGV0IGs7XG4gICAgZm9yKGsgaW4gZGVzY3JpcHRvcnMpe1xuICAgICAgICBpZiAoZGVzY3JpcHRvcnNba10uYm9yZGVyQ29sb3IgfHwgZGVzY3JpcHRvcnNba10uYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb250YWluc0NvbG9yc0RlZmluaXRpb24oZGVzY3JpcHRvcikge1xuICAgIHJldHVybiBkZXNjcmlwdG9yICYmIChkZXNjcmlwdG9yLmJvcmRlckNvbG9yIHx8IGRlc2NyaXB0b3IuYmFja2dyb3VuZENvbG9yKTtcbn1cbmZ1bmN0aW9uIGNvbnRhaW5zRGVmYXVsdENvbG9yc0RlZmVuaXRpb25zKCkge1xuICAgIHJldHVybiBkZWZhdWx0cy5ib3JkZXJDb2xvciAhPT0gJ3JnYmEoMCwwLDAsMC4xKScgfHwgZGVmYXVsdHMuYmFja2dyb3VuZENvbG9yICE9PSAncmdiYSgwLDAsMCwwLjEpJztcbn1cbnZhciBwbHVnaW5fY29sb3JzID0ge1xuICAgIGlkOiAnY29sb3JzJyxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBmb3JjZU92ZXJyaWRlOiBmYWxzZVxuICAgIH0sXG4gICAgYmVmb3JlTGF5b3V0IChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLmVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGRhdGE6IHsgZGF0YXNldHMgIH0gLCBvcHRpb25zOiBjaGFydE9wdGlvbnMgIH0gPSBjaGFydC5jb25maWc7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudHMgIH0gPSBjaGFydE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zQ29sb3JEZWZlbml0aW9uID0gY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhkYXRhc2V0cykgfHwgY29udGFpbnNDb2xvcnNEZWZpbml0aW9uKGNoYXJ0T3B0aW9ucykgfHwgZWxlbWVudHMgJiYgY29udGFpbnNDb2xvcnNEZWZpbml0aW9ucyhlbGVtZW50cykgfHwgY29udGFpbnNEZWZhdWx0Q29sb3JzRGVmZW5pdGlvbnMoKTtcbiAgICAgICAgaWYgKCFvcHRpb25zLmZvcmNlT3ZlcnJpZGUgJiYgY29udGFpbnNDb2xvckRlZmVuaXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2xvcml6ZXIgPSBnZXRDb2xvcml6ZXIoY2hhcnQpO1xuICAgICAgICBkYXRhc2V0cy5mb3JFYWNoKGNvbG9yaXplcik7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gbHR0YkRlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCwgb3B0aW9ucykge1xuIGNvbnN0IHNhbXBsZXMgPSBvcHRpb25zLnNhbXBsZXMgfHwgYXZhaWxhYmxlV2lkdGg7XG4gICAgaWYgKHNhbXBsZXMgPj0gY291bnQpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgY291bnQpO1xuICAgIH1cbiAgICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgICBjb25zdCBidWNrZXRXaWR0aCA9IChjb3VudCAtIDIpIC8gKHNhbXBsZXMgLSAyKTtcbiAgICBsZXQgc2FtcGxlZEluZGV4ID0gMDtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAgIGxldCBhID0gc3RhcnQ7XG4gICAgbGV0IGksIG1heEFyZWFQb2ludCwgbWF4QXJlYSwgYXJlYSwgbmV4dEE7XG4gICAgZGVjaW1hdGVkW3NhbXBsZWRJbmRleCsrXSA9IGRhdGFbYV07XG4gICAgZm9yKGkgPSAwOyBpIDwgc2FtcGxlcyAtIDI7IGkrKyl7XG4gICAgICAgIGxldCBhdmdYID0gMDtcbiAgICAgICAgbGV0IGF2Z1kgPSAwO1xuICAgICAgICBsZXQgajtcbiAgICAgICAgY29uc3QgYXZnUmFuZ2VTdGFydCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIGJ1Y2tldFdpZHRoKSArIDEgKyBzdGFydDtcbiAgICAgICAgY29uc3QgYXZnUmFuZ2VFbmQgPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMikgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICAgICAgY29uc3QgYXZnUmFuZ2VMZW5ndGggPSBhdmdSYW5nZUVuZCAtIGF2Z1JhbmdlU3RhcnQ7XG4gICAgICAgIGZvcihqID0gYXZnUmFuZ2VTdGFydDsgaiA8IGF2Z1JhbmdlRW5kOyBqKyspe1xuICAgICAgICAgICAgYXZnWCArPSBkYXRhW2pdLng7XG4gICAgICAgICAgICBhdmdZICs9IGRhdGFbal0ueTtcbiAgICAgICAgfVxuICAgICAgICBhdmdYIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgICAgICBhdmdZIC89IGF2Z1JhbmdlTGVuZ3RoO1xuICAgICAgICBjb25zdCByYW5nZU9mZnMgPSBNYXRoLmZsb29yKGkgKiBidWNrZXRXaWR0aCkgKyAxICsgc3RhcnQ7XG4gICAgICAgIGNvbnN0IHJhbmdlVG8gPSBNYXRoLm1pbihNYXRoLmZsb29yKChpICsgMSkgKiBidWNrZXRXaWR0aCkgKyAxLCBjb3VudCkgKyBzdGFydDtcbiAgICAgICAgY29uc3QgeyB4OiBwb2ludEF4ICwgeTogcG9pbnRBeSAgfSA9IGRhdGFbYV07XG4gICAgICAgIG1heEFyZWEgPSBhcmVhID0gLTE7XG4gICAgICAgIGZvcihqID0gcmFuZ2VPZmZzOyBqIDwgcmFuZ2VUbzsgaisrKXtcbiAgICAgICAgICAgIGFyZWEgPSAwLjUgKiBNYXRoLmFicygocG9pbnRBeCAtIGF2Z1gpICogKGRhdGFbal0ueSAtIHBvaW50QXkpIC0gKHBvaW50QXggLSBkYXRhW2pdLngpICogKGF2Z1kgLSBwb2ludEF5KSk7XG4gICAgICAgICAgICBpZiAoYXJlYSA+IG1heEFyZWEpIHtcbiAgICAgICAgICAgICAgICBtYXhBcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICBtYXhBcmVhUG9pbnQgPSBkYXRhW2pdO1xuICAgICAgICAgICAgICAgIG5leHRBID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWNpbWF0ZWRbc2FtcGxlZEluZGV4KytdID0gbWF4QXJlYVBvaW50O1xuICAgICAgICBhID0gbmV4dEE7XG4gICAgfVxuICAgIGRlY2ltYXRlZFtzYW1wbGVkSW5kZXgrK10gPSBkYXRhW2VuZEluZGV4XTtcbiAgICByZXR1cm4gZGVjaW1hdGVkO1xufVxuZnVuY3Rpb24gbWluTWF4RGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoKSB7XG4gICAgbGV0IGF2Z1ggPSAwO1xuICAgIGxldCBjb3VudFggPSAwO1xuICAgIGxldCBpLCBwb2ludCwgeCwgeSwgcHJldlgsIG1pbkluZGV4LCBtYXhJbmRleCwgc3RhcnRJbmRleCwgbWluWSwgbWF4WTtcbiAgICBjb25zdCBkZWNpbWF0ZWQgPSBbXTtcbiAgICBjb25zdCBlbmRJbmRleCA9IHN0YXJ0ICsgY291bnQgLSAxO1xuICAgIGNvbnN0IHhNaW4gPSBkYXRhW3N0YXJ0XS54O1xuICAgIGNvbnN0IHhNYXggPSBkYXRhW2VuZEluZGV4XS54O1xuICAgIGNvbnN0IGR4ID0geE1heCAtIHhNaW47XG4gICAgZm9yKGkgPSBzdGFydDsgaSA8IHN0YXJ0ICsgY291bnQ7ICsraSl7XG4gICAgICAgIHBvaW50ID0gZGF0YVtpXTtcbiAgICAgICAgeCA9IChwb2ludC54IC0geE1pbikgLyBkeCAqIGF2YWlsYWJsZVdpZHRoO1xuICAgICAgICB5ID0gcG9pbnQueTtcbiAgICAgICAgY29uc3QgdHJ1bmNYID0geCB8IDA7XG4gICAgICAgIGlmICh0cnVuY1ggPT09IHByZXZYKSB7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIHtcbiAgICAgICAgICAgICAgICBtaW5ZID0geTtcbiAgICAgICAgICAgICAgICBtaW5JbmRleCA9IGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHkgPiBtYXhZKSB7XG4gICAgICAgICAgICAgICAgbWF4WSA9IHk7XG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXZnWCA9IChjb3VudFggKiBhdmdYICsgcG9pbnQueCkgLyArK2NvdW50WDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGkgLSAxO1xuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG1pbkluZGV4KSAmJiAhaXNOdWxsT3JVbmRlZihtYXhJbmRleCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm1lZGlhdGVJbmRleDEgPSBNYXRoLm1pbihtaW5JbmRleCwgbWF4SW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGludGVybWVkaWF0ZUluZGV4MiA9IE1hdGgubWF4KG1pbkluZGV4LCBtYXhJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGludGVybWVkaWF0ZUluZGV4MSAhPT0gc3RhcnRJbmRleCAmJiBpbnRlcm1lZGlhdGVJbmRleDEgIT09IGxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBkZWNpbWF0ZWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhW2ludGVybWVkaWF0ZUluZGV4MV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBhdmdYXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJtZWRpYXRlSW5kZXgyICE9PSBzdGFydEluZGV4ICYmIGludGVybWVkaWF0ZUluZGV4MiAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmRhdGFbaW50ZXJtZWRpYXRlSW5kZXgyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGF2Z1hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPiAwICYmIGxhc3RJbmRleCAhPT0gc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgIGRlY2ltYXRlZC5wdXNoKGRhdGFbbGFzdEluZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWNpbWF0ZWQucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2WCA9IHRydW5jWDtcbiAgICAgICAgICAgIGNvdW50WCA9IDA7XG4gICAgICAgICAgICBtaW5ZID0gbWF4WSA9IHk7XG4gICAgICAgICAgICBtaW5JbmRleCA9IG1heEluZGV4ID0gc3RhcnRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlY2ltYXRlZDtcbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YXNldChkYXRhc2V0KSB7XG4gICAgaWYgKGRhdGFzZXQuX2RlY2ltYXRlZCkge1xuICAgICAgICBjb25zdCBkYXRhID0gZGF0YXNldC5fZGF0YTtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuX2RlY2ltYXRlZDtcbiAgICAgICAgZGVsZXRlIGRhdGFzZXQuX2RhdGE7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkYXRhc2V0LCAnZGF0YScsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBkYXRhXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCkge1xuICAgIGNoYXJ0LmRhdGEuZGF0YXNldHMuZm9yRWFjaCgoZGF0YXNldCk9PntcbiAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhc2V0KGRhdGFzZXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50c1NpbXBsaWZpZWQobWV0YSwgcG9pbnRzKSB7XG4gICAgY29uc3QgcG9pbnRDb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IHN0YXJ0ID0gMDtcbiAgICBsZXQgY291bnQ7XG4gICAgY29uc3QgeyBpU2NhbGUgIH0gPSBtZXRhO1xuICAgIGNvbnN0IHsgbWluICwgbWF4ICwgbWluRGVmaW5lZCAsIG1heERlZmluZWQgIH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICAgIHN0YXJ0ID0gX2xpbWl0VmFsdWUoX2xvb2t1cEJ5S2V5KHBvaW50cywgaVNjYWxlLmF4aXMsIG1pbikubG8sIDAsIHBvaW50Q291bnQgLSAxKTtcbiAgICB9XG4gICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShfbG9va3VwQnlLZXkocG9pbnRzLCBpU2NhbGUuYXhpcywgbWF4KS5oaSArIDEsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ID0gcG9pbnRDb3VudCAtIHN0YXJ0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCxcbiAgICAgICAgY291bnRcbiAgICB9O1xufVxudmFyIHBsdWdpbl9kZWNpbWF0aW9uID0ge1xuICAgIGlkOiAnZGVjaW1hdGlvbicsXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWxnb3JpdGhtOiAnbWluLW1heCcsXG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgfSxcbiAgICBiZWZvcmVFbGVtZW50c1VwZGF0ZTogKGNoYXJ0LCBhcmdzLCBvcHRpb25zKT0+e1xuICAgICAgICBpZiAoIW9wdGlvbnMuZW5hYmxlZCkge1xuICAgICAgICAgICAgY2xlYW5EZWNpbWF0ZWREYXRhKGNoYXJ0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhdmFpbGFibGVXaWR0aCA9IGNoYXJ0LndpZHRoO1xuICAgICAgICBjaGFydC5kYXRhLmRhdGFzZXRzLmZvckVhY2goKGRhdGFzZXQsIGRhdGFzZXRJbmRleCk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgX2RhdGEgLCBpbmRleEF4aXMgIH0gPSBkYXRhc2V0O1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCk7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gX2RhdGEgfHwgZGF0YXNldC5kYXRhO1xuICAgICAgICAgICAgaWYgKHJlc29sdmUoW1xuICAgICAgICAgICAgICAgIGluZGV4QXhpcyxcbiAgICAgICAgICAgICAgICBjaGFydC5vcHRpb25zLmluZGV4QXhpc1xuICAgICAgICAgICAgXSkgPT09ICd5Jykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbWV0YS5jb250cm9sbGVyLnN1cHBvcnRzRGVjaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHhBeGlzID0gY2hhcnQuc2NhbGVzW21ldGEueEF4aXNJRF07XG4gICAgICAgICAgICBpZiAoeEF4aXMudHlwZSAhPT0gJ2xpbmVhcicgJiYgeEF4aXMudHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNoYXJ0Lm9wdGlvbnMucGFyc2luZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB7IHN0YXJ0ICwgY291bnQgIH0gPSBnZXRTdGFydEFuZENvdW50T2ZWaXNpYmxlUG9pbnRzU2ltcGxpZmllZChtZXRhLCBkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IHRocmVzaG9sZCA9IG9wdGlvbnMudGhyZXNob2xkIHx8IDQgKiBhdmFpbGFibGVXaWR0aDtcbiAgICAgICAgICAgIGlmIChjb3VudCA8PSB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICBjbGVhbkRlY2ltYXRlZERhdGFzZXQoZGF0YXNldCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTnVsbE9yVW5kZWYoX2RhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC5fZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGRhdGFzZXQuZGF0YTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YXNldCwgJ2RhdGEnLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWNpbWF0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkZWNpbWF0ZWQ7XG4gICAgICAgICAgICBzd2l0Y2gob3B0aW9ucy5hbGdvcml0aG0pe1xuICAgICAgICAgICAgICAgIGNhc2UgJ2x0dGInOlxuICAgICAgICAgICAgICAgICAgICBkZWNpbWF0ZWQgPSBsdHRiRGVjaW1hdGlvbihkYXRhLCBzdGFydCwgY291bnQsIGF2YWlsYWJsZVdpZHRoLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbWluLW1heCc6XG4gICAgICAgICAgICAgICAgICAgIGRlY2ltYXRlZCA9IG1pbk1heERlY2ltYXRpb24oZGF0YSwgc3RhcnQsIGNvdW50LCBhdmFpbGFibGVXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgZGVjaW1hdGlvbiBhbGdvcml0aG0gJyR7b3B0aW9ucy5hbGdvcml0aG19J2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YXNldC5fZGVjaW1hdGVkID0gZGVjaW1hdGVkO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRlc3Ryb3kgKGNoYXJ0KSB7XG4gICAgICAgIGNsZWFuRGVjaW1hdGVkRGF0YShjaGFydCk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gX3NlZ21lbnRzKGxpbmUsIHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gICAgY29uc3QgcG9pbnRzID0gbGluZS5wb2ludHM7XG4gICAgY29uc3QgdHBvaW50cyA9IHRhcmdldC5wb2ludHM7XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpe1xuICAgICAgICBsZXQgeyBzdGFydCAsIGVuZCAgfSA9IHNlZ21lbnQ7XG4gICAgICAgIGVuZCA9IF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpO1xuICAgICAgICBjb25zdCBib3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCBwb2ludHNbc3RhcnRdLCBwb2ludHNbZW5kXSwgc2VnbWVudC5sb29wKTtcbiAgICAgICAgaWYgKCF0YXJnZXQuc2VnbWVudHMpIHtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNvdXJjZTogc2VnbWVudCxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGJvdW5kcyxcbiAgICAgICAgICAgICAgICBzdGFydDogcG9pbnRzW3N0YXJ0XSxcbiAgICAgICAgICAgICAgICBlbmQ6IHBvaW50c1tlbmRdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFNlZ21lbnRzID0gX2JvdW5kU2VnbWVudHModGFyZ2V0LCBib3VuZHMpO1xuICAgICAgICBmb3IgKGNvbnN0IHRndCBvZiB0YXJnZXRTZWdtZW50cyl7XG4gICAgICAgICAgICBjb25zdCBzdWJCb3VuZHMgPSBfZ2V0Qm91bmRzKHByb3BlcnR5LCB0cG9pbnRzW3RndC5zdGFydF0sIHRwb2ludHNbdGd0LmVuZF0sIHRndC5sb29wKTtcbiAgICAgICAgICAgIGNvbnN0IGZpbGxTb3VyY2VzID0gX2JvdW5kU2VnbWVudChzZWdtZW50LCBwb2ludHMsIHN1YkJvdW5kcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpbGxTb3VyY2Ugb2YgZmlsbFNvdXJjZXMpe1xuICAgICAgICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGZpbGxTb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGd0LFxuICAgICAgICAgICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgW3Byb3BlcnR5XTogX2dldEVkZ2UoYm91bmRzLCBzdWJCb3VuZHMsICdzdGFydCcsIE1hdGgubWF4KVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwcm9wZXJ0eV06IF9nZXRFZGdlKGJvdW5kcywgc3ViQm91bmRzLCAnZW5kJywgTWF0aC5taW4pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydHM7XG59XG5mdW5jdGlvbiBfZ2V0Qm91bmRzKHByb3BlcnR5LCBmaXJzdCwgbGFzdCwgbG9vcCkge1xuICAgIGlmIChsb29wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gZmlyc3RbcHJvcGVydHldO1xuICAgIGxldCBlbmQgPSBsYXN0W3Byb3BlcnR5XTtcbiAgICBpZiAocHJvcGVydHkgPT09ICdhbmdsZScpIHtcbiAgICAgICAgc3RhcnQgPSBfbm9ybWFsaXplQW5nbGUoc3RhcnQpO1xuICAgICAgICBlbmQgPSBfbm9ybWFsaXplQW5nbGUoZW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gX3BvaW50c0Zyb21TZWdtZW50cyhib3VuZGFyeSwgbGluZSkge1xuICAgIGNvbnN0IHsgeCA9bnVsbCAsIHkgPW51bGwgIH0gPSBib3VuZGFyeSB8fCB7fTtcbiAgICBjb25zdCBsaW5lUG9pbnRzID0gbGluZS5wb2ludHM7XG4gICAgY29uc3QgcG9pbnRzID0gW107XG4gICAgbGluZS5zZWdtZW50cy5mb3JFYWNoKCh7IHN0YXJ0ICwgZW5kICB9KT0+e1xuICAgICAgICBlbmQgPSBfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgbGluZVBvaW50cyk7XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gbGluZVBvaW50c1tzdGFydF07XG4gICAgICAgIGNvbnN0IGxhc3QgPSBsaW5lUG9pbnRzW2VuZF07XG4gICAgICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgeDogZmlyc3QueCxcbiAgICAgICAgICAgICAgICB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICB4OiBsYXN0LngsXG4gICAgICAgICAgICAgICAgeVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoeCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgeTogZmlyc3QueVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb2ludHMucHVzaCh7XG4gICAgICAgICAgICAgICAgeCxcbiAgICAgICAgICAgICAgICB5OiBsYXN0LnlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50cztcbn1cbmZ1bmN0aW9uIF9maW5kU2VnbWVudEVuZChzdGFydCwgZW5kLCBwb2ludHMpIHtcbiAgICBmb3IoOyBlbmQgPiBzdGFydDsgZW5kLS0pe1xuICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tlbmRdO1xuICAgICAgICBpZiAoIWlzTmFOKHBvaW50LngpICYmICFpc05hTihwb2ludC55KSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cbmZ1bmN0aW9uIF9nZXRFZGdlKGEsIGIsIHByb3AsIGZuKSB7XG4gICAgaWYgKGEgJiYgYikge1xuICAgICAgICByZXR1cm4gZm4oYVtwcm9wXSwgYltwcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiBhID8gYVtwcm9wXSA6IGIgPyBiW3Byb3BdIDogMDtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUJvdW5kYXJ5TGluZShib3VuZGFyeSwgbGluZSkge1xuICAgIGxldCBwb2ludHMgPSBbXTtcbiAgICBsZXQgX2xvb3AgPSBmYWxzZTtcbiAgICBpZiAoaXNBcnJheShib3VuZGFyeSkpIHtcbiAgICAgICAgX2xvb3AgPSB0cnVlO1xuICAgICAgICBwb2ludHMgPSBib3VuZGFyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwb2ludHMgPSBfcG9pbnRzRnJvbVNlZ21lbnRzKGJvdW5kYXJ5LCBsaW5lKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cy5sZW5ndGggPyBuZXcgTGluZUVsZW1lbnQoe1xuICAgICAgICBwb2ludHMsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHRlbnNpb246IDBcbiAgICAgICAgfSxcbiAgICAgICAgX2xvb3AsXG4gICAgICAgIF9mdWxsTG9vcDogX2xvb3BcbiAgICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2UgJiYgc291cmNlLmZpbGwgIT09IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBfcmVzb2x2ZVRhcmdldChzb3VyY2VzLCBpbmRleCwgcHJvcGFnYXRlKSB7XG4gICAgY29uc3Qgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgbGV0IGZpbGwgPSBzb3VyY2UuZmlsbDtcbiAgICBjb25zdCB2aXNpdGVkID0gW1xuICAgICAgICBpbmRleFxuICAgIF07XG4gICAgbGV0IHRhcmdldDtcbiAgICBpZiAoIXByb3BhZ2F0ZSkge1xuICAgICAgICByZXR1cm4gZmlsbDtcbiAgICB9XG4gICAgd2hpbGUoZmlsbCAhPT0gZmFsc2UgJiYgdmlzaXRlZC5pbmRleE9mKGZpbGwpID09PSAtMSl7XG4gICAgICAgIGlmICghaXNOdW1iZXJGaW5pdGUoZmlsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWxsO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldCA9IHNvdXJjZXNbZmlsbF07XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldC52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlsbDtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLnB1c2goZmlsbCk7XG4gICAgICAgIGZpbGwgPSB0YXJnZXQuZmlsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIGZ1bmN0aW9uIF9kZWNvZGVGaWxsKGxpbmUsIGluZGV4LCBjb3VudCkge1xuICAgICBjb25zdCBmaWxsID0gcGFyc2VGaWxsT3B0aW9uKGxpbmUpO1xuICAgIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgICAgICByZXR1cm4gaXNOYU4oZmlsbC52YWx1ZSkgPyBmYWxzZSA6IGZpbGw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBwYXJzZUZsb2F0KGZpbGwpO1xuICAgIGlmIChpc051bWJlckZpbml0ZSh0YXJnZXQpICYmIE1hdGguZmxvb3IodGFyZ2V0KSA9PT0gdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVUYXJnZXRJbmRleChmaWxsWzBdLCBpbmRleCwgdGFyZ2V0LCBjb3VudCk7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgICdvcmlnaW4nLFxuICAgICAgICAnc3RhcnQnLFxuICAgICAgICAnZW5kJyxcbiAgICAgICAgJ3N0YWNrJyxcbiAgICAgICAgJ3NoYXBlJ1xuICAgIF0uaW5kZXhPZihmaWxsKSA+PSAwICYmIGZpbGw7XG59XG5mdW5jdGlvbiBkZWNvZGVUYXJnZXRJbmRleChmaXJzdENoLCBpbmRleCwgdGFyZ2V0LCBjb3VudCkge1xuICAgIGlmIChmaXJzdENoID09PSAnLScgfHwgZmlyc3RDaCA9PT0gJysnKSB7XG4gICAgICAgIHRhcmdldCA9IGluZGV4ICsgdGFyZ2V0O1xuICAgIH1cbiAgICBpZiAodGFyZ2V0ID09PSBpbmRleCB8fCB0YXJnZXQgPCAwIHx8IHRhcmdldCA+PSBjb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG4gZnVuY3Rpb24gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKSB7XG4gICAgbGV0IHBpeGVsID0gbnVsbDtcbiAgICBpZiAoZmlsbCA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBwaXhlbCA9IHNjYWxlLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdlbmQnKSB7XG4gICAgICAgIHBpeGVsID0gc2NhbGUudG9wO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoZmlsbCkpIHtcbiAgICAgICAgcGl4ZWwgPSBzY2FsZS5nZXRQaXhlbEZvclZhbHVlKGZpbGwudmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2NhbGUuZ2V0QmFzZVBpeGVsKSB7XG4gICAgICAgIHBpeGVsID0gc2NhbGUuZ2V0QmFzZVBpeGVsKCk7XG4gICAgfVxuICAgIHJldHVybiBwaXhlbDtcbn1cbiBmdW5jdGlvbiBfZ2V0VGFyZ2V0VmFsdWUoZmlsbCwgc2NhbGUsIHN0YXJ0VmFsdWUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKGZpbGwgPT09ICdzdGFydCcpIHtcbiAgICAgICAgdmFsdWUgPSBzdGFydFZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2VuZCcpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FsZS5vcHRpb25zLnJldmVyc2UgPyBzY2FsZS5taW4gOiBzY2FsZS5tYXg7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChmaWxsKSkge1xuICAgICAgICB2YWx1ZSA9IGZpbGwudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FsZS5nZXRCYXNlVmFsdWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuIGZ1bmN0aW9uIHBhcnNlRmlsbE9wdGlvbihsaW5lKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGxpbmUub3B0aW9ucztcbiAgICBjb25zdCBmaWxsT3B0aW9uID0gb3B0aW9ucy5maWxsO1xuICAgIGxldCBmaWxsID0gdmFsdWVPckRlZmF1bHQoZmlsbE9wdGlvbiAmJiBmaWxsT3B0aW9uLnRhcmdldCwgZmlsbE9wdGlvbik7XG4gICAgaWYgKGZpbGwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmaWxsID0gISFvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gICAgaWYgKGZpbGwgPT09IGZhbHNlIHx8IGZpbGwgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZmlsbCA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gJ29yaWdpbic7XG4gICAgfVxuICAgIHJldHVybiBmaWxsO1xufVxuXG5mdW5jdGlvbiBfYnVpbGRTdGFja0xpbmUoc291cmNlKSB7XG4gICAgY29uc3QgeyBzY2FsZSAsIGluZGV4ICwgbGluZSAgfSA9IHNvdXJjZTtcbiAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICBjb25zdCBzZWdtZW50cyA9IGxpbmUuc2VnbWVudHM7XG4gICAgY29uc3Qgc291cmNlUG9pbnRzID0gbGluZS5wb2ludHM7XG4gICAgY29uc3QgbGluZXNCZWxvdyA9IGdldExpbmVzQmVsb3coc2NhbGUsIGluZGV4KTtcbiAgICBsaW5lc0JlbG93LnB1c2goX2NyZWF0ZUJvdW5kYXJ5TGluZSh7XG4gICAgICAgIHg6IG51bGwsXG4gICAgICAgIHk6IHNjYWxlLmJvdHRvbVxuICAgIH0sIGxpbmUpKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgICAgIGZvcihsZXQgaiA9IHNlZ21lbnQuc3RhcnQ7IGogPD0gc2VnbWVudC5lbmQ7IGorKyl7XG4gICAgICAgICAgICBhZGRQb2ludHNCZWxvdyhwb2ludHMsIHNvdXJjZVBvaW50c1tqXSwgbGluZXNCZWxvdyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBMaW5lRWxlbWVudCh7XG4gICAgICAgIHBvaW50cyxcbiAgICAgICAgb3B0aW9uczoge31cbiAgICB9KTtcbn1cbiBmdW5jdGlvbiBnZXRMaW5lc0JlbG93KHNjYWxlLCBpbmRleCkge1xuICAgIGNvbnN0IGJlbG93ID0gW107XG4gICAgY29uc3QgbWV0YXMgPSBzY2FsZS5nZXRNYXRjaGluZ1Zpc2libGVNZXRhcygnbGluZScpO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtZXRhcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBtZXRhc1tpXTtcbiAgICAgICAgaWYgKG1ldGEuaW5kZXggPT09IGluZGV4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1ldGEuaGlkZGVuKSB7XG4gICAgICAgICAgICBiZWxvdy51bnNoaWZ0KG1ldGEuZGF0YXNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJlbG93O1xufVxuIGZ1bmN0aW9uIGFkZFBvaW50c0JlbG93KHBvaW50cywgc291cmNlUG9pbnQsIGxpbmVzQmVsb3cpIHtcbiAgICBjb25zdCBwb3N0cG9uZWQgPSBbXTtcbiAgICBmb3IobGV0IGogPSAwOyBqIDwgbGluZXNCZWxvdy5sZW5ndGg7IGorKyl7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsaW5lc0JlbG93W2pdO1xuICAgICAgICBjb25zdCB7IGZpcnN0ICwgbGFzdCAsIHBvaW50ICB9ID0gZmluZFBvaW50KGxpbmUsIHNvdXJjZVBvaW50LCAneCcpO1xuICAgICAgICBpZiAoIXBvaW50IHx8IGZpcnN0ICYmIGxhc3QpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgcG9zdHBvbmVkLnVuc2hpZnQocG9pbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9pbnRzLnB1c2gocG9pbnQpO1xuICAgICAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRzLnB1c2goLi4ucG9zdHBvbmVkKTtcbn1cbiBmdW5jdGlvbiBmaW5kUG9pbnQobGluZSwgc291cmNlUG9pbnQsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgcG9pbnQgPSBsaW5lLmludGVycG9sYXRlKHNvdXJjZVBvaW50LCBwcm9wZXJ0eSk7XG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBvaW50VmFsdWUgPSBwb2ludFtwcm9wZXJ0eV07XG4gICAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICAgIGNvbnN0IGxpbmVQb2ludHMgPSBsaW5lLnBvaW50cztcbiAgICBsZXQgZmlyc3QgPSBmYWxzZTtcbiAgICBsZXQgbGFzdCA9IGZhbHNlO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICAgICAgY29uc3QgZmlyc3RWYWx1ZSA9IGxpbmVQb2ludHNbc2VnbWVudC5zdGFydF1bcHJvcGVydHldO1xuICAgICAgICBjb25zdCBsYXN0VmFsdWUgPSBsaW5lUG9pbnRzW3NlZ21lbnQuZW5kXVtwcm9wZXJ0eV07XG4gICAgICAgIGlmIChfaXNCZXR3ZWVuKHBvaW50VmFsdWUsIGZpcnN0VmFsdWUsIGxhc3RWYWx1ZSkpIHtcbiAgICAgICAgICAgIGZpcnN0ID0gcG9pbnRWYWx1ZSA9PT0gZmlyc3RWYWx1ZTtcbiAgICAgICAgICAgIGxhc3QgPSBwb2ludFZhbHVlID09PSBsYXN0VmFsdWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBmaXJzdCxcbiAgICAgICAgbGFzdCxcbiAgICAgICAgcG9pbnRcbiAgICB9O1xufVxuXG5jbGFzcyBzaW1wbGVBcmMge1xuICAgIGNvbnN0cnVjdG9yKG9wdHMpe1xuICAgICAgICB0aGlzLnggPSBvcHRzLng7XG4gICAgICAgIHRoaXMueSA9IG9wdHMueTtcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBvcHRzLnJhZGl1cztcbiAgICB9XG4gICAgcGF0aFNlZ21lbnQoY3R4LCBib3VuZHMsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgeyB4ICwgeSAsIHJhZGl1cyAgfSA9IHRoaXM7XG4gICAgICAgIGJvdW5kcyA9IGJvdW5kcyB8fCB7XG4gICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgIGVuZDogVEFVXG4gICAgICAgIH07XG4gICAgICAgIGN0eC5hcmMoeCwgeSwgcmFkaXVzLCBib3VuZHMuZW5kLCBib3VuZHMuc3RhcnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gIW9wdHMuYm91bmRzO1xuICAgIH1cbiAgICBpbnRlcnBvbGF0ZShwb2ludCkge1xuICAgICAgICBjb25zdCB7IHggLCB5ICwgcmFkaXVzICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgYW5nbGUgPSBwb2ludC5hbmdsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICAgICAgICB5OiB5ICsgTWF0aC5zaW4oYW5nbGUpICogcmFkaXVzLFxuICAgICAgICAgICAgYW5nbGVcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIF9nZXRUYXJnZXQoc291cmNlKSB7XG4gICAgY29uc3QgeyBjaGFydCAsIGZpbGwgLCBsaW5lICB9ID0gc291cmNlO1xuICAgIGlmIChpc051bWJlckZpbml0ZShmaWxsKSkge1xuICAgICAgICByZXR1cm4gZ2V0TGluZUJ5SW5kZXgoY2hhcnQsIGZpbGwpO1xuICAgIH1cbiAgICBpZiAoZmlsbCA9PT0gJ3N0YWNrJykge1xuICAgICAgICByZXR1cm4gX2J1aWxkU3RhY2tMaW5lKHNvdXJjZSk7XG4gICAgfVxuICAgIGlmIChmaWxsID09PSAnc2hhcGUnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBib3VuZGFyeSA9IGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpO1xuICAgIGlmIChib3VuZGFyeSBpbnN0YW5jZW9mIHNpbXBsZUFyYykge1xuICAgICAgICByZXR1cm4gYm91bmRhcnk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQm91bmRhcnlMaW5lKGJvdW5kYXJ5LCBsaW5lKTtcbn1cbiBmdW5jdGlvbiBnZXRMaW5lQnlJbmRleChjaGFydCwgaW5kZXgpIHtcbiAgICBjb25zdCBtZXRhID0gY2hhcnQuZ2V0RGF0YXNldE1ldGEoaW5kZXgpO1xuICAgIGNvbnN0IHZpc2libGUgPSBtZXRhICYmIGNoYXJ0LmlzRGF0YXNldFZpc2libGUoaW5kZXgpO1xuICAgIHJldHVybiB2aXNpYmxlID8gbWV0YS5kYXRhc2V0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeShzb3VyY2UpIHtcbiAgICBjb25zdCBzY2FsZSA9IHNvdXJjZS5zY2FsZSB8fCB7fTtcbiAgICBpZiAoc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKSB7XG4gICAgICAgIHJldHVybiBjb21wdXRlQ2lyY3VsYXJCb3VuZGFyeShzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcHV0ZUxpbmVhckJvdW5kYXJ5KHNvdXJjZSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTGluZWFyQm91bmRhcnkoc291cmNlKSB7XG4gICAgY29uc3QgeyBzY2FsZSA9e30gLCBmaWxsICB9ID0gc291cmNlO1xuICAgIGNvbnN0IHBpeGVsID0gX2dldFRhcmdldFBpeGVsKGZpbGwsIHNjYWxlKTtcbiAgICBpZiAoaXNOdW1iZXJGaW5pdGUocGl4ZWwpKSB7XG4gICAgICAgIGNvbnN0IGhvcml6b250YWwgPSBzY2FsZS5pc0hvcml6b250YWwoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IGhvcml6b250YWwgPyBwaXhlbCA6IG51bGwsXG4gICAgICAgICAgICB5OiBob3Jpem9udGFsID8gbnVsbCA6IHBpeGVsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNpcmN1bGFyQm91bmRhcnkoc291cmNlKSB7XG4gICAgY29uc3QgeyBzY2FsZSAsIGZpbGwgIH0gPSBzb3VyY2U7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHNjYWxlLm9wdGlvbnM7XG4gICAgY29uc3QgbGVuZ3RoID0gc2NhbGUuZ2V0TGFiZWxzKCkubGVuZ3RoO1xuICAgIGNvbnN0IHN0YXJ0ID0gb3B0aW9ucy5yZXZlcnNlID8gc2NhbGUubWF4IDogc2NhbGUubWluO1xuICAgIGNvbnN0IHZhbHVlID0gX2dldFRhcmdldFZhbHVlKGZpbGwsIHNjYWxlLCBzdGFydCk7XG4gICAgY29uc3QgdGFyZ2V0ID0gW107XG4gICAgaWYgKG9wdGlvbnMuZ3JpZC5jaXJjdWxhcikge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uRm9yVmFsdWUoMCwgc3RhcnQpO1xuICAgICAgICByZXR1cm4gbmV3IHNpbXBsZUFyYyh7XG4gICAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICAgIHk6IGNlbnRlci55LFxuICAgICAgICAgICAgcmFkaXVzOiBzY2FsZS5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSl7XG4gICAgICAgIHRhcmdldC5wdXNoKHNjYWxlLmdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpLCB2YWx1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBfZHJhd2ZpbGwoY3R4LCBzb3VyY2UsIGFyZWEpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBfZ2V0VGFyZ2V0KHNvdXJjZSk7XG4gICAgY29uc3QgeyBjaGFydCAsIGluZGV4ICwgbGluZSAsIHNjYWxlICwgYXhpcyAgfSA9IHNvdXJjZTtcbiAgICBjb25zdCBsaW5lT3B0cyA9IGxpbmUub3B0aW9ucztcbiAgICBjb25zdCBmaWxsT3B0aW9uID0gbGluZU9wdHMuZmlsbDtcbiAgICBjb25zdCBjb2xvciA9IGxpbmVPcHRzLmJhY2tncm91bmRDb2xvcjtcbiAgICBjb25zdCB7IGFib3ZlID1jb2xvciAsIGJlbG93ID1jb2xvciAgfSA9IGZpbGxPcHRpb24gfHwge307XG4gICAgY29uc3QgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGluZGV4KTtcbiAgICBjb25zdCBjbGlwID0gZ2V0RGF0YXNldENsaXBBcmVhKGNoYXJ0LCBtZXRhKTtcbiAgICBpZiAodGFyZ2V0ICYmIGxpbmUucG9pbnRzLmxlbmd0aCkge1xuICAgICAgICBjbGlwQXJlYShjdHgsIGFyZWEpO1xuICAgICAgICBkb0ZpbGwoY3R4LCB7XG4gICAgICAgICAgICBsaW5lLFxuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgYWJvdmUsXG4gICAgICAgICAgICBiZWxvdyxcbiAgICAgICAgICAgIGFyZWEsXG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgICAgIGF4aXMsXG4gICAgICAgICAgICBjbGlwXG4gICAgICAgIH0pO1xuICAgICAgICB1bmNsaXBBcmVhKGN0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9GaWxsKGN0eCwgY2ZnKSB7XG4gICAgY29uc3QgeyBsaW5lICwgdGFyZ2V0ICwgYWJvdmUgLCBiZWxvdyAsIGFyZWEgLCBzY2FsZSAsIGNsaXAgIH0gPSBjZmc7XG4gICAgY29uc3QgcHJvcGVydHkgPSBsaW5lLl9sb29wID8gJ2FuZ2xlJyA6IGNmZy5heGlzO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgaWYgKHByb3BlcnR5ID09PSAneCcgJiYgYmVsb3cgIT09IGFib3ZlKSB7XG4gICAgICAgIGNsaXBWZXJ0aWNhbChjdHgsIHRhcmdldCwgYXJlYS50b3ApO1xuICAgICAgICBmaWxsKGN0eCwge1xuICAgICAgICAgICAgbGluZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIGNvbG9yOiBhYm92ZSxcbiAgICAgICAgICAgIHNjYWxlLFxuICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICBjbGlwXG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGFyZWEuYm90dG9tKTtcbiAgICB9XG4gICAgZmlsbChjdHgsIHtcbiAgICAgICAgbGluZSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjb2xvcjogYmVsb3csXG4gICAgICAgIHNjYWxlLFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgY2xpcFxuICAgIH0pO1xuICAgIGN0eC5yZXN0b3JlKCk7XG59XG5mdW5jdGlvbiBjbGlwVmVydGljYWwoY3R4LCB0YXJnZXQsIGNsaXBZKSB7XG4gICAgY29uc3QgeyBzZWdtZW50cyAsIHBvaW50cyAgfSA9IHRhcmdldDtcbiAgICBsZXQgZmlyc3QgPSB0cnVlO1xuICAgIGxldCBsaW5lTG9vcCA9IGZhbHNlO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpe1xuICAgICAgICBjb25zdCB7IHN0YXJ0ICwgZW5kICB9ID0gc2VnbWVudDtcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHBvaW50c1tzdGFydF07XG4gICAgICAgIGNvbnN0IGxhc3RQb2ludCA9IHBvaW50c1tfZmluZFNlZ21lbnRFbmQoc3RhcnQsIGVuZCwgcG9pbnRzKV07XG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XG4gICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGNsaXBZKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVMb29wID0gISF0YXJnZXQucGF0aFNlZ21lbnQoY3R4LCBzZWdtZW50LCB7XG4gICAgICAgICAgICBtb3ZlOiBsaW5lTG9vcFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGxpbmVMb29wKSB7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKGxhc3RQb2ludC54LCBjbGlwWSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3R4LmxpbmVUbyh0YXJnZXQuZmlyc3QoKS54LCBjbGlwWSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIGN0eC5jbGlwKCk7XG59XG5mdW5jdGlvbiBmaWxsKGN0eCwgY2ZnKSB7XG4gICAgY29uc3QgeyBsaW5lICwgdGFyZ2V0ICwgcHJvcGVydHkgLCBjb2xvciAsIHNjYWxlICwgY2xpcCAgfSA9IGNmZztcbiAgICBjb25zdCBzZWdtZW50cyA9IF9zZWdtZW50cyhsaW5lLCB0YXJnZXQsIHByb3BlcnR5KTtcbiAgICBmb3IgKGNvbnN0IHsgc291cmNlOiBzcmMgLCB0YXJnZXQ6IHRndCAsIHN0YXJ0ICwgZW5kICB9IG9mIHNlZ21lbnRzKXtcbiAgICAgICAgY29uc3QgeyBzdHlsZTogeyBiYWNrZ3JvdW5kQ29sb3IgPWNvbG9yICB9ID0ge30gIH0gPSBzcmM7XG4gICAgICAgIGNvbnN0IG5vdFNoYXBlID0gdGFyZ2V0ICE9PSB0cnVlO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZENvbG9yO1xuICAgICAgICBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIG5vdFNoYXBlICYmIF9nZXRCb3VuZHMocHJvcGVydHksIHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjb25zdCBsaW5lTG9vcCA9ICEhbGluZS5wYXRoU2VnbWVudChjdHgsIHNyYyk7XG4gICAgICAgIGxldCBsb29wO1xuICAgICAgICBpZiAobm90U2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChsaW5lTG9vcCkge1xuICAgICAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBlbmQsIHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldExvb3AgPSAhIXRhcmdldC5wYXRoU2VnbWVudChjdHgsIHRndCwge1xuICAgICAgICAgICAgICAgIG1vdmU6IGxpbmVMb29wLFxuICAgICAgICAgICAgICAgIHJldmVyc2U6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbG9vcCA9IGxpbmVMb29wICYmIHRhcmdldExvb3A7XG4gICAgICAgICAgICBpZiAoIWxvb3ApIHtcbiAgICAgICAgICAgICAgICBpbnRlcnBvbGF0ZWRMaW5lVG8oY3R4LCB0YXJnZXQsIHN0YXJ0LCBwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICBjdHguZmlsbChsb29wID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGlwQm91bmRzKGN0eCwgc2NhbGUsIGNsaXAsIGJvdW5kcykge1xuICAgIGNvbnN0IGNoYXJ0QXJlYSA9IHNjYWxlLmNoYXJ0LmNoYXJ0QXJlYTtcbiAgICBjb25zdCB7IHByb3BlcnR5ICwgc3RhcnQgLCBlbmQgIH0gPSBib3VuZHMgfHwge307XG4gICAgaWYgKHByb3BlcnR5ID09PSAneCcgfHwgcHJvcGVydHkgPT09ICd5Jykge1xuICAgICAgICBsZXQgbGVmdCwgdG9wLCByaWdodCwgYm90dG9tO1xuICAgICAgICBpZiAocHJvcGVydHkgPT09ICd4Jykge1xuICAgICAgICAgICAgbGVmdCA9IHN0YXJ0O1xuICAgICAgICAgICAgdG9wID0gY2hhcnRBcmVhLnRvcDtcbiAgICAgICAgICAgIHJpZ2h0ID0gZW5kO1xuICAgICAgICAgICAgYm90dG9tID0gY2hhcnRBcmVhLmJvdHRvbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxlZnQgPSBjaGFydEFyZWEubGVmdDtcbiAgICAgICAgICAgIHRvcCA9IHN0YXJ0O1xuICAgICAgICAgICAgcmlnaHQgPSBjaGFydEFyZWEucmlnaHQ7XG4gICAgICAgICAgICBib3R0b20gPSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBpZiAoY2xpcCkge1xuICAgICAgICAgICAgbGVmdCA9IE1hdGgubWF4KGxlZnQsIGNsaXAubGVmdCk7XG4gICAgICAgICAgICByaWdodCA9IE1hdGgubWluKHJpZ2h0LCBjbGlwLnJpZ2h0KTtcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgY2xpcC50b3ApO1xuICAgICAgICAgICAgYm90dG9tID0gTWF0aC5taW4oYm90dG9tLCBjbGlwLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnJlY3QobGVmdCwgdG9wLCByaWdodCAtIGxlZnQsIGJvdHRvbSAtIHRvcCk7XG4gICAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGVkTGluZVRvKGN0eCwgdGFyZ2V0LCBwb2ludCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRQb2ludCA9IHRhcmdldC5pbnRlcnBvbGF0ZShwb2ludCwgcHJvcGVydHkpO1xuICAgIGlmIChpbnRlcnBvbGF0ZWRQb2ludCkge1xuICAgICAgICBjdHgubGluZVRvKGludGVycG9sYXRlZFBvaW50LngsIGludGVycG9sYXRlZFBvaW50LnkpO1xuICAgIH1cbn1cblxudmFyIGluZGV4ID0ge1xuICAgIGlkOiAnZmlsbGVyJyxcbiAgICBhZnRlckRhdGFzZXRzVXBkYXRlIChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgY291bnQgPSAoY2hhcnQuZGF0YS5kYXRhc2V0cyB8fCBbXSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBzb3VyY2VzID0gW107XG4gICAgICAgIGxldCBtZXRhLCBpLCBsaW5lLCBzb3VyY2U7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGNvdW50OyArK2kpe1xuICAgICAgICAgICAgbWV0YSA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGkpO1xuICAgICAgICAgICAgbGluZSA9IG1ldGEuZGF0YXNldDtcbiAgICAgICAgICAgIHNvdXJjZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAobGluZSAmJiBsaW5lLm9wdGlvbnMgJiYgbGluZSBpbnN0YW5jZW9mIExpbmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0ge1xuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlOiBjaGFydC5pc0RhdGFzZXRWaXNpYmxlKGkpLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogX2RlY29kZUZpbGwobGluZSwgaSwgY291bnQpLFxuICAgICAgICAgICAgICAgICAgICBjaGFydCxcbiAgICAgICAgICAgICAgICAgICAgYXhpczogbWV0YS5jb250cm9sbGVyLm9wdGlvbnMuaW5kZXhBeGlzLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZTogbWV0YS52U2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGxpbmVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWV0YS4kZmlsbGVyID0gc291cmNlO1xuICAgICAgICAgICAgc291cmNlcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgY291bnQ7ICsraSl7XG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UgfHwgc291cmNlLmZpbGwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzb3VyY2UuZmlsbCA9IF9yZXNvbHZlVGFyZ2V0KHNvdXJjZXMsIGksIG9wdGlvbnMucHJvcGFnYXRlKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlRHJhdyAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRyYXcgPSBvcHRpb25zLmRyYXdUaW1lID09PSAnYmVmb3JlRHJhdyc7XG4gICAgICAgIGNvbnN0IG1ldGFzZXRzID0gY2hhcnQuZ2V0U29ydGVkVmlzaWJsZURhdGFzZXRNZXRhcygpO1xuICAgICAgICBjb25zdCBhcmVhID0gY2hhcnQuY2hhcnRBcmVhO1xuICAgICAgICBmb3IobGV0IGkgPSBtZXRhc2V0cy5sZW5ndGggLSAxOyBpID49IDA7IC0taSl7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXRhc2V0c1tpXS4kZmlsbGVyO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvdXJjZS5saW5lLnVwZGF0ZUNvbnRyb2xQb2ludHMoYXJlYSwgc291cmNlLmF4aXMpO1xuICAgICAgICAgICAgaWYgKGRyYXcgJiYgc291cmNlLmZpbGwpIHtcbiAgICAgICAgICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGFyZWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVEYXRhc2V0c0RyYXcgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXRzRHJhdycpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhc2V0cyA9IGNoYXJ0LmdldFNvcnRlZFZpc2libGVEYXRhc2V0TWV0YXMoKTtcbiAgICAgICAgZm9yKGxldCBpID0gbWV0YXNldHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpe1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gbWV0YXNldHNbaV0uJGZpbGxlcjtcbiAgICAgICAgICAgIGlmIChfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBfZHJhd2ZpbGwoY2hhcnQuY3R4LCBzb3VyY2UsIGNoYXJ0LmNoYXJ0QXJlYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZURhdGFzZXREcmF3IChjaGFydCwgYXJncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBhcmdzLm1ldGEuJGZpbGxlcjtcbiAgICAgICAgaWYgKCFfc2hvdWxkQXBwbHlGaWxsKHNvdXJjZSkgfHwgb3B0aW9ucy5kcmF3VGltZSAhPT0gJ2JlZm9yZURhdGFzZXREcmF3Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIF9kcmF3ZmlsbChjaGFydC5jdHgsIHNvdXJjZSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICB9LFxuICAgIGRlZmF1bHRzOiB7XG4gICAgICAgIHByb3BhZ2F0ZTogdHJ1ZSxcbiAgICAgICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0RHJhdydcbiAgICB9XG59O1xuXG5jb25zdCBnZXRCb3hTaXplID0gKGxhYmVsT3B0cywgZm9udFNpemUpPT57XG4gICAgbGV0IHsgYm94SGVpZ2h0ID1mb250U2l6ZSAsIGJveFdpZHRoID1mb250U2l6ZSAgfSA9IGxhYmVsT3B0cztcbiAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgYm94SGVpZ2h0ID0gTWF0aC5taW4oYm94SGVpZ2h0LCBmb250U2l6ZSk7XG4gICAgICAgIGJveFdpZHRoID0gbGFiZWxPcHRzLnBvaW50U3R5bGVXaWR0aCB8fCBNYXRoLm1pbihib3hXaWR0aCwgZm9udFNpemUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBib3hXaWR0aCxcbiAgICAgICAgYm94SGVpZ2h0LFxuICAgICAgICBpdGVtSGVpZ2h0OiBNYXRoLm1heChmb250U2l6ZSwgYm94SGVpZ2h0KVxuICAgIH07XG59O1xuY29uc3QgaXRlbXNFcXVhbCA9IChhLCBiKT0+YSAhPT0gbnVsbCAmJiBiICE9PSBudWxsICYmIGEuZGF0YXNldEluZGV4ID09PSBiLmRhdGFzZXRJbmRleCAmJiBhLmluZGV4ID09PSBiLmluZGV4O1xuY2xhc3MgTGVnZW5kIGV4dGVuZHMgRWxlbWVudCB7XG4gY29uc3RydWN0b3IoY29uZmlnKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5fYWRkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuIHRoaXMuX2hvdmVyZWRJdGVtID0gbnVsbDtcbiAgICAgICAgdGhpcy5kb3VnaG51dE1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuY3R4ID0gY29uZmlnLmN0eDtcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jb2x1bW5TaXplcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5saW5lV2lkdGhzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm1heEhlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50b3AgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYm90dG9tID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxlZnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndpZHRoID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9tYXJnaW5zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLndlaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5mdWxsU2l6ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdXBkYXRlKG1heFdpZHRoLCBtYXhIZWlnaHQsIG1hcmdpbnMpIHtcbiAgICAgICAgdGhpcy5tYXhXaWR0aCA9IG1heFdpZHRoO1xuICAgICAgICB0aGlzLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICAgICAgdGhpcy5fbWFyZ2lucyA9IG1hcmdpbnM7XG4gICAgICAgIHRoaXMuc2V0RGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLmJ1aWxkTGFiZWxzKCk7XG4gICAgICAgIHRoaXMuZml0KCk7XG4gICAgfVxuICAgIHNldERpbWVuc2lvbnMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IHRoaXMuX21hcmdpbnMubGVmdDtcbiAgICAgICAgICAgIHRoaXMucmlnaHQgPSB0aGlzLndpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm1heEhlaWdodDtcbiAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy5fbWFyZ2lucy50b3A7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IHRoaXMuaGVpZ2h0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkTGFiZWxzKCkge1xuICAgICAgICBjb25zdCBsYWJlbE9wdHMgPSB0aGlzLm9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICAgICAgICBsZXQgbGVnZW5kSXRlbXMgPSBjYWxsYmFjayhsYWJlbE9wdHMuZ2VuZXJhdGVMYWJlbHMsIFtcbiAgICAgICAgICAgIHRoaXMuY2hhcnRcbiAgICAgICAgXSwgdGhpcykgfHwgW107XG4gICAgICAgIGlmIChsYWJlbE9wdHMuZmlsdGVyKSB7XG4gICAgICAgICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLmZpbHRlcigoaXRlbSk9PmxhYmVsT3B0cy5maWx0ZXIoaXRlbSwgdGhpcy5jaGFydC5kYXRhKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhYmVsT3B0cy5zb3J0KSB7XG4gICAgICAgICAgICBsZWdlbmRJdGVtcyA9IGxlZ2VuZEl0ZW1zLnNvcnQoKGEsIGIpPT5sYWJlbE9wdHMuc29ydChhLCBiLCB0aGlzLmNoYXJ0LmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2UpIHtcbiAgICAgICAgICAgIGxlZ2VuZEl0ZW1zLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1zID0gbGVnZW5kSXRlbXM7XG4gICAgfVxuICAgIGZpdCgpIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zICwgY3R4ICB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFvcHRpb25zLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWxPcHRzID0gb3B0aW9ucy5sYWJlbHM7XG4gICAgICAgIGNvbnN0IGxhYmVsRm9udCA9IHRvRm9udChsYWJlbE9wdHMuZm9udCk7XG4gICAgICAgIGNvbnN0IGZvbnRTaXplID0gbGFiZWxGb250LnNpemU7XG4gICAgICAgIGNvbnN0IHRpdGxlSGVpZ2h0ID0gdGhpcy5fY29tcHV0ZVRpdGxlSGVpZ2h0KCk7XG4gICAgICAgIGNvbnN0IHsgYm94V2lkdGggLCBpdGVtSGVpZ2h0ICB9ID0gZ2V0Qm94U2l6ZShsYWJlbE9wdHMsIGZvbnRTaXplKTtcbiAgICAgICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgICAgIGN0eC5mb250ID0gbGFiZWxGb250LnN0cmluZztcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIHdpZHRoID0gdGhpcy5tYXhXaWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkgKyAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMubWF4SGVpZ2h0O1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBpdGVtSGVpZ2h0KSArIDEwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSBNYXRoLm1pbih3aWR0aCwgb3B0aW9ucy5tYXhXaWR0aCB8fCB0aGlzLm1heFdpZHRoKTtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLm1pbihoZWlnaHQsIG9wdGlvbnMubWF4SGVpZ2h0IHx8IHRoaXMubWF4SGVpZ2h0KTtcbiAgICB9XG4gX2ZpdFJvd3ModGl0bGVIZWlnaHQsIGZvbnRTaXplLCBib3hXaWR0aCwgaXRlbUhlaWdodCkge1xuICAgICAgICBjb25zdCB7IGN0eCAsIG1heFdpZHRoICwgb3B0aW9uczogeyBsYWJlbHM6IHsgcGFkZGluZyAgfSAgfSAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGhpdGJveGVzID0gdGhpcy5sZWdlbmRIaXRCb3hlcyA9IFtdO1xuICAgICAgICBjb25zdCBsaW5lV2lkdGhzID0gdGhpcy5saW5lV2lkdGhzID0gW1xuICAgICAgICAgICAgMFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIGxldCB0b3RhbEhlaWdodCA9IHRpdGxlSGVpZ2h0O1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2xlZnQnO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGxldCByb3cgPSAtMTtcbiAgICAgICAgbGV0IHRvcCA9IC1saW5lSGVpZ2h0O1xuICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1zLmZvckVhY2goKGxlZ2VuZEl0ZW0sIGkpPT57XG4gICAgICAgICAgICBjb25zdCBpdGVtV2lkdGggPSBib3hXaWR0aCArIGZvbnRTaXplIC8gMiArIGN0eC5tZWFzdXJlVGV4dChsZWdlbmRJdGVtLnRleHQpLndpZHRoO1xuICAgICAgICAgICAgaWYgKGkgPT09IDAgfHwgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICsgaXRlbVdpZHRoICsgMiAqIHBhZGRpbmcgPiBtYXhXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRvdGFsSGVpZ2h0ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIChpID4gMCA/IDAgOiAxKV0gPSAwO1xuICAgICAgICAgICAgICAgIHRvcCArPSBsaW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIHJvdysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGl0Ym94ZXNbaV0gPSB7XG4gICAgICAgICAgICAgICAgbGVmdDogMCxcbiAgICAgICAgICAgICAgICB0b3AsXG4gICAgICAgICAgICAgICAgcm93LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpdGVtV2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBpdGVtSGVpZ2h0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGluZVdpZHRoc1tsaW5lV2lkdGhzLmxlbmd0aCAtIDFdICs9IGl0ZW1XaWR0aCArIHBhZGRpbmc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdG90YWxIZWlnaHQ7XG4gICAgfVxuICAgIF9maXRDb2xzKHRpdGxlSGVpZ2h0LCBsYWJlbEZvbnQsIGJveFdpZHRoLCBfaXRlbUhlaWdodCkge1xuICAgICAgICBjb25zdCB7IGN0eCAsIG1heEhlaWdodCAsIG9wdGlvbnM6IHsgbGFiZWxzOiB7IHBhZGRpbmcgIH0gIH0gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBoaXRib3hlcyA9IHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBbXTtcbiAgICAgICAgY29uc3QgY29sdW1uU2l6ZXMgPSB0aGlzLmNvbHVtblNpemVzID0gW107XG4gICAgICAgIGNvbnN0IGhlaWdodExpbWl0ID0gbWF4SGVpZ2h0IC0gdGl0bGVIZWlnaHQ7XG4gICAgICAgIGxldCB0b3RhbFdpZHRoID0gcGFkZGluZztcbiAgICAgICAgbGV0IGN1cnJlbnRDb2xXaWR0aCA9IDA7XG4gICAgICAgIGxldCBjdXJyZW50Q29sSGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGxlZnQgPSAwO1xuICAgICAgICBsZXQgY29sID0gMDtcbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtcy5mb3JFYWNoKChsZWdlbmRJdGVtLCBpKT0+e1xuICAgICAgICAgICAgY29uc3QgeyBpdGVtV2lkdGggLCBpdGVtSGVpZ2h0ICB9ID0gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCk7XG4gICAgICAgICAgICBpZiAoaSA+IDAgJiYgY3VycmVudENvbEhlaWdodCArIGl0ZW1IZWlnaHQgKyAyICogcGFkZGluZyA+IGhlaWdodExpbWl0KSB7XG4gICAgICAgICAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGggKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgIGNvbHVtblNpemVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogY3VycmVudENvbFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGN1cnJlbnRDb2xIZWlnaHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZWZ0ICs9IGN1cnJlbnRDb2xXaWR0aCArIHBhZGRpbmc7XG4gICAgICAgICAgICAgICAgY29sKys7XG4gICAgICAgICAgICAgICAgY3VycmVudENvbFdpZHRoID0gY3VycmVudENvbEhlaWdodCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaXRib3hlc1tpXSA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0LFxuICAgICAgICAgICAgICAgIHRvcDogY3VycmVudENvbEhlaWdodCxcbiAgICAgICAgICAgICAgICBjb2wsXG4gICAgICAgICAgICAgICAgd2lkdGg6IGl0ZW1XaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGl0ZW1IZWlnaHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjdXJyZW50Q29sV2lkdGggPSBNYXRoLm1heChjdXJyZW50Q29sV2lkdGgsIGl0ZW1XaWR0aCk7XG4gICAgICAgICAgICBjdXJyZW50Q29sSGVpZ2h0ICs9IGl0ZW1IZWlnaHQgKyBwYWRkaW5nO1xuICAgICAgICB9KTtcbiAgICAgICAgdG90YWxXaWR0aCArPSBjdXJyZW50Q29sV2lkdGg7XG4gICAgICAgIGNvbHVtblNpemVzLnB1c2goe1xuICAgICAgICAgICAgd2lkdGg6IGN1cnJlbnRDb2xXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY3VycmVudENvbEhlaWdodFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRvdGFsV2lkdGg7XG4gICAgfVxuICAgIGFkanVzdEhpdEJveGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICAgICAgY29uc3QgeyBsZWdlbmRIaXRCb3hlczogaGl0Ym94ZXMgLCBvcHRpb25zOiB7IGFsaWduICwgbGFiZWxzOiB7IHBhZGRpbmcgIH0gLCBydGwgIH0gIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKHJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNIb3Jpem9udGFsKCkpIHtcbiAgICAgICAgICAgIGxldCByb3cgPSAwO1xuICAgICAgICAgICAgbGV0IGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKXtcbiAgICAgICAgICAgICAgICBpZiAocm93ICE9PSBoaXRib3gucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdyA9IGhpdGJveC5yb3c7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdGhpcy5sZWZ0ICsgcGFkZGluZywgdGhpcy5yaWdodCAtIHRoaXMubGluZVdpZHRoc1tyb3ddKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGl0Ym94LnRvcCArPSB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgICAgICAgICBoaXRib3gubGVmdCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54KGxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICAgICAgICAgIGxlZnQgKz0gaGl0Ym94LndpZHRoICsgcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb2wgPSAwO1xuICAgICAgICAgICAgbGV0IHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGl0Ym94IG9mIGhpdGJveGVzKXtcbiAgICAgICAgICAgICAgICBpZiAoaGl0Ym94LmNvbCAhPT0gY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbCA9IGhpdGJveC5jb2w7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSB0aGlzLmNvbHVtblNpemVzW2NvbF0uaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaGl0Ym94LnRvcCA9IHRvcDtcbiAgICAgICAgICAgICAgICBoaXRib3gubGVmdCArPSB0aGlzLmxlZnQgKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgIGhpdGJveC5sZWZ0ID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsSGVscGVyLngoaGl0Ym94LmxlZnQpLCBoaXRib3gud2lkdGgpO1xuICAgICAgICAgICAgICAgIHRvcCArPSBoaXRib3guaGVpZ2h0ICsgcGFkZGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMucG9zaXRpb24gPT09ICd0b3AnIHx8IHRoaXMub3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIGRyYXcoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzcGxheSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgICAgICBjbGlwQXJlYShjdHgsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5fZHJhdygpO1xuICAgICAgICAgICAgdW5jbGlwQXJlYShjdHgpO1xuICAgICAgICB9XG4gICAgfVxuIF9kcmF3KCkge1xuICAgICAgICBjb25zdCB7IG9wdGlvbnM6IG9wdHMgLCBjb2x1bW5TaXplcyAsIGxpbmVXaWR0aHMgLCBjdHggIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGFsaWduICwgbGFiZWxzOiBsYWJlbE9wdHMgIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBkZWZhdWx0Q29sb3IgPSBkZWZhdWx0cy5jb2xvcjtcbiAgICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRzLnJ0bCwgdGhpcy5sZWZ0LCB0aGlzLndpZHRoKTtcbiAgICAgICAgY29uc3QgbGFiZWxGb250ID0gdG9Gb250KGxhYmVsT3B0cy5mb250KTtcbiAgICAgICAgY29uc3QgeyBwYWRkaW5nICB9ID0gbGFiZWxPcHRzO1xuICAgICAgICBjb25zdCBmb250U2l6ZSA9IGxhYmVsRm9udC5zaXplO1xuICAgICAgICBjb25zdCBoYWxmRm9udFNpemUgPSBmb250U2l6ZSAvIDI7XG4gICAgICAgIGxldCBjdXJzb3I7XG4gICAgICAgIHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKCdsZWZ0Jyk7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNTtcbiAgICAgICAgY3R4LmZvbnQgPSBsYWJlbEZvbnQuc3RyaW5nO1xuICAgICAgICBjb25zdCB7IGJveFdpZHRoICwgYm94SGVpZ2h0ICwgaXRlbUhlaWdodCAgfSA9IGdldEJveFNpemUobGFiZWxPcHRzLCBmb250U2l6ZSk7XG4gICAgICAgIGNvbnN0IGRyYXdMZWdlbmRCb3ggPSBmdW5jdGlvbih4LCB5LCBsZWdlbmRJdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXNOYU4oYm94V2lkdGgpIHx8IGJveFdpZHRoIDw9IDAgfHwgaXNOYU4oYm94SGVpZ2h0KSB8fCBib3hIZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVXaWR0aCA9IHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZVdpZHRoLCAxKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmZpbGxTdHlsZSwgZGVmYXVsdENvbG9yKTtcbiAgICAgICAgICAgIGN0eC5saW5lQ2FwID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lQ2FwLCAnYnV0dCcpO1xuICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gdmFsdWVPckRlZmF1bHQobGVnZW5kSXRlbS5saW5lRGFzaE9mZnNldCwgMCk7XG4gICAgICAgICAgICBjdHgubGluZUpvaW4gPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLmxpbmVKb2luLCAnbWl0ZXInKTtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChsZWdlbmRJdGVtLnN0cm9rZVN0eWxlLCBkZWZhdWx0Q29sb3IpO1xuICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKHZhbHVlT3JEZWZhdWx0KGxlZ2VuZEl0ZW0ubGluZURhc2gsIFtdKSk7XG4gICAgICAgICAgICBpZiAobGFiZWxPcHRzLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcmF3T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBib3hIZWlnaHQgKiBNYXRoLlNRUlQyIC8gMixcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogbGVnZW5kSXRlbS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgICAgICByb3RhdGlvbjogbGVnZW5kSXRlbS5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IGxpbmVXaWR0aFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHJ0bEhlbHBlci54UGx1cyh4LCBib3hXaWR0aCAvIDIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSB5ICsgaGFsZkZvbnRTaXplO1xuICAgICAgICAgICAgICAgIGRyYXdQb2ludExlZ2VuZChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZLCBsYWJlbE9wdHMucG9pbnRTdHlsZVdpZHRoICYmIGJveFdpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeUJveFRvcCA9IHkgKyBNYXRoLm1heCgoZm9udFNpemUgLSBib3hIZWlnaHQpIC8gMiwgMCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeEJveExlZnQgPSBydGxIZWxwZXIubGVmdEZvckx0cih4LCBib3hXaWR0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsZWdlbmRJdGVtLmJvcmRlclJhZGl1cyk7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QudmFsdWVzKGJvcmRlclJhZGl1cykuc29tZSgodik9PnYgIT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHhCb3hMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeUJveFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHc6IGJveFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaDogYm94SGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnJlY3QoeEJveExlZnQsIHlCb3hUb3AsIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lV2lkdGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpbGxUZXh0ID0gZnVuY3Rpb24oeCwgeSwgbGVnZW5kSXRlbSkge1xuICAgICAgICAgICAgcmVuZGVyVGV4dChjdHgsIGxlZ2VuZEl0ZW0udGV4dCwgeCwgeSArIGl0ZW1IZWlnaHQgLyAyLCBsYWJlbEZvbnQsIHtcbiAgICAgICAgICAgICAgICBzdHJpa2V0aHJvdWdoOiBsZWdlbmRJdGVtLmhpZGRlbixcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246IHJ0bEhlbHBlci50ZXh0QWxpZ24obGVnZW5kSXRlbS50ZXh0QWxpZ24pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaXNIb3Jpem9udGFsID0gdGhpcy5pc0hvcml6b250YWwoKTtcbiAgICAgICAgY29uc3QgdGl0bGVIZWlnaHQgPSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKTtcbiAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgICAgIHg6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1swXSksXG4gICAgICAgICAgICAgICAgeTogdGhpcy50b3AgKyBwYWRkaW5nICsgdGl0bGVIZWlnaHQsXG4gICAgICAgICAgICAgICAgbGluZTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgICB4OiB0aGlzLmxlZnQgKyBwYWRkaW5nLFxuICAgICAgICAgICAgICAgIHk6IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLnRvcCArIHRpdGxlSGVpZ2h0ICsgcGFkZGluZywgdGhpcy5ib3R0b20gLSBjb2x1bW5TaXplc1swXS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIGxpbmU6IDBcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3ZlcnJpZGVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gaXRlbUhlaWdodCArIHBhZGRpbmc7XG4gICAgICAgIHRoaXMubGVnZW5kSXRlbXMuZm9yRWFjaCgobGVnZW5kSXRlbSwgaSk9PntcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxlZ2VuZEl0ZW0uZm9udENvbG9yO1xuICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGxlZ2VuZEl0ZW0udGV4dCkud2lkdGg7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QWxpZ24gPSBydGxIZWxwZXIudGV4dEFsaWduKGxlZ2VuZEl0ZW0udGV4dEFsaWduIHx8IChsZWdlbmRJdGVtLnRleHRBbGlnbiA9IGxhYmVsT3B0cy50ZXh0QWxpZ24pKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gYm94V2lkdGggKyBoYWxmRm9udFNpemUgKyB0ZXh0V2lkdGg7XG4gICAgICAgICAgICBsZXQgeCA9IGN1cnNvci54O1xuICAgICAgICAgICAgbGV0IHkgPSBjdXJzb3IueTtcbiAgICAgICAgICAgIHJ0bEhlbHBlci5zZXRXaWR0aCh0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA+IDAgJiYgeCArIHdpZHRoICsgcGFkZGluZyA+IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGN1cnNvci55ICs9IGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjdXJzb3IueCA9IF9hbGlnblN0YXJ0RW5kKGFsaWduLCB0aGlzLmxlZnQgKyBwYWRkaW5nLCB0aGlzLnJpZ2h0IC0gbGluZVdpZHRoc1tjdXJzb3IubGluZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA+IDAgJiYgeSArIGxpbmVIZWlnaHQgPiB0aGlzLmJvdHRvbSkge1xuICAgICAgICAgICAgICAgIHggPSBjdXJzb3IueCA9IHggKyBjb2x1bW5TaXplc1tjdXJzb3IubGluZV0ud2lkdGggKyBwYWRkaW5nO1xuICAgICAgICAgICAgICAgIGN1cnNvci5saW5lKys7XG4gICAgICAgICAgICAgICAgeSA9IGN1cnNvci55ID0gX2FsaWduU3RhcnRFbmQoYWxpZ24sIHRoaXMudG9wICsgdGl0bGVIZWlnaHQgKyBwYWRkaW5nLCB0aGlzLmJvdHRvbSAtIGNvbHVtblNpemVzW2N1cnNvci5saW5lXS5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVhbFggPSBydGxIZWxwZXIueCh4KTtcbiAgICAgICAgICAgIGRyYXdMZWdlbmRCb3gocmVhbFgsIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgICAgICAgeCA9IF90ZXh0WCh0ZXh0QWxpZ24sIHggKyBib3hXaWR0aCArIGhhbGZGb250U2l6ZSwgaXNIb3Jpem9udGFsID8geCArIHdpZHRoIDogdGhpcy5yaWdodCwgb3B0cy5ydGwpO1xuICAgICAgICAgICAgZmlsbFRleHQocnRsSGVscGVyLngoeCksIHksIGxlZ2VuZEl0ZW0pO1xuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgICAgIGN1cnNvci54ICs9IHdpZHRoICsgcGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxlZ2VuZEl0ZW0udGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb250TGluZUhlaWdodCA9IGxhYmVsRm9udC5saW5lSGVpZ2h0O1xuICAgICAgICAgICAgICAgIGN1cnNvci55ICs9IGNhbGN1bGF0ZUxlZ2VuZEl0ZW1IZWlnaHQobGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpICsgcGFkZGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnkgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3RvcmVUZXh0RGlyZWN0aW9uKHRoaXMuY3R4LCBvcHRzLnRleHREaXJlY3Rpb24pO1xuICAgIH1cbiBkcmF3VGl0bGUoKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHRpdGxlT3B0cyA9IG9wdHMudGl0bGU7XG4gICAgICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgICAgIGlmICghdGl0bGVPcHRzLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydGxIZWxwZXIgPSBnZXRSdGxBZGFwdGVyKG9wdHMucnRsLCB0aGlzLmxlZnQsIHRoaXMud2lkdGgpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aXRsZU9wdHMucG9zaXRpb247XG4gICAgICAgIGNvbnN0IGhhbGZGb250U2l6ZSA9IHRpdGxlRm9udC5zaXplIC8gMjtcbiAgICAgICAgY29uc3QgdG9wUGFkZGluZ1BsdXNIYWxmRm9udFNpemUgPSB0aXRsZVBhZGRpbmcudG9wICsgaGFsZkZvbnRTaXplO1xuICAgICAgICBsZXQgeTtcbiAgICAgICAgbGV0IGxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIGxldCBtYXhXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KC4uLnRoaXMubGluZVdpZHRocyk7XG4gICAgICAgICAgICB5ID0gdGhpcy50b3AgKyB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZTtcbiAgICAgICAgICAgIGxlZnQgPSBfYWxpZ25TdGFydEVuZChvcHRzLmFsaWduLCBsZWZ0LCB0aGlzLnJpZ2h0IC0gbWF4V2lkdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gdGhpcy5jb2x1bW5TaXplcy5yZWR1Y2UoKGFjYywgc2l6ZSk9Pk1hdGgubWF4KGFjYywgc2l6ZS5oZWlnaHQpLCAwKTtcbiAgICAgICAgICAgIHkgPSB0b3BQYWRkaW5nUGx1c0hhbGZGb250U2l6ZSArIF9hbGlnblN0YXJ0RW5kKG9wdHMuYWxpZ24sIHRoaXMudG9wLCB0aGlzLmJvdHRvbSAtIG1heEhlaWdodCAtIG9wdHMubGFiZWxzLnBhZGRpbmcgLSB0aGlzLl9jb21wdXRlVGl0bGVIZWlnaHQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeCA9IF9hbGlnblN0YXJ0RW5kKHBvc2l0aW9uLCBsZWZ0LCBsZWZ0ICsgbWF4V2lkdGgpO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihfdG9MZWZ0UmlnaHRDZW50ZXIocG9zaXRpb24pKTtcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aXRsZU9wdHMuY29sb3I7XG4gICAgICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICAgICAgcmVuZGVyVGV4dChjdHgsIHRpdGxlT3B0cy50ZXh0LCB4LCB5LCB0aXRsZUZvbnQpO1xuICAgIH1cbiBfY29tcHV0ZVRpdGxlSGVpZ2h0KCkge1xuICAgICAgICBjb25zdCB0aXRsZU9wdHMgPSB0aGlzLm9wdGlvbnMudGl0bGU7XG4gICAgICAgIGNvbnN0IHRpdGxlRm9udCA9IHRvRm9udCh0aXRsZU9wdHMuZm9udCk7XG4gICAgICAgIGNvbnN0IHRpdGxlUGFkZGluZyA9IHRvUGFkZGluZyh0aXRsZU9wdHMucGFkZGluZyk7XG4gICAgICAgIHJldHVybiB0aXRsZU9wdHMuZGlzcGxheSA/IHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgdGl0bGVQYWRkaW5nLmhlaWdodCA6IDA7XG4gICAgfVxuIF9nZXRMZWdlbmRJdGVtQXQoeCwgeSkge1xuICAgICAgICBsZXQgaSwgaGl0Qm94LCBsaDtcbiAgICAgICAgaWYgKF9pc0JldHdlZW4oeCwgdGhpcy5sZWZ0LCB0aGlzLnJpZ2h0KSAmJiBfaXNCZXR3ZWVuKHksIHRoaXMudG9wLCB0aGlzLmJvdHRvbSkpIHtcbiAgICAgICAgICAgIGxoID0gdGhpcy5sZWdlbmRIaXRCb3hlcztcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGxoLmxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICBoaXRCb3ggPSBsaFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoX2lzQmV0d2Vlbih4LCBoaXRCb3gubGVmdCwgaGl0Qm94LmxlZnQgKyBoaXRCb3gud2lkdGgpICYmIF9pc0JldHdlZW4oeSwgaGl0Qm94LnRvcCwgaGl0Qm94LnRvcCArIGhpdEJveC5oZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZ2VuZEl0ZW1zW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gaGFuZGxlRXZlbnQoZSkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoIWlzTGlzdGVuZWQoZS50eXBlLCBvcHRzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gdGhpcy5fZ2V0TGVnZW5kSXRlbUF0KGUueCwgZS55KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PT0gJ21vdXNlbW92ZScgfHwgZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91cyA9IHRoaXMuX2hvdmVyZWRJdGVtO1xuICAgICAgICAgICAgY29uc3Qgc2FtZUl0ZW0gPSBpdGVtc0VxdWFsKHByZXZpb3VzLCBob3ZlcmVkSXRlbSk7XG4gICAgICAgICAgICBpZiAocHJldmlvdXMgJiYgIXNhbWVJdGVtKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sob3B0cy5vbkxlYXZlLCBbXG4gICAgICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLFxuICAgICAgICAgICAgICAgICAgICB0aGlzXG4gICAgICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9ob3ZlcmVkSXRlbSA9IGhvdmVyZWRJdGVtO1xuICAgICAgICAgICAgaWYgKGhvdmVyZWRJdGVtICYmICFzYW1lSXRlbSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG9wdHMub25Ib3ZlciwgW1xuICAgICAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgICAgICBob3ZlcmVkSXRlbSxcbiAgICAgICAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhvcHRzLm9uQ2xpY2ssIFtcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgIGhvdmVyZWRJdGVtLFxuICAgICAgICAgICAgICAgIHRoaXNcbiAgICAgICAgICAgIF0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbVNpemUoYm94V2lkdGgsIGxhYmVsRm9udCwgY3R4LCBsZWdlbmRJdGVtLCBfaXRlbUhlaWdodCkge1xuICAgIGNvbnN0IGl0ZW1XaWR0aCA9IGNhbGN1bGF0ZUl0ZW1XaWR0aChsZWdlbmRJdGVtLCBib3hXaWR0aCwgbGFiZWxGb250LCBjdHgpO1xuICAgIGNvbnN0IGl0ZW1IZWlnaHQgPSBjYWxjdWxhdGVJdGVtSGVpZ2h0KF9pdGVtSGVpZ2h0LCBsZWdlbmRJdGVtLCBsYWJlbEZvbnQubGluZUhlaWdodCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbVdpZHRoLFxuICAgICAgICBpdGVtSGVpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUl0ZW1XaWR0aChsZWdlbmRJdGVtLCBib3hXaWR0aCwgbGFiZWxGb250LCBjdHgpIHtcbiAgICBsZXQgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtLnRleHQ7XG4gICAgaWYgKGxlZ2VuZEl0ZW1UZXh0ICYmIHR5cGVvZiBsZWdlbmRJdGVtVGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGVnZW5kSXRlbVRleHQgPSBsZWdlbmRJdGVtVGV4dC5yZWR1Y2UoKGEsIGIpPT5hLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGIpO1xuICAgIH1cbiAgICByZXR1cm4gYm94V2lkdGggKyBsYWJlbEZvbnQuc2l6ZSAvIDIgKyBjdHgubWVhc3VyZVRleHQobGVnZW5kSXRlbVRleHQpLndpZHRoO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlSXRlbUhlaWdodChfaXRlbUhlaWdodCwgbGVnZW5kSXRlbSwgZm9udExpbmVIZWlnaHQpIHtcbiAgICBsZXQgaXRlbUhlaWdodCA9IF9pdGVtSGVpZ2h0O1xuICAgIGlmICh0eXBlb2YgbGVnZW5kSXRlbS50ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICBpdGVtSGVpZ2h0ID0gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiBpdGVtSGVpZ2h0O1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTGVnZW5kSXRlbUhlaWdodChsZWdlbmRJdGVtLCBmb250TGluZUhlaWdodCkge1xuICAgIGNvbnN0IGxhYmVsSGVpZ2h0ID0gbGVnZW5kSXRlbS50ZXh0ID8gbGVnZW5kSXRlbS50ZXh0Lmxlbmd0aCA6IDA7XG4gICAgcmV0dXJuIGZvbnRMaW5lSGVpZ2h0ICogbGFiZWxIZWlnaHQ7XG59XG5mdW5jdGlvbiBpc0xpc3RlbmVkKHR5cGUsIG9wdHMpIHtcbiAgICBpZiAoKHR5cGUgPT09ICdtb3VzZW1vdmUnIHx8IHR5cGUgPT09ICdtb3VzZW91dCcpICYmIChvcHRzLm9uSG92ZXIgfHwgb3B0cy5vbkxlYXZlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMub25DbGljayAmJiAodHlwZSA9PT0gJ2NsaWNrJyB8fCB0eXBlID09PSAnbW91c2V1cCcpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG52YXIgcGx1Z2luX2xlZ2VuZCA9IHtcbiAgICBpZDogJ2xlZ2VuZCcsXG4gX2VsZW1lbnQ6IExlZ2VuZCxcbiAgICBzdGFydCAoY2hhcnQsIF9hcmdzLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZCA9IG5ldyBMZWdlbmQoe1xuICAgICAgICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY2hhcnRcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCBsZWdlbmQsIG9wdGlvbnMpO1xuICAgICAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgbGVnZW5kKTtcbiAgICB9LFxuICAgIHN0b3AgKGNoYXJ0KSB7XG4gICAgICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBjaGFydC5sZWdlbmQpO1xuICAgICAgICBkZWxldGUgY2hhcnQubGVnZW5kO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlIChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGVnZW5kID0gY2hhcnQubGVnZW5kO1xuICAgICAgICBsYXlvdXRzLmNvbmZpZ3VyZShjaGFydCwgbGVnZW5kLCBvcHRpb25zKTtcbiAgICAgICAgbGVnZW5kLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH0sXG4gICAgYWZ0ZXJVcGRhdGUgKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IGxlZ2VuZCA9IGNoYXJ0LmxlZ2VuZDtcbiAgICAgICAgbGVnZW5kLmJ1aWxkTGFiZWxzKCk7XG4gICAgICAgIGxlZ2VuZC5hZGp1c3RIaXRCb3hlcygpO1xuICAgIH0sXG4gICAgYWZ0ZXJFdmVudCAoY2hhcnQsIGFyZ3MpIHtcbiAgICAgICAgaWYgKCFhcmdzLnJlcGxheSkge1xuICAgICAgICAgICAgY2hhcnQubGVnZW5kLmhhbmRsZUV2ZW50KGFyZ3MuZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgICAgIGFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgZnVsbFNpemU6IHRydWUsXG4gICAgICAgIHJldmVyc2U6IGZhbHNlLFxuICAgICAgICB3ZWlnaHQ6IDEwMDAsXG4gICAgICAgIG9uQ2xpY2sgKGUsIGxlZ2VuZEl0ZW0sIGxlZ2VuZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBsZWdlbmRJdGVtLmRhdGFzZXRJbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGNpID0gbGVnZW5kLmNoYXJ0O1xuICAgICAgICAgICAgaWYgKGNpLmlzRGF0YXNldFZpc2libGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgY2kuaGlkZShpbmRleCk7XG4gICAgICAgICAgICAgICAgbGVnZW5kSXRlbS5oaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaS5zaG93KGluZGV4KTtcbiAgICAgICAgICAgICAgICBsZWdlbmRJdGVtLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvbkhvdmVyOiBudWxsLFxuICAgICAgICBvbkxlYXZlOiBudWxsLFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiAoY3R4KT0+Y3R4LmNoYXJ0Lm9wdGlvbnMuY29sb3IsXG4gICAgICAgICAgICBib3hXaWR0aDogNDAsXG4gICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAgICAgICAgICAgIGdlbmVyYXRlTGFiZWxzIChjaGFydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFzZXRzID0gY2hhcnQuZGF0YS5kYXRhc2V0cztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhYmVsczogeyB1c2VQb2ludFN0eWxlICwgcG9pbnRTdHlsZSAsIHRleHRBbGlnbiAsIGNvbG9yICwgdXNlQm9yZGVyUmFkaXVzICwgYm9yZGVyUmFkaXVzICB9ICB9ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKS5tYXAoKG1ldGEpPT57XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSB0b1BhZGRpbmcoc3R5bGUuYm9yZGVyV2lkdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRDb2xvcjogY29sb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW46ICFtZXRhLnZpc2libGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lQ2FwOiBzdHlsZS5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVEYXNoOiBzdHlsZS5ib3JkZXJEYXNoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZURhc2hPZmZzZXQ6IHN0eWxlLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSm9pbjogc3R5bGUuYm9yZGVySm9pblN0eWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVdpZHRoOiAoYm9yZGVyV2lkdGgud2lkdGggKyBib3JkZXJXaWR0aC5oZWlnaHQpIC8gNCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cm9rZVN0eWxlOiBzdHlsZS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IHBvaW50U3R5bGUgfHwgc3R5bGUucG9pbnRTdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBzdHlsZS5yb3RhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHRBbGlnbjogdGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogdXNlQm9yZGVyUmFkaXVzICYmIChib3JkZXJSYWRpdXMgfHwgc3R5bGUuYm9yZGVyUmFkaXVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgY29sb3I6IChjdHgpPT5jdHguY2hhcnQub3B0aW9ucy5jb2xvcixcbiAgICAgICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICAgICAgcG9zaXRpb246ICdjZW50ZXInLFxuICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZGVzY3JpcHRvcnM6IHtcbiAgICAgICAgX3NjcmlwdGFibGU6IChuYW1lKT0+IW5hbWUuc3RhcnRzV2l0aCgnb24nKSxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT4hW1xuICAgICAgICAgICAgICAgICAgICAnZ2VuZXJhdGVMYWJlbHMnLFxuICAgICAgICAgICAgICAgICAgICAnZmlsdGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3NvcnQnXG4gICAgICAgICAgICAgICAgXS5pbmNsdWRlcyhuYW1lKVxuICAgICAgICB9XG4gICAgfVxufTtcblxuY2xhc3MgVGl0bGUgZXh0ZW5kcyBFbGVtZW50IHtcbiBjb25zdHJ1Y3Rvcihjb25maWcpe1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYXJ0ID0gY29uZmlnLmNoYXJ0O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBjb25maWcub3B0aW9ucztcbiAgICAgICAgdGhpcy5jdHggPSBjb25maWcuY3R4O1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnRvcCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5ib3R0b20gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMubGVmdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yaWdodCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy53aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucG9zaXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZ1bGxTaXplID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICB1cGRhdGUobWF4V2lkdGgsIG1heEhlaWdodCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLmxlZnQgPSAwO1xuICAgICAgICB0aGlzLnRvcCA9IDA7XG4gICAgICAgIGlmICghb3B0cy5kaXNwbGF5KSB7XG4gICAgICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSB0aGlzLnJpZ2h0ID0gdGhpcy5ib3R0b20gPSAwO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLnJpZ2h0ID0gbWF4V2lkdGg7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3R0b20gPSBtYXhIZWlnaHQ7XG4gICAgICAgIGNvbnN0IGxpbmVDb3VudCA9IGlzQXJyYXkob3B0cy50ZXh0KSA/IG9wdHMudGV4dC5sZW5ndGggOiAxO1xuICAgICAgICB0aGlzLl9wYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMucGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHRleHRTaXplID0gbGluZUNvdW50ICogdG9Gb250KG9wdHMuZm9udCkubGluZUhlaWdodCArIHRoaXMuX3BhZGRpbmcuaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0ZXh0U2l6ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSB0ZXh0U2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0hvcml6b250YWwoKSB7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcbiAgICAgICAgcmV0dXJuIHBvcyA9PT0gJ3RvcCcgfHwgcG9zID09PSAnYm90dG9tJztcbiAgICB9XG4gICAgX2RyYXdBcmdzKG9mZnNldCkge1xuICAgICAgICBjb25zdCB7IHRvcCAsIGxlZnQgLCBib3R0b20gLCByaWdodCAsIG9wdGlvbnMgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBhbGlnbiA9IG9wdGlvbnMuYWxpZ247XG4gICAgICAgIGxldCByb3RhdGlvbiA9IDA7XG4gICAgICAgIGxldCBtYXhXaWR0aCwgdGl0bGVYLCB0aXRsZVk7XG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCgpKSB7XG4gICAgICAgICAgICB0aXRsZVggPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgdGl0bGVZID0gdG9wICsgb2Zmc2V0O1xuICAgICAgICAgICAgbWF4V2lkdGggPSByaWdodCAtIGxlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICAgICAgdGl0bGVYID0gbGVmdCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgYm90dG9tLCB0b3ApO1xuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gUEkgKiAtMC41O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aXRsZVggPSByaWdodCAtIG9mZnNldDtcbiAgICAgICAgICAgICAgICB0aXRsZVkgPSBfYWxpZ25TdGFydEVuZChhbGlnbiwgdG9wLCBib3R0b20pO1xuICAgICAgICAgICAgICAgIHJvdGF0aW9uID0gUEkgKiAwLjU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXhXaWR0aCA9IGJvdHRvbSAtIHRvcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGl0bGVYLFxuICAgICAgICAgICAgdGl0bGVZLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICByb3RhdGlvblxuICAgICAgICB9O1xuICAgIH1cbiAgICBkcmF3KCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCFvcHRzLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb250T3B0cyA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gZm9udE9wdHMubGluZUhlaWdodDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbGluZUhlaWdodCAvIDIgKyB0aGlzLl9wYWRkaW5nLnRvcDtcbiAgICAgICAgY29uc3QgeyB0aXRsZVggLCB0aXRsZVkgLCBtYXhXaWR0aCAsIHJvdGF0aW9uICB9ID0gdGhpcy5fZHJhd0FyZ3Mob2Zmc2V0KTtcbiAgICAgICAgcmVuZGVyVGV4dChjdHgsIG9wdHMudGV4dCwgMCwgMCwgZm9udE9wdHMsIHtcbiAgICAgICAgICAgIGNvbG9yOiBvcHRzLmNvbG9yLFxuICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICByb3RhdGlvbixcbiAgICAgICAgICAgIHRleHRBbGlnbjogX3RvTGVmdFJpZ2h0Q2VudGVyKG9wdHMuYWxpZ24pLFxuICAgICAgICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJyxcbiAgICAgICAgICAgIHRyYW5zbGF0aW9uOiBbXG4gICAgICAgICAgICAgICAgdGl0bGVYLFxuICAgICAgICAgICAgICAgIHRpdGxlWVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVUaXRsZShjaGFydCwgdGl0bGVPcHRzKSB7XG4gICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgICBjdHg6IGNoYXJ0LmN0eCxcbiAgICAgICAgb3B0aW9uczogdGl0bGVPcHRzLFxuICAgICAgICBjaGFydFxuICAgIH0pO1xuICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgdGl0bGVPcHRzKTtcbiAgICBsYXlvdXRzLmFkZEJveChjaGFydCwgdGl0bGUpO1xuICAgIGNoYXJ0LnRpdGxlQmxvY2sgPSB0aXRsZTtcbn1cbnZhciBwbHVnaW5fdGl0bGUgPSB7XG4gICAgaWQ6ICd0aXRsZScsXG4gX2VsZW1lbnQ6IFRpdGxlLFxuICAgIHN0YXJ0IChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY3JlYXRlVGl0bGUoY2hhcnQsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgc3RvcCAoY2hhcnQpIHtcbiAgICAgICAgY29uc3QgdGl0bGVCbG9jayA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCB0aXRsZUJsb2NrKTtcbiAgICAgICAgZGVsZXRlIGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgfSxcbiAgICBiZWZvcmVVcGRhdGUgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB0aXRsZSA9IGNoYXJ0LnRpdGxlQmxvY2s7XG4gICAgICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgICAgIHRpdGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH0sXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICBkaXNwbGF5OiBmYWxzZSxcbiAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCdcbiAgICAgICAgfSxcbiAgICAgICAgZnVsbFNpemU6IHRydWUsXG4gICAgICAgIHBhZGRpbmc6IDEwLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICB3ZWlnaHQ6IDIwMDBcbiAgICB9LFxuICAgIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICAgICAgY29sb3I6ICdjb2xvcidcbiAgICB9LFxuICAgIGRlc2NyaXB0b3JzOiB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgICAgICBfaW5kZXhhYmxlOiBmYWxzZVxuICAgIH1cbn07XG5cbmNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG52YXIgcGx1Z2luX3N1YnRpdGxlID0ge1xuICAgIGlkOiAnc3VidGl0bGUnLFxuICAgIHN0YXJ0IChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBuZXcgVGl0bGUoe1xuICAgICAgICAgICAgY3R4OiBjaGFydC5jdHgsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY2hhcnRcbiAgICAgICAgfSk7XG4gICAgICAgIGxheW91dHMuY29uZmlndXJlKGNoYXJ0LCB0aXRsZSwgb3B0aW9ucyk7XG4gICAgICAgIGxheW91dHMuYWRkQm94KGNoYXJ0LCB0aXRsZSk7XG4gICAgICAgIG1hcC5zZXQoY2hhcnQsIHRpdGxlKTtcbiAgICB9LFxuICAgIHN0b3AgKGNoYXJ0KSB7XG4gICAgICAgIGxheW91dHMucmVtb3ZlQm94KGNoYXJ0LCBtYXAuZ2V0KGNoYXJ0KSk7XG4gICAgICAgIG1hcC5kZWxldGUoY2hhcnQpO1xuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlIChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBtYXAuZ2V0KGNoYXJ0KTtcbiAgICAgICAgbGF5b3V0cy5jb25maWd1cmUoY2hhcnQsIHRpdGxlLCBvcHRpb25zKTtcbiAgICAgICAgdGl0bGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBhbGlnbjogJ2NlbnRlcicsXG4gICAgICAgIGRpc3BsYXk6IGZhbHNlLFxuICAgICAgICBmb250OiB7XG4gICAgICAgICAgICB3ZWlnaHQ6ICdub3JtYWwnXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bGxTaXplOiB0cnVlLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBwb3NpdGlvbjogJ3RvcCcsXG4gICAgICAgIHRleHQ6ICcnLFxuICAgICAgICB3ZWlnaHQ6IDE1MDBcbiAgICB9LFxuICAgIGRlZmF1bHRSb3V0ZXM6IHtcbiAgICAgICAgY29sb3I6ICdjb2xvcidcbiAgICB9LFxuICAgIGRlc2NyaXB0b3JzOiB7XG4gICAgICAgIF9zY3JpcHRhYmxlOiB0cnVlLFxuICAgICAgICBfaW5kZXhhYmxlOiBmYWxzZVxuICAgIH1cbn07XG5cbmNvbnN0IHBvc2l0aW9uZXJzID0ge1xuIGF2ZXJhZ2UgKGl0ZW1zKSB7XG4gICAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGksIGxlbjtcbiAgICAgICAgbGV0IHhTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgZm9yKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IGVsLnRvb2x0aXBQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgIHhTZXQuYWRkKHBvcy54KTtcbiAgICAgICAgICAgICAgICB5ICs9IHBvcy55O1xuICAgICAgICAgICAgICAgICsrY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID09PSAwIHx8IHhTZXQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHhBdmVyYWdlID0gW1xuICAgICAgICAgICAgLi4ueFNldFxuICAgICAgICBdLnJlZHVjZSgoYSwgYik9PmEgKyBiKSAvIHhTZXQuc2l6ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IHhBdmVyYWdlLFxuICAgICAgICAgICAgeTogeSAvIGNvdW50XG4gICAgICAgIH07XG4gICAgfSxcbiBuZWFyZXN0IChpdGVtcywgZXZlbnRQb3NpdGlvbikge1xuICAgICAgICBpZiAoIWl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB4ID0gZXZlbnRQb3NpdGlvbi54O1xuICAgICAgICBsZXQgeSA9IGV2ZW50UG9zaXRpb24ueTtcbiAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBsZXQgaSwgbGVuLCBuZWFyZXN0RWxlbWVudDtcbiAgICAgICAgZm9yKGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47ICsraSl7XG4gICAgICAgICAgICBjb25zdCBlbCA9IGl0ZW1zW2ldLmVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoZWwgJiYgZWwuaGFzVmFsdWUoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IGVsLmdldENlbnRlclBvaW50KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZCA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhldmVudFBvc2l0aW9uLCBjZW50ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChkIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkO1xuICAgICAgICAgICAgICAgICAgICBuZWFyZXN0RWxlbWVudCA9IGVsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmVhcmVzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRwID0gbmVhcmVzdEVsZW1lbnQudG9vbHRpcFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB4ID0gdHAueDtcbiAgICAgICAgICAgIHkgPSB0cC55O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwdXNoT3JDb25jYXQoYmFzZSwgdG9QdXNoKSB7XG4gICAgaWYgKHRvUHVzaCkge1xuICAgICAgICBpZiAoaXNBcnJheSh0b1B1c2gpKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShiYXNlLCB0b1B1c2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmFzZS5wdXNoKHRvUHVzaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG59XG4gZnVuY3Rpb24gc3BsaXROZXdsaW5lcyhzdHIpIHtcbiAgICBpZiAoKHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnIHx8IHN0ciBpbnN0YW5jZW9mIFN0cmluZykgJiYgc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5zcGxpdCgnXFxuJyk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG4gZnVuY3Rpb24gY3JlYXRlVG9vbHRpcEl0ZW0oY2hhcnQsIGl0ZW0pIHtcbiAgICBjb25zdCB7IGVsZW1lbnQgLCBkYXRhc2V0SW5kZXggLCBpbmRleCAgfSA9IGl0ZW07XG4gICAgY29uc3QgY29udHJvbGxlciA9IGNoYXJ0LmdldERhdGFzZXRNZXRhKGRhdGFzZXRJbmRleCkuY29udHJvbGxlcjtcbiAgICBjb25zdCB7IGxhYmVsICwgdmFsdWUgIH0gPSBjb250cm9sbGVyLmdldExhYmVsQW5kVmFsdWUoaW5kZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoYXJ0LFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgcGFyc2VkOiBjb250cm9sbGVyLmdldFBhcnNlZChpbmRleCksXG4gICAgICAgIHJhdzogY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdLmRhdGFbaW5kZXhdLFxuICAgICAgICBmb3JtYXR0ZWRWYWx1ZTogdmFsdWUsXG4gICAgICAgIGRhdGFzZXQ6IGNvbnRyb2xsZXIuZ2V0RGF0YXNldCgpLFxuICAgICAgICBkYXRhSW5kZXg6IGluZGV4LFxuICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgIGVsZW1lbnRcbiAgICB9O1xufVxuIGZ1bmN0aW9uIGdldFRvb2x0aXBTaXplKHRvb2x0aXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjdHggPSB0b29sdGlwLmNoYXJ0LmN0eDtcbiAgICBjb25zdCB7IGJvZHkgLCBmb290ZXIgLCB0aXRsZSAgfSA9IHRvb2x0aXA7XG4gICAgY29uc3QgeyBib3hXaWR0aCAsIGJveEhlaWdodCAgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgYm9keUZvbnQgPSB0b0ZvbnQob3B0aW9ucy5ib2R5Rm9udCk7XG4gICAgY29uc3QgdGl0bGVGb250ID0gdG9Gb250KG9wdGlvbnMudGl0bGVGb250KTtcbiAgICBjb25zdCBmb290ZXJGb250ID0gdG9Gb250KG9wdGlvbnMuZm9vdGVyRm9udCk7XG4gICAgY29uc3QgdGl0bGVMaW5lQ291bnQgPSB0aXRsZS5sZW5ndGg7XG4gICAgY29uc3QgZm9vdGVyTGluZUNvdW50ID0gZm9vdGVyLmxlbmd0aDtcbiAgICBjb25zdCBib2R5TGluZUl0ZW1Db3VudCA9IGJvZHkubGVuZ3RoO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICBsZXQgaGVpZ2h0ID0gcGFkZGluZy5oZWlnaHQ7XG4gICAgbGV0IHdpZHRoID0gMDtcbiAgICBsZXQgY29tYmluZWRCb2R5TGVuZ3RoID0gYm9keS5yZWR1Y2UoKGNvdW50LCBib2R5SXRlbSk9PmNvdW50ICsgYm9keUl0ZW0uYmVmb3JlLmxlbmd0aCArIGJvZHlJdGVtLmxpbmVzLmxlbmd0aCArIGJvZHlJdGVtLmFmdGVyLmxlbmd0aCwgMCk7XG4gICAgY29tYmluZWRCb2R5TGVuZ3RoICs9IHRvb2x0aXAuYmVmb3JlQm9keS5sZW5ndGggKyB0b29sdGlwLmFmdGVyQm9keS5sZW5ndGg7XG4gICAgaWYgKHRpdGxlTGluZUNvdW50KSB7XG4gICAgICAgIGhlaWdodCArPSB0aXRsZUxpbmVDb3VudCAqIHRpdGxlRm9udC5saW5lSGVpZ2h0ICsgKHRpdGxlTGluZUNvdW50IC0gMSkgKiBvcHRpb25zLnRpdGxlU3BhY2luZyArIG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b207XG4gICAgfVxuICAgIGlmIChjb21iaW5lZEJvZHlMZW5ndGgpIHtcbiAgICAgICAgY29uc3QgYm9keUxpbmVIZWlnaHQgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBNYXRoLm1heChib3hIZWlnaHQsIGJvZHlGb250LmxpbmVIZWlnaHQpIDogYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgICAgaGVpZ2h0ICs9IGJvZHlMaW5lSXRlbUNvdW50ICogYm9keUxpbmVIZWlnaHQgKyAoY29tYmluZWRCb2R5TGVuZ3RoIC0gYm9keUxpbmVJdGVtQ291bnQpICogYm9keUZvbnQubGluZUhlaWdodCArIChjb21iaW5lZEJvZHlMZW5ndGggLSAxKSAqIG9wdGlvbnMuYm9keVNwYWNpbmc7XG4gICAgfVxuICAgIGlmIChmb290ZXJMaW5lQ291bnQpIHtcbiAgICAgICAgaGVpZ2h0ICs9IG9wdGlvbnMuZm9vdGVyTWFyZ2luVG9wICsgZm9vdGVyTGluZUNvdW50ICogZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgKGZvb3RlckxpbmVDb3VudCAtIDEpICogb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgIH1cbiAgICBsZXQgd2lkdGhQYWRkaW5nID0gMDtcbiAgICBjb25zdCBtYXhMaW5lV2lkdGggPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lKS53aWR0aCArIHdpZHRoUGFkZGluZyk7XG4gICAgfTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5mb250ID0gdGl0bGVGb250LnN0cmluZztcbiAgICBlYWNoKHRvb2x0aXAudGl0bGUsIG1heExpbmVXaWR0aCk7XG4gICAgY3R4LmZvbnQgPSBib2R5Rm9udC5zdHJpbmc7XG4gICAgZWFjaCh0b29sdGlwLmJlZm9yZUJvZHkuY29uY2F0KHRvb2x0aXAuYWZ0ZXJCb2R5KSwgbWF4TGluZVdpZHRoKTtcbiAgICB3aWR0aFBhZGRpbmcgPSBvcHRpb25zLmRpc3BsYXlDb2xvcnMgPyBib3hXaWR0aCArIDIgKyBvcHRpb25zLmJveFBhZGRpbmcgOiAwO1xuICAgIGVhY2goYm9keSwgKGJvZHlJdGVtKT0+e1xuICAgICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgbWF4TGluZVdpZHRoKTtcbiAgICAgICAgZWFjaChib2R5SXRlbS5saW5lcywgbWF4TGluZVdpZHRoKTtcbiAgICAgICAgZWFjaChib2R5SXRlbS5hZnRlciwgbWF4TGluZVdpZHRoKTtcbiAgICB9KTtcbiAgICB3aWR0aFBhZGRpbmcgPSAwO1xuICAgIGN0eC5mb250ID0gZm9vdGVyRm9udC5zdHJpbmc7XG4gICAgZWFjaCh0b29sdGlwLmZvb3RlciwgbWF4TGluZVdpZHRoKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICAgIHdpZHRoICs9IHBhZGRpbmcud2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgIH07XG59XG5mdW5jdGlvbiBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpIHtcbiAgICBjb25zdCB7IHkgLCBoZWlnaHQgIH0gPSBzaXplO1xuICAgIGlmICh5IDwgaGVpZ2h0IC8gMikge1xuICAgICAgICByZXR1cm4gJ3RvcCc7XG4gICAgfSBlbHNlIGlmICh5ID4gY2hhcnQuaGVpZ2h0IC0gaGVpZ2h0IC8gMikge1xuICAgICAgICByZXR1cm4gJ2JvdHRvbSc7XG4gICAgfVxuICAgIHJldHVybiAnY2VudGVyJztcbn1cbmZ1bmN0aW9uIGRvZXNOb3RGaXRXaXRoQWxpZ24oeEFsaWduLCBjaGFydCwgb3B0aW9ucywgc2l6ZSkge1xuICAgIGNvbnN0IHsgeCAsIHdpZHRoICB9ID0gc2l6ZTtcbiAgICBjb25zdCBjYXJldCA9IG9wdGlvbnMuY2FyZXRTaXplICsgb3B0aW9ucy5jYXJldFBhZGRpbmc7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnICYmIHggKyB3aWR0aCArIGNhcmV0ID4gY2hhcnQud2lkdGgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh4QWxpZ24gPT09ICdyaWdodCcgJiYgeCAtIHdpZHRoIC0gY2FyZXQgPCAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGVybWluZVhBbGlnbihjaGFydCwgb3B0aW9ucywgc2l6ZSwgeUFsaWduKSB7XG4gICAgY29uc3QgeyB4ICwgd2lkdGggIH0gPSBzaXplO1xuICAgIGNvbnN0IHsgd2lkdGg6IGNoYXJ0V2lkdGggLCBjaGFydEFyZWE6IHsgbGVmdCAsIHJpZ2h0ICB9ICB9ID0gY2hhcnQ7XG4gICAgbGV0IHhBbGlnbiA9ICdjZW50ZXInO1xuICAgIGlmICh5QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHhBbGlnbiA9IHggPD0gKGxlZnQgKyByaWdodCkgLyAyID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICB9IGVsc2UgaWYgKHggPD0gd2lkdGggLyAyKSB7XG4gICAgICAgIHhBbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKHggPj0gY2hhcnRXaWR0aCAtIHdpZHRoIC8gMikge1xuICAgICAgICB4QWxpZ24gPSAncmlnaHQnO1xuICAgIH1cbiAgICBpZiAoZG9lc05vdEZpdFdpdGhBbGlnbih4QWxpZ24sIGNoYXJ0LCBvcHRpb25zLCBzaXplKSkge1xuICAgICAgICB4QWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG4gICAgcmV0dXJuIHhBbGlnbjtcbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVBbGlnbm1lbnQoY2hhcnQsIG9wdGlvbnMsIHNpemUpIHtcbiAgICBjb25zdCB5QWxpZ24gPSBzaXplLnlBbGlnbiB8fCBvcHRpb25zLnlBbGlnbiB8fCBkZXRlcm1pbmVZQWxpZ24oY2hhcnQsIHNpemUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHhBbGlnbjogc2l6ZS54QWxpZ24gfHwgb3B0aW9ucy54QWxpZ24gfHwgZGV0ZXJtaW5lWEFsaWduKGNoYXJ0LCBvcHRpb25zLCBzaXplLCB5QWxpZ24pLFxuICAgICAgICB5QWxpZ25cbiAgICB9O1xufVxuZnVuY3Rpb24gYWxpZ25YKHNpemUsIHhBbGlnbikge1xuICAgIGxldCB7IHggLCB3aWR0aCAgfSA9IHNpemU7XG4gICAgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4IC09IHdpZHRoO1xuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4IC09IHdpZHRoIC8gMjtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG59XG5mdW5jdGlvbiBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSkge1xuICAgIGxldCB7IHkgLCBoZWlnaHQgIH0gPSBzaXplO1xuICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkgKz0gcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgIHkgLT0gaGVpZ2h0ICsgcGFkZGluZ0FuZFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgeSAtPSBoZWlnaHQgLyAyO1xuICAgIH1cbiAgICByZXR1cm4geTtcbn1cbiBmdW5jdGlvbiBnZXRCYWNrZ3JvdW5kUG9pbnQob3B0aW9ucywgc2l6ZSwgYWxpZ25tZW50LCBjaGFydCkge1xuICAgIGNvbnN0IHsgY2FyZXRTaXplICwgY2FyZXRQYWRkaW5nICwgY29ybmVyUmFkaXVzICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHhBbGlnbiAsIHlBbGlnbiAgfSA9IGFsaWdubWVudDtcbiAgICBjb25zdCBwYWRkaW5nQW5kU2l6ZSA9IGNhcmV0U2l6ZSArIGNhcmV0UGFkZGluZztcbiAgICBjb25zdCB7IHRvcExlZnQgLCB0b3BSaWdodCAsIGJvdHRvbUxlZnQgLCBib3R0b21SaWdodCAgfSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICBsZXQgeCA9IGFsaWduWChzaXplLCB4QWxpZ24pO1xuICAgIGNvbnN0IHkgPSBhbGlnblkoc2l6ZSwgeUFsaWduLCBwYWRkaW5nQW5kU2l6ZSk7XG4gICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgaWYgKHhBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgICAgICB4ICs9IHBhZGRpbmdBbmRTaXplO1xuICAgICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgeCAtPSBwYWRkaW5nQW5kU2l6ZTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgeCAtPSBNYXRoLm1heCh0b3BMZWZ0LCBib3R0b21MZWZ0KSArIGNhcmV0U2l6ZTtcbiAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICB4ICs9IE1hdGgubWF4KHRvcFJpZ2h0LCBib3R0b21SaWdodCkgKyBjYXJldFNpemU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IF9saW1pdFZhbHVlKHgsIDAsIGNoYXJ0LndpZHRoIC0gc2l6ZS53aWR0aCksXG4gICAgICAgIHk6IF9saW1pdFZhbHVlKHksIDAsIGNoYXJ0LmhlaWdodCAtIHNpemUuaGVpZ2h0KVxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRBbGlnbmVkWCh0b29sdGlwLCBhbGlnbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICByZXR1cm4gYWxpZ24gPT09ICdjZW50ZXInID8gdG9vbHRpcC54ICsgdG9vbHRpcC53aWR0aCAvIDIgOiBhbGlnbiA9PT0gJ3JpZ2h0JyA/IHRvb2x0aXAueCArIHRvb2x0aXAud2lkdGggLSBwYWRkaW5nLnJpZ2h0IDogdG9vbHRpcC54ICsgcGFkZGluZy5sZWZ0O1xufVxuIGZ1bmN0aW9uIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHB1c2hPckNvbmNhdChbXSwgc3BsaXROZXdsaW5lcyhjYWxsYmFjaykpO1xufVxuZnVuY3Rpb24gY3JlYXRlVG9vbHRpcENvbnRleHQocGFyZW50LCB0b29sdGlwLCB0b29sdGlwSXRlbXMpIHtcbiAgICByZXR1cm4gY3JlYXRlQ29udGV4dChwYXJlbnQsIHtcbiAgICAgICAgdG9vbHRpcCxcbiAgICAgICAgdG9vbHRpcEl0ZW1zLFxuICAgICAgICB0eXBlOiAndG9vbHRpcCdcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlQ2FsbGJhY2tzKGNhbGxiYWNrcywgY29udGV4dCkge1xuICAgIGNvbnN0IG92ZXJyaWRlID0gY29udGV4dCAmJiBjb250ZXh0LmRhdGFzZXQgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAgJiYgY29udGV4dC5kYXRhc2V0LnRvb2x0aXAuY2FsbGJhY2tzO1xuICAgIHJldHVybiBvdmVycmlkZSA/IGNhbGxiYWNrcy5vdmVycmlkZShvdmVycmlkZSkgOiBjYWxsYmFja3M7XG59XG5jb25zdCBkZWZhdWx0Q2FsbGJhY2tzID0ge1xuICAgIGJlZm9yZVRpdGxlOiBub29wLFxuICAgIHRpdGxlICh0b29sdGlwSXRlbXMpIHtcbiAgICAgICAgaWYgKHRvb2x0aXBJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdG9vbHRpcEl0ZW1zWzBdO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxzID0gaXRlbS5jaGFydC5kYXRhLmxhYmVscztcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsQ291bnQgPSBsYWJlbHMgPyBsYWJlbHMubGVuZ3RoIDogMDtcbiAgICAgICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLmxhYmVsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChsYWJlbENvdW50ID4gMCAmJiBpdGVtLmRhdGFJbmRleCA8IGxhYmVsQ291bnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGFiZWxzW2l0ZW0uZGF0YUluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfSxcbiAgICBhZnRlclRpdGxlOiBub29wLFxuICAgIGJlZm9yZUJvZHk6IG5vb3AsXG4gICAgYmVmb3JlTGFiZWw6IG5vb3AsXG4gICAgbGFiZWwgKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMubW9kZSA9PT0gJ2RhdGFzZXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9vbHRpcEl0ZW0ubGFiZWwgKyAnOiAnICsgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWUgfHwgdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxhYmVsID0gdG9vbHRpcEl0ZW0uZGF0YXNldC5sYWJlbCB8fCAnJztcbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgICBsYWJlbCArPSAnOiAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9vbHRpcEl0ZW0uZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIGlmICghaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxhYmVsICs9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbDtcbiAgICB9LFxuICAgIGxhYmVsQ29sb3IgKHRvb2x0aXBJdGVtKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0b29sdGlwSXRlbS5jaGFydC5nZXREYXRhc2V0TWV0YSh0b29sdGlwSXRlbS5kYXRhc2V0SW5kZXgpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHRvb2x0aXBJdGVtLmRhdGFJbmRleCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICBib3JkZXJXaWR0aDogb3B0aW9ucy5ib3JkZXJXaWR0aCxcbiAgICAgICAgICAgIGJvcmRlckRhc2g6IG9wdGlvbnMuYm9yZGVyRGFzaCxcbiAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IG9wdGlvbnMuYm9yZGVyRGFzaE9mZnNldCxcbiAgICAgICAgICAgIGJvcmRlclJhZGl1czogMFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgbGFiZWxUZXh0Q29sb3IgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmJvZHlDb2xvcjtcbiAgICB9LFxuICAgIGxhYmVsUG9pbnRTdHlsZSAodG9vbHRpcEl0ZW0pIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRvb2x0aXBJdGVtLmNoYXJ0LmdldERhdGFzZXRNZXRhKHRvb2x0aXBJdGVtLmRhdGFzZXRJbmRleCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodG9vbHRpcEl0ZW0uZGF0YUluZGV4KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvaW50U3R5bGU6IG9wdGlvbnMucG9pbnRTdHlsZSxcbiAgICAgICAgICAgIHJvdGF0aW9uOiBvcHRpb25zLnJvdGF0aW9uXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZnRlckxhYmVsOiBub29wLFxuICAgIGFmdGVyQm9keTogbm9vcCxcbiAgICBiZWZvcmVGb290ZXI6IG5vb3AsXG4gICAgZm9vdGVyOiBub29wLFxuICAgIGFmdGVyRm9vdGVyOiBub29wXG59O1xuIGZ1bmN0aW9uIGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgbmFtZSwgY3R4LCBhcmcpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjYWxsYmFja3NbbmFtZV0uY2FsbChjdHgsIGFyZyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0Q2FsbGJhY2tzW25hbWVdLmNhbGwoY3R4LCBhcmcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgVG9vbHRpcCBleHRlbmRzIEVsZW1lbnQge1xuIHN0YXRpYyBwb3NpdGlvbmVycyA9IHBvc2l0aW9uZXJzO1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDA7XG4gICAgICAgIHRoaXMuX2FjdGl2ZSA9IFtdO1xuICAgICAgICB0aGlzLl9ldmVudFBvc2l0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zaXplID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9jYWNoZWRBbmltYXRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl90b29sdGlwSXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy4kYW5pbWF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaGFydCA9IGNvbmZpZy5jaGFydDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gY29uZmlnLm9wdGlvbnM7XG4gICAgICAgIHRoaXMuZGF0YVBvaW50cyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy50aXRsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmJvZHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmZvb3RlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy54QWxpZ24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMueUFsaWduID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMueSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuY2FyZXRYID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNhcmV0WSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYWJlbENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5sYWJlbFBvaW50U3R5bGVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmxhYmVsVGV4dENvbG9ycyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuJGNvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgfVxuIF9yZXNvbHZlQW5pbWF0aW9ucygpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy5fY2FjaGVkQW5pbWF0aW9ucztcbiAgICAgICAgaWYgKGNhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMuc2V0Q29udGV4dCh0aGlzLmdldENvbnRleHQoKSk7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBvcHRpb25zLmVuYWJsZWQgJiYgY2hhcnQub3B0aW9ucy5hbmltYXRpb24gJiYgb3B0aW9ucy5hbmltYXRpb25zO1xuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnModGhpcy5jaGFydCwgb3B0cyk7XG4gICAgICAgIGlmIChvcHRzLl9jYWNoZWFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlZEFuaW1hdGlvbnMgPSBPYmplY3QuZnJlZXplKGFuaW1hdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiBnZXRDb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kY29udGV4dCB8fCAodGhpcy4kY29udGV4dCA9IGNyZWF0ZVRvb2x0aXBDb250ZXh0KHRoaXMuY2hhcnQuZ2V0Q29udGV4dCgpLCB0aGlzLCB0aGlzLl90b29sdGlwSXRlbXMpKTtcbiAgICB9XG4gICAgZ2V0VGl0bGUoY29udGV4dCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGNhbGxiYWNrcyAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGJlZm9yZVRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYmVmb3JlVGl0bGUnLCB0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgY29uc3QgdGl0bGUgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICd0aXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBjb25zdCBhZnRlclRpdGxlID0gaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soY2FsbGJhY2tzLCAnYWZ0ZXJUaXRsZScsIHRoaXMsIGNvbnRleHQpO1xuICAgICAgICBsZXQgbGluZXMgPSBbXTtcbiAgICAgICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYmVmb3JlVGl0bGUpKTtcbiAgICAgICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXModGl0bGUpKTtcbiAgICAgICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJUaXRsZSkpO1xuICAgICAgICByZXR1cm4gbGluZXM7XG4gICAgfVxuICAgIGdldEJlZm9yZUJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBnZXRCZWZvcmVBZnRlckJvZHlMaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhvcHRpb25zLmNhbGxiYWNrcywgJ2JlZm9yZUJvZHknLCB0aGlzLCB0b29sdGlwSXRlbXMpKTtcbiAgICB9XG4gICAgZ2V0Qm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja3MgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5SXRlbXMgPSBbXTtcbiAgICAgICAgZWFjaCh0b29sdGlwSXRlbXMsIChjb250ZXh0KT0+e1xuICAgICAgICAgICAgY29uc3QgYm9keUl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgYmVmb3JlOiBbXSxcbiAgICAgICAgICAgICAgICBsaW5lczogW10sXG4gICAgICAgICAgICAgICAgYWZ0ZXI6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc2NvcGVkID0gb3ZlcnJpZGVDYWxsYmFja3MoY2FsbGJhY2tzLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5iZWZvcmUsIHNwbGl0TmV3bGluZXMoaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnYmVmb3JlTGFiZWwnLCB0aGlzLCBjb250ZXh0KSkpO1xuICAgICAgICAgICAgcHVzaE9yQ29uY2F0KGJvZHlJdGVtLmxpbmVzLCBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdsYWJlbCcsIHRoaXMsIGNvbnRleHQpKTtcbiAgICAgICAgICAgIHB1c2hPckNvbmNhdChib2R5SXRlbS5hZnRlciwgc3BsaXROZXdsaW5lcyhpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhzY29wZWQsICdhZnRlckxhYmVsJywgdGhpcywgY29udGV4dCkpKTtcbiAgICAgICAgICAgIGJvZHlJdGVtcy5wdXNoKGJvZHlJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBib2R5SXRlbXM7XG4gICAgfVxuICAgIGdldEFmdGVyQm9keSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGdldEJlZm9yZUFmdGVyQm9keUxpbmVzKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKG9wdGlvbnMuY2FsbGJhY2tzLCAnYWZ0ZXJCb2R5JywgdGhpcywgdG9vbHRpcEl0ZW1zKSk7XG4gICAgfVxuICAgIGdldEZvb3Rlcih0b29sdGlwSXRlbXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBjYWxsYmFja3MgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBiZWZvcmVGb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdiZWZvcmVGb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgICAgICBjb25zdCBmb290ZXIgPSBpbnZva2VDYWxsYmFja1dpdGhGYWxsYmFjayhjYWxsYmFja3MsICdmb290ZXInLCB0aGlzLCB0b29sdGlwSXRlbXMpO1xuICAgICAgICBjb25zdCBhZnRlckZvb3RlciA9IGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKGNhbGxiYWNrcywgJ2FmdGVyRm9vdGVyJywgdGhpcywgdG9vbHRpcEl0ZW1zKTtcbiAgICAgICAgbGV0IGxpbmVzID0gW107XG4gICAgICAgIGxpbmVzID0gcHVzaE9yQ29uY2F0KGxpbmVzLCBzcGxpdE5ld2xpbmVzKGJlZm9yZUZvb3RlcikpO1xuICAgICAgICBsaW5lcyA9IHB1c2hPckNvbmNhdChsaW5lcywgc3BsaXROZXdsaW5lcyhmb290ZXIpKTtcbiAgICAgICAgbGluZXMgPSBwdXNoT3JDb25jYXQobGluZXMsIHNwbGl0TmV3bGluZXMoYWZ0ZXJGb290ZXIpKTtcbiAgICAgICAgcmV0dXJuIGxpbmVzO1xuICAgIH1cbiBfY3JlYXRlSXRlbXMob3B0aW9ucykge1xuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLl9hY3RpdmU7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLmNoYXJ0LmRhdGE7XG4gICAgICAgIGNvbnN0IGxhYmVsQ29sb3JzID0gW107XG4gICAgICAgIGNvbnN0IGxhYmVsUG9pbnRTdHlsZXMgPSBbXTtcbiAgICAgICAgY29uc3QgbGFiZWxUZXh0Q29sb3JzID0gW107XG4gICAgICAgIGxldCB0b29sdGlwSXRlbXMgPSBbXTtcbiAgICAgICAgbGV0IGksIGxlbjtcbiAgICAgICAgZm9yKGkgPSAwLCBsZW4gPSBhY3RpdmUubGVuZ3RoOyBpIDwgbGVuOyArK2kpe1xuICAgICAgICAgICAgdG9vbHRpcEl0ZW1zLnB1c2goY3JlYXRlVG9vbHRpcEl0ZW0odGhpcy5jaGFydCwgYWN0aXZlW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmlsdGVyKSB7XG4gICAgICAgICAgICB0b29sdGlwSXRlbXMgPSB0b29sdGlwSXRlbXMuZmlsdGVyKChlbGVtZW50LCBpbmRleCwgYXJyYXkpPT5vcHRpb25zLmZpbHRlcihlbGVtZW50LCBpbmRleCwgYXJyYXksIGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5pdGVtU29ydCkge1xuICAgICAgICAgICAgdG9vbHRpcEl0ZW1zID0gdG9vbHRpcEl0ZW1zLnNvcnQoKGEsIGIpPT5vcHRpb25zLml0ZW1Tb3J0KGEsIGIsIGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICBlYWNoKHRvb2x0aXBJdGVtcywgKGNvbnRleHQpPT57XG4gICAgICAgICAgICBjb25zdCBzY29wZWQgPSBvdmVycmlkZUNhbGxiYWNrcyhvcHRpb25zLmNhbGxiYWNrcywgY29udGV4dCk7XG4gICAgICAgICAgICBsYWJlbENvbG9ycy5wdXNoKGludm9rZUNhbGxiYWNrV2l0aEZhbGxiYWNrKHNjb3BlZCwgJ2xhYmVsQ29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgICAgICBsYWJlbFBvaW50U3R5bGVzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxQb2ludFN0eWxlJywgdGhpcywgY29udGV4dCkpO1xuICAgICAgICAgICAgbGFiZWxUZXh0Q29sb3JzLnB1c2goaW52b2tlQ2FsbGJhY2tXaXRoRmFsbGJhY2soc2NvcGVkLCAnbGFiZWxUZXh0Q29sb3InLCB0aGlzLCBjb250ZXh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhYmVsQ29sb3JzID0gbGFiZWxDb2xvcnM7XG4gICAgICAgIHRoaXMubGFiZWxQb2ludFN0eWxlcyA9IGxhYmVsUG9pbnRTdHlsZXM7XG4gICAgICAgIHRoaXMubGFiZWxUZXh0Q29sb3JzID0gbGFiZWxUZXh0Q29sb3JzO1xuICAgICAgICB0aGlzLmRhdGFQb2ludHMgPSB0b29sdGlwSXRlbXM7XG4gICAgICAgIHJldHVybiB0b29sdGlwSXRlbXM7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VkLCByZXBsYXkpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucy5zZXRDb250ZXh0KHRoaXMuZ2V0Q29udGV4dCgpKTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fYWN0aXZlO1xuICAgICAgICBsZXQgcHJvcGVydGllcztcbiAgICAgICAgbGV0IHRvb2x0aXBJdGVtcyA9IFtdO1xuICAgICAgICBpZiAoIWFjdGl2ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIHRoaXMuX2V2ZW50UG9zaXRpb24pO1xuICAgICAgICAgICAgdG9vbHRpcEl0ZW1zID0gdGhpcy5fY3JlYXRlSXRlbXMob3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnRpdGxlID0gdGhpcy5nZXRUaXRsZSh0b29sdGlwSXRlbXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5iZWZvcmVCb2R5ID0gdGhpcy5nZXRCZWZvcmVCb2R5KHRvb2x0aXBJdGVtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmJvZHkgPSB0aGlzLmdldEJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuYWZ0ZXJCb2R5ID0gdGhpcy5nZXRBZnRlckJvZHkodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuZm9vdGVyID0gdGhpcy5nZXRGb290ZXIodG9vbHRpcEl0ZW1zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLl9zaXplID0gZ2V0VG9vbHRpcFNpemUodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkFuZFNpemUgPSBPYmplY3QuYXNzaWduKHt9LCBwb3NpdGlvbiwgc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbm1lbnQgPSBkZXRlcm1pbmVBbGlnbm1lbnQodGhpcy5jaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGJhY2tncm91bmRQb2ludCA9IGdldEJhY2tncm91bmRQb2ludChvcHRpb25zLCBwb3NpdGlvbkFuZFNpemUsIGFsaWdubWVudCwgdGhpcy5jaGFydCk7XG4gICAgICAgICAgICB0aGlzLnhBbGlnbiA9IGFsaWdubWVudC54QWxpZ247XG4gICAgICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgeDogYmFja2dyb3VuZFBvaW50LngsXG4gICAgICAgICAgICAgICAgeTogYmFja2dyb3VuZFBvaW50LnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNpemUud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzaXplLmhlaWdodCxcbiAgICAgICAgICAgICAgICBjYXJldFg6IHBvc2l0aW9uLngsXG4gICAgICAgICAgICAgICAgY2FyZXRZOiBwb3NpdGlvbi55XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Rvb2x0aXBJdGVtcyA9IHRvb2x0aXBJdGVtcztcbiAgICAgICAgdGhpcy4kY29udGV4dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFuZ2VkICYmIG9wdGlvbnMuZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXh0ZXJuYWwuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICAgICAgY2hhcnQ6IHRoaXMuY2hhcnQsXG4gICAgICAgICAgICAgICAgdG9vbHRpcDogdGhpcyxcbiAgICAgICAgICAgICAgICByZXBsYXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXdDYXJldCh0b29sdGlwUG9pbnQsIGN0eCwgc2l6ZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBjYXJldFBvc2l0aW9uID0gdGhpcy5nZXRDYXJldFBvc2l0aW9uKHRvb2x0aXBQb2ludCwgc2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MSwgY2FyZXRQb3NpdGlvbi55MSk7XG4gICAgICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MiwgY2FyZXRQb3NpdGlvbi55Mik7XG4gICAgICAgIGN0eC5saW5lVG8oY2FyZXRQb3NpdGlvbi54MywgY2FyZXRQb3NpdGlvbi55Myk7XG4gICAgfVxuICAgIGdldENhcmV0UG9zaXRpb24odG9vbHRpcFBvaW50LCBzaXplLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgeEFsaWduICwgeUFsaWduICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBjYXJldFNpemUgLCBjb3JuZXJSYWRpdXMgIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB7IHRvcExlZnQgLCB0b3BSaWdodCAsIGJvdHRvbUxlZnQgLCBib3R0b21SaWdodCAgfSA9IHRvVFJCTENvcm5lcnMoY29ybmVyUmFkaXVzKTtcbiAgICAgICAgY29uc3QgeyB4OiBwdFggLCB5OiBwdFkgIH0gPSB0b29sdGlwUG9pbnQ7XG4gICAgICAgIGNvbnN0IHsgd2lkdGggLCBoZWlnaHQgIH0gPSBzaXplO1xuICAgICAgICBsZXQgeDEsIHgyLCB4MywgeTEsIHkyLCB5MztcbiAgICAgICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgICAgICAgIHkyID0gcHRZICsgaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHgxID0gcHRYO1xuICAgICAgICAgICAgICAgIHgyID0geDEgLSBjYXJldFNpemU7XG4gICAgICAgICAgICAgICAgeTEgPSB5MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgICAgICB5MyA9IHkyIC0gY2FyZXRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4MSA9IHB0WCArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHgyID0geDEgKyBjYXJldFNpemU7XG4gICAgICAgICAgICAgICAgeTEgPSB5MiAtIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgICAgICB5MyA9IHkyICsgY2FyZXRTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeDMgPSB4MTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh4QWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHgyID0gcHRYICsgTWF0aC5tYXgodG9wTGVmdCwgYm90dG9tTGVmdCkgKyBjYXJldFNpemU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgICAgIHgyID0gcHRYICsgd2lkdGggLSBNYXRoLm1heCh0b3BSaWdodCwgYm90dG9tUmlnaHQpIC0gY2FyZXRTaXplO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4MiA9IHRoaXMuY2FyZXRYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHlBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICB5MSA9IHB0WTtcbiAgICAgICAgICAgICAgICB5MiA9IHkxIC0gY2FyZXRTaXplO1xuICAgICAgICAgICAgICAgIHgxID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgICAgICAgICAgeDMgPSB4MiArIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeTEgPSBwdFkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgeTIgPSB5MSArIGNhcmV0U2l6ZTtcbiAgICAgICAgICAgICAgICB4MSA9IHgyICsgY2FyZXRTaXplO1xuICAgICAgICAgICAgICAgIHgzID0geDIgLSBjYXJldFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5MyA9IHkxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4MSxcbiAgICAgICAgICAgIHgyLFxuICAgICAgICAgICAgeDMsXG4gICAgICAgICAgICB5MSxcbiAgICAgICAgICAgIHkyLFxuICAgICAgICAgICAgeTNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZHJhd1RpdGxlKHB0LCBjdHgsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLnRpdGxlO1xuICAgICAgICBjb25zdCBsZW5ndGggPSB0aXRsZS5sZW5ndGg7XG4gICAgICAgIGxldCB0aXRsZUZvbnQsIHRpdGxlU3BhY2luZywgaTtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLnRpdGxlQWxpZ24sIG9wdGlvbnMpO1xuICAgICAgICAgICAgY3R4LnRleHRBbGlnbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24ob3B0aW9ucy50aXRsZUFsaWduKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIHRpdGxlRm9udCA9IHRvRm9udChvcHRpb25zLnRpdGxlRm9udCk7XG4gICAgICAgICAgICB0aXRsZVNwYWNpbmcgPSBvcHRpb25zLnRpdGxlU3BhY2luZztcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLnRpdGxlQ29sb3I7XG4gICAgICAgICAgICBjdHguZm9udCA9IHRpdGxlRm9udC5zdHJpbmc7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSl7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxUZXh0KHRpdGxlW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIHRpdGxlRm9udC5saW5lSGVpZ2h0IC8gMik7XG4gICAgICAgICAgICAgICAgcHQueSArPSB0aXRsZUZvbnQubGluZUhlaWdodCArIHRpdGxlU3BhY2luZztcbiAgICAgICAgICAgICAgICBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwdC55ICs9IG9wdGlvbnMudGl0bGVNYXJnaW5Cb3R0b20gLSB0aXRsZVNwYWNpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuIF9kcmF3Q29sb3JCb3goY3R4LCBwdCwgaSwgcnRsSGVscGVyLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsQ29sb3IgPSB0aGlzLmxhYmVsQ29sb3JzW2ldO1xuICAgICAgICBjb25zdCBsYWJlbFBvaW50U3R5bGUgPSB0aGlzLmxhYmVsUG9pbnRTdHlsZXNbaV07XG4gICAgICAgIGNvbnN0IHsgYm94SGVpZ2h0ICwgYm94V2lkdGggIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBib2R5Rm9udCA9IHRvRm9udChvcHRpb25zLmJvZHlGb250KTtcbiAgICAgICAgY29uc3QgY29sb3JYID0gZ2V0QWxpZ25lZFgodGhpcywgJ2xlZnQnLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgcnRsQ29sb3JYID0gcnRsSGVscGVyLngoY29sb3JYKTtcbiAgICAgICAgY29uc3QgeU9mZlNldCA9IGJveEhlaWdodCA8IGJvZHlGb250LmxpbmVIZWlnaHQgPyAoYm9keUZvbnQubGluZUhlaWdodCAtIGJveEhlaWdodCkgLyAyIDogMDtcbiAgICAgICAgY29uc3QgY29sb3JZID0gcHQueSArIHlPZmZTZXQ7XG4gICAgICAgIGlmIChvcHRpb25zLnVzZVBvaW50U3R5bGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYXdPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHJhZGl1czogTWF0aC5taW4oYm94V2lkdGgsIGJveEhlaWdodCkgLyAyLFxuICAgICAgICAgICAgICAgIHBvaW50U3R5bGU6IGxhYmVsUG9pbnRTdHlsZS5wb2ludFN0eWxlLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBsYWJlbFBvaW50U3R5bGUucm90YXRpb24sXG4gICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJYID0gcnRsSGVscGVyLmxlZnRGb3JMdHIocnRsQ29sb3JYLCBib3hXaWR0aCkgKyBib3hXaWR0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gY29sb3JZICsgYm94SGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICAgICAgZHJhd1BvaW50KGN0eCwgZHJhd09wdGlvbnMsIGNlbnRlclgsIGNlbnRlclkpO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgIGRyYXdQb2ludChjdHgsIGRyYXdPcHRpb25zLCBjZW50ZXJYLCBjZW50ZXJZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBpc09iamVjdChsYWJlbENvbG9yLmJvcmRlcldpZHRoKSA/IE1hdGgubWF4KC4uLk9iamVjdC52YWx1ZXMobGFiZWxDb2xvci5ib3JkZXJXaWR0aCkpIDogbGFiZWxDb2xvci5ib3JkZXJXaWR0aCB8fCAxO1xuICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gbGFiZWxDb2xvci5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChsYWJlbENvbG9yLmJvcmRlckRhc2ggfHwgW10pO1xuICAgICAgICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gbGFiZWxDb2xvci5ib3JkZXJEYXNoT2Zmc2V0IHx8IDA7XG4gICAgICAgICAgICBjb25zdCBvdXRlclggPSBydGxIZWxwZXIubGVmdEZvckx0cihydGxDb2xvclgsIGJveFdpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGlubmVyWCA9IHJ0bEhlbHBlci5sZWZ0Rm9yTHRyKHJ0bEhlbHBlci54UGx1cyhydGxDb2xvclgsIDEpLCBib3hXaWR0aCAtIDIpO1xuICAgICAgICAgICAgY29uc3QgYm9yZGVyUmFkaXVzID0gdG9UUkJMQ29ybmVycyhsYWJlbENvbG9yLmJvcmRlclJhZGl1cyk7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUoKHYpPT52ICE9PSAwKSkge1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5tdWx0aUtleUJhY2tncm91bmQ7XG4gICAgICAgICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgICAgICAgICB4OiBvdXRlclgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGNvbG9yWSxcbiAgICAgICAgICAgICAgICAgICAgdzogYm94V2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGg6IGJveEhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBib3JkZXJSYWRpdXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gbGFiZWxDb2xvci5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgICAgIGFkZFJvdW5kZWRSZWN0UGF0aChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogaW5uZXJYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjb2xvclkgKyAxLFxuICAgICAgICAgICAgICAgICAgICB3OiBib3hXaWR0aCAtIDIsXG4gICAgICAgICAgICAgICAgICAgIGg6IGJveEhlaWdodCAtIDIsXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdGlvbnMubXVsdGlLZXlCYWNrZ3JvdW5kO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdChvdXRlclgsIGNvbG9yWSwgYm94V2lkdGgsIGJveEhlaWdodCk7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3Qob3V0ZXJYLCBjb2xvclksIGJveFdpZHRoLCBib3hIZWlnaHQpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBsYWJlbENvbG9yLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFJlY3QoaW5uZXJYLCBjb2xvclkgKyAxLCBib3hXaWR0aCAtIDIsIGJveEhlaWdodCAtIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgICB9XG4gICAgZHJhd0JvZHkocHQsIGN0eCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGJvZHkgIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IGJvZHlTcGFjaW5nICwgYm9keUFsaWduICwgZGlzcGxheUNvbG9ycyAsIGJveEhlaWdodCAsIGJveFdpZHRoICwgYm94UGFkZGluZyAgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGJvZHlGb250ID0gdG9Gb250KG9wdGlvbnMuYm9keUZvbnQpO1xuICAgICAgICBsZXQgYm9keUxpbmVIZWlnaHQgPSBib2R5Rm9udC5saW5lSGVpZ2h0O1xuICAgICAgICBsZXQgeExpbmVQYWRkaW5nID0gMDtcbiAgICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgY29uc3QgZmlsbExpbmVPZlRleHQgPSBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQobGluZSwgcnRsSGVscGVyLngocHQueCArIHhMaW5lUGFkZGluZyksIHB0LnkgKyBib2R5TGluZUhlaWdodCAvIDIpO1xuICAgICAgICAgICAgcHQueSArPSBib2R5TGluZUhlaWdodCArIGJvZHlTcGFjaW5nO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBib2R5QWxpZ25Gb3JDYWxjdWxhdGlvbiA9IHJ0bEhlbHBlci50ZXh0QWxpZ24oYm9keUFsaWduKTtcbiAgICAgICAgbGV0IGJvZHlJdGVtLCB0ZXh0Q29sb3IsIGxpbmVzLCBpLCBqLCBpbGVuLCBqbGVuO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gYm9keUFsaWduO1xuICAgICAgICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIGN0eC5mb250ID0gYm9keUZvbnQuc3RyaW5nO1xuICAgICAgICBwdC54ID0gZ2V0QWxpZ25lZFgodGhpcywgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24sIG9wdGlvbnMpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0aW9ucy5ib2R5Q29sb3I7XG4gICAgICAgIGVhY2godGhpcy5iZWZvcmVCb2R5LCBmaWxsTGluZU9mVGV4dCk7XG4gICAgICAgIHhMaW5lUGFkZGluZyA9IGRpc3BsYXlDb2xvcnMgJiYgYm9keUFsaWduRm9yQ2FsY3VsYXRpb24gIT09ICdyaWdodCcgPyBib2R5QWxpZ24gPT09ICdjZW50ZXInID8gYm94V2lkdGggLyAyICsgYm94UGFkZGluZyA6IGJveFdpZHRoICsgMiArIGJveFBhZGRpbmcgOiAwO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBib2R5Lmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBib2R5SXRlbSA9IGJvZHlbaV07XG4gICAgICAgICAgICB0ZXh0Q29sb3IgPSB0aGlzLmxhYmVsVGV4dENvbG9yc1tpXTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0ZXh0Q29sb3I7XG4gICAgICAgICAgICBlYWNoKGJvZHlJdGVtLmJlZm9yZSwgZmlsbExpbmVPZlRleHQpO1xuICAgICAgICAgICAgbGluZXMgPSBib2R5SXRlbS5saW5lcztcbiAgICAgICAgICAgIGlmIChkaXNwbGF5Q29sb3JzICYmIGxpbmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDb2xvckJveChjdHgsIHB0LCBpLCBydGxIZWxwZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gTWF0aC5tYXgoYm9keUZvbnQubGluZUhlaWdodCwgYm94SGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvcihqID0gMCwgamxlbiA9IGxpbmVzLmxlbmd0aDsgaiA8IGpsZW47ICsrail7XG4gICAgICAgICAgICAgICAgZmlsbExpbmVPZlRleHQobGluZXNbal0pO1xuICAgICAgICAgICAgICAgIGJvZHlMaW5lSGVpZ2h0ID0gYm9keUZvbnQubGluZUhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVhY2goYm9keUl0ZW0uYWZ0ZXIsIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB4TGluZVBhZGRpbmcgPSAwO1xuICAgICAgICBib2R5TGluZUhlaWdodCA9IGJvZHlGb250LmxpbmVIZWlnaHQ7XG4gICAgICAgIGVhY2godGhpcy5hZnRlckJvZHksIGZpbGxMaW5lT2ZUZXh0KTtcbiAgICAgICAgcHQueSAtPSBib2R5U3BhY2luZztcbiAgICB9XG4gICAgZHJhd0Zvb3RlcihwdCwgY3R4LCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGZvb3RlciA9IHRoaXMuZm9vdGVyO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBmb290ZXIubGVuZ3RoO1xuICAgICAgICBsZXQgZm9vdGVyRm9udCwgaTtcbiAgICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgcnRsSGVscGVyID0gZ2V0UnRsQWRhcHRlcihvcHRpb25zLnJ0bCwgdGhpcy54LCB0aGlzLndpZHRoKTtcbiAgICAgICAgICAgIHB0LnggPSBnZXRBbGlnbmVkWCh0aGlzLCBvcHRpb25zLmZvb3RlckFsaWduLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHB0LnkgKz0gb3B0aW9ucy5mb290ZXJNYXJnaW5Ub3A7XG4gICAgICAgICAgICBjdHgudGV4dEFsaWduID0gcnRsSGVscGVyLnRleHRBbGlnbihvcHRpb25zLmZvb3RlckFsaWduKTtcbiAgICAgICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGZvb3RlckZvbnQgPSB0b0ZvbnQob3B0aW9ucy5mb290ZXJGb250KTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZvb3RlckNvbG9yO1xuICAgICAgICAgICAgY3R4LmZvbnQgPSBmb290ZXJGb250LnN0cmluZztcbiAgICAgICAgICAgIGZvcihpID0gMDsgaSA8IGxlbmd0aDsgKytpKXtcbiAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQoZm9vdGVyW2ldLCBydGxIZWxwZXIueChwdC54KSwgcHQueSArIGZvb3RlckZvbnQubGluZUhlaWdodCAvIDIpO1xuICAgICAgICAgICAgICAgIHB0LnkgKz0gZm9vdGVyRm9udC5saW5lSGVpZ2h0ICsgb3B0aW9ucy5mb290ZXJTcGFjaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgeEFsaWduICwgeUFsaWduICB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyB4ICwgeSAgfSA9IHB0O1xuICAgICAgICBjb25zdCB7IHdpZHRoICwgaGVpZ2h0ICB9ID0gdG9vbHRpcFNpemU7XG4gICAgICAgIGNvbnN0IHsgdG9wTGVmdCAsIHRvcFJpZ2h0ICwgYm90dG9tTGVmdCAsIGJvdHRvbVJpZ2h0ICB9ID0gdG9UUkJMQ29ybmVycyhvcHRpb25zLmNvcm5lclJhZGl1cyk7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gb3B0aW9ucy5ib3JkZXJDb2xvcjtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdGlvbnMuYm9yZGVyV2lkdGg7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4ICsgdG9wTGVmdCwgeSk7XG4gICAgICAgIGlmICh5QWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSB0b3BSaWdodCwgeSk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgdG9wUmlnaHQpO1xuICAgICAgICBpZiAoeUFsaWduID09PSAnY2VudGVyJyAmJiB4QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJvdHRvbVJpZ2h0KTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBib3R0b21SaWdodCwgeSArIGhlaWdodCk7XG4gICAgICAgIGlmICh5QWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYXdDYXJldChwdCwgY3R4LCB0b29sdGlwU2l6ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgYm90dG9tTGVmdCwgeSArIGhlaWdodCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHkgKyBoZWlnaHQsIHgsIHkgKyBoZWlnaHQgLSBib3R0b21MZWZ0KTtcbiAgICAgICAgaWYgKHlBbGlnbiA9PT0gJ2NlbnRlcicgJiYgeEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhd0NhcmV0KHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjdHgubGluZVRvKHgsIHkgKyB0b3BMZWZ0KTtcbiAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIHRvcExlZnQsIHkpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuIF91cGRhdGVBbmltYXRpb25UYXJnZXQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgICAgIGNvbnN0IGFuaW1zID0gdGhpcy4kYW5pbWF0aW9ucztcbiAgICAgICAgY29uc3QgYW5pbVggPSBhbmltcyAmJiBhbmltcy54O1xuICAgICAgICBjb25zdCBhbmltWSA9IGFuaW1zICYmIGFuaW1zLnk7XG4gICAgICAgIGlmIChhbmltWCB8fCBhbmltWSkge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBwb3NpdGlvbmVyc1tvcHRpb25zLnBvc2l0aW9uXS5jYWxsKHRoaXMsIHRoaXMuX2FjdGl2ZSwgdGhpcy5fZXZlbnRQb3NpdGlvbik7XG4gICAgICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NpemUgPSBnZXRUb29sdGlwU2l6ZSh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQW5kU2l6ZSA9IE9iamVjdC5hc3NpZ24oe30sIHBvc2l0aW9uLCB0aGlzLl9zaXplKTtcbiAgICAgICAgICAgIGNvbnN0IGFsaWdubWVudCA9IGRldGVybWluZUFsaWdubWVudChjaGFydCwgb3B0aW9ucywgcG9zaXRpb25BbmRTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ID0gZ2V0QmFja2dyb3VuZFBvaW50KG9wdGlvbnMsIHBvc2l0aW9uQW5kU2l6ZSwgYWxpZ25tZW50LCBjaGFydCk7XG4gICAgICAgICAgICBpZiAoYW5pbVguX3RvICE9PSBwb2ludC54IHx8IGFuaW1ZLl90byAhPT0gcG9pbnQueSkge1xuICAgICAgICAgICAgICAgIHRoaXMueEFsaWduID0gYWxpZ25tZW50LnhBbGlnbjtcbiAgICAgICAgICAgICAgICB0aGlzLnlBbGlnbiA9IGFsaWdubWVudC55QWxpZ247XG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcmV0WCA9IHBvc2l0aW9uLng7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXJldFkgPSBwb3NpdGlvbi55O1xuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc29sdmVBbmltYXRpb25zKCkudXBkYXRlKHRoaXMsIHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiBfd2lsbFJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5vcGFjaXR5O1xuICAgIH1cbiAgICBkcmF3KGN0eCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KCkpO1xuICAgICAgICBsZXQgb3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICAgICAgaWYgKCFvcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlQW5pbWF0aW9uVGFyZ2V0KG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB0b29sdGlwU2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBwdCA9IHtcbiAgICAgICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgICAgIHk6IHRoaXMueVxuICAgICAgICB9O1xuICAgICAgICBvcGFjaXR5ID0gTWF0aC5hYnMob3BhY2l0eSkgPCAxZS0zID8gMCA6IG9wYWNpdHk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSB0b1BhZGRpbmcob3B0aW9ucy5wYWRkaW5nKTtcbiAgICAgICAgY29uc3QgaGFzVG9vbHRpcENvbnRlbnQgPSB0aGlzLnRpdGxlLmxlbmd0aCB8fCB0aGlzLmJlZm9yZUJvZHkubGVuZ3RoIHx8IHRoaXMuYm9keS5sZW5ndGggfHwgdGhpcy5hZnRlckJvZHkubGVuZ3RoIHx8IHRoaXMuZm9vdGVyLmxlbmd0aDtcbiAgICAgICAgaWYgKG9wdGlvbnMuZW5hYmxlZCAmJiBoYXNUb29sdGlwQ29udGVudCkge1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XG4gICAgICAgICAgICB0aGlzLmRyYXdCYWNrZ3JvdW5kKHB0LCBjdHgsIHRvb2x0aXBTaXplLCBvcHRpb25zKTtcbiAgICAgICAgICAgIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIG9wdGlvbnMudGV4dERpcmVjdGlvbik7XG4gICAgICAgICAgICBwdC55ICs9IHBhZGRpbmcudG9wO1xuICAgICAgICAgICAgdGhpcy5kcmF3VGl0bGUocHQsIGN0eCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLmRyYXdCb2R5KHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5kcmF3Rm9vdGVyKHB0LCBjdHgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmVzdG9yZVRleHREaXJlY3Rpb24oY3R4LCBvcHRpb25zLnRleHREaXJlY3Rpb24pO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiBnZXRBY3RpdmVFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICB9XG4gc2V0QWN0aXZlRWxlbWVudHMoYWN0aXZlRWxlbWVudHMsIGV2ZW50UG9zaXRpb24pIHtcbiAgICAgICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gYWN0aXZlRWxlbWVudHMubWFwKCh7IGRhdGFzZXRJbmRleCAsIGluZGV4ICB9KT0+e1xuICAgICAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuY2hhcnQuZ2V0RGF0YXNldE1ldGEoZGF0YXNldEluZGV4KTtcbiAgICAgICAgICAgIGlmICghbWV0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgYSBkYXRhc2V0IGF0IGluZGV4ICcgKyBkYXRhc2V0SW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogbWV0YS5kYXRhW2luZGV4XSxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYW5nZWQgPSAhX2VsZW1lbnRzRXF1YWwobGFzdEFjdGl2ZSwgYWN0aXZlKTtcbiAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2VkID0gdGhpcy5fcG9zaXRpb25DaGFuZ2VkKGFjdGl2ZSwgZXZlbnRQb3NpdGlvbik7XG4gICAgICAgIGlmIChjaGFuZ2VkIHx8IHBvc2l0aW9uQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5fYWN0aXZlID0gYWN0aXZlO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRQb3NpdGlvbiA9IGV2ZW50UG9zaXRpb247XG4gICAgICAgICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUodHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gaGFuZGxlRXZlbnQoZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSA9IHRydWUpIHtcbiAgICAgICAgaWYgKHJlcGxheSAmJiB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pZ25vcmVSZXBsYXlFdmVudHMgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgbGFzdEFjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCBbXTtcbiAgICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlZCA9IHRoaXMuX3Bvc2l0aW9uQ2hhbmdlZChhY3RpdmUsIGUpO1xuICAgICAgICBjb25zdCBjaGFuZ2VkID0gcmVwbGF5IHx8ICFfZWxlbWVudHNFcXVhbChhY3RpdmUsIGxhc3RBY3RpdmUpIHx8IHBvc2l0aW9uQ2hhbmdlZDtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2FjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVuYWJsZWQgfHwgb3B0aW9ucy5leHRlcm5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50UG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGUueCxcbiAgICAgICAgICAgICAgICAgICAgeTogZS55XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSh0cnVlLCByZXBsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cbiBfZ2V0QWN0aXZlRWxlbWVudHMoZSwgbGFzdEFjdGl2ZSwgcmVwbGF5LCBpbkNoYXJ0QXJlYSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAoZS50eXBlID09PSAnbW91c2VvdXQnKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbkNoYXJ0QXJlYSkge1xuICAgICAgICAgICAgcmV0dXJuIGxhc3RBY3RpdmUuZmlsdGVyKChpKT0+dGhpcy5jaGFydC5kYXRhLmRhdGFzZXRzW2kuZGF0YXNldEluZGV4XSAmJiB0aGlzLmNoYXJ0LmdldERhdGFzZXRNZXRhKGkuZGF0YXNldEluZGV4KS5jb250cm9sbGVyLmdldFBhcnNlZChpLmluZGV4KSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY3RpdmUgPSB0aGlzLmNoYXJ0LmdldEVsZW1lbnRzQXRFdmVudEZvck1vZGUoZSwgb3B0aW9ucy5tb2RlLCBvcHRpb25zLCByZXBsYXkpO1xuICAgICAgICBpZiAob3B0aW9ucy5yZXZlcnNlKSB7XG4gICAgICAgICAgICBhY3RpdmUucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY3RpdmU7XG4gICAgfVxuIF9wb3NpdGlvbkNoYW5nZWQoYWN0aXZlLCBlKSB7XG4gICAgICAgIGNvbnN0IHsgY2FyZXRYICwgY2FyZXRZICwgb3B0aW9ucyAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gcG9zaXRpb25lcnNbb3B0aW9ucy5wb3NpdGlvbl0uY2FsbCh0aGlzLCBhY3RpdmUsIGUpO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24gIT09IGZhbHNlICYmIChjYXJldFggIT09IHBvc2l0aW9uLnggfHwgY2FyZXRZICE9PSBwb3NpdGlvbi55KTtcbiAgICB9XG59XG52YXIgcGx1Z2luX3Rvb2x0aXAgPSB7XG4gICAgaWQ6ICd0b29sdGlwJyxcbiAgICBfZWxlbWVudDogVG9vbHRpcCxcbiAgICBwb3NpdGlvbmVycyxcbiAgICBhZnRlckluaXQgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAgICAgY2hhcnQudG9vbHRpcCA9IG5ldyBUb29sdGlwKHtcbiAgICAgICAgICAgICAgICBjaGFydCxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgYmVmb3JlVXBkYXRlIChjaGFydCwgX2FyZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGNoYXJ0LnRvb2x0aXApIHtcbiAgICAgICAgICAgIGNoYXJ0LnRvb2x0aXAuaW5pdGlhbGl6ZShvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVzZXQgKGNoYXJ0LCBfYXJncywgb3B0aW9ucykge1xuICAgICAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgICAgICAgY2hhcnQudG9vbHRpcC5pbml0aWFsaXplKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZnRlckRyYXcgKGNoYXJ0KSB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXAgPSBjaGFydC50b29sdGlwO1xuICAgICAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLl93aWxsUmVuZGVyKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjaGFydC5ub3RpZnlQbHVnaW5zKCdiZWZvcmVUb29sdGlwRHJhdycsIHtcbiAgICAgICAgICAgICAgICAuLi5hcmdzLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgICAgICAgIH0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvb2x0aXAuZHJhdyhjaGFydC5jdHgpO1xuICAgICAgICAgICAgY2hhcnQubm90aWZ5UGx1Z2lucygnYWZ0ZXJUb29sdGlwRHJhdycsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZnRlckV2ZW50IChjaGFydCwgYXJncykge1xuICAgICAgICBpZiAoY2hhcnQudG9vbHRpcCkge1xuICAgICAgICAgICAgY29uc3QgdXNlRmluYWxQb3NpdGlvbiA9IGFyZ3MucmVwbGF5O1xuICAgICAgICAgICAgaWYgKGNoYXJ0LnRvb2x0aXAuaGFuZGxlRXZlbnQoYXJncy5ldmVudCwgdXNlRmluYWxQb3NpdGlvbiwgYXJncy5pbkNoYXJ0QXJlYSkpIHtcbiAgICAgICAgICAgICAgICBhcmdzLmNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBkZWZhdWx0czoge1xuICAgICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgICBleHRlcm5hbDogbnVsbCxcbiAgICAgICAgcG9zaXRpb246ICdhdmVyYWdlJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjgpJyxcbiAgICAgICAgdGl0bGVDb2xvcjogJyNmZmYnLFxuICAgICAgICB0aXRsZUZvbnQ6IHtcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlU3BhY2luZzogMixcbiAgICAgICAgdGl0bGVNYXJnaW5Cb3R0b206IDYsXG4gICAgICAgIHRpdGxlQWxpZ246ICdsZWZ0JyxcbiAgICAgICAgYm9keUNvbG9yOiAnI2ZmZicsXG4gICAgICAgIGJvZHlTcGFjaW5nOiAyLFxuICAgICAgICBib2R5Rm9udDoge30sXG4gICAgICAgIGJvZHlBbGlnbjogJ2xlZnQnLFxuICAgICAgICBmb290ZXJDb2xvcjogJyNmZmYnLFxuICAgICAgICBmb290ZXJTcGFjaW5nOiAyLFxuICAgICAgICBmb290ZXJNYXJnaW5Ub3A6IDYsXG4gICAgICAgIGZvb3RlckZvbnQ6IHtcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnXG4gICAgICAgIH0sXG4gICAgICAgIGZvb3RlckFsaWduOiAnbGVmdCcsXG4gICAgICAgIHBhZGRpbmc6IDYsXG4gICAgICAgIGNhcmV0UGFkZGluZzogMixcbiAgICAgICAgY2FyZXRTaXplOiA1LFxuICAgICAgICBjb3JuZXJSYWRpdXM6IDYsXG4gICAgICAgIGJveEhlaWdodDogKGN0eCwgb3B0cyk9Pm9wdHMuYm9keUZvbnQuc2l6ZSxcbiAgICAgICAgYm94V2lkdGg6IChjdHgsIG9wdHMpPT5vcHRzLmJvZHlGb250LnNpemUsXG4gICAgICAgIG11bHRpS2V5QmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICBkaXNwbGF5Q29sb3JzOiB0cnVlLFxuICAgICAgICBib3hQYWRkaW5nOiAwLFxuICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMCknLFxuICAgICAgICBib3JkZXJXaWR0aDogMCxcbiAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICBkdXJhdGlvbjogNDAwLFxuICAgICAgICAgICAgZWFzaW5nOiAnZWFzZU91dFF1YXJ0J1xuICAgICAgICB9LFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBudW1iZXJzOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAneCcsXG4gICAgICAgICAgICAgICAgICAgICd5JyxcbiAgICAgICAgICAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICdjYXJldFgnLFxuICAgICAgICAgICAgICAgICAgICAnY2FyZXRZJ1xuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxiYWNrczogZGVmYXVsdENhbGxiYWNrc1xuICAgIH0sXG4gICAgZGVmYXVsdFJvdXRlczoge1xuICAgICAgICBib2R5Rm9udDogJ2ZvbnQnLFxuICAgICAgICBmb290ZXJGb250OiAnZm9udCcsXG4gICAgICAgIHRpdGxlRm9udDogJ2ZvbnQnXG4gICAgfSxcbiAgICBkZXNjcmlwdG9yczoge1xuICAgICAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT5uYW1lICE9PSAnZmlsdGVyJyAmJiBuYW1lICE9PSAnaXRlbVNvcnQnICYmIG5hbWUgIT09ICdleHRlcm5hbCcsXG4gICAgICAgIF9pbmRleGFibGU6IGZhbHNlLFxuICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgIF9zY3JpcHRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIF9pbmRleGFibGU6IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgX2ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICBfZmFsbGJhY2s6ICdhbmltYXRpb24nXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZGl0aW9uYWxPcHRpb25TY29wZXM6IFtcbiAgICAgICAgJ2ludGVyYWN0aW9uJ1xuICAgIF1cbn07XG5cbnZhciBwbHVnaW5zID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuX19wcm90b19fOiBudWxsLFxuQ29sb3JzOiBwbHVnaW5fY29sb3JzLFxuRGVjaW1hdGlvbjogcGx1Z2luX2RlY2ltYXRpb24sXG5GaWxsZXI6IGluZGV4LFxuTGVnZW5kOiBwbHVnaW5fbGVnZW5kLFxuU3ViVGl0bGU6IHBsdWdpbl9zdWJ0aXRsZSxcblRpdGxlOiBwbHVnaW5fdGl0bGUsXG5Ub29sdGlwOiBwbHVnaW5fdG9vbHRpcFxufSk7XG5cbmNvbnN0IGFkZElmU3RyaW5nID0gKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpPT57XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGluZGV4ID0gbGFiZWxzLnB1c2gocmF3KSAtIDE7XG4gICAgICAgIGFkZGVkTGFiZWxzLnVuc2hpZnQoe1xuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICBsYWJlbDogcmF3XG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNOYU4ocmF3KSkge1xuICAgICAgICBpbmRleCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn07XG5mdW5jdGlvbiBmaW5kT3JBZGRMYWJlbChsYWJlbHMsIHJhdywgaW5kZXgsIGFkZGVkTGFiZWxzKSB7XG4gICAgY29uc3QgZmlyc3QgPSBsYWJlbHMuaW5kZXhPZihyYXcpO1xuICAgIGlmIChmaXJzdCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGFkZElmU3RyaW5nKGxhYmVscywgcmF3LCBpbmRleCwgYWRkZWRMYWJlbHMpO1xuICAgIH1cbiAgICBjb25zdCBsYXN0ID0gbGFiZWxzLmxhc3RJbmRleE9mKHJhdyk7XG4gICAgcmV0dXJuIGZpcnN0ICE9PSBsYXN0ID8gaW5kZXggOiBmaXJzdDtcbn1cbmNvbnN0IHZhbGlkSW5kZXggPSAoaW5kZXgsIG1heCk9PmluZGV4ID09PSBudWxsID8gbnVsbCA6IF9saW1pdFZhbHVlKE1hdGgucm91bmQoaW5kZXgpLCAwLCBtYXgpO1xuZnVuY3Rpb24gX2dldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBsYWJlbHMgPSB0aGlzLmdldExhYmVscygpO1xuICAgIGlmICh2YWx1ZSA+PSAwICYmIHZhbHVlIDwgbGFiZWxzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW3ZhbHVlXTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY2xhc3MgQ2F0ZWdvcnlTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgICBzdGF0aWMgaWQgPSAnY2F0ZWdvcnknO1xuIHN0YXRpYyBkZWZhdWx0cyA9IHtcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIGNhbGxiYWNrOiBfZ2V0TGFiZWxGb3JWYWx1ZVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcihjZmcpO1xuICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fdmFsdWVSYW5nZSA9IDA7XG4gICAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgfVxuICAgIGluaXQoc2NhbGVPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFkZGVkID0gdGhpcy5fYWRkZWRMYWJlbHM7XG4gICAgICAgIGlmIChhZGRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgaW5kZXggLCBsYWJlbCAgfSBvZiBhZGRlZCl7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsc1tpbmRleF0gPT09IGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2FkZGVkTGFiZWxzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuaW5pdChzY2FsZU9wdGlvbnMpO1xuICAgIH1cbiAgICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmKHJhdykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhYmVscyA9IHRoaXMuZ2V0TGFiZWxzKCk7XG4gICAgICAgIGluZGV4ID0gaXNGaW5pdGUoaW5kZXgpICYmIGxhYmVsc1tpbmRleF0gPT09IHJhdyA/IGluZGV4IDogZmluZE9yQWRkTGFiZWwobGFiZWxzLCByYXcsIHZhbHVlT3JEZWZhdWx0KGluZGV4LCByYXcpLCB0aGlzLl9hZGRlZExhYmVscyk7XG4gICAgICAgIHJldHVybiB2YWxpZEluZGV4KGluZGV4LCBsYWJlbHMubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICAgIGNvbnN0IHsgbWluRGVmaW5lZCAsIG1heERlZmluZWQgIH0gPSB0aGlzLmdldFVzZXJCb3VuZHMoKTtcbiAgICAgICAgbGV0IHsgbWluICwgbWF4ICB9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYm91bmRzID09PSAndGlja3MnKSB7XG4gICAgICAgICAgICBpZiAoIW1pbkRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtaW4gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFtYXhEZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gdGhpcy5nZXRMYWJlbHMoKS5sZW5ndGggLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWluID0gbWluO1xuICAgICAgICB0aGlzLm1heCA9IG1heDtcbiAgICB9XG4gICAgYnVpbGRUaWNrcygpIHtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLm9wdGlvbnMub2Zmc2V0O1xuICAgICAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgICAgICBsZXQgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgICAgbGFiZWxzID0gbWluID09PSAwICYmIG1heCA9PT0gbGFiZWxzLmxlbmd0aCAtIDEgPyBsYWJlbHMgOiBsYWJlbHMuc2xpY2UobWluLCBtYXggKyAxKTtcbiAgICAgICAgdGhpcy5fdmFsdWVSYW5nZSA9IE1hdGgubWF4KGxhYmVscy5sZW5ndGggLSAob2Zmc2V0ID8gMCA6IDEpLCAxKTtcbiAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHRoaXMubWluIC0gKG9mZnNldCA/IDAuNSA6IDApO1xuICAgICAgICBmb3IobGV0IHZhbHVlID0gbWluOyB2YWx1ZSA8PSBtYXg7IHZhbHVlKyspe1xuICAgICAgICAgICAgdGlja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrcztcbiAgICB9XG4gICAgZ2V0TGFiZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX2dldExhYmVsRm9yVmFsdWUuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgc3VwZXIuY29uZmlndXJlKCk7XG4gICAgICAgIGlmICghdGhpcy5pc0hvcml6b250YWwoKSkge1xuICAgICAgICAgICAgdGhpcy5fcmV2ZXJzZVBpeGVscyA9ICF0aGlzLl9yZXZlcnNlUGl4ZWxzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFBpeGVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gTmFOIDogdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKHZhbHVlIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gICAgZ2V0UGl4ZWxGb3JUaWNrKGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gdGhpcy50aWNrcztcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCBpbmRleCA+IHRpY2tzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldFBpeGVsRm9yVmFsdWUodGlja3NbaW5kZXhdLnZhbHVlKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh0aGlzLl9zdGFydFZhbHVlICsgdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gICAgfVxuICAgIGdldEJhc2VQaXhlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyQxKGdlbmVyYXRpb25PcHRpb25zLCBkYXRhUmFuZ2UpIHtcbiAgICBjb25zdCB0aWNrcyA9IFtdO1xuICAgIGNvbnN0IE1JTl9TUEFDSU5HID0gMWUtMTQ7XG4gICAgY29uc3QgeyBib3VuZHMgLCBzdGVwICwgbWluICwgbWF4ICwgcHJlY2lzaW9uICwgY291bnQgLCBtYXhUaWNrcyAsIG1heERpZ2l0cyAsIGluY2x1ZGVCb3VuZHMgIH0gPSBnZW5lcmF0aW9uT3B0aW9ucztcbiAgICBjb25zdCB1bml0ID0gc3RlcCB8fCAxO1xuICAgIGNvbnN0IG1heFNwYWNlcyA9IG1heFRpY2tzIC0gMTtcbiAgICBjb25zdCB7IG1pbjogcm1pbiAsIG1heDogcm1heCAgfSA9IGRhdGFSYW5nZTtcbiAgICBjb25zdCBtaW5EZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWluKTtcbiAgICBjb25zdCBtYXhEZWZpbmVkID0gIWlzTnVsbE9yVW5kZWYobWF4KTtcbiAgICBjb25zdCBjb3VudERlZmluZWQgPSAhaXNOdWxsT3JVbmRlZihjb3VudCk7XG4gICAgY29uc3QgbWluU3BhY2luZyA9IChybWF4IC0gcm1pbikgLyAobWF4RGlnaXRzICsgMSk7XG4gICAgbGV0IHNwYWNpbmcgPSBuaWNlTnVtKChybWF4IC0gcm1pbikgLyBtYXhTcGFjZXMgLyB1bml0KSAqIHVuaXQ7XG4gICAgbGV0IGZhY3RvciwgbmljZU1pbiwgbmljZU1heCwgbnVtU3BhY2VzO1xuICAgIGlmIChzcGFjaW5nIDwgTUlOX1NQQUNJTkcgJiYgIW1pbkRlZmluZWQgJiYgIW1heERlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcm1pblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcm1heFxuICAgICAgICAgICAgfVxuICAgICAgICBdO1xuICAgIH1cbiAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwocm1heCAvIHNwYWNpbmcpIC0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZyk7XG4gICAgaWYgKG51bVNwYWNlcyA+IG1heFNwYWNlcykge1xuICAgICAgICBzcGFjaW5nID0gbmljZU51bShudW1TcGFjZXMgKiBzcGFjaW5nIC8gbWF4U3BhY2VzIC8gdW5pdCkgKiB1bml0O1xuICAgIH1cbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYocHJlY2lzaW9uKSkge1xuICAgICAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uKTtcbiAgICAgICAgc3BhY2luZyA9IE1hdGguY2VpbChzcGFjaW5nICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICB9XG4gICAgaWYgKGJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgICBuaWNlTWluID0gTWF0aC5mbG9vcihybWluIC8gc3BhY2luZykgKiBzcGFjaW5nO1xuICAgICAgICBuaWNlTWF4ID0gTWF0aC5jZWlsKHJtYXggLyBzcGFjaW5nKSAqIHNwYWNpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbmljZU1pbiA9IHJtaW47XG4gICAgICAgIG5pY2VNYXggPSBybWF4O1xuICAgIH1cbiAgICBpZiAobWluRGVmaW5lZCAmJiBtYXhEZWZpbmVkICYmIHN0ZXAgJiYgYWxtb3N0V2hvbGUoKG1heCAtIG1pbikgLyBzdGVwLCBzcGFjaW5nIC8gMTAwMCkpIHtcbiAgICAgICAgbnVtU3BhY2VzID0gTWF0aC5yb3VuZChNYXRoLm1pbigobWF4IC0gbWluKSAvIHNwYWNpbmcsIG1heFRpY2tzKSk7XG4gICAgICAgIHNwYWNpbmcgPSAobWF4IC0gbWluKSAvIG51bVNwYWNlcztcbiAgICAgICAgbmljZU1pbiA9IG1pbjtcbiAgICAgICAgbmljZU1heCA9IG1heDtcbiAgICB9IGVsc2UgaWYgKGNvdW50RGVmaW5lZCkge1xuICAgICAgICBuaWNlTWluID0gbWluRGVmaW5lZCA/IG1pbiA6IG5pY2VNaW47XG4gICAgICAgIG5pY2VNYXggPSBtYXhEZWZpbmVkID8gbWF4IDogbmljZU1heDtcbiAgICAgICAgbnVtU3BhY2VzID0gY291bnQgLSAxO1xuICAgICAgICBzcGFjaW5nID0gKG5pY2VNYXggLSBuaWNlTWluKSAvIG51bVNwYWNlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICBudW1TcGFjZXMgPSAobmljZU1heCAtIG5pY2VNaW4pIC8gc3BhY2luZztcbiAgICAgICAgaWYgKGFsbW9zdEVxdWFscyhudW1TcGFjZXMsIE1hdGgucm91bmQobnVtU3BhY2VzKSwgc3BhY2luZyAvIDEwMDApKSB7XG4gICAgICAgICAgICBudW1TcGFjZXMgPSBNYXRoLnJvdW5kKG51bVNwYWNlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBudW1TcGFjZXMgPSBNYXRoLmNlaWwobnVtU3BhY2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWNpbWFsUGxhY2VzID0gTWF0aC5tYXgoX2RlY2ltYWxQbGFjZXMoc3BhY2luZyksIF9kZWNpbWFsUGxhY2VzKG5pY2VNaW4pKTtcbiAgICBmYWN0b3IgPSBNYXRoLnBvdygxMCwgaXNOdWxsT3JVbmRlZihwcmVjaXNpb24pID8gZGVjaW1hbFBsYWNlcyA6IHByZWNpc2lvbik7XG4gICAgbmljZU1pbiA9IE1hdGgucm91bmQobmljZU1pbiAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgbmljZU1heCA9IE1hdGgucm91bmQobmljZU1heCAqIGZhY3RvcikgLyBmYWN0b3I7XG4gICAgbGV0IGogPSAwO1xuICAgIGlmIChtaW5EZWZpbmVkKSB7XG4gICAgICAgIGlmIChpbmNsdWRlQm91bmRzICYmIG5pY2VNaW4gIT09IG1pbikge1xuICAgICAgICAgICAgdGlja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG1pblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobmljZU1pbiA8IG1pbikge1xuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbG1vc3RFcXVhbHMoTWF0aC5yb3VuZCgobmljZU1pbiArIGogKiBzcGFjaW5nKSAqIGZhY3RvcikgLyBmYWN0b3IsIG1pbiwgcmVsYXRpdmVMYWJlbFNpemUobWluLCBtaW5TcGFjaW5nLCBnZW5lcmF0aW9uT3B0aW9ucykpKSB7XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5pY2VNaW4gPCBtaW4pIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IoOyBqIDwgbnVtU3BhY2VzOyArK2ope1xuICAgICAgICBjb25zdCB0aWNrVmFsdWUgPSBNYXRoLnJvdW5kKChuaWNlTWluICsgaiAqIHNwYWNpbmcpICogZmFjdG9yKSAvIGZhY3RvcjtcbiAgICAgICAgaWYgKG1heERlZmluZWQgJiYgdGlja1ZhbHVlID4gbWF4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlOiB0aWNrVmFsdWVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChtYXhEZWZpbmVkICYmIGluY2x1ZGVCb3VuZHMgJiYgbmljZU1heCAhPT0gbWF4KSB7XG4gICAgICAgIGlmICh0aWNrcy5sZW5ndGggJiYgYWxtb3N0RXF1YWxzKHRpY2tzW3RpY2tzLmxlbmd0aCAtIDFdLnZhbHVlLCBtYXgsIHJlbGF0aXZlTGFiZWxTaXplKG1heCwgbWluU3BhY2luZywgZ2VuZXJhdGlvbk9wdGlvbnMpKSkge1xuICAgICAgICAgICAgdGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUgPSBtYXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbWF4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIW1heERlZmluZWQgfHwgbmljZU1heCA9PT0gbWF4KSB7XG4gICAgICAgIHRpY2tzLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IG5pY2VNYXhcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aWNrcztcbn1cbmZ1bmN0aW9uIHJlbGF0aXZlTGFiZWxTaXplKHZhbHVlLCBtaW5TcGFjaW5nLCB7IGhvcml6b250YWwgLCBtaW5Sb3RhdGlvbiAgfSkge1xuICAgIGNvbnN0IHJhZCA9IHRvUmFkaWFucyhtaW5Sb3RhdGlvbik7XG4gICAgY29uc3QgcmF0aW8gPSAoaG9yaXpvbnRhbCA/IE1hdGguc2luKHJhZCkgOiBNYXRoLmNvcyhyYWQpKSB8fCAwLjAwMTtcbiAgICBjb25zdCBsZW5ndGggPSAwLjc1ICogbWluU3BhY2luZyAqICgnJyArIHZhbHVlKS5sZW5ndGg7XG4gICAgcmV0dXJuIE1hdGgubWluKG1pblNwYWNpbmcgLyByYXRpbywgbGVuZ3RoKTtcbn1cbmNsYXNzIExpbmVhclNjYWxlQmFzZSBleHRlbmRzIFNjYWxlIHtcbiAgICBjb25zdHJ1Y3RvcihjZmcpe1xuICAgICAgICBzdXBlcihjZmcpO1xuICAgICAgICAgdGhpcy5zdGFydCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuZW5kID0gdW5kZWZpbmVkO1xuICAgICAgICAgdGhpcy5fc3RhcnRWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuX2VuZFZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl92YWx1ZVJhbmdlID0gMDtcbiAgICB9XG4gICAgcGFyc2UocmF3LCBpbmRleCkge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZihyYXcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHR5cGVvZiByYXcgPT09ICdudW1iZXInIHx8IHJhdyBpbnN0YW5jZW9mIE51bWJlcikgJiYgIWlzRmluaXRlKCtyYXcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gK3JhdztcbiAgICB9XG4gICAgaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpIHtcbiAgICAgICAgY29uc3QgeyBiZWdpbkF0WmVybyAgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgeyBtaW5EZWZpbmVkICwgbWF4RGVmaW5lZCAgfSA9IHRoaXMuZ2V0VXNlckJvdW5kcygpO1xuICAgICAgICBsZXQgeyBtaW4gLCBtYXggIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBzZXRNaW4gPSAodik9Pm1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2O1xuICAgICAgICBjb25zdCBzZXRNYXggPSAodik9Pm1heCA9IG1heERlZmluZWQgPyBtYXggOiB2O1xuICAgICAgICBpZiAoYmVnaW5BdFplcm8pIHtcbiAgICAgICAgICAgIGNvbnN0IG1pblNpZ24gPSBzaWduKG1pbik7XG4gICAgICAgICAgICBjb25zdCBtYXhTaWduID0gc2lnbihtYXgpO1xuICAgICAgICAgICAgaWYgKG1pblNpZ24gPCAwICYmIG1heFNpZ24gPCAwKSB7XG4gICAgICAgICAgICAgICAgc2V0TWF4KDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtaW5TaWduID4gMCAmJiBtYXhTaWduID4gMCkge1xuICAgICAgICAgICAgICAgIHNldE1pbigwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgICAgIGxldCBvZmZzZXQgPSBtYXggPT09IDAgPyAxIDogTWF0aC5hYnMobWF4ICogMC4wNSk7XG4gICAgICAgICAgICBzZXRNYXgobWF4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICghYmVnaW5BdFplcm8pIHtcbiAgICAgICAgICAgICAgICBzZXRNaW4obWluIC0gb2Zmc2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgfVxuICAgIGdldFRpY2tMaW1pdCgpIHtcbiAgICAgICAgY29uc3QgdGlja09wdHMgPSB0aGlzLm9wdGlvbnMudGlja3M7XG4gICAgICAgIGxldCB7IG1heFRpY2tzTGltaXQgLCBzdGVwU2l6ZSAgfSA9IHRpY2tPcHRzO1xuICAgICAgICBsZXQgbWF4VGlja3M7XG4gICAgICAgIGlmIChzdGVwU2l6ZSkge1xuICAgICAgICAgICAgbWF4VGlja3MgPSBNYXRoLmNlaWwodGhpcy5tYXggLyBzdGVwU2l6ZSkgLSBNYXRoLmZsb29yKHRoaXMubWluIC8gc3RlcFNpemUpICsgMTtcbiAgICAgICAgICAgIGlmIChtYXhUaWNrcyA+IDEwMDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYHNjYWxlcy4ke3RoaXMuaWR9LnRpY2tzLnN0ZXBTaXplOiAke3N0ZXBTaXplfSB3b3VsZCByZXN1bHQgZ2VuZXJhdGluZyB1cCB0byAke21heFRpY2tzfSB0aWNrcy4gTGltaXRpbmcgdG8gMTAwMC5gKTtcbiAgICAgICAgICAgICAgICBtYXhUaWNrcyA9IDEwMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXhUaWNrcyA9IHRoaXMuY29tcHV0ZVRpY2tMaW1pdCgpO1xuICAgICAgICAgICAgbWF4VGlja3NMaW1pdCA9IG1heFRpY2tzTGltaXQgfHwgMTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heFRpY2tzTGltaXQpIHtcbiAgICAgICAgICAgIG1heFRpY2tzID0gTWF0aC5taW4obWF4VGlja3NMaW1pdCwgbWF4VGlja3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXhUaWNrcztcbiAgICB9XG4gY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB9XG4gICAgYnVpbGRUaWNrcygpIHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgdGlja09wdHMgPSBvcHRzLnRpY2tzO1xuICAgICAgICBsZXQgbWF4VGlja3MgPSB0aGlzLmdldFRpY2tMaW1pdCgpO1xuICAgICAgICBtYXhUaWNrcyA9IE1hdGgubWF4KDIsIG1heFRpY2tzKTtcbiAgICAgICAgY29uc3QgbnVtZXJpY0dlbmVyYXRvck9wdGlvbnMgPSB7XG4gICAgICAgICAgICBtYXhUaWNrcyxcbiAgICAgICAgICAgIGJvdW5kczogb3B0cy5ib3VuZHMsXG4gICAgICAgICAgICBtaW46IG9wdHMubWluLFxuICAgICAgICAgICAgbWF4OiBvcHRzLm1heCxcbiAgICAgICAgICAgIHByZWNpc2lvbjogdGlja09wdHMucHJlY2lzaW9uLFxuICAgICAgICAgICAgc3RlcDogdGlja09wdHMuc3RlcFNpemUsXG4gICAgICAgICAgICBjb3VudDogdGlja09wdHMuY291bnQsXG4gICAgICAgICAgICBtYXhEaWdpdHM6IHRoaXMuX21heERpZ2l0cygpLFxuICAgICAgICAgICAgaG9yaXpvbnRhbDogdGhpcy5pc0hvcml6b250YWwoKSxcbiAgICAgICAgICAgIG1pblJvdGF0aW9uOiB0aWNrT3B0cy5taW5Sb3RhdGlvbiB8fCAwLFxuICAgICAgICAgICAgaW5jbHVkZUJvdW5kczogdGlja09wdHMuaW5jbHVkZUJvdW5kcyAhPT0gZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZGF0YVJhbmdlID0gdGhpcy5fcmFuZ2UgfHwgdGhpcztcbiAgICAgICAgY29uc3QgdGlja3MgPSBnZW5lcmF0ZVRpY2tzJDEobnVtZXJpY0dlbmVyYXRvck9wdGlvbnMsIGRhdGFSYW5nZSk7XG4gICAgICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICAgICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfVxuIGNvbmZpZ3VyZSgpIHtcbiAgICAgICAgY29uc3QgdGlja3MgPSB0aGlzLnRpY2tzO1xuICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLm1pbjtcbiAgICAgICAgbGV0IGVuZCA9IHRoaXMubWF4O1xuICAgICAgICBzdXBlci5jb25maWd1cmUoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vZmZzZXQgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoZW5kIC0gc3RhcnQpIC8gTWF0aC5tYXgodGlja3MubGVuZ3RoIC0gMSwgMSkgLyAyO1xuICAgICAgICAgICAgc3RhcnQgLT0gb2Zmc2V0O1xuICAgICAgICAgICAgZW5kICs9IG9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuX2VuZFZhbHVlID0gZW5kO1xuICAgICAgICB0aGlzLl92YWx1ZVJhbmdlID0gZW5kIC0gc3RhcnQ7XG4gICAgfVxuICAgIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdE51bWJlcih2YWx1ZSwgdGhpcy5jaGFydC5vcHRpb25zLmxvY2FsZSwgdGhpcy5vcHRpb25zLnRpY2tzLmZvcm1hdCk7XG4gICAgfVxufVxuXG5jbGFzcyBMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gICAgc3RhdGljIGlkID0gJ2xpbmVhcic7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXRlcm1pbmVEYXRhTGltaXRzKCkge1xuICAgICAgICBjb25zdCB7IG1pbiAsIG1heCAgfSA9IHRoaXMuZ2V0TWluTWF4KHRydWUpO1xuICAgICAgICB0aGlzLm1pbiA9IGlzTnVtYmVyRmluaXRlKG1pbikgPyBtaW4gOiAwO1xuICAgICAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBtYXggOiAxO1xuICAgICAgICB0aGlzLmhhbmRsZVRpY2tSYW5nZU9wdGlvbnMoKTtcbiAgICB9XG4gY29tcHV0ZVRpY2tMaW1pdCgpIHtcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbCA9IHRoaXMuaXNIb3Jpem9udGFsKCk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGhvcml6b250YWwgPyB0aGlzLndpZHRoIDogdGhpcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IG1pblJvdGF0aW9uID0gdG9SYWRpYW5zKHRoaXMub3B0aW9ucy50aWNrcy5taW5Sb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IHJhdGlvID0gKGhvcml6b250YWwgPyBNYXRoLnNpbihtaW5Sb3RhdGlvbikgOiBNYXRoLmNvcyhtaW5Sb3RhdGlvbikpIHx8IDAuMDAxO1xuICAgICAgICBjb25zdCB0aWNrRm9udCA9IHRoaXMuX3Jlc29sdmVUaWNrRm9udE9wdGlvbnMoMCk7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwobGVuZ3RoIC8gTWF0aC5taW4oNDAsIHRpY2tGb250LmxpbmVIZWlnaHQgLyByYXRpbykpO1xuICAgIH1cbiAgICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6IHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKCh2YWx1ZSAtIHRoaXMuX3N0YXJ0VmFsdWUpIC8gdGhpcy5fdmFsdWVSYW5nZSk7XG4gICAgfVxuICAgIGdldFZhbHVlRm9yUGl4ZWwocGl4ZWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0VmFsdWUgKyB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgKiB0aGlzLl92YWx1ZVJhbmdlO1xuICAgIH1cbn1cblxuY29uc3QgbG9nMTBGbG9vciA9ICh2KT0+TWF0aC5mbG9vcihsb2cxMCh2KSk7XG5jb25zdCBjaGFuZ2VFeHBvbmVudCA9ICh2LCBtKT0+TWF0aC5wb3coMTAsIGxvZzEwRmxvb3IodikgKyBtKTtcbmZ1bmN0aW9uIGlzTWFqb3IodGlja1ZhbCkge1xuICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tWYWwgLyBNYXRoLnBvdygxMCwgbG9nMTBGbG9vcih0aWNrVmFsKSk7XG4gICAgcmV0dXJuIHJlbWFpbiA9PT0gMTtcbn1cbmZ1bmN0aW9uIHN0ZXBzKG1pbiwgbWF4LCByYW5nZUV4cCkge1xuICAgIGNvbnN0IHJhbmdlU3RlcCA9IE1hdGgucG93KDEwLCByYW5nZUV4cCk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKG1pbiAvIHJhbmdlU3RlcCk7XG4gICAgY29uc3QgZW5kID0gTWF0aC5jZWlsKG1heCAvIHJhbmdlU3RlcCk7XG4gICAgcmV0dXJuIGVuZCAtIHN0YXJ0O1xufVxuZnVuY3Rpb24gc3RhcnRFeHAobWluLCBtYXgpIHtcbiAgICBjb25zdCByYW5nZSA9IG1heCAtIG1pbjtcbiAgICBsZXQgcmFuZ2VFeHAgPSBsb2cxMEZsb29yKHJhbmdlKTtcbiAgICB3aGlsZShzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApID4gMTApe1xuICAgICAgICByYW5nZUV4cCsrO1xuICAgIH1cbiAgICB3aGlsZShzdGVwcyhtaW4sIG1heCwgcmFuZ2VFeHApIDwgMTApe1xuICAgICAgICByYW5nZUV4cC0tO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4ocmFuZ2VFeHAsIGxvZzEwRmxvb3IobWluKSk7XG59XG4gZnVuY3Rpb24gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgeyBtaW4gLCBtYXggIH0pIHtcbiAgICBtaW4gPSBmaW5pdGVPckRlZmF1bHQoZ2VuZXJhdGlvbk9wdGlvbnMubWluLCBtaW4pO1xuICAgIGNvbnN0IHRpY2tzID0gW107XG4gICAgY29uc3QgbWluRXhwID0gbG9nMTBGbG9vcihtaW4pO1xuICAgIGxldCBleHAgPSBzdGFydEV4cChtaW4sIG1heCk7XG4gICAgbGV0IHByZWNpc2lvbiA9IGV4cCA8IDAgPyBNYXRoLnBvdygxMCwgTWF0aC5hYnMoZXhwKSkgOiAxO1xuICAgIGNvbnN0IHN0ZXBTaXplID0gTWF0aC5wb3coMTAsIGV4cCk7XG4gICAgY29uc3QgYmFzZSA9IG1pbkV4cCA+IGV4cCA/IE1hdGgucG93KDEwLCBtaW5FeHApIDogMDtcbiAgICBjb25zdCBzdGFydCA9IE1hdGgucm91bmQoKG1pbiAtIGJhc2UpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbjtcbiAgICBjb25zdCBvZmZzZXQgPSBNYXRoLmZsb29yKChtaW4gLSBiYXNlKSAvIHN0ZXBTaXplIC8gMTApICogc3RlcFNpemUgKiAxMDtcbiAgICBsZXQgc2lnbmlmaWNhbmQgPSBNYXRoLmZsb29yKChzdGFydCAtIG9mZnNldCkgLyBNYXRoLnBvdygxMCwgZXhwKSk7XG4gICAgbGV0IHZhbHVlID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1pbiwgTWF0aC5yb3VuZCgoYmFzZSArIG9mZnNldCArIHNpZ25pZmljYW5kICogTWF0aC5wb3coMTAsIGV4cCkpICogcHJlY2lzaW9uKSAvIHByZWNpc2lvbik7XG4gICAgd2hpbGUodmFsdWUgPCBtYXgpe1xuICAgICAgICB0aWNrcy5wdXNoKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWFqb3I6IGlzTWFqb3IodmFsdWUpLFxuICAgICAgICAgICAgc2lnbmlmaWNhbmRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzaWduaWZpY2FuZCA+PSAxMCkge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmQgPSBzaWduaWZpY2FuZCA8IDE1ID8gMTUgOiAyMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ25pZmljYW5kID49IDIwKSB7XG4gICAgICAgICAgICBleHArKztcbiAgICAgICAgICAgIHNpZ25pZmljYW5kID0gMjtcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IGV4cCA+PSAwID8gMSA6IHByZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IE1hdGgucm91bmQoKGJhc2UgKyBvZmZzZXQgKyBzaWduaWZpY2FuZCAqIE1hdGgucG93KDEwLCBleHApKSAqIHByZWNpc2lvbikgLyBwcmVjaXNpb247XG4gICAgfVxuICAgIGNvbnN0IGxhc3RUaWNrID0gZmluaXRlT3JEZWZhdWx0KGdlbmVyYXRpb25PcHRpb25zLm1heCwgdmFsdWUpO1xuICAgIHRpY2tzLnB1c2goe1xuICAgICAgICB2YWx1ZTogbGFzdFRpY2ssXG4gICAgICAgIG1ham9yOiBpc01ham9yKGxhc3RUaWNrKSxcbiAgICAgICAgc2lnbmlmaWNhbmRcbiAgICB9KTtcbiAgICByZXR1cm4gdGlja3M7XG59XG5jbGFzcyBMb2dhcml0aG1pY1NjYWxlIGV4dGVuZHMgU2NhbGUge1xuICAgIHN0YXRpYyBpZCA9ICdsb2dhcml0aG1pYyc7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICB0aWNrczoge1xuICAgICAgICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubG9nYXJpdGhtaWMsXG4gICAgICAgICAgICBtYWpvcjoge1xuICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3RydWN0b3IoY2ZnKXtcbiAgICAgICAgc3VwZXIoY2ZnKTtcbiAgICAgICAgIHRoaXMuc3RhcnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLmVuZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuX3N0YXJ0VmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX3ZhbHVlUmFuZ2UgPSAwO1xuICAgIH1cbiAgICBwYXJzZShyYXcsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gTGluZWFyU2NhbGVCYXNlLnByb3RvdHlwZS5wYXJzZS5hcHBseSh0aGlzLCBbXG4gICAgICAgICAgICByYXcsXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLl96ZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSAmJiB2YWx1ZSA+IDAgPyB2YWx1ZSA6IG51bGw7XG4gICAgfVxuICAgIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICAgIGNvbnN0IHsgbWluICwgbWF4ICB9ID0gdGhpcy5nZXRNaW5NYXgodHJ1ZSk7XG4gICAgICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSA/IE1hdGgubWF4KDAsIG1pbikgOiBudWxsO1xuICAgICAgICB0aGlzLm1heCA9IGlzTnVtYmVyRmluaXRlKG1heCkgPyBNYXRoLm1heCgwLCBtYXgpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iZWdpbkF0WmVybykge1xuICAgICAgICAgICAgdGhpcy5femVybyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3plcm8gJiYgdGhpcy5taW4gIT09IHRoaXMuX3N1Z2dlc3RlZE1pbiAmJiAhaXNOdW1iZXJGaW5pdGUodGhpcy5fdXNlck1pbikpIHtcbiAgICAgICAgICAgIHRoaXMubWluID0gbWluID09PSBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgMCkgPyBjaGFuZ2VFeHBvbmVudCh0aGlzLm1pbiwgLTEpIDogY2hhbmdlRXhwb25lbnQodGhpcy5taW4sIDApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICAgIH1cbiAgICBoYW5kbGVUaWNrUmFuZ2VPcHRpb25zKCkge1xuICAgICAgICBjb25zdCB7IG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gICAgICAgIGxldCBtaW4gPSB0aGlzLm1pbjtcbiAgICAgICAgbGV0IG1heCA9IHRoaXMubWF4O1xuICAgICAgICBjb25zdCBzZXRNaW4gPSAodik9Pm1pbiA9IG1pbkRlZmluZWQgPyBtaW4gOiB2O1xuICAgICAgICBjb25zdCBzZXRNYXggPSAodik9Pm1heCA9IG1heERlZmluZWQgPyBtYXggOiB2O1xuICAgICAgICBpZiAobWluID09PSBtYXgpIHtcbiAgICAgICAgICAgIGlmIChtaW4gPD0gMCkge1xuICAgICAgICAgICAgICAgIHNldE1pbigxKTtcbiAgICAgICAgICAgICAgICBzZXRNYXgoMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWluLCAtMSkpO1xuICAgICAgICAgICAgICAgIHNldE1heChjaGFuZ2VFeHBvbmVudChtYXgsICsxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbiA8PSAwKSB7XG4gICAgICAgICAgICBzZXRNaW4oY2hhbmdlRXhwb25lbnQobWF4LCAtMSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXggPD0gMCkge1xuICAgICAgICAgICAgc2V0TWF4KGNoYW5nZUV4cG9uZW50KG1pbiwgKzEpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XG4gICAgfVxuICAgIGJ1aWxkVGlja3MoKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgbWluOiB0aGlzLl91c2VyTWluLFxuICAgICAgICAgICAgbWF4OiB0aGlzLl91c2VyTWF4XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRpY2tzID0gZ2VuZXJhdGVUaWNrcyhnZW5lcmF0aW9uT3B0aW9ucywgdGhpcyk7XG4gICAgICAgIGlmIChvcHRzLmJvdW5kcyA9PT0gJ3RpY2tzJykge1xuICAgICAgICAgICAgX3NldE1pbkFuZE1heEJ5S2V5KHRpY2tzLCB0aGlzLCAndmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5yZXZlcnNlKSB7XG4gICAgICAgICAgICB0aWNrcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdGhpcy5tYXg7XG4gICAgICAgICAgICB0aGlzLmVuZCA9IHRoaXMubWluO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHRoaXMubWluO1xuICAgICAgICAgICAgdGhpcy5lbmQgPSB0aGlzLm1heDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGlja3M7XG4gICAgfVxuIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyAnMCcgOiBmb3JtYXROdW1iZXIodmFsdWUsIHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGUsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgIH1cbiBjb25maWd1cmUoKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5taW47XG4gICAgICAgIHN1cGVyLmNvbmZpZ3VyZSgpO1xuICAgICAgICB0aGlzLl9zdGFydFZhbHVlID0gbG9nMTAoc3RhcnQpO1xuICAgICAgICB0aGlzLl92YWx1ZVJhbmdlID0gbG9nMTAodGhpcy5tYXgpIC0gbG9nMTAoc3RhcnQpO1xuICAgIH1cbiAgICBnZXRQaXhlbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHRoaXMubWluO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCBpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UGl4ZWxGb3JEZWNpbWFsKHZhbHVlID09PSB0aGlzLm1pbiA/IDAgOiAobG9nMTAodmFsdWUpIC0gdGhpcy5fc3RhcnRWYWx1ZSkgLyB0aGlzLl92YWx1ZVJhbmdlKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgICAgICBjb25zdCBkZWNpbWFsID0gdGhpcy5nZXREZWNpbWFsRm9yUGl4ZWwocGl4ZWwpO1xuICAgICAgICByZXR1cm4gTWF0aC5wb3coMTAsIHRoaXMuX3N0YXJ0VmFsdWUgKyBkZWNpbWFsICogdGhpcy5fdmFsdWVSYW5nZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaWNrQmFja2Ryb3BIZWlnaHQob3B0cykge1xuICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICBpZiAodGlja09wdHMuZGlzcGxheSAmJiBvcHRzLmRpc3BsYXkpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyh0aWNrT3B0cy5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICByZXR1cm4gdmFsdWVPckRlZmF1bHQodGlja09wdHMuZm9udCAmJiB0aWNrT3B0cy5mb250LnNpemUsIGRlZmF1bHRzLmZvbnQuc2l6ZSkgKyBwYWRkaW5nLmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBtZWFzdXJlTGFiZWxTaXplKGN0eCwgZm9udCwgbGFiZWwpIHtcbiAgICBsYWJlbCA9IGlzQXJyYXkobGFiZWwpID8gbGFiZWwgOiBbXG4gICAgICAgIGxhYmVsXG4gICAgXTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3OiBfbG9uZ2VzdFRleHQoY3R4LCBmb250LnN0cmluZywgbGFiZWwpLFxuICAgICAgICBoOiBsYWJlbC5sZW5ndGggKiBmb250LmxpbmVIZWlnaHRcbiAgICB9O1xufVxuZnVuY3Rpb24gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb3MsIHNpemUsIG1pbiwgbWF4KSB7XG4gICAgaWYgKGFuZ2xlID09PSBtaW4gfHwgYW5nbGUgPT09IG1heCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHBvcyAtIHNpemUgLyAyLFxuICAgICAgICAgICAgZW5kOiBwb3MgKyBzaXplIC8gMlxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPCBtaW4gfHwgYW5nbGUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXJ0OiBwb3MgLSBzaXplLFxuICAgICAgICAgICAgZW5kOiBwb3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6IHBvcyxcbiAgICAgICAgZW5kOiBwb3MgKyBzaXplXG4gICAgfTtcbn1cbiBmdW5jdGlvbiBmaXRXaXRoUG9pbnRMYWJlbHMoc2NhbGUpIHtcbiAgICBjb25zdCBvcmlnID0ge1xuICAgICAgICBsOiBzY2FsZS5sZWZ0ICsgc2NhbGUuX3BhZGRpbmcubGVmdCxcbiAgICAgICAgcjogc2NhbGUucmlnaHQgLSBzY2FsZS5fcGFkZGluZy5yaWdodCxcbiAgICAgICAgdDogc2NhbGUudG9wICsgc2NhbGUuX3BhZGRpbmcudG9wLFxuICAgICAgICBiOiBzY2FsZS5ib3R0b20gLSBzY2FsZS5fcGFkZGluZy5ib3R0b21cbiAgICB9O1xuICAgIGNvbnN0IGxpbWl0cyA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWcpO1xuICAgIGNvbnN0IGxhYmVsU2l6ZXMgPSBbXTtcbiAgICBjb25zdCBwYWRkaW5nID0gW107XG4gICAgY29uc3QgdmFsdWVDb3VudCA9IHNjYWxlLl9wb2ludExhYmVscy5sZW5ndGg7XG4gICAgY29uc3QgcG9pbnRMYWJlbE9wdHMgPSBzY2FsZS5vcHRpb25zLnBvaW50TGFiZWxzO1xuICAgIGNvbnN0IGFkZGl0aW9uYWxBbmdsZSA9IHBvaW50TGFiZWxPcHRzLmNlbnRlclBvaW50TGFiZWxzID8gUEkgLyB2YWx1ZUNvdW50IDogMDtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKXtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHBvaW50TGFiZWxPcHRzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBwYWRkaW5nW2ldID0gb3B0cy5wYWRkaW5nO1xuICAgICAgICBjb25zdCBwb2ludFBvc2l0aW9uID0gc2NhbGUuZ2V0UG9pbnRQb3NpdGlvbihpLCBzY2FsZS5kcmF3aW5nQXJlYSArIHBhZGRpbmdbaV0sIGFkZGl0aW9uYWxBbmdsZSk7XG4gICAgICAgIGNvbnN0IHBsRm9udCA9IHRvRm9udChvcHRzLmZvbnQpO1xuICAgICAgICBjb25zdCB0ZXh0U2l6ZSA9IG1lYXN1cmVMYWJlbFNpemUoc2NhbGUuY3R4LCBwbEZvbnQsIHNjYWxlLl9wb2ludExhYmVsc1tpXSk7XG4gICAgICAgIGxhYmVsU2l6ZXNbaV0gPSB0ZXh0U2l6ZTtcbiAgICAgICAgY29uc3QgYW5nbGVSYWRpYW5zID0gX25vcm1hbGl6ZUFuZ2xlKHNjYWxlLmdldEluZGV4QW5nbGUoaSkgKyBhZGRpdGlvbmFsQW5nbGUpO1xuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGgucm91bmQodG9EZWdyZWVzKGFuZ2xlUmFkaWFucykpO1xuICAgICAgICBjb25zdCBoTGltaXRzID0gZGV0ZXJtaW5lTGltaXRzKGFuZ2xlLCBwb2ludFBvc2l0aW9uLngsIHRleHRTaXplLncsIDAsIDE4MCk7XG4gICAgICAgIGNvbnN0IHZMaW1pdHMgPSBkZXRlcm1pbmVMaW1pdHMoYW5nbGUsIHBvaW50UG9zaXRpb24ueSwgdGV4dFNpemUuaCwgOTAsIDI3MCk7XG4gICAgICAgIHVwZGF0ZUxpbWl0cyhsaW1pdHMsIG9yaWcsIGFuZ2xlUmFkaWFucywgaExpbWl0cywgdkxpbWl0cyk7XG4gICAgfVxuICAgIHNjYWxlLnNldENlbnRlclBvaW50KG9yaWcubCAtIGxpbWl0cy5sLCBsaW1pdHMuciAtIG9yaWcuciwgb3JpZy50IC0gbGltaXRzLnQsIGxpbWl0cy5iIC0gb3JpZy5iKTtcbiAgICBzY2FsZS5fcG9pbnRMYWJlbEl0ZW1zID0gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpO1xufVxuZnVuY3Rpb24gdXBkYXRlTGltaXRzKGxpbWl0cywgb3JpZywgYW5nbGUsIGhMaW1pdHMsIHZMaW1pdHMpIHtcbiAgICBjb25zdCBzaW4gPSBNYXRoLmFicyhNYXRoLnNpbihhbmdsZSkpO1xuICAgIGNvbnN0IGNvcyA9IE1hdGguYWJzKE1hdGguY29zKGFuZ2xlKSk7XG4gICAgbGV0IHggPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICBpZiAoaExpbWl0cy5zdGFydCA8IG9yaWcubCkge1xuICAgICAgICB4ID0gKG9yaWcubCAtIGhMaW1pdHMuc3RhcnQpIC8gc2luO1xuICAgICAgICBsaW1pdHMubCA9IE1hdGgubWluKGxpbWl0cy5sLCBvcmlnLmwgLSB4KTtcbiAgICB9IGVsc2UgaWYgKGhMaW1pdHMuZW5kID4gb3JpZy5yKSB7XG4gICAgICAgIHggPSAoaExpbWl0cy5lbmQgLSBvcmlnLnIpIC8gc2luO1xuICAgICAgICBsaW1pdHMuciA9IE1hdGgubWF4KGxpbWl0cy5yLCBvcmlnLnIgKyB4KTtcbiAgICB9XG4gICAgaWYgKHZMaW1pdHMuc3RhcnQgPCBvcmlnLnQpIHtcbiAgICAgICAgeSA9IChvcmlnLnQgLSB2TGltaXRzLnN0YXJ0KSAvIGNvcztcbiAgICAgICAgbGltaXRzLnQgPSBNYXRoLm1pbihsaW1pdHMudCwgb3JpZy50IC0geSk7XG4gICAgfSBlbHNlIGlmICh2TGltaXRzLmVuZCA+IG9yaWcuYikge1xuICAgICAgICB5ID0gKHZMaW1pdHMuZW5kIC0gb3JpZy5iKSAvIGNvcztcbiAgICAgICAgbGltaXRzLmIgPSBNYXRoLm1heChsaW1pdHMuYiwgb3JpZy5iICsgeSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGluZGV4LCBpdGVtT3B0cykge1xuICAgIGNvbnN0IG91dGVyRGlzdGFuY2UgPSBzY2FsZS5kcmF3aW5nQXJlYTtcbiAgICBjb25zdCB7IGV4dHJhICwgYWRkaXRpb25hbEFuZ2xlICwgcGFkZGluZyAsIHNpemUgIH0gPSBpdGVtT3B0cztcbiAgICBjb25zdCBwb2ludExhYmVsUG9zaXRpb24gPSBzY2FsZS5nZXRQb2ludFBvc2l0aW9uKGluZGV4LCBvdXRlckRpc3RhbmNlICsgZXh0cmEgKyBwYWRkaW5nLCBhZGRpdGlvbmFsQW5nbGUpO1xuICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5yb3VuZCh0b0RlZ3JlZXMoX25vcm1hbGl6ZUFuZ2xlKHBvaW50TGFiZWxQb3NpdGlvbi5hbmdsZSArIEhBTEZfUEkpKSk7XG4gICAgY29uc3QgeSA9IHlGb3JBbmdsZShwb2ludExhYmVsUG9zaXRpb24ueSwgc2l6ZS5oLCBhbmdsZSk7XG4gICAgY29uc3QgdGV4dEFsaWduID0gZ2V0VGV4dEFsaWduRm9yQW5nbGUoYW5nbGUpO1xuICAgIGNvbnN0IGxlZnQgPSBsZWZ0Rm9yVGV4dEFsaWduKHBvaW50TGFiZWxQb3NpdGlvbi54LCBzaXplLncsIHRleHRBbGlnbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgeDogcG9pbnRMYWJlbFBvc2l0aW9uLngsXG4gICAgICAgIHksXG4gICAgICAgIHRleHRBbGlnbixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgdG9wOiB5LFxuICAgICAgICByaWdodDogbGVmdCArIHNpemUudyxcbiAgICAgICAgYm90dG9tOiB5ICsgc2l6ZS5oXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzTm90T3ZlcmxhcHBlZChpdGVtLCBhcmVhKSB7XG4gICAgaWYgKCFhcmVhKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB7IGxlZnQgLCB0b3AgLCByaWdodCAsIGJvdHRvbSAgfSA9IGl0ZW07XG4gICAgY29uc3QgYXBleGVzSW5BcmVhID0gX2lzUG9pbnRJbkFyZWEoe1xuICAgICAgICB4OiBsZWZ0LFxuICAgICAgICB5OiB0b3BcbiAgICB9LCBhcmVhKSB8fCBfaXNQb2ludEluQXJlYSh7XG4gICAgICAgIHg6IGxlZnQsXG4gICAgICAgIHk6IGJvdHRvbVxuICAgIH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHtcbiAgICAgICAgeDogcmlnaHQsXG4gICAgICAgIHk6IHRvcFxuICAgIH0sIGFyZWEpIHx8IF9pc1BvaW50SW5BcmVhKHtcbiAgICAgICAgeDogcmlnaHQsXG4gICAgICAgIHk6IGJvdHRvbVxuICAgIH0sIGFyZWEpO1xuICAgIHJldHVybiAhYXBleGVzSW5BcmVhO1xufVxuZnVuY3Rpb24gYnVpbGRQb2ludExhYmVsSXRlbXMoc2NhbGUsIGxhYmVsU2l6ZXMsIHBhZGRpbmcpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlQ291bnQgPSBzY2FsZS5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgIGNvbnN0IG9wdHMgPSBzY2FsZS5vcHRpb25zO1xuICAgIGNvbnN0IHsgY2VudGVyUG9pbnRMYWJlbHMgLCBkaXNwbGF5ICB9ID0gb3B0cy5wb2ludExhYmVscztcbiAgICBjb25zdCBpdGVtT3B0cyA9IHtcbiAgICAgICAgZXh0cmE6IGdldFRpY2tCYWNrZHJvcEhlaWdodChvcHRzKSAvIDIsXG4gICAgICAgIGFkZGl0aW9uYWxBbmdsZTogY2VudGVyUG9pbnRMYWJlbHMgPyBQSSAvIHZhbHVlQ291bnQgOiAwXG4gICAgfTtcbiAgICBsZXQgYXJlYTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgdmFsdWVDb3VudDsgaSsrKXtcbiAgICAgICAgaXRlbU9wdHMucGFkZGluZyA9IHBhZGRpbmdbaV07XG4gICAgICAgIGl0ZW1PcHRzLnNpemUgPSBsYWJlbFNpemVzW2ldO1xuICAgICAgICBjb25zdCBpdGVtID0gY3JlYXRlUG9pbnRMYWJlbEl0ZW0oc2NhbGUsIGksIGl0ZW1PcHRzKTtcbiAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgaWYgKGRpc3BsYXkgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgaXRlbS52aXNpYmxlID0gaXNOb3RPdmVybGFwcGVkKGl0ZW0sIGFyZWEpO1xuICAgICAgICAgICAgaWYgKGl0ZW0udmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIGFyZWEgPSBpdGVtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpdGVtcztcbn1cbmZ1bmN0aW9uIGdldFRleHRBbGlnbkZvckFuZ2xlKGFuZ2xlKSB7XG4gICAgaWYgKGFuZ2xlID09PSAwIHx8IGFuZ2xlID09PSAxODApIHtcbiAgICAgICAgcmV0dXJuICdjZW50ZXInO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPCAxODApIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICB9XG4gICAgcmV0dXJuICdyaWdodCc7XG59XG5mdW5jdGlvbiBsZWZ0Rm9yVGV4dEFsaWduKHgsIHcsIGFsaWduKSB7XG4gICAgaWYgKGFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHggLT0gdztcbiAgICB9IGVsc2UgaWYgKGFsaWduID09PSAnY2VudGVyJykge1xuICAgICAgICB4IC09IHcgLyAyO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbmZ1bmN0aW9uIHlGb3JBbmdsZSh5LCBoLCBhbmdsZSkge1xuICAgIGlmIChhbmdsZSA9PT0gOTAgfHwgYW5nbGUgPT09IDI3MCkge1xuICAgICAgICB5IC09IGggLyAyO1xuICAgIH0gZWxzZSBpZiAoYW5nbGUgPiAyNzAgfHwgYW5nbGUgPCA5MCkge1xuICAgICAgICB5IC09IGg7XG4gICAgfVxuICAgIHJldHVybiB5O1xufVxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxCb3goY3R4LCBvcHRzLCBpdGVtKSB7XG4gICAgY29uc3QgeyBsZWZ0ICwgdG9wICwgcmlnaHQgLCBib3R0b20gIH0gPSBpdGVtO1xuICAgIGNvbnN0IHsgYmFja2Ryb3BDb2xvciAgfSA9IG9wdHM7XG4gICAgaWYgKCFpc051bGxPclVuZGVmKGJhY2tkcm9wQ29sb3IpKSB7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHRvVFJCTENvcm5lcnMob3B0cy5ib3JkZXJSYWRpdXMpO1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gdG9QYWRkaW5nKG9wdHMuYmFja2Ryb3BQYWRkaW5nKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGJhY2tkcm9wQ29sb3I7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wTGVmdCA9IGxlZnQgLSBwYWRkaW5nLmxlZnQ7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wVG9wID0gdG9wIC0gcGFkZGluZy50b3A7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wV2lkdGggPSByaWdodCAtIGxlZnQgKyBwYWRkaW5nLndpZHRoO1xuICAgICAgICBjb25zdCBiYWNrZHJvcEhlaWdodCA9IGJvdHRvbSAtIHRvcCArIHBhZGRpbmcuaGVpZ2h0O1xuICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhib3JkZXJSYWRpdXMpLnNvbWUoKHYpPT52ICE9PSAwKSkge1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwge1xuICAgICAgICAgICAgICAgIHg6IGJhY2tkcm9wTGVmdCxcbiAgICAgICAgICAgICAgICB5OiBiYWNrZHJvcFRvcCxcbiAgICAgICAgICAgICAgICB3OiBiYWNrZHJvcFdpZHRoLFxuICAgICAgICAgICAgICAgIGg6IGJhY2tkcm9wSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHJhZGl1czogYm9yZGVyUmFkaXVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoYmFja2Ryb3BMZWZ0LCBiYWNrZHJvcFRvcCwgYmFja2Ryb3BXaWR0aCwgYmFja2Ryb3BIZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd1BvaW50TGFiZWxzKHNjYWxlLCBsYWJlbENvdW50KSB7XG4gICAgY29uc3QgeyBjdHggLCBvcHRpb25zOiB7IHBvaW50TGFiZWxzICB9ICB9ID0gc2NhbGU7XG4gICAgZm9yKGxldCBpID0gbGFiZWxDb3VudCAtIDE7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgY29uc3QgaXRlbSA9IHNjYWxlLl9wb2ludExhYmVsSXRlbXNbaV07XG4gICAgICAgIGlmICghaXRlbS52aXNpYmxlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHBvaW50TGFiZWxzLnNldENvbnRleHQoc2NhbGUuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICBkcmF3UG9pbnRMYWJlbEJveChjdHgsIG9wdHNBdEluZGV4LCBpdGVtKTtcbiAgICAgICAgY29uc3QgcGxGb250ID0gdG9Gb250KG9wdHNBdEluZGV4LmZvbnQpO1xuICAgICAgICBjb25zdCB7IHggLCB5ICwgdGV4dEFsaWduICB9ID0gaXRlbTtcbiAgICAgICAgcmVuZGVyVGV4dChjdHgsIHNjYWxlLl9wb2ludExhYmVsc1tpXSwgeCwgeSArIHBsRm9udC5saW5lSGVpZ2h0IC8gMiwgcGxGb250LCB7XG4gICAgICAgICAgICBjb2xvcjogb3B0c0F0SW5kZXguY29sb3IsXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHRleHRBbGlnbixcbiAgICAgICAgICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpIHtcbiAgICBjb25zdCB7IGN0eCAgfSA9IHNjYWxlO1xuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgICBjdHguYXJjKHNjYWxlLnhDZW50ZXIsIHNjYWxlLnlDZW50ZXIsIHJhZGl1cywgMCwgVEFVKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oMCwgcmFkaXVzKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludFBvc2l0aW9uLngsIHBvaW50UG9zaXRpb24ueSk7XG4gICAgICAgIGZvcihsZXQgaSA9IDE7IGkgPCBsYWJlbENvdW50OyBpKyspe1xuICAgICAgICAgICAgcG9pbnRQb3NpdGlvbiA9IHNjYWxlLmdldFBvaW50UG9zaXRpb24oaSwgcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRQb3NpdGlvbi54LCBwb2ludFBvc2l0aW9uLnkpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZHJhd1JhZGl1c0xpbmUoc2NhbGUsIGdyaWRMaW5lT3B0cywgcmFkaXVzLCBsYWJlbENvdW50LCBib3JkZXJPcHRzKSB7XG4gICAgY29uc3QgY3R4ID0gc2NhbGUuY3R4O1xuICAgIGNvbnN0IGNpcmN1bGFyID0gZ3JpZExpbmVPcHRzLmNpcmN1bGFyO1xuICAgIGNvbnN0IHsgY29sb3IgLCBsaW5lV2lkdGggIH0gPSBncmlkTGluZU9wdHM7XG4gICAgaWYgKCFjaXJjdWxhciAmJiAhbGFiZWxDb3VudCB8fCAhY29sb3IgfHwgIWxpbmVXaWR0aCB8fCByYWRpdXMgPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvcjtcbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgIGN0eC5zZXRMaW5lRGFzaChib3JkZXJPcHRzLmRhc2ggfHwgW10pO1xuICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGJvcmRlck9wdHMuZGFzaE9mZnNldDtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgcGF0aFJhZGl1c0xpbmUoc2NhbGUsIHJhZGl1cywgY2lyY3VsYXIsIGxhYmVsQ291bnQpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBvaW50TGFiZWxDb250ZXh0KHBhcmVudCwgaW5kZXgsIGxhYmVsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNvbnRleHQocGFyZW50LCB7XG4gICAgICAgIGxhYmVsLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgdHlwZTogJ3BvaW50TGFiZWwnXG4gICAgfSk7XG59XG5jbGFzcyBSYWRpYWxMaW5lYXJTY2FsZSBleHRlbmRzIExpbmVhclNjYWxlQmFzZSB7XG4gICAgc3RhdGljIGlkID0gJ3JhZGlhbExpbmVhcic7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICBhbmltYXRlOiB0cnVlLFxuICAgICAgICBwb3NpdGlvbjogJ2NoYXJ0QXJlYScsXG4gICAgICAgIGFuZ2xlTGluZXM6IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgICAgICBib3JkZXJEYXNoOiBbXSxcbiAgICAgICAgICAgIGJvcmRlckRhc2hPZmZzZXQ6IDAuMFxuICAgICAgICB9LFxuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgICBjaXJjdWxhcjogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRBbmdsZTogMCxcbiAgICAgICAgdGlja3M6IHtcbiAgICAgICAgICAgIHNob3dMYWJlbEJhY2tkcm9wOiB0cnVlLFxuICAgICAgICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMubnVtZXJpY1xuICAgICAgICB9LFxuICAgICAgICBwb2ludExhYmVsczoge1xuICAgICAgICAgICAgYmFja2Ryb3BDb2xvcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyLFxuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBzaXplOiAxMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbGxiYWNrIChsYWJlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYWRkaW5nOiA1LFxuICAgICAgICAgICAgY2VudGVyUG9pbnRMYWJlbHM6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHN0YXRpYyBkZWZhdWx0Um91dGVzID0ge1xuICAgICAgICAnYW5nbGVMaW5lcy5jb2xvcic6ICdib3JkZXJDb2xvcicsXG4gICAgICAgICdwb2ludExhYmVscy5jb2xvcic6ICdjb2xvcicsXG4gICAgICAgICd0aWNrcy5jb2xvcic6ICdjb2xvcidcbiAgICB9O1xuICAgIHN0YXRpYyBkZXNjcmlwdG9ycyA9IHtcbiAgICAgICAgYW5nbGVMaW5lczoge1xuICAgICAgICAgICAgX2ZhbGxiYWNrOiAnZ3JpZCdcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3RydWN0b3IoY2ZnKXtcbiAgICAgICAgc3VwZXIoY2ZnKTtcbiAgICAgICAgIHRoaXMueENlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMueUNlbnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgIHRoaXMuZHJhd2luZ0FyZWEgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLl9wb2ludExhYmVscyA9IFtdO1xuICAgICAgICB0aGlzLl9wb2ludExhYmVsSXRlbXMgPSBbXTtcbiAgICB9XG4gICAgc2V0RGltZW5zaW9ucygpIHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IHRoaXMuX3BhZGRpbmcgPSB0b1BhZGRpbmcoZ2V0VGlja0JhY2tkcm9wSGVpZ2h0KHRoaXMub3B0aW9ucykgLyAyKTtcbiAgICAgICAgY29uc3QgdyA9IHRoaXMud2lkdGggPSB0aGlzLm1heFdpZHRoIC0gcGFkZGluZy53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaGVpZ2h0ID0gdGhpcy5tYXhIZWlnaHQgLSBwYWRkaW5nLmhlaWdodDtcbiAgICAgICAgdGhpcy54Q2VudGVyID0gTWF0aC5mbG9vcih0aGlzLmxlZnQgKyB3IC8gMiArIHBhZGRpbmcubGVmdCk7XG4gICAgICAgIHRoaXMueUNlbnRlciA9IE1hdGguZmxvb3IodGhpcy50b3AgKyBoIC8gMiArIHBhZGRpbmcudG9wKTtcbiAgICAgICAgdGhpcy5kcmF3aW5nQXJlYSA9IE1hdGguZmxvb3IoTWF0aC5taW4odywgaCkgLyAyKTtcbiAgICB9XG4gICAgZGV0ZXJtaW5lRGF0YUxpbWl0cygpIHtcbiAgICAgICAgY29uc3QgeyBtaW4gLCBtYXggIH0gPSB0aGlzLmdldE1pbk1heChmYWxzZSk7XG4gICAgICAgIHRoaXMubWluID0gaXNOdW1iZXJGaW5pdGUobWluKSAmJiAhaXNOYU4obWluKSA/IG1pbiA6IDA7XG4gICAgICAgIHRoaXMubWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6IDA7XG4gICAgICAgIHRoaXMuaGFuZGxlVGlja1JhbmdlT3B0aW9ucygpO1xuICAgIH1cbiBjb21wdXRlVGlja0xpbWl0KCkge1xuICAgICAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuZHJhd2luZ0FyZWEgLyBnZXRUaWNrQmFja2Ryb3BIZWlnaHQodGhpcy5vcHRpb25zKSk7XG4gICAgfVxuICAgIGdlbmVyYXRlVGlja0xhYmVscyh0aWNrcykge1xuICAgICAgICBMaW5lYXJTY2FsZUJhc2UucHJvdG90eXBlLmdlbmVyYXRlVGlja0xhYmVscy5jYWxsKHRoaXMsIHRpY2tzKTtcbiAgICAgICAgdGhpcy5fcG9pbnRMYWJlbHMgPSB0aGlzLmdldExhYmVscygpLm1hcCgodmFsdWUsIGluZGV4KT0+e1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjYWxsYmFjayh0aGlzLm9wdGlvbnMucG9pbnRMYWJlbHMuY2FsbGJhY2ssIFtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBpbmRleFxuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwgfHwgbGFiZWwgPT09IDAgPyBsYWJlbCA6ICcnO1xuICAgICAgICB9KS5maWx0ZXIoKHYsIGkpPT50aGlzLmNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpKTtcbiAgICB9XG4gICAgZml0KCkge1xuICAgICAgICBjb25zdCBvcHRzID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBpZiAob3B0cy5kaXNwbGF5ICYmIG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgICAgICAgZml0V2l0aFBvaW50TGFiZWxzKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRDZW50ZXJQb2ludCgwLCAwLCAwLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDZW50ZXJQb2ludChsZWZ0TW92ZW1lbnQsIHJpZ2h0TW92ZW1lbnQsIHRvcE1vdmVtZW50LCBib3R0b21Nb3ZlbWVudCkge1xuICAgICAgICB0aGlzLnhDZW50ZXIgKz0gTWF0aC5mbG9vcigobGVmdE1vdmVtZW50IC0gcmlnaHRNb3ZlbWVudCkgLyAyKTtcbiAgICAgICAgdGhpcy55Q2VudGVyICs9IE1hdGguZmxvb3IoKHRvcE1vdmVtZW50IC0gYm90dG9tTW92ZW1lbnQpIC8gMik7XG4gICAgICAgIHRoaXMuZHJhd2luZ0FyZWEgLT0gTWF0aC5taW4odGhpcy5kcmF3aW5nQXJlYSAvIDIsIE1hdGgubWF4KGxlZnRNb3ZlbWVudCwgcmlnaHRNb3ZlbWVudCwgdG9wTW92ZW1lbnQsIGJvdHRvbU1vdmVtZW50KSk7XG4gICAgfVxuICAgIGdldEluZGV4QW5nbGUoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgYW5nbGVNdWx0aXBsaWVyID0gVEFVIC8gKHRoaXMuX3BvaW50TGFiZWxzLmxlbmd0aCB8fCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMub3B0aW9ucy5zdGFydEFuZ2xlIHx8IDA7XG4gICAgICAgIHJldHVybiBfbm9ybWFsaXplQW5nbGUoaW5kZXggKiBhbmdsZU11bHRpcGxpZXIgKyB0b1JhZGlhbnMoc3RhcnRBbmdsZSkpO1xuICAgIH1cbiAgICBnZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NhbGluZ0ZhY3RvciA9IHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLm1heCAtIHZhbHVlKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh2YWx1ZSAtIHRoaXMubWluKSAqIHNjYWxpbmdGYWN0b3I7XG4gICAgfVxuICAgIGdldFZhbHVlRm9yRGlzdGFuY2VGcm9tQ2VudGVyKGRpc3RhbmNlKSB7XG4gICAgICAgIGlmIChpc051bGxPclVuZGVmKGRpc3RhbmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2FsZWREaXN0YW5jZSA9IGRpc3RhbmNlIC8gKHRoaXMuZHJhd2luZ0FyZWEgLyAodGhpcy5tYXggLSB0aGlzLm1pbikpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnJldmVyc2UgPyB0aGlzLm1heCAtIHNjYWxlZERpc3RhbmNlIDogdGhpcy5taW4gKyBzY2FsZWREaXN0YW5jZTtcbiAgICB9XG4gICAgZ2V0UG9pbnRMYWJlbENvbnRleHQoaW5kZXgpIHtcbiAgICAgICAgY29uc3QgcG9pbnRMYWJlbHMgPSB0aGlzLl9wb2ludExhYmVscyB8fCBbXTtcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCBwb2ludExhYmVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50TGFiZWwgPSBwb2ludExhYmVsc1tpbmRleF07XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlUG9pbnRMYWJlbENvbnRleHQodGhpcy5nZXRDb250ZXh0KCksIGluZGV4LCBwb2ludExhYmVsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRQb2ludFBvc2l0aW9uKGluZGV4LCBkaXN0YW5jZUZyb21DZW50ZXIsIGFkZGl0aW9uYWxBbmdsZSA9IDApIHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0aGlzLmdldEluZGV4QW5nbGUoaW5kZXgpIC0gSEFMRl9QSSArIGFkZGl0aW9uYWxBbmdsZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHg6IE1hdGguY29zKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueENlbnRlcixcbiAgICAgICAgICAgIHk6IE1hdGguc2luKGFuZ2xlKSAqIGRpc3RhbmNlRnJvbUNlbnRlciArIHRoaXMueUNlbnRlcixcbiAgICAgICAgICAgIGFuZ2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFBvaW50UG9zaXRpb25Gb3JWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpbmRleCwgdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICBnZXRCYXNlUG9zaXRpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnRQb3NpdGlvbkZvclZhbHVlKGluZGV4IHx8IDAsIHRoaXMuZ2V0QmFzZVZhbHVlKCkpO1xuICAgIH1cbiAgICBnZXRQb2ludExhYmVsUG9zaXRpb24oaW5kZXgpIHtcbiAgICAgICAgY29uc3QgeyBsZWZ0ICwgdG9wICwgcmlnaHQgLCBib3R0b20gIH0gPSB0aGlzLl9wb2ludExhYmVsSXRlbXNbaW5kZXhdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGVmdCxcbiAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIHJpZ2h0LFxuICAgICAgICAgICAgYm90dG9tXG4gICAgICAgIH07XG4gICAgfVxuIGRyYXdCYWNrZ3JvdW5kKCkge1xuICAgICAgICBjb25zdCB7IGJhY2tncm91bmRDb2xvciAsIGdyaWQ6IHsgY2lyY3VsYXIgIH0gIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIHBhdGhSYWRpdXNMaW5lKHRoaXMsIHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy5fZW5kVmFsdWUpLCBjaXJjdWxhciwgdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBiYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiBkcmF3R3JpZCgpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgYW5nbGVMaW5lcyAsIGdyaWQgLCBib3JkZXIgIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCBsYWJlbENvdW50ID0gdGhpcy5fcG9pbnRMYWJlbHMubGVuZ3RoO1xuICAgICAgICBsZXQgaSwgb2Zmc2V0LCBwb3NpdGlvbjtcbiAgICAgICAgaWYgKG9wdHMucG9pbnRMYWJlbHMuZGlzcGxheSkge1xuICAgICAgICAgICAgZHJhd1BvaW50TGFiZWxzKHRoaXMsIGxhYmVsQ291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmRpc3BsYXkpIHtcbiAgICAgICAgICAgIHRoaXMudGlja3MuZm9yRWFjaCgodGljaywgaW5kZXgpPT57XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwIHx8IGluZGV4ID09PSAwICYmIHRoaXMubWluIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGlzLmdldERpc3RhbmNlRnJvbUNlbnRlckZvclZhbHVlKHRpY2sudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0c0F0SW5kZXggPSBncmlkLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4Qm9yZGVyID0gYm9yZGVyLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGRyYXdSYWRpdXNMaW5lKHRoaXMsIG9wdHNBdEluZGV4LCBvZmZzZXQsIGxhYmVsQ291bnQsIG9wdHNBdEluZGV4Qm9yZGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5nbGVMaW5lcy5kaXNwbGF5KSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgZm9yKGkgPSBsYWJlbENvdW50IC0gMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdHNBdEluZGV4ID0gYW5nbGVMaW5lcy5zZXRDb250ZXh0KHRoaXMuZ2V0UG9pbnRMYWJlbENvbnRleHQoaSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY29sb3IgLCBsaW5lV2lkdGggIH0gPSBvcHRzQXRJbmRleDtcbiAgICAgICAgICAgICAgICBpZiAoIWxpbmVXaWR0aCB8fCAhY29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICAgICAgICAgICAgY3R4LnNldExpbmVEYXNoKG9wdHNBdEluZGV4LmJvcmRlckRhc2gpO1xuICAgICAgICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9wdHNBdEluZGV4LmJvcmRlckRhc2hPZmZzZXQ7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gdGhpcy5nZXREaXN0YW5jZUZyb21DZW50ZXJGb3JWYWx1ZShvcHRzLnJldmVyc2UgPyB0aGlzLm1pbiA6IHRoaXMubWF4KTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IHRoaXMuZ2V0UG9pbnRQb3NpdGlvbihpLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjdHgubW92ZVRvKHRoaXMueENlbnRlciwgdGhpcy55Q2VudGVyKTtcbiAgICAgICAgICAgICAgICBjdHgubGluZVRvKHBvc2l0aW9uLngsIHBvc2l0aW9uLnkpO1xuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gZHJhd0JvcmRlcigpIHt9XG4gZHJhd0xhYmVscygpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnN0IG9wdHMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHRpY2tPcHRzID0gb3B0cy50aWNrcztcbiAgICAgICAgaWYgKCF0aWNrT3B0cy5kaXNwbGF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRBbmdsZSA9IHRoaXMuZ2V0SW5kZXhBbmdsZSgwKTtcbiAgICAgICAgbGV0IG9mZnNldCwgd2lkdGg7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy54Q2VudGVyLCB0aGlzLnlDZW50ZXIpO1xuICAgICAgICBjdHgucm90YXRlKHN0YXJ0QW5nbGUpO1xuICAgICAgICBjdHgudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgICAgdGhpcy50aWNrcy5mb3JFYWNoKCh0aWNrLCBpbmRleCk9PntcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiB0aGlzLm1pbiA+PSAwICYmICFvcHRzLnJldmVyc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcHRzQXRJbmRleCA9IHRpY2tPcHRzLnNldENvbnRleHQodGhpcy5nZXRDb250ZXh0KGluZGV4KSk7XG4gICAgICAgICAgICBjb25zdCB0aWNrRm9udCA9IHRvRm9udChvcHRzQXRJbmRleC5mb250KTtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZ2V0RGlzdGFuY2VGcm9tQ2VudGVyRm9yVmFsdWUodGhpcy50aWNrc1tpbmRleF0udmFsdWUpO1xuICAgICAgICAgICAgaWYgKG9wdHNBdEluZGV4LnNob3dMYWJlbEJhY2tkcm9wKSB7XG4gICAgICAgICAgICAgICAgY3R4LmZvbnQgPSB0aWNrRm9udC5zdHJpbmc7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGljay5sYWJlbCkud2lkdGg7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IG9wdHNBdEluZGV4LmJhY2tkcm9wQ29sb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFkZGluZyA9IHRvUGFkZGluZyhvcHRzQXRJbmRleC5iYWNrZHJvcFBhZGRpbmcpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsUmVjdCgtd2lkdGggLyAyIC0gcGFkZGluZy5sZWZ0LCAtb2Zmc2V0IC0gdGlja0ZvbnQuc2l6ZSAvIDIgLSBwYWRkaW5nLnRvcCwgd2lkdGggKyBwYWRkaW5nLndpZHRoLCB0aWNrRm9udC5zaXplICsgcGFkZGluZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVuZGVyVGV4dChjdHgsIHRpY2subGFiZWwsIDAsIC1vZmZzZXQsIHRpY2tGb250LCB7XG4gICAgICAgICAgICAgICAgY29sb3I6IG9wdHNBdEluZGV4LmNvbG9yLFxuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBvcHRzQXRJbmRleC50ZXh0U3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICAgICAgc3Ryb2tlV2lkdGg6IG9wdHNBdEluZGV4LnRleHRTdHJva2VXaWR0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiBkcmF3VGl0bGUoKSB7fVxufVxuXG5jb25zdCBJTlRFUlZBTFMgPSB7XG4gICAgbWlsbGlzZWNvbmQ6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiAxLFxuICAgICAgICBzdGVwczogMTAwMFxuICAgIH0sXG4gICAgc2Vjb25kOiB7XG4gICAgICAgIGNvbW1vbjogdHJ1ZSxcbiAgICAgICAgc2l6ZTogMTAwMCxcbiAgICAgICAgc3RlcHM6IDYwXG4gICAgfSxcbiAgICBtaW51dGU6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiA2MDAwMCxcbiAgICAgICAgc3RlcHM6IDYwXG4gICAgfSxcbiAgICBob3VyOiB7XG4gICAgICAgIGNvbW1vbjogdHJ1ZSxcbiAgICAgICAgc2l6ZTogMzYwMDAwMCxcbiAgICAgICAgc3RlcHM6IDI0XG4gICAgfSxcbiAgICBkYXk6IHtcbiAgICAgICAgY29tbW9uOiB0cnVlLFxuICAgICAgICBzaXplOiA4NjQwMDAwMCxcbiAgICAgICAgc3RlcHM6IDMwXG4gICAgfSxcbiAgICB3ZWVrOiB7XG4gICAgICAgIGNvbW1vbjogZmFsc2UsXG4gICAgICAgIHNpemU6IDYwNDgwMDAwMCxcbiAgICAgICAgc3RlcHM6IDRcbiAgICB9LFxuICAgIG1vbnRoOiB7XG4gICAgICAgIGNvbW1vbjogdHJ1ZSxcbiAgICAgICAgc2l6ZTogMi42MjhlOSxcbiAgICAgICAgc3RlcHM6IDEyXG4gICAgfSxcbiAgICBxdWFydGVyOiB7XG4gICAgICAgIGNvbW1vbjogZmFsc2UsXG4gICAgICAgIHNpemU6IDcuODg0ZTksXG4gICAgICAgIHN0ZXBzOiA0XG4gICAgfSxcbiAgICB5ZWFyOiB7XG4gICAgICAgIGNvbW1vbjogdHJ1ZSxcbiAgICAgICAgc2l6ZTogMy4xNTRlMTBcbiAgICB9XG59O1xuIGNvbnN0IFVOSVRTID0gIC8qICNfX1BVUkVfXyAqLyBPYmplY3Qua2V5cyhJTlRFUlZBTFMpO1xuIGZ1bmN0aW9uIHNvcnRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuIGZ1bmN0aW9uIHBhcnNlKHNjYWxlLCBpbnB1dCkge1xuICAgIGlmIChpc051bGxPclVuZGVmKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgYWRhcHRlciA9IHNjYWxlLl9hZGFwdGVyO1xuICAgIGNvbnN0IHsgcGFyc2VyICwgcm91bmQgLCBpc29XZWVrZGF5ICB9ID0gc2NhbGUuX3BhcnNlT3B0cztcbiAgICBsZXQgdmFsdWUgPSBpbnB1dDtcbiAgICBpZiAodHlwZW9mIHBhcnNlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHBhcnNlcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICghaXNOdW1iZXJGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHBhcnNlciA9PT0gJ3N0cmluZycgPyBhZGFwdGVyLnBhcnNlKHZhbHVlLCBwYXJzZXIpIDogYWRhcHRlci5wYXJzZSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHJvdW5kKSB7XG4gICAgICAgIHZhbHVlID0gcm91bmQgPT09ICd3ZWVrJyAmJiAoaXNOdW1iZXIoaXNvV2Vla2RheSkgfHwgaXNvV2Vla2RheSA9PT0gdHJ1ZSkgPyBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsICdpc29XZWVrJywgaXNvV2Vla2RheSkgOiBhZGFwdGVyLnN0YXJ0T2YodmFsdWUsIHJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuICt2YWx1ZTtcbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKG1pblVuaXQsIG1pbiwgbWF4LCBjYXBhY2l0eSkge1xuICAgIGNvbnN0IGlsZW4gPSBVTklUUy5sZW5ndGg7XG4gICAgZm9yKGxldCBpID0gVU5JVFMuaW5kZXhPZihtaW5Vbml0KTsgaSA8IGlsZW4gLSAxOyArK2kpe1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IElOVEVSVkFMU1tVTklUU1tpXV07XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IGludGVydmFsLnN0ZXBzID8gaW50ZXJ2YWwuc3RlcHMgOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgICAgaWYgKGludGVydmFsLmNvbW1vbiAmJiBNYXRoLmNlaWwoKG1heCAtIG1pbikgLyAoZmFjdG9yICogaW50ZXJ2YWwuc2l6ZSkpIDw9IGNhcGFjaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gVU5JVFNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVOSVRTW2lsZW4gLSAxXTtcbn1cbiBmdW5jdGlvbiBkZXRlcm1pbmVVbml0Rm9yRm9ybWF0dGluZyhzY2FsZSwgbnVtVGlja3MsIG1pblVuaXQsIG1pbiwgbWF4KSB7XG4gICAgZm9yKGxldCBpID0gVU5JVFMubGVuZ3RoIC0gMTsgaSA+PSBVTklUUy5pbmRleE9mKG1pblVuaXQpOyBpLS0pe1xuICAgICAgICBjb25zdCB1bml0ID0gVU5JVFNbaV07XG4gICAgICAgIGlmIChJTlRFUlZBTFNbdW5pdF0uY29tbW9uICYmIHNjYWxlLl9hZGFwdGVyLmRpZmYobWF4LCBtaW4sIHVuaXQpID49IG51bVRpY2tzIC0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuaXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFVOSVRTW21pblVuaXQgPyBVTklUUy5pbmRleE9mKG1pblVuaXQpIDogMF07XG59XG4gZnVuY3Rpb24gZGV0ZXJtaW5lTWFqb3JVbml0KHVuaXQpIHtcbiAgICBmb3IobGV0IGkgPSBVTklUUy5pbmRleE9mKHVuaXQpICsgMSwgaWxlbiA9IFVOSVRTLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGlmIChJTlRFUlZBTFNbVU5JVFNbaV1dLmNvbW1vbikge1xuICAgICAgICAgICAgcmV0dXJuIFVOSVRTW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuIGZ1bmN0aW9uIGFkZFRpY2sodGlja3MsIHRpbWUsIHRpbWVzdGFtcHMpIHtcbiAgICBpZiAoIXRpbWVzdGFtcHMpIHtcbiAgICAgICAgdGlja3NbdGltZV0gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeyBsbyAsIGhpICB9ID0gX2xvb2t1cCh0aW1lc3RhbXBzLCB0aW1lKTtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gdGltZXN0YW1wc1tsb10gPj0gdGltZSA/IHRpbWVzdGFtcHNbbG9dIDogdGltZXN0YW1wc1toaV07XG4gICAgICAgIHRpY2tzW3RpbWVzdGFtcF0gPSB0cnVlO1xuICAgIH1cbn1cbiBmdW5jdGlvbiBzZXRNYWpvclRpY2tzKHNjYWxlLCB0aWNrcywgbWFwLCBtYWpvclVuaXQpIHtcbiAgICBjb25zdCBhZGFwdGVyID0gc2NhbGUuX2FkYXB0ZXI7XG4gICAgY29uc3QgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKHRpY2tzWzBdLnZhbHVlLCBtYWpvclVuaXQpO1xuICAgIGNvbnN0IGxhc3QgPSB0aWNrc1t0aWNrcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgICBsZXQgbWFqb3IsIGluZGV4O1xuICAgIGZvcihtYWpvciA9IGZpcnN0OyBtYWpvciA8PSBsYXN0OyBtYWpvciA9ICthZGFwdGVyLmFkZChtYWpvciwgMSwgbWFqb3JVbml0KSl7XG4gICAgICAgIGluZGV4ID0gbWFwW21ham9yXTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgIHRpY2tzW2luZGV4XS5tYWpvciA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRpY2tzO1xufVxuIGZ1bmN0aW9uIHRpY2tzRnJvbVRpbWVzdGFtcHMoc2NhbGUsIHZhbHVlcywgbWFqb3JVbml0KSB7XG4gICAgY29uc3QgdGlja3MgPSBbXTtcbiAgICAgY29uc3QgbWFwID0ge307XG4gICAgY29uc3QgaWxlbiA9IHZhbHVlcy5sZW5ndGg7XG4gICAgbGV0IGksIHZhbHVlO1xuICAgIGZvcihpID0gMDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICBtYXBbdmFsdWVdID0gaTtcbiAgICAgICAgdGlja3MucHVzaCh7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1ham9yOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGlsZW4gPT09IDAgfHwgIW1ham9yVW5pdCA/IHRpY2tzIDogc2V0TWFqb3JUaWNrcyhzY2FsZSwgdGlja3MsIG1hcCwgbWFqb3JVbml0KTtcbn1cbmNsYXNzIFRpbWVTY2FsZSBleHRlbmRzIFNjYWxlIHtcbiAgICBzdGF0aWMgaWQgPSAndGltZSc7XG4gc3RhdGljIGRlZmF1bHRzID0ge1xuIGJvdW5kczogJ2RhdGEnLFxuICAgICAgICBhZGFwdGVyczoge30sXG4gICAgICAgIHRpbWU6IHtcbiAgICAgICAgICAgIHBhcnNlcjogZmFsc2UsXG4gICAgICAgICAgICB1bml0OiBmYWxzZSxcbiAgICAgICAgICAgIHJvdW5kOiBmYWxzZSxcbiAgICAgICAgICAgIGlzb1dlZWtkYXk6IGZhbHNlLFxuICAgICAgICAgICAgbWluVW5pdDogJ21pbGxpc2Vjb25kJyxcbiAgICAgICAgICAgIGRpc3BsYXlGb3JtYXRzOiB7fVxuICAgICAgICB9LFxuICAgICAgICB0aWNrczoge1xuIHNvdXJjZTogJ2F1dG8nLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGZhbHNlLFxuICAgICAgICAgICAgbWFqb3I6IHtcbiAgICAgICAgICAgICAgICBlbmFibGVkOiBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgIHRoaXMuX2NhY2hlID0ge1xuICAgICAgICAgICAgZGF0YTogW10sXG4gICAgICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAgICAgYWxsOiBbXVxuICAgICAgICB9O1xuICAgICAgICAgdGhpcy5fdW5pdCA9ICdkYXknO1xuICAgICAgICAgdGhpcy5fbWFqb3JVbml0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9vZmZzZXRzID0ge307XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGFyc2VPcHRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpbml0KHNjYWxlT3B0cywgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBzY2FsZU9wdHMudGltZSB8fCAoc2NhbGVPcHRzLnRpbWUgPSB7fSk7XG4gICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlciA9IG5ldyBhZGFwdGVycy5fZGF0ZShzY2FsZU9wdHMuYWRhcHRlcnMuZGF0ZSk7XG4gICAgICAgIGFkYXB0ZXIuaW5pdChvcHRzKTtcbiAgICAgICAgbWVyZ2VJZih0aW1lLmRpc3BsYXlGb3JtYXRzLCBhZGFwdGVyLmZvcm1hdHMoKSk7XG4gICAgICAgIHRoaXMuX3BhcnNlT3B0cyA9IHtcbiAgICAgICAgICAgIHBhcnNlcjogdGltZS5wYXJzZXIsXG4gICAgICAgICAgICByb3VuZDogdGltZS5yb3VuZCxcbiAgICAgICAgICAgIGlzb1dlZWtkYXk6IHRpbWUuaXNvV2Vla2RheVxuICAgICAgICB9O1xuICAgICAgICBzdXBlci5pbml0KHNjYWxlT3B0cyk7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWQgPSBvcHRzLm5vcm1hbGl6ZWQ7XG4gICAgfVxuIHBhcnNlKHJhdywgaW5kZXgpIHtcbiAgICAgICAgaWYgKHJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2UodGhpcywgcmF3KTtcbiAgICB9XG4gICAgYmVmb3JlTGF5b3V0KCkge1xuICAgICAgICBzdXBlci5iZWZvcmVMYXlvdXQoKTtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7XG4gICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgIGxhYmVsczogW10sXG4gICAgICAgICAgICBhbGw6IFtdXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRldGVybWluZURhdGFMaW1pdHMoKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzLl9hZGFwdGVyO1xuICAgICAgICBjb25zdCB1bml0ID0gb3B0aW9ucy50aW1lLnVuaXQgfHwgJ2RheSc7XG4gICAgICAgIGxldCB7IG1pbiAsIG1heCAsIG1pbkRlZmluZWQgLCBtYXhEZWZpbmVkICB9ID0gdGhpcy5nZXRVc2VyQm91bmRzKCk7XG4gZnVuY3Rpb24gX2FwcGx5Qm91bmRzKGJvdW5kcykge1xuICAgICAgICAgICAgaWYgKCFtaW5EZWZpbmVkICYmICFpc05hTihib3VuZHMubWluKSkge1xuICAgICAgICAgICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgYm91bmRzLm1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1heERlZmluZWQgJiYgIWlzTmFOKGJvdW5kcy5tYXgpKSB7XG4gICAgICAgICAgICAgICAgbWF4ID0gTWF0aC5tYXgobWF4LCBib3VuZHMubWF4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1pbkRlZmluZWQgfHwgIW1heERlZmluZWQpIHtcbiAgICAgICAgICAgIF9hcHBseUJvdW5kcyh0aGlzLl9nZXRMYWJlbEJvdW5kcygpKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmJvdW5kcyAhPT0gJ3RpY2tzJyB8fCBvcHRpb25zLnRpY2tzLnNvdXJjZSAhPT0gJ2xhYmVscycpIHtcbiAgICAgICAgICAgICAgICBfYXBwbHlCb3VuZHModGhpcy5nZXRNaW5NYXgoZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtaW4gPSBpc051bWJlckZpbml0ZShtaW4pICYmICFpc05hTihtaW4pID8gbWluIDogK2FkYXB0ZXIuc3RhcnRPZihEYXRlLm5vdygpLCB1bml0KTtcbiAgICAgICAgbWF4ID0gaXNOdW1iZXJGaW5pdGUobWF4KSAmJiAhaXNOYU4obWF4KSA/IG1heCA6ICthZGFwdGVyLmVuZE9mKERhdGUubm93KCksIHVuaXQpICsgMTtcbiAgICAgICAgdGhpcy5taW4gPSBNYXRoLm1pbihtaW4sIG1heCAtIDEpO1xuICAgICAgICB0aGlzLm1heCA9IE1hdGgubWF4KG1pbiArIDEsIG1heCk7XG4gICAgfVxuIF9nZXRMYWJlbEJvdW5kcygpIHtcbiAgICAgICAgY29uc3QgYXJyID0gdGhpcy5nZXRMYWJlbFRpbWVzdGFtcHMoKTtcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgaWYgKGFyci5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1pbiA9IGFyclswXTtcbiAgICAgICAgICAgIG1heCA9IGFyclthcnIubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgIG1heFxuICAgICAgICB9O1xuICAgIH1cbiBidWlsZFRpY2tzKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAgICAgY29uc3QgdGlja09wdHMgPSBvcHRpb25zLnRpY2tzO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXBzID0gdGlja09wdHMuc291cmNlID09PSAnbGFiZWxzJyA/IHRoaXMuZ2V0TGFiZWxUaW1lc3RhbXBzKCkgOiB0aGlzLl9nZW5lcmF0ZSgpO1xuICAgICAgICBpZiAob3B0aW9ucy5ib3VuZHMgPT09ICd0aWNrcycgJiYgdGltZXN0YW1wcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubWluID0gdGhpcy5fdXNlck1pbiB8fCB0aW1lc3RhbXBzWzBdO1xuICAgICAgICAgICAgdGhpcy5tYXggPSB0aGlzLl91c2VyTWF4IHx8IHRpbWVzdGFtcHNbdGltZXN0YW1wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pbjtcbiAgICAgICAgY29uc3QgbWF4ID0gdGhpcy5tYXg7XG4gICAgICAgIGNvbnN0IHRpY2tzID0gX2ZpbHRlckJldHdlZW4odGltZXN0YW1wcywgbWluLCBtYXgpO1xuICAgICAgICB0aGlzLl91bml0ID0gdGltZU9wdHMudW5pdCB8fCAodGlja09wdHMuYXV0b1NraXAgPyBkZXRlcm1pbmVVbml0Rm9yQXV0b1RpY2tzKHRpbWVPcHRzLm1pblVuaXQsIHRoaXMubWluLCB0aGlzLm1heCwgdGhpcy5fZ2V0TGFiZWxDYXBhY2l0eShtaW4pKSA6IGRldGVybWluZVVuaXRGb3JGb3JtYXR0aW5nKHRoaXMsIHRpY2tzLmxlbmd0aCwgdGltZU9wdHMubWluVW5pdCwgdGhpcy5taW4sIHRoaXMubWF4KSk7XG4gICAgICAgIHRoaXMuX21ham9yVW5pdCA9ICF0aWNrT3B0cy5tYWpvci5lbmFibGVkIHx8IHRoaXMuX3VuaXQgPT09ICd5ZWFyJyA/IHVuZGVmaW5lZCA6IGRldGVybWluZU1ham9yVW5pdCh0aGlzLl91bml0KTtcbiAgICAgICAgdGhpcy5pbml0T2Zmc2V0cyh0aW1lc3RhbXBzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xuICAgICAgICAgICAgdGlja3MucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aWNrc0Zyb21UaW1lc3RhbXBzKHRoaXMsIHRpY2tzLCB0aGlzLl9tYWpvclVuaXQpO1xuICAgIH1cbiAgICBhZnRlckF1dG9Ta2lwKCkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldEFmdGVyQXV0b3NraXApIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdE9mZnNldHModGhpcy50aWNrcy5tYXAoKHRpY2spPT4rdGljay52YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxuIGluaXRPZmZzZXRzKHRpbWVzdGFtcHMgPSBbXSkge1xuICAgICAgICBsZXQgc3RhcnQgPSAwO1xuICAgICAgICBsZXQgZW5kID0gMDtcbiAgICAgICAgbGV0IGZpcnN0LCBsYXN0O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9mZnNldCAmJiB0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgZmlyc3QgPSB0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzBdKTtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gMSAtIGZpcnN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9ICh0aGlzLmdldERlY2ltYWxGb3JWYWx1ZSh0aW1lc3RhbXBzWzFdKSAtIGZpcnN0KSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0ID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGxhc3Q7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGVuZCA9IChsYXN0IC0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodGltZXN0YW1wc1t0aW1lc3RhbXBzLmxlbmd0aCAtIDJdKSkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbWl0ID0gdGltZXN0YW1wcy5sZW5ndGggPCAzID8gMC41IDogMC4yNTtcbiAgICAgICAgc3RhcnQgPSBfbGltaXRWYWx1ZShzdGFydCwgMCwgbGltaXQpO1xuICAgICAgICBlbmQgPSBfbGltaXRWYWx1ZShlbmQsIDAsIGxpbWl0KTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0cyA9IHtcbiAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgZW5kLFxuICAgICAgICAgICAgZmFjdG9yOiAxIC8gKHN0YXJ0ICsgMSArIGVuZClcbiAgICAgICAgfTtcbiAgICB9XG4gX2dlbmVyYXRlKCkge1xuICAgICAgICBjb25zdCBhZGFwdGVyID0gdGhpcy5fYWRhcHRlcjtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCB0aW1lT3B0cyA9IG9wdGlvbnMudGltZTtcbiAgICAgICAgY29uc3QgbWlub3IgPSB0aW1lT3B0cy51bml0IHx8IGRldGVybWluZVVuaXRGb3JBdXRvVGlja3ModGltZU9wdHMubWluVW5pdCwgbWluLCBtYXgsIHRoaXMuX2dldExhYmVsQ2FwYWNpdHkobWluKSk7XG4gICAgICAgIGNvbnN0IHN0ZXBTaXplID0gdmFsdWVPckRlZmF1bHQob3B0aW9ucy50aWNrcy5zdGVwU2l6ZSwgMSk7XG4gICAgICAgIGNvbnN0IHdlZWtkYXkgPSBtaW5vciA9PT0gJ3dlZWsnID8gdGltZU9wdHMuaXNvV2Vla2RheSA6IGZhbHNlO1xuICAgICAgICBjb25zdCBoYXNXZWVrZGF5ID0gaXNOdW1iZXIod2Vla2RheSkgfHwgd2Vla2RheSA9PT0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGlja3MgPSB7fTtcbiAgICAgICAgbGV0IGZpcnN0ID0gbWluO1xuICAgICAgICBsZXQgdGltZSwgY291bnQ7XG4gICAgICAgIGlmIChoYXNXZWVrZGF5KSB7XG4gICAgICAgICAgICBmaXJzdCA9ICthZGFwdGVyLnN0YXJ0T2YoZmlyc3QsICdpc29XZWVrJywgd2Vla2RheSk7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3QgPSArYWRhcHRlci5zdGFydE9mKGZpcnN0LCBoYXNXZWVrZGF5ID8gJ2RheScgOiBtaW5vcik7XG4gICAgICAgIGlmIChhZGFwdGVyLmRpZmYobWF4LCBtaW4sIG1pbm9yKSA+IDEwMDAwMCAqIHN0ZXBTaXplKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWluICsgJyBhbmQgJyArIG1heCArICcgYXJlIHRvbyBmYXIgYXBhcnQgd2l0aCBzdGVwU2l6ZSBvZiAnICsgc3RlcFNpemUgKyAnICcgKyBtaW5vcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IG9wdGlvbnMudGlja3Muc291cmNlID09PSAnZGF0YScgJiYgdGhpcy5nZXREYXRhVGltZXN0YW1wcygpO1xuICAgICAgICBmb3IodGltZSA9IGZpcnN0LCBjb3VudCA9IDA7IHRpbWUgPCBtYXg7IHRpbWUgPSArYWRhcHRlci5hZGQodGltZSwgc3RlcFNpemUsIG1pbm9yKSwgY291bnQrKyl7XG4gICAgICAgICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGltZSA9PT0gbWF4IHx8IG9wdGlvbnMuYm91bmRzID09PSAndGlja3MnIHx8IGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICBhZGRUaWNrKHRpY2tzLCB0aW1lLCB0aW1lc3RhbXBzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGlja3MpLnNvcnQoc29ydGVyKS5tYXAoKHgpPT4reCk7XG4gICAgfVxuIGdldExhYmVsRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYWRhcHRlciA9IHRoaXMuX2FkYXB0ZXI7XG4gICAgICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgICAgIGlmICh0aW1lT3B0cy50b29sdGlwRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlci5mb3JtYXQodmFsdWUsIHRpbWVPcHRzLnRvb2x0aXBGb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhZGFwdGVyLmZvcm1hdCh2YWx1ZSwgdGltZU9wdHMuZGlzcGxheUZvcm1hdHMuZGF0ZXRpbWUpO1xuICAgIH1cbiBmb3JtYXQodmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBmb3JtYXRzID0gb3B0aW9ucy50aW1lLmRpc3BsYXlGb3JtYXRzO1xuICAgICAgICBjb25zdCB1bml0ID0gdGhpcy5fdW5pdDtcbiAgICAgICAgY29uc3QgZm10ID0gZm9ybWF0IHx8IGZvcm1hdHNbdW5pdF07XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyLmZvcm1hdCh2YWx1ZSwgZm10KTtcbiAgICB9XG4gX3RpY2tGb3JtYXRGdW5jdGlvbih0aW1lLCBpbmRleCwgdGlja3MsIGZvcm1hdCkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZXIgPSBvcHRpb25zLnRpY2tzLmNhbGxiYWNrO1xuICAgICAgICBpZiAoZm9ybWF0dGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZm9ybWF0dGVyLCBbXG4gICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICB0aWNrc1xuICAgICAgICAgICAgXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0cyA9IG9wdGlvbnMudGltZS5kaXNwbGF5Rm9ybWF0cztcbiAgICAgICAgY29uc3QgdW5pdCA9IHRoaXMuX3VuaXQ7XG4gICAgICAgIGNvbnN0IG1ham9yVW5pdCA9IHRoaXMuX21ham9yVW5pdDtcbiAgICAgICAgY29uc3QgbWlub3JGb3JtYXQgPSB1bml0ICYmIGZvcm1hdHNbdW5pdF07XG4gICAgICAgIGNvbnN0IG1ham9yRm9ybWF0ID0gbWFqb3JVbml0ICYmIGZvcm1hdHNbbWFqb3JVbml0XTtcbiAgICAgICAgY29uc3QgdGljayA9IHRpY2tzW2luZGV4XTtcbiAgICAgICAgY29uc3QgbWFqb3IgPSBtYWpvclVuaXQgJiYgbWFqb3JGb3JtYXQgJiYgdGljayAmJiB0aWNrLm1ham9yO1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRhcHRlci5mb3JtYXQodGltZSwgZm9ybWF0IHx8IChtYWpvciA/IG1ham9yRm9ybWF0IDogbWlub3JGb3JtYXQpKTtcbiAgICB9XG4gZ2VuZXJhdGVUaWNrTGFiZWxzKHRpY2tzKSB7XG4gICAgICAgIGxldCBpLCBpbGVuLCB0aWNrO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aWNrcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICAgICAgdGljayA9IHRpY2tzW2ldO1xuICAgICAgICAgICAgdGljay5sYWJlbCA9IHRoaXMuX3RpY2tGb3JtYXRGdW5jdGlvbih0aWNrLnZhbHVlLCBpLCB0aWNrcyk7XG4gICAgICAgIH1cbiAgICB9XG4gZ2V0RGVjaW1hbEZvclZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IE5hTiA6ICh2YWx1ZSAtIHRoaXMubWluKSAvICh0aGlzLm1heCAtIHRoaXMubWluKTtcbiAgICB9XG4gZ2V0UGl4ZWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5nZXREZWNpbWFsRm9yVmFsdWUodmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRQaXhlbEZvckRlY2ltYWwoKG9mZnNldHMuc3RhcnQgKyBwb3MpICogb2Zmc2V0cy5mYWN0b3IpO1xuICAgIH1cbiBnZXRWYWx1ZUZvclBpeGVsKHBpeGVsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldHMgPSB0aGlzLl9vZmZzZXRzO1xuICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldERlY2ltYWxGb3JQaXhlbChwaXhlbCkgLyBvZmZzZXRzLmZhY3RvciAtIG9mZnNldHMuZW5kO1xuICAgICAgICByZXR1cm4gdGhpcy5taW4gKyBwb3MgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gICAgfVxuIF9nZXRMYWJlbFNpemUobGFiZWwpIHtcbiAgICAgICAgY29uc3QgdGlja3NPcHRzID0gdGhpcy5vcHRpb25zLnRpY2tzO1xuICAgICAgICBjb25zdCB0aWNrTGFiZWxXaWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0b1JhZGlhbnModGhpcy5pc0hvcml6b250YWwoKSA/IHRpY2tzT3B0cy5tYXhSb3RhdGlvbiA6IHRpY2tzT3B0cy5taW5Sb3RhdGlvbik7XG4gICAgICAgIGNvbnN0IGNvc1JvdGF0aW9uID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICBjb25zdCBzaW5Sb3RhdGlvbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgY29uc3QgdGlja0ZvbnRTaXplID0gdGhpcy5fcmVzb2x2ZVRpY2tGb250T3B0aW9ucygwKS5zaXplO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdzogdGlja0xhYmVsV2lkdGggKiBjb3NSb3RhdGlvbiArIHRpY2tGb250U2l6ZSAqIHNpblJvdGF0aW9uLFxuICAgICAgICAgICAgaDogdGlja0xhYmVsV2lkdGggKiBzaW5Sb3RhdGlvbiArIHRpY2tGb250U2l6ZSAqIGNvc1JvdGF0aW9uXG4gICAgICAgIH07XG4gICAgfVxuIF9nZXRMYWJlbENhcGFjaXR5KGV4YW1wbGVUaW1lKSB7XG4gICAgICAgIGNvbnN0IHRpbWVPcHRzID0gdGhpcy5vcHRpb25zLnRpbWU7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlGb3JtYXRzID0gdGltZU9wdHMuZGlzcGxheUZvcm1hdHM7XG4gICAgICAgIGNvbnN0IGZvcm1hdCA9IGRpc3BsYXlGb3JtYXRzW3RpbWVPcHRzLnVuaXRdIHx8IGRpc3BsYXlGb3JtYXRzLm1pbGxpc2Vjb25kO1xuICAgICAgICBjb25zdCBleGFtcGxlTGFiZWwgPSB0aGlzLl90aWNrRm9ybWF0RnVuY3Rpb24oZXhhbXBsZVRpbWUsIDAsIHRpY2tzRnJvbVRpbWVzdGFtcHModGhpcywgW1xuICAgICAgICAgICAgZXhhbXBsZVRpbWVcbiAgICAgICAgXSwgdGhpcy5fbWFqb3JVbml0KSwgZm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX2dldExhYmVsU2l6ZShleGFtcGxlTGFiZWwpO1xuICAgICAgICBjb25zdCBjYXBhY2l0eSA9IE1hdGguZmxvb3IodGhpcy5pc0hvcml6b250YWwoKSA/IHRoaXMud2lkdGggLyBzaXplLncgOiB0aGlzLmhlaWdodCAvIHNpemUuaCkgLSAxO1xuICAgICAgICByZXR1cm4gY2FwYWNpdHkgPiAwID8gY2FwYWNpdHkgOiAxO1xuICAgIH1cbiBnZXREYXRhVGltZXN0YW1wcygpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5kYXRhIHx8IFtdO1xuICAgICAgICBsZXQgaSwgaWxlbjtcbiAgICAgICAgaWYgKHRpbWVzdGFtcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGltZXN0YW1wcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXRhcyA9IHRoaXMuZ2V0TWF0Y2hpbmdWaXNpYmxlTWV0YXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX25vcm1hbGl6ZWQgJiYgbWV0YXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGUuZGF0YSA9IG1ldGFzWzBdLmNvbnRyb2xsZXIuZ2V0QWxsUGFyc2VkVmFsdWVzKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IG1ldGFzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gdGltZXN0YW1wcy5jb25jYXQobWV0YXNbaV0uY29udHJvbGxlci5nZXRBbGxQYXJzZWRWYWx1ZXModGhpcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZS5kYXRhID0gdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcyk7XG4gICAgfVxuIGdldExhYmVsVGltZXN0YW1wcygpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2NhY2hlLmxhYmVscyB8fCBbXTtcbiAgICAgICAgbGV0IGksIGlsZW47XG4gICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWxzID0gdGhpcy5nZXRMYWJlbHMoKTtcbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICB0aW1lc3RhbXBzLnB1c2gocGFyc2UodGhpcywgbGFiZWxzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlLmxhYmVscyA9IHRoaXMuX25vcm1hbGl6ZWQgPyB0aW1lc3RhbXBzIDogdGhpcy5ub3JtYWxpemUodGltZXN0YW1wcyk7XG4gICAgfVxuIG5vcm1hbGl6ZSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9hcnJheVVuaXF1ZSh2YWx1ZXMuc29ydChzb3J0ZXIpKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKHRhYmxlLCB2YWwsIHJldmVyc2UpIHtcbiAgICBsZXQgbG8gPSAwO1xuICAgIGxldCBoaSA9IHRhYmxlLmxlbmd0aCAtIDE7XG4gICAgbGV0IHByZXZTb3VyY2UsIG5leHRTb3VyY2UsIHByZXZUYXJnZXQsIG5leHRUYXJnZXQ7XG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgICAgaWYgKHZhbCA+PSB0YWJsZVtsb10ucG9zICYmIHZhbCA8PSB0YWJsZVtoaV0ucG9zKSB7XG4gICAgICAgICAgICAoeyBsbyAsIGhpICB9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAncG9zJywgdmFsKSk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgcG9zOiBwcmV2U291cmNlICwgdGltZTogcHJldlRhcmdldCAgfSA9IHRhYmxlW2xvXSk7XG4gICAgICAgICh7IHBvczogbmV4dFNvdXJjZSAsIHRpbWU6IG5leHRUYXJnZXQgIH0gPSB0YWJsZVtoaV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh2YWwgPj0gdGFibGVbbG9dLnRpbWUgJiYgdmFsIDw9IHRhYmxlW2hpXS50aW1lKSB7XG4gICAgICAgICAgICAoeyBsbyAsIGhpICB9ID0gX2xvb2t1cEJ5S2V5KHRhYmxlLCAndGltZScsIHZhbCkpO1xuICAgICAgICB9XG4gICAgICAgICh7IHRpbWU6IHByZXZTb3VyY2UgLCBwb3M6IHByZXZUYXJnZXQgIH0gPSB0YWJsZVtsb10pO1xuICAgICAgICAoeyB0aW1lOiBuZXh0U291cmNlICwgcG9zOiBuZXh0VGFyZ2V0ICB9ID0gdGFibGVbaGldKTtcbiAgICB9XG4gICAgY29uc3Qgc3BhbiA9IG5leHRTb3VyY2UgLSBwcmV2U291cmNlO1xuICAgIHJldHVybiBzcGFuID8gcHJldlRhcmdldCArIChuZXh0VGFyZ2V0IC0gcHJldlRhcmdldCkgKiAodmFsIC0gcHJldlNvdXJjZSkgLyBzcGFuIDogcHJldlRhcmdldDtcbn1cbmNsYXNzIFRpbWVTZXJpZXNTY2FsZSBleHRlbmRzIFRpbWVTY2FsZSB7XG4gICAgc3RhdGljIGlkID0gJ3RpbWVzZXJpZXMnO1xuIHN0YXRpYyBkZWZhdWx0cyA9IFRpbWVTY2FsZS5kZWZhdWx0cztcbiBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgIHRoaXMuX3RhYmxlID0gW107XG4gICAgICAgICB0aGlzLl9taW5Qb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICB0aGlzLl90YWJsZVJhbmdlID0gdW5kZWZpbmVkO1xuICAgIH1cbiBpbml0T2Zmc2V0cygpIHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wcyA9IHRoaXMuX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpO1xuICAgICAgICBjb25zdCB0YWJsZSA9IHRoaXMuX3RhYmxlID0gdGhpcy5idWlsZExvb2t1cFRhYmxlKHRpbWVzdGFtcHMpO1xuICAgICAgICB0aGlzLl9taW5Qb3MgPSBpbnRlcnBvbGF0ZSh0YWJsZSwgdGhpcy5taW4pO1xuICAgICAgICB0aGlzLl90YWJsZVJhbmdlID0gaW50ZXJwb2xhdGUodGFibGUsIHRoaXMubWF4KSAtIHRoaXMuX21pblBvcztcbiAgICAgICAgc3VwZXIuaW5pdE9mZnNldHModGltZXN0YW1wcyk7XG4gICAgfVxuIGJ1aWxkTG9va3VwVGFibGUodGltZXN0YW1wcykge1xuICAgICAgICBjb25zdCB7IG1pbiAsIG1heCAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICAgIGNvbnN0IHRhYmxlID0gW107XG4gICAgICAgIGxldCBpLCBpbGVuLCBwcmV2LCBjdXJyLCBuZXh0O1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSB0aW1lc3RhbXBzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgICAgICBjdXJyID0gdGltZXN0YW1wc1tpXTtcbiAgICAgICAgICAgIGlmIChjdXJyID49IG1pbiAmJiBjdXJyIDw9IG1heCkge1xuICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2goY3Vycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBtaW4sXG4gICAgICAgICAgICAgICAgICAgIHBvczogMFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0aW1lOiBtYXgsXG4gICAgICAgICAgICAgICAgICAgIHBvczogMVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZm9yKGkgPSAwLCBpbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIG5leHQgPSBpdGVtc1tpICsgMV07XG4gICAgICAgICAgICBwcmV2ID0gaXRlbXNbaSAtIDFdO1xuICAgICAgICAgICAgY3VyciA9IGl0ZW1zW2ldO1xuICAgICAgICAgICAgaWYgKE1hdGgucm91bmQoKG5leHQgKyBwcmV2KSAvIDIpICE9PSBjdXJyKSB7XG4gICAgICAgICAgICAgICAgdGFibGUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGN1cnIsXG4gICAgICAgICAgICAgICAgICAgIHBvczogaSAvIChpbGVuIC0gMSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGU7XG4gICAgfVxuIF9nZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW47XG4gICAgICAgIGNvbnN0IG1heCA9IHRoaXMubWF4O1xuICAgICAgICBsZXQgdGltZXN0YW1wcyA9IHN1cGVyLmdldERhdGFUaW1lc3RhbXBzKCk7XG4gICAgICAgIGlmICghdGltZXN0YW1wcy5pbmNsdWRlcyhtaW4pIHx8ICF0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGltZXN0YW1wcy5zcGxpY2UoMCwgMCwgbWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRpbWVzdGFtcHMuaW5jbHVkZXMobWF4KSB8fCB0aW1lc3RhbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGltZXN0YW1wcy5wdXNoKG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHMuc29ydCgoYSwgYik9PmEgLSBiKTtcbiAgICB9XG4gX2dldFRpbWVzdGFtcHNGb3JUYWJsZSgpIHtcbiAgICAgICAgbGV0IHRpbWVzdGFtcHMgPSB0aGlzLl9jYWNoZS5hbGwgfHwgW107XG4gICAgICAgIGlmICh0aW1lc3RhbXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHRoaXMuZ2V0RGF0YVRpbWVzdGFtcHMoKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLmdldExhYmVsVGltZXN0YW1wcygpO1xuICAgICAgICBpZiAoZGF0YS5sZW5ndGggJiYgbGFiZWwubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gdGhpcy5ub3JtYWxpemUoZGF0YS5jb25jYXQobGFiZWwpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRpbWVzdGFtcHMgPSBkYXRhLmxlbmd0aCA/IGRhdGEgOiBsYWJlbDtcbiAgICAgICAgfVxuICAgICAgICB0aW1lc3RhbXBzID0gdGhpcy5fY2FjaGUuYWxsID0gdGltZXN0YW1wcztcbiAgICAgICAgcmV0dXJuIHRpbWVzdGFtcHM7XG4gICAgfVxuIGdldERlY2ltYWxGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKGludGVycG9sYXRlKHRoaXMuX3RhYmxlLCB2YWx1ZSkgLSB0aGlzLl9taW5Qb3MpIC8gdGhpcy5fdGFibGVSYW5nZTtcbiAgICB9XG4gZ2V0VmFsdWVGb3JQaXhlbChwaXhlbCkge1xuICAgICAgICBjb25zdCBvZmZzZXRzID0gdGhpcy5fb2Zmc2V0cztcbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IHRoaXMuZ2V0RGVjaW1hbEZvclBpeGVsKHBpeGVsKSAvIG9mZnNldHMuZmFjdG9yIC0gb2Zmc2V0cy5lbmQ7XG4gICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0aGlzLl90YWJsZSwgZGVjaW1hbCAqIHRoaXMuX3RhYmxlUmFuZ2UgKyB0aGlzLl9taW5Qb3MsIHRydWUpO1xuICAgIH1cbn1cblxudmFyIHNjYWxlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbl9fcHJvdG9fXzogbnVsbCxcbkNhdGVnb3J5U2NhbGU6IENhdGVnb3J5U2NhbGUsXG5MaW5lYXJTY2FsZTogTGluZWFyU2NhbGUsXG5Mb2dhcml0aG1pY1NjYWxlOiBMb2dhcml0aG1pY1NjYWxlLFxuUmFkaWFsTGluZWFyU2NhbGU6IFJhZGlhbExpbmVhclNjYWxlLFxuVGltZVNjYWxlOiBUaW1lU2NhbGUsXG5UaW1lU2VyaWVzU2NhbGU6IFRpbWVTZXJpZXNTY2FsZVxufSk7XG5cbmNvbnN0IHJlZ2lzdGVyYWJsZXMgPSBbXG4gICAgY29udHJvbGxlcnMsXG4gICAgZWxlbWVudHMsXG4gICAgcGx1Z2lucyxcbiAgICBzY2FsZXNcbl07XG5cbmV4cG9ydCB7IEFuaW1hdGlvbiwgQW5pbWF0aW9ucywgQXJjRWxlbWVudCwgQmFyQ29udHJvbGxlciwgQmFyRWxlbWVudCwgQmFzZVBsYXRmb3JtLCBCYXNpY1BsYXRmb3JtLCBCdWJibGVDb250cm9sbGVyLCBDYXRlZ29yeVNjYWxlLCBDaGFydCwgcGx1Z2luX2NvbG9ycyBhcyBDb2xvcnMsIERhdGFzZXRDb250cm9sbGVyLCBwbHVnaW5fZGVjaW1hdGlvbiBhcyBEZWNpbWF0aW9uLCBEb21QbGF0Zm9ybSwgRG91Z2hudXRDb250cm9sbGVyLCBFbGVtZW50LCBpbmRleCBhcyBGaWxsZXIsIEludGVyYWN0aW9uLCBwbHVnaW5fbGVnZW5kIGFzIExlZ2VuZCwgTGluZUNvbnRyb2xsZXIsIExpbmVFbGVtZW50LCBMaW5lYXJTY2FsZSwgTG9nYXJpdGhtaWNTY2FsZSwgUGllQ29udHJvbGxlciwgUG9pbnRFbGVtZW50LCBQb2xhckFyZWFDb250cm9sbGVyLCBSYWRhckNvbnRyb2xsZXIsIFJhZGlhbExpbmVhclNjYWxlLCBTY2FsZSwgU2NhdHRlckNvbnRyb2xsZXIsIHBsdWdpbl9zdWJ0aXRsZSBhcyBTdWJUaXRsZSwgVGlja3MsIFRpbWVTY2FsZSwgVGltZVNlcmllc1NjYWxlLCBwbHVnaW5fdGl0bGUgYXMgVGl0bGUsIHBsdWdpbl90b29sdGlwIGFzIFRvb2x0aXAsIGFkYXB0ZXJzIGFzIF9hZGFwdGVycywgX2RldGVjdFBsYXRmb3JtLCBhbmltYXRvciwgY29udHJvbGxlcnMsIGRlZmF1bHRzLCBlbGVtZW50cywgbGF5b3V0cywgcGx1Z2lucywgcmVnaXN0ZXJhYmxlcywgcmVnaXN0cnksIHNjYWxlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcnQuanMubWFwXG4iLCIvKiFcbiAqIENoYXJ0LmpzIHY0LjQuOVxuICogaHR0cHM6Ly93d3cuY2hhcnRqcy5vcmdcbiAqIChjKSAyMDI1IENoYXJ0LmpzIENvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IENvbG9yIH0gZnJvbSAnQGt1cmtsZS9jb2xvcic7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBDaGFydC5oZWxwZXJzXG4gKi8gLyoqXG4gKiBBbiBlbXB0eSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkLCBmb3IgZXhhbXBsZSwgZm9yIG9wdGlvbmFsIGNhbGxiYWNrLlxuICovIGZ1bmN0aW9uIG5vb3AoKSB7XG4vKiBub29wICovIH1cbi8qKlxuICogUmV0dXJucyBhIHVuaXF1ZSBpZCwgc2VxdWVudGlhbGx5IGdlbmVyYXRlZCBmcm9tIGEgZ2xvYmFsIHZhcmlhYmxlLlxuICovIGNvbnN0IHVpZCA9ICgoKT0+e1xuICAgIGxldCBpZCA9IDA7XG4gICAgcmV0dXJuICgpPT5pZCsrO1xufSkoKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgbmVpdGhlciBudWxsIG5vciB1bmRlZmluZWQsIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQHNpbmNlIDIuNy4wXG4gKi8gZnVuY3Rpb24gaXNOdWxsT3JVbmRlZih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSAoaW5jbHVkaW5nIHR5cGVkIGFycmF5cyksIGVsc2UgcmV0dXJucyBmYWxzZS5cbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byB0ZXN0LlxuICogQGZ1bmN0aW9uXG4gKi8gZnVuY3Rpb24gaXNBcnJheSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICBpZiAodHlwZS5zbGljZSgwLCA3KSA9PT0gJ1tvYmplY3QnICYmIHR5cGUuc2xpY2UoLTYpID09PSAnQXJyYXldJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QgKGV4Y2x1ZGluZyBudWxsKSwgZWxzZSByZXR1cm5zIGZhbHNlLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAc2luY2UgMi43LjBcbiAqLyBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgYSBmaW5pdGUgbnVtYmVyLCBlbHNlIHJldHVybnMgZmFsc2VcbiAqIEBwYXJhbSB2YWx1ZSAgLSBUaGUgdmFsdWUgdG8gdGVzdC5cbiAqLyBmdW5jdGlvbiBpc051bWJlckZpbml0ZSh2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikgJiYgaXNGaW5pdGUoK3ZhbHVlKTtcbn1cbi8qKlxuICogUmV0dXJucyBgdmFsdWVgIGlmIGZpbml0ZSwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyBub3QgZmluaXRlLlxuICovIGZ1bmN0aW9uIGZpbml0ZU9yRGVmYXVsdCh2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIGlzTnVtYmVyRmluaXRlKHZhbHVlKSA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufVxuLyoqXG4gKiBSZXR1cm5zIGB2YWx1ZWAgaWYgZGVmaW5lZCwgZWxzZSByZXR1cm5zIGBkZWZhdWx0VmFsdWVgLlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHJldHVybiBpZiBkZWZpbmVkLlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSB2YWx1ZSB0byByZXR1cm4gaWYgYHZhbHVlYCBpcyB1bmRlZmluZWQuXG4gKi8gZnVuY3Rpb24gdmFsdWVPckRlZmF1bHQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG59XG5jb25zdCB0b1BlcmNlbnRhZ2UgPSAodmFsdWUsIGRpbWVuc2lvbik9PnR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwIDogK3ZhbHVlIC8gZGltZW5zaW9uO1xuY29uc3QgdG9EaW1lbnNpb24gPSAodmFsdWUsIGRpbWVuc2lvbik9PnR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgdmFsdWUuZW5kc1dpdGgoJyUnKSA/IHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogZGltZW5zaW9uIDogK3ZhbHVlO1xuLyoqXG4gKiBDYWxscyBgZm5gIHdpdGggdGhlIGdpdmVuIGBhcmdzYCBpbiB0aGUgc2NvcGUgZGVmaW5lZCBieSBgdGhpc0FyZ2AgYW5kIHJldHVybnMgdGhlXG4gKiB2YWx1ZSByZXR1cm5lZCBieSBgZm5gLiBJZiBgZm5gIGlzIG5vdCBhIGZ1bmN0aW9uLCB0aGlzIG1ldGhvZCByZXR1cm5zIHVuZGVmaW5lZC5cbiAqIEBwYXJhbSBmbiAtIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICogQHBhcmFtIGFyZ3MgLSBUaGUgYXJndW1lbnRzIHdpdGggd2hpY2ggYGZuYCBzaG91bGQgYmUgY2FsbGVkLlxuICogQHBhcmFtIFt0aGlzQXJnXSAtIFRoZSB2YWx1ZSBvZiBgdGhpc2AgcHJvdmlkZWQgZm9yIHRoZSBjYWxsIHRvIGBmbmAuXG4gKi8gZnVuY3Rpb24gY2FsbGJhY2soZm4sIGFyZ3MsIHRoaXNBcmcpIHtcbiAgICBpZiAoZm4gJiYgdHlwZW9mIGZuLmNhbGwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVhY2gobG9vcGFibGUsIGZuLCB0aGlzQXJnLCByZXZlcnNlKSB7XG4gICAgbGV0IGksIGxlbiwga2V5cztcbiAgICBpZiAoaXNBcnJheShsb29wYWJsZSkpIHtcbiAgICAgICAgbGVuID0gbG9vcGFibGUubGVuZ3RoO1xuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgICAgZm9yKGkgPSBsZW4gLSAxOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IoaSA9IDA7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtpXSwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxvb3BhYmxlKSkge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXMobG9vcGFibGUpO1xuICAgICAgICBsZW4gPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgZm9yKGkgPSAwOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgZm4uY2FsbCh0aGlzQXJnLCBsb29wYWJsZVtrZXlzW2ldXSwga2V5c1tpXSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYGEwYCBhbmQgYGExYCBhcnJheXMgaGF2ZSB0aGUgc2FtZSBjb250ZW50LCBlbHNlIHJldHVybnMgZmFsc2UuXG4gKiBAcGFyYW0gYTAgLSBUaGUgYXJyYXkgdG8gY29tcGFyZVxuICogQHBhcmFtIGExIC0gVGhlIGFycmF5IHRvIGNvbXBhcmVcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2VsZW1lbnRzRXF1YWwoYTAsIGExKSB7XG4gICAgbGV0IGksIGlsZW4sIHYwLCB2MTtcbiAgICBpZiAoIWEwIHx8ICFhMSB8fCBhMC5sZW5ndGggIT09IGExLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvcihpID0gMCwgaWxlbiA9IGEwLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIHYwID0gYTBbaV07XG4gICAgICAgIHYxID0gYTFbaV07XG4gICAgICAgIGlmICh2MC5kYXRhc2V0SW5kZXggIT09IHYxLmRhdGFzZXRJbmRleCB8fCB2MC5pbmRleCAhPT0gdjEuaW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGRlZXAgY29weSBvZiBgc291cmNlYCB3aXRob3V0IGtlZXBpbmcgcmVmZXJlbmNlcyBvbiBvYmplY3RzIGFuZCBhcnJheXMuXG4gKiBAcGFyYW0gc291cmNlIC0gVGhlIHZhbHVlIHRvIGNsb25lLlxuICovIGZ1bmN0aW9uIGNsb25lKHNvdXJjZSkge1xuICAgIGlmIChpc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgcmV0dXJuIHNvdXJjZS5tYXAoY2xvbmUpO1xuICAgIH1cbiAgICBpZiAoaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc291cmNlKTtcbiAgICAgICAgY29uc3Qga2xlbiA9IGtleXMubGVuZ3RoO1xuICAgICAgICBsZXQgayA9IDA7XG4gICAgICAgIGZvcig7IGsgPCBrbGVuOyArK2spe1xuICAgICAgICAgICAgdGFyZ2V0W2tleXNba11dID0gY2xvbmUoc291cmNlW2tleXNba11dKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEtleShrZXkpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAnX19wcm90b19fJyxcbiAgICAgICAgJ3Byb3RvdHlwZScsXG4gICAgICAgICdjb25zdHJ1Y3RvcidcbiAgICBdLmluZGV4T2Yoa2V5KSA9PT0gLTE7XG59XG4vKipcbiAqIFRoZSBkZWZhdWx0IG1lcmdlciB3aGVuIENoYXJ0LmhlbHBlcnMubWVyZ2UgaXMgY2FsbGVkIHdpdGhvdXQgbWVyZ2VyIG9wdGlvbi5cbiAqIE5vdGUoU0IpOiBhbHNvIHVzZWQgYnkgbWVyZ2VDb25maWcgYW5kIG1lcmdlU2NhbGVDb25maWcgYXMgZmFsbGJhY2suXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9tZXJnZXIoa2V5LCB0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICBtZXJnZSh0dmFsLCBzdmFsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRba2V5XSA9IGNsb25lKHN2YWwpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc291cmNlcyA9IGlzQXJyYXkoc291cmNlKSA/IHNvdXJjZSA6IFtcbiAgICAgICAgc291cmNlXG4gICAgXTtcbiAgICBjb25zdCBpbGVuID0gc291cmNlcy5sZW5ndGg7XG4gICAgaWYgKCFpc09iamVjdCh0YXJnZXQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IG1lcmdlciA9IG9wdGlvbnMubWVyZ2VyIHx8IF9tZXJnZXI7XG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIGN1cnJlbnQgPSBzb3VyY2VzW2ldO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoY3VycmVudCk7XG4gICAgICAgIGZvcihsZXQgayA9IDAsIGtsZW4gPSBrZXlzLmxlbmd0aDsgayA8IGtsZW47ICsrayl7XG4gICAgICAgICAgICBtZXJnZXIoa2V5c1trXSwgdGFyZ2V0LCBjdXJyZW50LCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VJZih0YXJnZXQsIHNvdXJjZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICByZXR1cm4gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIHtcbiAgICAgICAgbWVyZ2VyOiBfbWVyZ2VySWZcbiAgICB9KTtcbn1cbi8qKlxuICogTWVyZ2VzIHNvdXJjZVtrZXldIGluIHRhcmdldFtrZXldIG9ubHkgaWYgdGFyZ2V0W2tleV0gaXMgdW5kZWZpbmVkLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfbWVyZ2VySWYoa2V5LCB0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICghaXNWYWxpZEtleShrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdHZhbCA9IHRhcmdldFtrZXldO1xuICAgIGNvbnN0IHN2YWwgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAoaXNPYmplY3QodHZhbCkgJiYgaXNPYmplY3Qoc3ZhbCkpIHtcbiAgICAgICAgbWVyZ2VJZih0dmFsLCBzdmFsKTtcbiAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc3ZhbCk7XG4gICAgfVxufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9kZXByZWNhdGVkKHNjb3BlLCB2YWx1ZSwgcHJldmlvdXMsIGN1cnJlbnQpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLndhcm4oc2NvcGUgKyAnOiBcIicgKyBwcmV2aW91cyArICdcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiJyArIGN1cnJlbnQgKyAnXCIgaW5zdGVhZCcpO1xuICAgIH1cbn1cbi8vIHJlc29sdmVPYmplY3RLZXkgcmVzb2x2ZXIgY2FjaGVcbmNvbnN0IGtleVJlc29sdmVycyA9IHtcbiAgICAvLyBDaGFydC5oZWxwZXJzLmNvcmUgcmVzb2x2ZU9iamVjdEtleSBzaG91bGQgcmVzb2x2ZSBlbXB0eSBrZXkgdG8gcm9vdCBvYmplY3RcbiAgICAnJzogKHYpPT52LFxuICAgIC8vIGRlZmF1bHQgcmVzb2x2ZXJzXG4gICAgeDogKG8pPT5vLngsXG4gICAgeTogKG8pPT5vLnlcbn07XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3NwbGl0S2V5KGtleSkge1xuICAgIGNvbnN0IHBhcnRzID0ga2V5LnNwbGl0KCcuJyk7XG4gICAgY29uc3Qga2V5cyA9IFtdO1xuICAgIGxldCB0bXAgPSAnJztcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFydHMpe1xuICAgICAgICB0bXAgKz0gcGFydDtcbiAgICAgICAgaWYgKHRtcC5lbmRzV2l0aCgnXFxcXCcpKSB7XG4gICAgICAgICAgICB0bXAgPSB0bXAuc2xpY2UoMCwgLTEpICsgJy4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAga2V5cy5wdXNoKHRtcCk7XG4gICAgICAgICAgICB0bXAgPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIF9nZXRLZXlSZXNvbHZlcihrZXkpIHtcbiAgICBjb25zdCBrZXlzID0gX3NwbGl0S2V5KGtleSk7XG4gICAgcmV0dXJuIChvYmopPT57XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKXtcbiAgICAgICAgICAgIGlmIChrID09PSAnJykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqID0gb2JqICYmIG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlT2JqZWN0S2V5KG9iaiwga2V5KSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBrZXlSZXNvbHZlcnNba2V5XSB8fCAoa2V5UmVzb2x2ZXJzW2tleV0gPSBfZ2V0S2V5UmVzb2x2ZXIoa2V5KSk7XG4gICAgcmV0dXJuIHJlc29sdmVyKG9iaik7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2NhcGl0YWxpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn1cbmNvbnN0IGRlZmluZWQgPSAodmFsdWUpPT50eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWx1ZSk9PnR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTEyODg1NS9jb21wYXJpbmctZWNtYTYtc2V0cy1mb3ItZXF1YWxpdHkjMzExMjkzODRcbmNvbnN0IHNldHNFcXVhbCA9IChhLCBiKT0+e1xuICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhKXtcbiAgICAgICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogQHBhcmFtIGUgLSBUaGUgZXZlbnRcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2lzQ2xpY2tFdmVudChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gJ21vdXNldXAnIHx8IGUudHlwZSA9PT0gJ2NsaWNrJyB8fCBlLnR5cGUgPT09ICdjb250ZXh0bWVudSc7XG59XG5cbi8qKlxuICogQGFsaWFzIENoYXJ0LmhlbHBlcnMubWF0aFxuICogQG5hbWVzcGFjZVxuICovIGNvbnN0IFBJID0gTWF0aC5QSTtcbmNvbnN0IFRBVSA9IDIgKiBQSTtcbmNvbnN0IFBJVEFVID0gVEFVICsgUEk7XG5jb25zdCBJTkZJTklUWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbmNvbnN0IFJBRF9QRVJfREVHID0gUEkgLyAxODA7XG5jb25zdCBIQUxGX1BJID0gUEkgLyAyO1xuY29uc3QgUVVBUlRFUl9QSSA9IFBJIC8gNDtcbmNvbnN0IFRXT19USElSRFNfUEkgPSBQSSAqIDIgLyAzO1xuY29uc3QgbG9nMTAgPSBNYXRoLmxvZzEwO1xuY29uc3Qgc2lnbiA9IE1hdGguc2lnbjtcbmZ1bmN0aW9uIGFsbW9zdEVxdWFscyh4LCB5LCBlcHNpbG9uKSB7XG4gICAgcmV0dXJuIE1hdGguYWJzKHggLSB5KSA8IGVwc2lsb247XG59XG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuaWNlIG51bWJlciBhbGdvcml0aG0gdXNlZCBpbiBkZXRlcm1pbmluZyB3aGVyZSBheGlzIGxhYmVscyB3aWxsIGdvXG4gKi8gZnVuY3Rpb24gbmljZU51bShyYW5nZSkge1xuICAgIGNvbnN0IHJvdW5kZWRSYW5nZSA9IE1hdGgucm91bmQocmFuZ2UpO1xuICAgIHJhbmdlID0gYWxtb3N0RXF1YWxzKHJhbmdlLCByb3VuZGVkUmFuZ2UsIHJhbmdlIC8gMTAwMCkgPyByb3VuZGVkUmFuZ2UgOiByYW5nZTtcbiAgICBjb25zdCBuaWNlUmFuZ2UgPSBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMChyYW5nZSkpKTtcbiAgICBjb25zdCBmcmFjdGlvbiA9IHJhbmdlIC8gbmljZVJhbmdlO1xuICAgIGNvbnN0IG5pY2VGcmFjdGlvbiA9IGZyYWN0aW9uIDw9IDEgPyAxIDogZnJhY3Rpb24gPD0gMiA/IDIgOiBmcmFjdGlvbiA8PSA1ID8gNSA6IDEwO1xuICAgIHJldHVybiBuaWNlRnJhY3Rpb24gKiBuaWNlUmFuZ2U7XG59XG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgZmFjdG9ycyBzb3J0ZWQgZnJvbSAxIHRvIHNxcnQodmFsdWUpXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9mYWN0b3JpemUodmFsdWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0KHZhbHVlKTtcbiAgICBsZXQgaTtcbiAgICBmb3IoaSA9IDE7IGkgPCBzcXJ0OyBpKyspe1xuICAgICAgICBpZiAodmFsdWUgJSBpID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlIC8gaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNxcnQgPT09IChzcXJ0IHwgMCkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goc3FydCk7XG4gICAgfVxuICAgIHJlc3VsdC5zb3J0KChhLCBiKT0+YSAtIGIpLnBvcCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoYXQgYXR0ZW1wdGluZyB0byBjb2VyY2UgbiB0byBzdHJpbmcgb3IgbnVtYmVyIHdvbid0IHRocm93IGEgVHlwZUVycm9yLlxuICovIGZ1bmN0aW9uIGlzTm9uUHJpbWl0aXZlKG4pIHtcbiAgICByZXR1cm4gdHlwZW9mIG4gPT09ICdzeW1ib2wnIHx8IHR5cGVvZiBuID09PSAnb2JqZWN0JyAmJiBuICE9PSBudWxsICYmICEoU3ltYm9sLnRvUHJpbWl0aXZlIGluIG4gfHwgJ3RvU3RyaW5nJyBpbiBuIHx8ICd2YWx1ZU9mJyBpbiBuKTtcbn1cbmZ1bmN0aW9uIGlzTnVtYmVyKG4pIHtcbiAgICByZXR1cm4gIWlzTm9uUHJpbWl0aXZlKG4pICYmICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTtcbn1cbmZ1bmN0aW9uIGFsbW9zdFdob2xlKHgsIGVwc2lsb24pIHtcbiAgICBjb25zdCByb3VuZGVkID0gTWF0aC5yb3VuZCh4KTtcbiAgICByZXR1cm4gcm91bmRlZCAtIGVwc2lsb24gPD0geCAmJiByb3VuZGVkICsgZXBzaWxvbiA+PSB4O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9zZXRNaW5BbmRNYXhCeUtleShhcnJheSwgdGFyZ2V0LCBwcm9wZXJ0eSkge1xuICAgIGxldCBpLCBpbGVuLCB2YWx1ZTtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBhcnJheS5sZW5ndGg7IGkgPCBpbGVuOyBpKyspe1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2ldW3Byb3BlcnR5XTtcbiAgICAgICAgaWYgKCFpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5taW4gPSBNYXRoLm1pbih0YXJnZXQubWluLCB2YWx1ZSk7XG4gICAgICAgICAgICB0YXJnZXQubWF4ID0gTWF0aC5tYXgodGFyZ2V0Lm1heCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICByZXR1cm4gZGVncmVlcyAqIChQSSAvIDE4MCk7XG59XG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xuICAgIHJldHVybiByYWRpYW5zICogKDE4MCAvIFBJKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzXG4gKiBpLmUuIHRoZSBudW1iZXIgb2YgZGlnaXRzIGFmdGVyIHRoZSBkZWNpbWFsIHBvaW50LCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBOdW1iZXIuXG4gKiBAcGFyYW0geCAtIEEgbnVtYmVyLlxuICogQHJldHVybnMgVGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2RlY2ltYWxQbGFjZXMoeCkge1xuICAgIGlmICghaXNOdW1iZXJGaW5pdGUoeCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgZSA9IDE7XG4gICAgbGV0IHAgPSAwO1xuICAgIHdoaWxlKE1hdGgucm91bmQoeCAqIGUpIC8gZSAhPT0geCl7XG4gICAgICAgIGUgKj0gMTA7XG4gICAgICAgIHArKztcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vLyBHZXRzIHRoZSBhbmdsZSBmcm9tIHZlcnRpY2FsIHVwcmlnaHQgdG8gdGhlIHBvaW50IGFib3V0IGEgY2VudHJlLlxuZnVuY3Rpb24gZ2V0QW5nbGVGcm9tUG9pbnQoY2VudHJlUG9pbnQsIGFuZ2xlUG9pbnQpIHtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21YQ2VudGVyID0gYW5nbGVQb2ludC54IC0gY2VudHJlUG9pbnQueDtcbiAgICBjb25zdCBkaXN0YW5jZUZyb21ZQ2VudGVyID0gYW5nbGVQb2ludC55IC0gY2VudHJlUG9pbnQueTtcbiAgICBjb25zdCByYWRpYWxEaXN0YW5jZUZyb21DZW50ZXIgPSBNYXRoLnNxcnQoZGlzdGFuY2VGcm9tWENlbnRlciAqIGRpc3RhbmNlRnJvbVhDZW50ZXIgKyBkaXN0YW5jZUZyb21ZQ2VudGVyICogZGlzdGFuY2VGcm9tWUNlbnRlcik7XG4gICAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMihkaXN0YW5jZUZyb21ZQ2VudGVyLCBkaXN0YW5jZUZyb21YQ2VudGVyKTtcbiAgICBpZiAoYW5nbGUgPCAtMC41ICogUEkpIHtcbiAgICAgICAgYW5nbGUgKz0gVEFVOyAvLyBtYWtlIHN1cmUgdGhlIHJldHVybmVkIGFuZ2xlIGlzIGluIHRoZSByYW5nZSBvZiAoLVBJLzIsIDNQSS8yXVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZSxcbiAgICAgICAgZGlzdGFuY2U6IHJhZGlhbERpc3RhbmNlRnJvbUNlbnRlclxuICAgIH07XG59XG5mdW5jdGlvbiBkaXN0YW5jZUJldHdlZW5Qb2ludHMocHQxLCBwdDIpIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHB0Mi54IC0gcHQxLngsIDIpICsgTWF0aC5wb3cocHQyLnkgLSBwdDEueSwgMikpO1xufVxuLyoqXG4gKiBTaG9ydGVzdCBkaXN0YW5jZSBiZXR3ZWVuIGFuZ2xlcywgaW4gZWl0aGVyIGRpcmVjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2FuZ2xlRGlmZihhLCBiKSB7XG4gICAgcmV0dXJuIChhIC0gYiArIFBJVEFVKSAlIFRBVSAtIFBJO1xufVxuLyoqXG4gKiBOb3JtYWxpemUgYW5nbGUgdG8gYmUgYmV0d2VlbiAwIGFuZCAyKlBJXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9ub3JtYWxpemVBbmdsZShhKSB7XG4gICAgcmV0dXJuIChhICUgVEFVICsgVEFVKSAlIFRBVTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfYW5nbGVCZXR3ZWVuKGFuZ2xlLCBzdGFydCwgZW5kLCBzYW1lQW5nbGVJc0Z1bGxDaXJjbGUpIHtcbiAgICBjb25zdCBhID0gX25vcm1hbGl6ZUFuZ2xlKGFuZ2xlKTtcbiAgICBjb25zdCBzID0gX25vcm1hbGl6ZUFuZ2xlKHN0YXJ0KTtcbiAgICBjb25zdCBlID0gX25vcm1hbGl6ZUFuZ2xlKGVuZCk7XG4gICAgY29uc3QgYW5nbGVUb1N0YXJ0ID0gX25vcm1hbGl6ZUFuZ2xlKHMgLSBhKTtcbiAgICBjb25zdCBhbmdsZVRvRW5kID0gX25vcm1hbGl6ZUFuZ2xlKGUgLSBhKTtcbiAgICBjb25zdCBzdGFydFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIHMpO1xuICAgIGNvbnN0IGVuZFRvQW5nbGUgPSBfbm9ybWFsaXplQW5nbGUoYSAtIGUpO1xuICAgIHJldHVybiBhID09PSBzIHx8IGEgPT09IGUgfHwgc2FtZUFuZ2xlSXNGdWxsQ2lyY2xlICYmIHMgPT09IGUgfHwgYW5nbGVUb1N0YXJ0ID4gYW5nbGVUb0VuZCAmJiBzdGFydFRvQW5nbGUgPCBlbmRUb0FuZ2xlO1xufVxuLyoqXG4gKiBMaW1pdCBgdmFsdWVgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBtaW5cbiAqIEBwYXJhbSBtYXhcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2xpbWl0VmFsdWUodmFsdWUsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obWF4LCB2YWx1ZSkpO1xufVxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2ludDE2UmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gX2xpbWl0VmFsdWUodmFsdWUsIC0zMjc2OCwgMzI3NjcpO1xufVxuLyoqXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBzdGFydFxuICogQHBhcmFtIGVuZFxuICogQHBhcmFtIFtlcHNpbG9uXVxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfaXNCZXR3ZWVuKHZhbHVlLCBzdGFydCwgZW5kLCBlcHNpbG9uID0gMWUtNikge1xuICAgIHJldHVybiB2YWx1ZSA+PSBNYXRoLm1pbihzdGFydCwgZW5kKSAtIGVwc2lsb24gJiYgdmFsdWUgPD0gTWF0aC5tYXgoc3RhcnQsIGVuZCkgKyBlcHNpbG9uO1xufVxuXG5mdW5jdGlvbiBfbG9va3VwKHRhYmxlLCB2YWx1ZSwgY21wKSB7XG4gICAgY21wID0gY21wIHx8ICgoaW5kZXgpPT50YWJsZVtpbmRleF0gPCB2YWx1ZSk7XG4gICAgbGV0IGhpID0gdGFibGUubGVuZ3RoIC0gMTtcbiAgICBsZXQgbG8gPSAwO1xuICAgIGxldCBtaWQ7XG4gICAgd2hpbGUoaGkgLSBsbyA+IDEpe1xuICAgICAgICBtaWQgPSBsbyArIGhpID4+IDE7XG4gICAgICAgIGlmIChjbXAobWlkKSkge1xuICAgICAgICAgICAgbG8gPSBtaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaSA9IG1pZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsbyxcbiAgICAgICAgaGlcbiAgICB9O1xufVxuLyoqXG4gKiBCaW5hcnkgc2VhcmNoXG4gKiBAcGFyYW0gdGFibGUgLSB0aGUgdGFibGUgc2VhcmNoLiBtdXN0IGJlIHNvcnRlZCFcbiAqIEBwYXJhbSBrZXkgLSBwcm9wZXJ0eSBuYW1lIGZvciB0aGUgdmFsdWUgaW4gZWFjaCBlbnRyeVxuICogQHBhcmFtIHZhbHVlIC0gdmFsdWUgdG8gZmluZFxuICogQHBhcmFtIGxhc3QgLSBsb29rdXAgbGFzdCBpbmRleFxuICogQHByaXZhdGVcbiAqLyBjb25zdCBfbG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUsIGxhc3QpPT5fbG9va3VwKHRhYmxlLCB2YWx1ZSwgbGFzdCA/IChpbmRleCk9PntcbiAgICAgICAgY29uc3QgdGkgPSB0YWJsZVtpbmRleF1ba2V5XTtcbiAgICAgICAgcmV0dXJuIHRpIDwgdmFsdWUgfHwgdGkgPT09IHZhbHVlICYmIHRhYmxlW2luZGV4ICsgMV1ba2V5XSA9PT0gdmFsdWU7XG4gICAgfSA6IChpbmRleCk9PnRhYmxlW2luZGV4XVtrZXldIDwgdmFsdWUpO1xuLyoqXG4gKiBSZXZlcnNlIGJpbmFyeSBzZWFyY2hcbiAqIEBwYXJhbSB0YWJsZSAtIHRoZSB0YWJsZSBzZWFyY2guIG11c3QgYmUgc29ydGVkIVxuICogQHBhcmFtIGtleSAtIHByb3BlcnR5IG5hbWUgZm9yIHRoZSB2YWx1ZSBpbiBlYWNoIGVudHJ5XG4gKiBAcGFyYW0gdmFsdWUgLSB2YWx1ZSB0byBmaW5kXG4gKiBAcHJpdmF0ZVxuICovIGNvbnN0IF9ybG9va3VwQnlLZXkgPSAodGFibGUsIGtleSwgdmFsdWUpPT5fbG9va3VwKHRhYmxlLCB2YWx1ZSwgKGluZGV4KT0+dGFibGVbaW5kZXhdW2tleV0gPj0gdmFsdWUpO1xuLyoqXG4gKiBSZXR1cm4gc3Vic2V0IG9mIGB2YWx1ZXNgIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgIGluY2x1c2l2ZS5cbiAqIFZhbHVlcyBhcmUgYXNzdW1lZCB0byBiZSBpbiBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0gdmFsdWVzIC0gc29ydGVkIGFycmF5IG9mIHZhbHVlc1xuICogQHBhcmFtIG1pbiAtIG1pbiB2YWx1ZVxuICogQHBhcmFtIG1heCAtIG1heCB2YWx1ZVxuICovIGZ1bmN0aW9uIF9maWx0ZXJCZXR3ZWVuKHZhbHVlcywgbWluLCBtYXgpIHtcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIGxldCBlbmQgPSB2YWx1ZXMubGVuZ3RoO1xuICAgIHdoaWxlKHN0YXJ0IDwgZW5kICYmIHZhbHVlc1tzdGFydF0gPCBtaW4pe1xuICAgICAgICBzdGFydCsrO1xuICAgIH1cbiAgICB3aGlsZShlbmQgPiBzdGFydCAmJiB2YWx1ZXNbZW5kIC0gMV0gPiBtYXgpe1xuICAgICAgICBlbmQtLTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YXJ0ID4gMCB8fCBlbmQgPCB2YWx1ZXMubGVuZ3RoID8gdmFsdWVzLnNsaWNlKHN0YXJ0LCBlbmQpIDogdmFsdWVzO1xufVxuY29uc3QgYXJyYXlFdmVudHMgPSBbXG4gICAgJ3B1c2gnLFxuICAgICdwb3AnLFxuICAgICdzaGlmdCcsXG4gICAgJ3NwbGljZScsXG4gICAgJ3Vuc2hpZnQnXG5dO1xuZnVuY3Rpb24gbGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gICAgaWYgKGFycmF5Ll9jaGFydGpzKSB7XG4gICAgICAgIGFycmF5Ll9jaGFydGpzLmxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksICdfY2hhcnRqcycsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIGxpc3RlbmVyczogW1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBhcnJheUV2ZW50cy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgIGNvbnN0IG1ldGhvZCA9ICdfb25EYXRhJyArIF9jYXBpdGFsaXplKGtleSk7XG4gICAgICAgIGNvbnN0IGJhc2UgPSBhcnJheVtrZXldO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXJyYXksIGtleSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZSAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGJhc2UuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgYXJyYXkuX2NoYXJ0anMubGlzdGVuZXJzLmZvckVhY2goKG9iamVjdCk9PntcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvYmplY3RbbWV0aG9kXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0W21ldGhvZF0oLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVubGlzdGVuQXJyYXlFdmVudHMoYXJyYXksIGxpc3RlbmVyKSB7XG4gICAgY29uc3Qgc3R1YiA9IGFycmF5Ll9jaGFydGpzO1xuICAgIGlmICghc3R1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVycyA9IHN0dWIubGlzdGVuZXJzO1xuICAgIGNvbnN0IGluZGV4ID0gbGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpO1xuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICAgIGlmIChsaXN0ZW5lcnMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFycmF5RXZlbnRzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgZGVsZXRlIGFycmF5W2tleV07XG4gICAgfSk7XG4gICAgZGVsZXRlIGFycmF5Ll9jaGFydGpzO1xufVxuLyoqXG4gKiBAcGFyYW0gaXRlbXNcbiAqLyBmdW5jdGlvbiBfYXJyYXlVbmlxdWUoaXRlbXMpIHtcbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0KGl0ZW1zKTtcbiAgICBpZiAoc2V0LnNpemUgPT09IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKHNldCk7XG59XG5cbmZ1bmN0aW9uIGZvbnRTdHJpbmcocGl4ZWxTaXplLCBmb250U3R5bGUsIGZvbnRGYW1pbHkpIHtcbiAgICByZXR1cm4gZm9udFN0eWxlICsgJyAnICsgcGl4ZWxTaXplICsgJ3B4ICcgKyBmb250RmFtaWx5O1xufVxuLyoqXG4qIFJlcXVlc3QgYW5pbWF0aW9uIHBvbHlmaWxsXG4qLyBjb25zdCByZXF1ZXN0QW5pbUZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xufSgpO1xuLyoqXG4gKiBUaHJvdHRsZXMgY2FsbGluZyBgZm5gIG9uY2UgcGVyIGFuaW1hdGlvbiBmcmFtZVxuICogTGF0ZXN0IGFyZ3VtZW50cyBhcmUgdXNlZCBvbiB0aGUgYWN0dWFsIGNhbGxcbiAqLyBmdW5jdGlvbiB0aHJvdHRsZWQoZm4sIHRoaXNBcmcpIHtcbiAgICBsZXQgYXJnc1RvVXNlID0gW107XG4gICAgbGV0IHRpY2tpbmcgPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICAvLyBTYXZlIHRoZSBhcmdzIGZvciB1c2UgbGF0ZXJcbiAgICAgICAgYXJnc1RvVXNlID0gYXJncztcbiAgICAgICAgaWYgKCF0aWNraW5nKSB7XG4gICAgICAgICAgICB0aWNraW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltRnJhbWUuY2FsbCh3aW5kb3csICgpPT57XG4gICAgICAgICAgICAgICAgdGlja2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3NUb1VzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIERlYm91bmNlcyBjYWxsaW5nIGBmbmAgZm9yIGBkZWxheWAgbXNcbiAqLyBmdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgICBsZXQgdGltZW91dDtcbiAgICByZXR1cm4gZnVuY3Rpb24oLi4uYXJncykge1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZuLCBkZWxheSwgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsYXk7XG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgJ3N0YXJ0JyB0byAnbGVmdCcsICdlbmQnIHRvICdyaWdodCcgYW5kIG90aGVycyB0byAnY2VudGVyJ1xuICogQHByaXZhdGVcbiAqLyBjb25zdCBfdG9MZWZ0UmlnaHRDZW50ZXIgPSAoYWxpZ24pPT5hbGlnbiA9PT0gJ3N0YXJ0JyA/ICdsZWZ0JyA6IGFsaWduID09PSAnZW5kJyA/ICdyaWdodCcgOiAnY2VudGVyJztcbi8qKlxuICogUmV0dXJucyBgc3RhcnRgLCBgZW5kYCBvciBgKHN0YXJ0ICsgZW5kKSAvIDJgIGRlcGVuZGluZyBvbiBgYWxpZ25gLiBEZWZhdWx0cyB0byBgY2VudGVyYFxuICogQHByaXZhdGVcbiAqLyBjb25zdCBfYWxpZ25TdGFydEVuZCA9IChhbGlnbiwgc3RhcnQsIGVuZCk9PmFsaWduID09PSAnc3RhcnQnID8gc3RhcnQgOiBhbGlnbiA9PT0gJ2VuZCcgPyBlbmQgOiAoc3RhcnQgKyBlbmQpIC8gMjtcbi8qKlxuICogUmV0dXJucyBgbGVmdGAsIGByaWdodGAgb3IgYChsZWZ0ICsgcmlnaHQpIC8gMmAgZGVwZW5kaW5nIG9uIGBhbGlnbmAuIERlZmF1bHRzIHRvIGBsZWZ0YFxuICogQHByaXZhdGVcbiAqLyBjb25zdCBfdGV4dFggPSAoYWxpZ24sIGxlZnQsIHJpZ2h0LCBydGwpPT57XG4gICAgY29uc3QgY2hlY2sgPSBydGwgPyAnbGVmdCcgOiAncmlnaHQnO1xuICAgIHJldHVybiBhbGlnbiA9PT0gY2hlY2sgPyByaWdodCA6IGFsaWduID09PSAnY2VudGVyJyA/IChsZWZ0ICsgcmlnaHQpIC8gMiA6IGxlZnQ7XG59O1xuLyoqXG4gKiBSZXR1cm4gc3RhcnQgYW5kIGNvdW50IG9mIHZpc2libGUgcG9pbnRzLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfZ2V0U3RhcnRBbmRDb3VudE9mVmlzaWJsZVBvaW50cyhtZXRhLCBwb2ludHMsIGFuaW1hdGlvbnNEaXNhYmxlZCkge1xuICAgIGNvbnN0IHBvaW50Q291bnQgPSBwb2ludHMubGVuZ3RoO1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGNvdW50ID0gcG9pbnRDb3VudDtcbiAgICBpZiAobWV0YS5fc29ydGVkKSB7XG4gICAgICAgIGNvbnN0IHsgaVNjYWxlICwgdlNjYWxlICwgX3BhcnNlZCAgfSA9IG1ldGE7XG4gICAgICAgIGNvbnN0IHNwYW5HYXBzID0gbWV0YS5kYXRhc2V0ID8gbWV0YS5kYXRhc2V0Lm9wdGlvbnMgPyBtZXRhLmRhdGFzZXQub3B0aW9ucy5zcGFuR2FwcyA6IG51bGwgOiBudWxsO1xuICAgICAgICBjb25zdCBheGlzID0gaVNjYWxlLmF4aXM7XG4gICAgICAgIGNvbnN0IHsgbWluICwgbWF4ICwgbWluRGVmaW5lZCAsIG1heERlZmluZWQgIH0gPSBpU2NhbGUuZ2V0VXNlckJvdW5kcygpO1xuICAgICAgICBpZiAobWluRGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnQgPSBNYXRoLm1pbigvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgYXhpcywgbWluKS5sbywgLy8gQHRzLWV4cGVjdC1lcnJvciBOZWVkIHRvIGZpeCB0eXBlcyBvbiBfbG9va3VwQnlLZXlcbiAgICAgICAgICAgIGFuaW1hdGlvbnNEaXNhYmxlZCA/IHBvaW50Q291bnQgOiBfbG9va3VwQnlLZXkocG9pbnRzLCBheGlzLCBpU2NhbGUuZ2V0UGl4ZWxGb3JWYWx1ZShtaW4pKS5sbyk7XG4gICAgICAgICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZExvID0gX3BhcnNlZC5zbGljZSgwLCBzdGFydCArIDEpLnJldmVyc2UoKS5maW5kSW5kZXgoKHBvaW50KT0+IWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSk7XG4gICAgICAgICAgICAgICAgc3RhcnQgLT0gTWF0aC5tYXgoMCwgZGlzdGFuY2VUb0RlZmluZWRMbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IF9saW1pdFZhbHVlKHN0YXJ0LCAwLCBwb2ludENvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1heERlZmluZWQpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSBNYXRoLm1heCgvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gdHlwZSBfcGFyc2VkXG4gICAgICAgICAgICBfbG9va3VwQnlLZXkoX3BhcnNlZCwgaVNjYWxlLmF4aXMsIG1heCwgdHJ1ZSkuaGkgKyAxLCAvLyBAdHMtZXhwZWN0LWVycm9yIE5lZWQgdG8gZml4IHR5cGVzIG9uIF9sb29rdXBCeUtleVxuICAgICAgICAgICAgYW5pbWF0aW9uc0Rpc2FibGVkID8gMCA6IF9sb29rdXBCeUtleShwb2ludHMsIGF4aXMsIGlTY2FsZS5nZXRQaXhlbEZvclZhbHVlKG1heCksIHRydWUpLmhpICsgMSk7XG4gICAgICAgICAgICBpZiAoc3BhbkdhcHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZVRvRGVmaW5lZEhpID0gX3BhcnNlZC5zbGljZShlbmQgLSAxKS5maW5kSW5kZXgoKHBvaW50KT0+IWlzTnVsbE9yVW5kZWYocG9pbnRbdlNjYWxlLmF4aXNdKSk7XG4gICAgICAgICAgICAgICAgZW5kICs9IE1hdGgubWF4KDAsIGRpc3RhbmNlVG9EZWZpbmVkSGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY291bnQgPSBfbGltaXRWYWx1ZShlbmQsIHN0YXJ0LCBwb2ludENvdW50KSAtIHN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY291bnQgPSBwb2ludENvdW50IC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGNvdW50XG4gICAgfTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzY2FsZSByYW5nZXMgaGF2ZSBjaGFuZ2VkLlxuICogQHBhcmFtIHtvYmplY3R9IG1ldGEgLSBkYXRhc2V0IG1ldGEuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3NjYWxlUmFuZ2VzQ2hhbmdlZChtZXRhKSB7XG4gICAgY29uc3QgeyB4U2NhbGUgLCB5U2NhbGUgLCBfc2NhbGVSYW5nZXMgIH0gPSBtZXRhO1xuICAgIGNvbnN0IG5ld1JhbmdlcyA9IHtcbiAgICAgICAgeG1pbjogeFNjYWxlLm1pbixcbiAgICAgICAgeG1heDogeFNjYWxlLm1heCxcbiAgICAgICAgeW1pbjogeVNjYWxlLm1pbixcbiAgICAgICAgeW1heDogeVNjYWxlLm1heFxuICAgIH07XG4gICAgaWYgKCFfc2NhbGVSYW5nZXMpIHtcbiAgICAgICAgbWV0YS5fc2NhbGVSYW5nZXMgPSBuZXdSYW5nZXM7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGFuZ2VkID0gX3NjYWxlUmFuZ2VzLnhtaW4gIT09IHhTY2FsZS5taW4gfHwgX3NjYWxlUmFuZ2VzLnhtYXggIT09IHhTY2FsZS5tYXggfHwgX3NjYWxlUmFuZ2VzLnltaW4gIT09IHlTY2FsZS5taW4gfHwgX3NjYWxlUmFuZ2VzLnltYXggIT09IHlTY2FsZS5tYXg7XG4gICAgT2JqZWN0LmFzc2lnbihfc2NhbGVSYW5nZXMsIG5ld1Jhbmdlcyk7XG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbmNvbnN0IGF0RWRnZSA9ICh0KT0+dCA9PT0gMCB8fCB0ID09PSAxO1xuY29uc3QgZWxhc3RpY0luID0gKHQsIHMsIHApPT4tKE1hdGgucG93KDIsIDEwICogKHQgLT0gMSkpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApKTtcbmNvbnN0IGVsYXN0aWNPdXQgPSAodCwgcywgcCk9Pk1hdGgucG93KDIsIC0xMCAqIHQpICogTWF0aC5zaW4oKHQgLSBzKSAqIFRBVSAvIHApICsgMTtcbi8qKlxuICogRWFzaW5nIGZ1bmN0aW9ucyBhZGFwdGVkIGZyb20gUm9iZXJ0IFBlbm5lcidzIGVhc2luZyBlcXVhdGlvbnMuXG4gKiBAbmFtZXNwYWNlIENoYXJ0LmhlbHBlcnMuZWFzaW5nLmVmZmVjdHNcbiAqIEBzZWUgaHR0cDovL3d3dy5yb2JlcnRwZW5uZXIuY29tL2Vhc2luZy9cbiAqLyBjb25zdCBlZmZlY3RzID0ge1xuICAgIGxpbmVhcjogKHQpPT50LFxuICAgIGVhc2VJblF1YWQ6ICh0KT0+dCAqIHQsXG4gICAgZWFzZU91dFF1YWQ6ICh0KT0+LXQgKiAodCAtIDIpLFxuICAgIGVhc2VJbk91dFF1YWQ6ICh0KT0+KHQgLz0gMC41KSA8IDEgPyAwLjUgKiB0ICogdCA6IC0wLjUgKiAoLS10ICogKHQgLSAyKSAtIDEpLFxuICAgIGVhc2VJbkN1YmljOiAodCk9PnQgKiB0ICogdCxcbiAgICBlYXNlT3V0Q3ViaWM6ICh0KT0+KHQgLT0gMSkgKiB0ICogdCArIDEsXG4gICAgZWFzZUluT3V0Q3ViaWM6ICh0KT0+KHQgLz0gMC41KSA8IDEgPyAwLjUgKiB0ICogdCAqIHQgOiAwLjUgKiAoKHQgLT0gMikgKiB0ICogdCArIDIpLFxuICAgIGVhc2VJblF1YXJ0OiAodCk9PnQgKiB0ICogdCAqIHQsXG4gICAgZWFzZU91dFF1YXJ0OiAodCk9Pi0oKHQgLT0gMSkgKiB0ICogdCAqIHQgLSAxKSxcbiAgICBlYXNlSW5PdXRRdWFydDogKHQpPT4odCAvPSAwLjUpIDwgMSA/IDAuNSAqIHQgKiB0ICogdCAqIHQgOiAtMC41ICogKCh0IC09IDIpICogdCAqIHQgKiB0IC0gMiksXG4gICAgZWFzZUluUXVpbnQ6ICh0KT0+dCAqIHQgKiB0ICogdCAqIHQsXG4gICAgZWFzZU91dFF1aW50OiAodCk9Pih0IC09IDEpICogdCAqIHQgKiB0ICogdCArIDEsXG4gICAgZWFzZUluT3V0UXVpbnQ6ICh0KT0+KHQgLz0gMC41KSA8IDEgPyAwLjUgKiB0ICogdCAqIHQgKiB0ICogdCA6IDAuNSAqICgodCAtPSAyKSAqIHQgKiB0ICogdCAqIHQgKyAyKSxcbiAgICBlYXNlSW5TaW5lOiAodCk9Pi1NYXRoLmNvcyh0ICogSEFMRl9QSSkgKyAxLFxuICAgIGVhc2VPdXRTaW5lOiAodCk9Pk1hdGguc2luKHQgKiBIQUxGX1BJKSxcbiAgICBlYXNlSW5PdXRTaW5lOiAodCk9Pi0wLjUgKiAoTWF0aC5jb3MoUEkgKiB0KSAtIDEpLFxuICAgIGVhc2VJbkV4cG86ICh0KT0+dCA9PT0gMCA/IDAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpLFxuICAgIGVhc2VPdXRFeHBvOiAodCk9PnQgPT09IDEgPyAxIDogLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSxcbiAgICBlYXNlSW5PdXRFeHBvOiAodCk9PmF0RWRnZSh0KSA/IHQgOiB0IDwgMC41ID8gMC41ICogTWF0aC5wb3coMiwgMTAgKiAodCAqIDIgLSAxKSkgOiAwLjUgKiAoLU1hdGgucG93KDIsIC0xMCAqICh0ICogMiAtIDEpKSArIDIpLFxuICAgIGVhc2VJbkNpcmM6ICh0KT0+dCA+PSAxID8gdCA6IC0oTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSxcbiAgICBlYXNlT3V0Q2lyYzogKHQpPT5NYXRoLnNxcnQoMSAtICh0IC09IDEpICogdCksXG4gICAgZWFzZUluT3V0Q2lyYzogKHQpPT4odCAvPSAwLjUpIDwgMSA/IC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSB0ICogdCkgLSAxKSA6IDAuNSAqIChNYXRoLnNxcnQoMSAtICh0IC09IDIpICogdCkgKyAxKSxcbiAgICBlYXNlSW5FbGFzdGljOiAodCk9PmF0RWRnZSh0KSA/IHQgOiBlbGFzdGljSW4odCwgMC4wNzUsIDAuMyksXG4gICAgZWFzZU91dEVsYXN0aWM6ICh0KT0+YXRFZGdlKHQpID8gdCA6IGVsYXN0aWNPdXQodCwgMC4wNzUsIDAuMyksXG4gICAgZWFzZUluT3V0RWxhc3RpYyAodCkge1xuICAgICAgICBjb25zdCBzID0gMC4xMTI1O1xuICAgICAgICBjb25zdCBwID0gMC40NTtcbiAgICAgICAgcmV0dXJuIGF0RWRnZSh0KSA/IHQgOiB0IDwgMC41ID8gMC41ICogZWxhc3RpY0luKHQgKiAyLCBzLCBwKSA6IDAuNSArIDAuNSAqIGVsYXN0aWNPdXQodCAqIDIgLSAxLCBzLCBwKTtcbiAgICB9LFxuICAgIGVhc2VJbkJhY2sgKHQpIHtcbiAgICAgICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH0sXG4gICAgZWFzZU91dEJhY2sgKHQpIHtcbiAgICAgICAgY29uc3QgcyA9IDEuNzAxNTg7XG4gICAgICAgIHJldHVybiAodCAtPSAxKSAqIHQgKiAoKHMgKyAxKSAqIHQgKyBzKSArIDE7XG4gICAgfSxcbiAgICBlYXNlSW5PdXRCYWNrICh0KSB7XG4gICAgICAgIGxldCBzID0gMS43MDE1ODtcbiAgICAgICAgaWYgKCh0IC89IDAuNSkgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMC41ICogKHQgKiB0ICogKCgocyAqPSAxLjUyNSkgKyAxKSAqIHQgLSBzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDAuNSAqICgodCAtPSAyKSAqIHQgKiAoKChzICo9IDEuNTI1KSArIDEpICogdCArIHMpICsgMik7XG4gICAgfSxcbiAgICBlYXNlSW5Cb3VuY2U6ICh0KT0+MSAtIGVmZmVjdHMuZWFzZU91dEJvdW5jZSgxIC0gdCksXG4gICAgZWFzZU91dEJvdW5jZSAodCkge1xuICAgICAgICBjb25zdCBtID0gNy41NjI1O1xuICAgICAgICBjb25zdCBkID0gMi43NTtcbiAgICAgICAgaWYgKHQgPCAxIC8gZCkge1xuICAgICAgICAgICAgcmV0dXJuIG0gKiB0ICogdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA8IDIgLyBkKSB7XG4gICAgICAgICAgICByZXR1cm4gbSAqICh0IC09IDEuNSAvIGQpICogdCArIDAuNzU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAyLjUgLyBkKSB7XG4gICAgICAgICAgICByZXR1cm4gbSAqICh0IC09IDIuMjUgLyBkKSAqIHQgKyAwLjkzNzU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0gKiAodCAtPSAyLjYyNSAvIGQpICogdCArIDAuOTg0Mzc1O1xuICAgIH0sXG4gICAgZWFzZUluT3V0Qm91bmNlOiAodCk9PnQgPCAwLjUgPyBlZmZlY3RzLmVhc2VJbkJvdW5jZSh0ICogMikgKiAwLjUgOiBlZmZlY3RzLmVhc2VPdXRCb3VuY2UodCAqIDIgLSAxKSAqIDAuNSArIDAuNVxufTtcblxuZnVuY3Rpb24gaXNQYXR0ZXJuT3JHcmFkaWVudCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdHlwZSA9PT0gJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IENhbnZhc0dyYWRpZW50XSc7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNvbG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGF0dGVybk9yR3JhZGllbnQodmFsdWUpID8gdmFsdWUgOiBuZXcgQ29sb3IodmFsdWUpO1xufVxuZnVuY3Rpb24gZ2V0SG92ZXJDb2xvcih2YWx1ZSkge1xuICAgIHJldHVybiBpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSA/IHZhbHVlIDogbmV3IENvbG9yKHZhbHVlKS5zYXR1cmF0ZSgwLjUpLmRhcmtlbigwLjEpLmhleFN0cmluZygpO1xufVxuXG5jb25zdCBudW1iZXJzID0gW1xuICAgICd4JyxcbiAgICAneScsXG4gICAgJ2JvcmRlcldpZHRoJyxcbiAgICAncmFkaXVzJyxcbiAgICAndGVuc2lvbidcbl07XG5jb25zdCBjb2xvcnMgPSBbXG4gICAgJ2NvbG9yJyxcbiAgICAnYm9yZGVyQ29sb3InLFxuICAgICdiYWNrZ3JvdW5kQ29sb3InXG5dO1xuZnVuY3Rpb24gYXBwbHlBbmltYXRpb25zRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cy5zZXQoJ2FuaW1hdGlvbicsIHtcbiAgICAgICAgZGVsYXk6IHVuZGVmaW5lZCxcbiAgICAgICAgZHVyYXRpb246IDEwMDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VPdXRRdWFydCcsXG4gICAgICAgIGZuOiB1bmRlZmluZWQsXG4gICAgICAgIGZyb206IHVuZGVmaW5lZCxcbiAgICAgICAgbG9vcDogdW5kZWZpbmVkLFxuICAgICAgICB0bzogdW5kZWZpbmVkLFxuICAgICAgICB0eXBlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9uJywge1xuICAgICAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgICAgICBfaW5kZXhhYmxlOiBmYWxzZSxcbiAgICAgICAgX3NjcmlwdGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ29uUHJvZ3Jlc3MnICYmIG5hbWUgIT09ICdvbkNvbXBsZXRlJyAmJiBuYW1lICE9PSAnZm4nXG4gICAgfSk7XG4gICAgZGVmYXVsdHMuc2V0KCdhbmltYXRpb25zJywge1xuICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgIHR5cGU6ICdjb2xvcicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBjb2xvcnNcbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyczoge1xuICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBudW1iZXJzXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZhdWx0cy5kZXNjcmliZSgnYW5pbWF0aW9ucycsIHtcbiAgICAgICAgX2ZhbGxiYWNrOiAnYW5pbWF0aW9uJ1xuICAgIH0pO1xuICAgIGRlZmF1bHRzLnNldCgndHJhbnNpdGlvbnMnLCB7XG4gICAgICAgIGFjdGl2ZToge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb246IDQwMFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZXNpemU6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNob3c6IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogJ3RyYW5zcGFyZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdmlzaWJsZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWRlOiB7XG4gICAgICAgICAgICBhbmltYXRpb25zOiB7XG4gICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgIHRvOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2aXNpYmxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nOiAnbGluZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgZm46ICh2KT0+diB8IDBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gYXBwbHlMYXlvdXRzRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cy5zZXQoJ2xheW91dCcsIHtcbiAgICAgICAgYXV0b1BhZGRpbmc6IHRydWUsXG4gICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICAgICAgbGVmdDogMFxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmNvbnN0IGludGxDYWNoZSA9IG5ldyBNYXAoKTtcbmZ1bmN0aW9uIGdldE51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBjYWNoZUtleSA9IGxvY2FsZSArIEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpO1xuICAgIGxldCBmb3JtYXR0ZXIgPSBpbnRsQ2FjaGUuZ2V0KGNhY2hlS2V5KTtcbiAgICBpZiAoIWZvcm1hdHRlcikge1xuICAgICAgICBmb3JtYXR0ZXIgPSBuZXcgSW50bC5OdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKTtcbiAgICAgICAgaW50bENhY2hlLnNldChjYWNoZUtleSwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdHRlcjtcbn1cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIGxvY2FsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBnZXROdW1iZXJGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXQobnVtKTtcbn1cblxuY29uc3QgZm9ybWF0dGVycyA9IHtcbiB2YWx1ZXMgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/ICB2YWx1ZSA6ICcnICsgdmFsdWU7XG4gICAgfSxcbiBudW1lcmljICh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgICAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHRoaXMuY2hhcnQub3B0aW9ucy5sb2NhbGU7XG4gICAgICAgIGxldCBub3RhdGlvbjtcbiAgICAgICAgbGV0IGRlbHRhID0gdGlja1ZhbHVlO1xuICAgICAgICBpZiAodGlja3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgbWF4VGljayA9IE1hdGgubWF4KE1hdGguYWJzKHRpY2tzWzBdLnZhbHVlKSwgTWF0aC5hYnModGlja3NbdGlja3MubGVuZ3RoIC0gMV0udmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChtYXhUaWNrIDwgMWUtNCB8fCBtYXhUaWNrID4gMWUrMTUpIHtcbiAgICAgICAgICAgICAgICBub3RhdGlvbiA9ICdzY2llbnRpZmljJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbHRhID0gY2FsY3VsYXRlRGVsdGEodGlja1ZhbHVlLCB0aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nRGVsdGEgPSBsb2cxMChNYXRoLmFicyhkZWx0YSkpO1xuICAgICAgICBjb25zdCBudW1EZWNpbWFsID0gaXNOYU4obG9nRGVsdGEpID8gMSA6IE1hdGgubWF4KE1hdGgubWluKC0xICogTWF0aC5mbG9vcihsb2dEZWx0YSksIDIwKSwgMCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBub3RhdGlvbixcbiAgICAgICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbCxcbiAgICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogbnVtRGVjaW1hbFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuYXNzaWduKG9wdGlvbnMsIHRoaXMub3B0aW9ucy50aWNrcy5mb3JtYXQpO1xuICAgICAgICByZXR1cm4gZm9ybWF0TnVtYmVyKHRpY2tWYWx1ZSwgbG9jYWxlLCBvcHRpb25zKTtcbiAgICB9LFxuIGxvZ2FyaXRobWljICh0aWNrVmFsdWUsIGluZGV4LCB0aWNrcykge1xuICAgICAgICBpZiAodGlja1ZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gJzAnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbWFpbiA9IHRpY2tzW2luZGV4XS5zaWduaWZpY2FuZCB8fCB0aWNrVmFsdWUgLyBNYXRoLnBvdygxMCwgTWF0aC5mbG9vcihsb2cxMCh0aWNrVmFsdWUpKSk7XG4gICAgICAgIGlmIChbXG4gICAgICAgICAgICAxLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgIDMsXG4gICAgICAgICAgICA1LFxuICAgICAgICAgICAgMTAsXG4gICAgICAgICAgICAxNVxuICAgICAgICBdLmluY2x1ZGVzKHJlbWFpbikgfHwgaW5kZXggPiAwLjggKiB0aWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmb3JtYXR0ZXJzLm51bWVyaWMuY2FsbCh0aGlzLCB0aWNrVmFsdWUsIGluZGV4LCB0aWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn07XG5mdW5jdGlvbiBjYWxjdWxhdGVEZWx0YSh0aWNrVmFsdWUsIHRpY2tzKSB7XG4gICAgbGV0IGRlbHRhID0gdGlja3MubGVuZ3RoID4gMyA/IHRpY2tzWzJdLnZhbHVlIC0gdGlja3NbMV0udmFsdWUgOiB0aWNrc1sxXS52YWx1ZSAtIHRpY2tzWzBdLnZhbHVlO1xuICAgIGlmIChNYXRoLmFicyhkZWx0YSkgPj0gMSAmJiB0aWNrVmFsdWUgIT09IE1hdGguZmxvb3IodGlja1ZhbHVlKSkge1xuICAgICAgICBkZWx0YSA9IHRpY2tWYWx1ZSAtIE1hdGguZmxvb3IodGlja1ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlbHRhO1xufVxuIHZhciBUaWNrcyA9IHtcbiAgICBmb3JtYXR0ZXJzXG59O1xuXG5mdW5jdGlvbiBhcHBseVNjYWxlRGVmYXVsdHMoZGVmYXVsdHMpIHtcbiAgICBkZWZhdWx0cy5zZXQoJ3NjYWxlJywge1xuICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICByZXZlcnNlOiBmYWxzZSxcbiAgICAgICAgYmVnaW5BdFplcm86IGZhbHNlLFxuIGJvdW5kczogJ3RpY2tzJyxcbiAgICAgICAgY2xpcDogdHJ1ZSxcbiBncmFjZTogMCxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgICAgIGRyYXdPbkNoYXJ0QXJlYTogdHJ1ZSxcbiAgICAgICAgICAgIGRyYXdUaWNrczogdHJ1ZSxcbiAgICAgICAgICAgIHRpY2tMZW5ndGg6IDgsXG4gICAgICAgICAgICB0aWNrV2lkdGg6IChfY3R4LCBvcHRpb25zKT0+b3B0aW9ucy5saW5lV2lkdGgsXG4gICAgICAgICAgICB0aWNrQ29sb3I6IChfY3R4LCBvcHRpb25zKT0+b3B0aW9ucy5jb2xvcixcbiAgICAgICAgICAgIG9mZnNldDogZmFsc2VcbiAgICAgICAgfSxcbiAgICAgICAgYm9yZGVyOiB7XG4gICAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgICAgZGFzaDogW10sXG4gICAgICAgICAgICBkYXNoT2Zmc2V0OiAwLjAsXG4gICAgICAgICAgICB3aWR0aDogMVxuICAgICAgICB9LFxuICAgICAgICB0aXRsZToge1xuICAgICAgICAgICAgZGlzcGxheTogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgICAgICB0b3A6IDQsXG4gICAgICAgICAgICAgICAgYm90dG9tOiA0XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRpY2tzOiB7XG4gICAgICAgICAgICBtaW5Sb3RhdGlvbjogMCxcbiAgICAgICAgICAgIG1heFJvdGF0aW9uOiA1MCxcbiAgICAgICAgICAgIG1pcnJvcjogZmFsc2UsXG4gICAgICAgICAgICB0ZXh0U3Ryb2tlV2lkdGg6IDAsXG4gICAgICAgICAgICB0ZXh0U3Ryb2tlQ29sb3I6ICcnLFxuICAgICAgICAgICAgcGFkZGluZzogMyxcbiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgICBhdXRvU2tpcDogdHJ1ZSxcbiAgICAgICAgICAgIGF1dG9Ta2lwUGFkZGluZzogMyxcbiAgICAgICAgICAgIGxhYmVsT2Zmc2V0OiAwLFxuICAgICAgICAgICAgY2FsbGJhY2s6IFRpY2tzLmZvcm1hdHRlcnMudmFsdWVzLFxuICAgICAgICAgICAgbWlub3I6IHt9LFxuICAgICAgICAgICAgbWFqb3I6IHt9LFxuICAgICAgICAgICAgYWxpZ246ICdjZW50ZXInLFxuICAgICAgICAgICAgY3Jvc3NBbGlnbjogJ25lYXInLFxuICAgICAgICAgICAgc2hvd0xhYmVsQmFja2Ryb3A6IGZhbHNlLFxuICAgICAgICAgICAgYmFja2Ryb3BDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC43NSknLFxuICAgICAgICAgICAgYmFja2Ryb3BQYWRkaW5nOiAyXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGlja3MnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG4gICAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmdyaWQnLCAnY29sb3InLCAnJywgJ2JvcmRlckNvbG9yJyk7XG4gICAgZGVmYXVsdHMucm91dGUoJ3NjYWxlLmJvcmRlcicsICdjb2xvcicsICcnLCAnYm9yZGVyQ29sb3InKTtcbiAgICBkZWZhdWx0cy5yb3V0ZSgnc2NhbGUudGl0bGUnLCAnY29sb3InLCAnJywgJ2NvbG9yJyk7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlJywge1xuICAgICAgICBfZmFsbGJhY2s6IGZhbHNlLFxuICAgICAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT4hbmFtZS5zdGFydHNXaXRoKCdiZWZvcmUnKSAmJiAhbmFtZS5zdGFydHNXaXRoKCdhZnRlcicpICYmIG5hbWUgIT09ICdjYWxsYmFjaycgJiYgbmFtZSAhPT0gJ3BhcnNlcicsXG4gICAgICAgIF9pbmRleGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ2JvcmRlckRhc2gnICYmIG5hbWUgIT09ICd0aWNrQm9yZGVyRGFzaCcgJiYgbmFtZSAhPT0gJ2Rhc2gnXG4gICAgfSk7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlcycsIHtcbiAgICAgICAgX2ZhbGxiYWNrOiAnc2NhbGUnXG4gICAgfSk7XG4gICAgZGVmYXVsdHMuZGVzY3JpYmUoJ3NjYWxlLnRpY2tzJywge1xuICAgICAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT5uYW1lICE9PSAnYmFja2Ryb3BQYWRkaW5nJyAmJiBuYW1lICE9PSAnY2FsbGJhY2snLFxuICAgICAgICBfaW5kZXhhYmxlOiAobmFtZSk9Pm5hbWUgIT09ICdiYWNrZHJvcFBhZGRpbmcnXG4gICAgfSk7XG59XG5cbmNvbnN0IG92ZXJyaWRlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gZnVuY3Rpb24gZ2V0U2NvcGUkMShub2RlLCBrZXkpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgY29uc3Qga2V5cyA9IGtleS5zcGxpdCgnLicpO1xuICAgIGZvcihsZXQgaSA9IDAsIG4gPSBrZXlzLmxlbmd0aDsgaSA8IG47ICsraSl7XG4gICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICBub2RlID0gbm9kZVtrXSB8fCAobm9kZVtrXSA9IE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHNldChyb290LCBzY29wZSwgdmFsdWVzKSB7XG4gICAgaWYgKHR5cGVvZiBzY29wZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlKGdldFNjb3BlJDEocm9vdCwgc2NvcGUpLCB2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2UoZ2V0U2NvcGUkMShyb290LCAnJyksIHNjb3BlKTtcbn1cbiBjbGFzcyBEZWZhdWx0cyB7XG4gICAgY29uc3RydWN0b3IoX2Rlc2NyaXB0b3JzLCBfYXBwbGllcnMpe1xuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLDAsMCwwLjEpJztcbiAgICAgICAgdGhpcy5ib3JkZXJDb2xvciA9ICdyZ2JhKDAsMCwwLDAuMSknO1xuICAgICAgICB0aGlzLmNvbG9yID0gJyM2NjYnO1xuICAgICAgICB0aGlzLmRhdGFzZXRzID0ge307XG4gICAgICAgIHRoaXMuZGV2aWNlUGl4ZWxSYXRpbyA9IChjb250ZXh0KT0+Y29udGV4dC5jaGFydC5wbGF0Zm9ybS5nZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSBbXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICdtb3VzZW91dCcsXG4gICAgICAgICAgICAnY2xpY2snLFxuICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgJ3RvdWNobW92ZSdcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5mb250ID0ge1xuICAgICAgICAgICAgZmFtaWx5OiBcIidIZWx2ZXRpY2EgTmV1ZScsICdIZWx2ZXRpY2EnLCAnQXJpYWwnLCBzYW5zLXNlcmlmXCIsXG4gICAgICAgICAgICBzaXplOiAxMixcbiAgICAgICAgICAgIHN0eWxlOiAnbm9ybWFsJyxcbiAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMixcbiAgICAgICAgICAgIHdlaWdodDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhvdmVyID0ge307XG4gICAgICAgIHRoaXMuaG92ZXJCYWNrZ3JvdW5kQ29sb3IgPSAoY3R4LCBvcHRpb25zKT0+Z2V0SG92ZXJDb2xvcihvcHRpb25zLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgIHRoaXMuaG92ZXJCb3JkZXJDb2xvciA9IChjdHgsIG9wdGlvbnMpPT5nZXRIb3ZlckNvbG9yKG9wdGlvbnMuYm9yZGVyQ29sb3IpO1xuICAgICAgICB0aGlzLmhvdmVyQ29sb3IgPSAoY3R4LCBvcHRpb25zKT0+Z2V0SG92ZXJDb2xvcihvcHRpb25zLmNvbG9yKTtcbiAgICAgICAgdGhpcy5pbmRleEF4aXMgPSAneCc7XG4gICAgICAgIHRoaXMuaW50ZXJhY3Rpb24gPSB7XG4gICAgICAgICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICAgICAgICBpbnRlcnNlY3Q6IHRydWUsXG4gICAgICAgICAgICBpbmNsdWRlSW52aXNpYmxlOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm1haW50YWluQXNwZWN0UmF0aW8gPSB0cnVlO1xuICAgICAgICB0aGlzLm9uSG92ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLm9uQ2xpY2sgPSBudWxsO1xuICAgICAgICB0aGlzLnBhcnNpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnBsdWdpbnMgPSB7fTtcbiAgICAgICAgdGhpcy5yZXNwb25zaXZlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zY2FsZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgICAgICAgdGhpcy5zaG93TGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhd0FjdGl2ZUVsZW1lbnRzT25Ub3AgPSB0cnVlO1xuICAgICAgICB0aGlzLmRlc2NyaWJlKF9kZXNjcmlwdG9ycyk7XG4gICAgICAgIHRoaXMuYXBwbHkoX2FwcGxpZXJzKTtcbiAgICB9XG4gc2V0KHNjb3BlLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHNldCh0aGlzLCBzY29wZSwgdmFsdWVzKTtcbiAgICB9XG4gZ2V0KHNjb3BlKSB7XG4gICAgICAgIHJldHVybiBnZXRTY29wZSQxKHRoaXMsIHNjb3BlKTtcbiAgICB9XG4gZGVzY3JpYmUoc2NvcGUsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gc2V0KGRlc2NyaXB0b3JzLCBzY29wZSwgdmFsdWVzKTtcbiAgICB9XG4gICAgb3ZlcnJpZGUoc2NvcGUsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gc2V0KG92ZXJyaWRlcywgc2NvcGUsIHZhbHVlcyk7XG4gICAgfVxuIHJvdXRlKHNjb3BlLCBuYW1lLCB0YXJnZXRTY29wZSwgdGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgc2NvcGUpO1xuICAgICAgICBjb25zdCB0YXJnZXRTY29wZU9iamVjdCA9IGdldFNjb3BlJDEodGhpcywgdGFyZ2V0U2NvcGUpO1xuICAgICAgICBjb25zdCBwcml2YXRlTmFtZSA9ICdfJyArIG5hbWU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHNjb3BlT2JqZWN0LCB7XG4gICAgICAgICAgICBbcHJpdmF0ZU5hbWVdOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHNjb3BlT2JqZWN0W25hbWVdLFxuICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgW25hbWVdOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQgKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXNbcHJpdmF0ZU5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0YXJnZXRTY29wZU9iamVjdFt0YXJnZXROYW1lXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGxvY2FsKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRhcmdldCwgbG9jYWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZU9yRGVmYXVsdChsb2NhbCwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldCAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1twcml2YXRlTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseShhcHBsaWVycykge1xuICAgICAgICBhcHBsaWVycy5mb3JFYWNoKChhcHBseSk9PmFwcGx5KHRoaXMpKTtcbiAgICB9XG59XG52YXIgZGVmYXVsdHMgPSAvKiAjX19QVVJFX18gKi8gbmV3IERlZmF1bHRzKHtcbiAgICBfc2NyaXB0YWJsZTogKG5hbWUpPT4hbmFtZS5zdGFydHNXaXRoKCdvbicpLFxuICAgIF9pbmRleGFibGU6IChuYW1lKT0+bmFtZSAhPT0gJ2V2ZW50cycsXG4gICAgaG92ZXI6IHtcbiAgICAgICAgX2ZhbGxiYWNrOiAnaW50ZXJhY3Rpb24nXG4gICAgfSxcbiAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBfc2NyaXB0YWJsZTogZmFsc2UsXG4gICAgICAgIF9pbmRleGFibGU6IGZhbHNlXG4gICAgfVxufSwgW1xuICAgIGFwcGx5QW5pbWF0aW9uc0RlZmF1bHRzLFxuICAgIGFwcGx5TGF5b3V0c0RlZmF1bHRzLFxuICAgIGFwcGx5U2NhbGVEZWZhdWx0c1xuXSk7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIGZvbnQgb2JqZWN0IGludG8gYSBDU1MgZm9udCBzdHJpbmcuXG4gKiBAcGFyYW0gZm9udCAtIEEgZm9udCBvYmplY3QuXG4gKiBAcmV0dXJuIFRoZSBDU1MgZm9udCBzdHJpbmcuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udFxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiB0b0ZvbnRTdHJpbmcoZm9udCkge1xuICAgIGlmICghZm9udCB8fCBpc051bGxPclVuZGVmKGZvbnQuc2l6ZSkgfHwgaXNOdWxsT3JVbmRlZihmb250LmZhbWlseSkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoZm9udC5zdHlsZSA/IGZvbnQuc3R5bGUgKyAnICcgOiAnJykgKyAoZm9udC53ZWlnaHQgPyBmb250LndlaWdodCArICcgJyA6ICcnKSArIGZvbnQuc2l6ZSArICdweCAnICsgZm9udC5mYW1pbHk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX21lYXN1cmVUZXh0KGN0eCwgZGF0YSwgZ2MsIGxvbmdlc3QsIHN0cmluZykge1xuICAgIGxldCB0ZXh0V2lkdGggPSBkYXRhW3N0cmluZ107XG4gICAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICAgICAgdGV4dFdpZHRoID0gZGF0YVtzdHJpbmddID0gY3R4Lm1lYXN1cmVUZXh0KHN0cmluZykud2lkdGg7XG4gICAgICAgIGdjLnB1c2goc3RyaW5nKTtcbiAgICB9XG4gICAgaWYgKHRleHRXaWR0aCA+IGxvbmdlc3QpIHtcbiAgICAgICAgbG9uZ2VzdCA9IHRleHRXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGxvbmdlc3Q7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIF9sb25nZXN0VGV4dChjdHgsIGZvbnQsIGFycmF5T2ZUaGluZ3MsIGNhY2hlKSB7XG4gICAgY2FjaGUgPSBjYWNoZSB8fCB7fTtcbiAgICBsZXQgZGF0YSA9IGNhY2hlLmRhdGEgPSBjYWNoZS5kYXRhIHx8IHt9O1xuICAgIGxldCBnYyA9IGNhY2hlLmdhcmJhZ2VDb2xsZWN0ID0gY2FjaGUuZ2FyYmFnZUNvbGxlY3QgfHwgW107XG4gICAgaWYgKGNhY2hlLmZvbnQgIT09IGZvbnQpIHtcbiAgICAgICAgZGF0YSA9IGNhY2hlLmRhdGEgPSB7fTtcbiAgICAgICAgZ2MgPSBjYWNoZS5nYXJiYWdlQ29sbGVjdCA9IFtdO1xuICAgICAgICBjYWNoZS5mb250ID0gZm9udDtcbiAgICB9XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguZm9udCA9IGZvbnQ7XG4gICAgbGV0IGxvbmdlc3QgPSAwO1xuICAgIGNvbnN0IGlsZW4gPSBhcnJheU9mVGhpbmdzLmxlbmd0aDtcbiAgICBsZXQgaSwgaiwgamxlbiwgdGhpbmcsIG5lc3RlZFRoaW5nO1xuICAgIGZvcihpID0gMDsgaSA8IGlsZW47IGkrKyl7XG4gICAgICAgIHRoaW5nID0gYXJyYXlPZlRoaW5nc1tpXTtcbiAgICAgICAgLy8gVW5kZWZpbmVkIHN0cmluZ3MgYW5kIGFycmF5cyBzaG91bGQgbm90IGJlIG1lYXN1cmVkXG4gICAgICAgIGlmICh0aGluZyAhPT0gdW5kZWZpbmVkICYmIHRoaW5nICE9PSBudWxsICYmICFpc0FycmF5KHRoaW5nKSkge1xuICAgICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCB0aGluZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0aGluZykpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIGFuIGFycmF5IGxldHMgbWVhc3VyZSBlYWNoIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvIGRvIG1heWJlIHNpbXBsaWZ5IHRoaXMgZnVuY3Rpb24gYSBiaXQgc28gd2UgY2FuIGRvIHRoaXMgbW9yZSByZWN1cnNpdmVseT9cbiAgICAgICAgICAgIGZvcihqID0gMCwgamxlbiA9IHRoaW5nLmxlbmd0aDsgaiA8IGpsZW47IGorKyl7XG4gICAgICAgICAgICAgICAgbmVzdGVkVGhpbmcgPSB0aGluZ1tqXTtcbiAgICAgICAgICAgICAgICAvLyBVbmRlZmluZWQgc3RyaW5ncyBhbmQgYXJyYXlzIHNob3VsZCBub3QgYmUgbWVhc3VyZWRcbiAgICAgICAgICAgICAgICBpZiAobmVzdGVkVGhpbmcgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRUaGluZyAhPT0gbnVsbCAmJiAhaXNBcnJheShuZXN0ZWRUaGluZykpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdCA9IF9tZWFzdXJlVGV4dChjdHgsIGRhdGEsIGdjLCBsb25nZXN0LCBuZXN0ZWRUaGluZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY29uc3QgZ2NMZW4gPSBnYy5sZW5ndGggLyAyO1xuICAgIGlmIChnY0xlbiA+IGFycmF5T2ZUaGluZ3MubGVuZ3RoKSB7XG4gICAgICAgIGZvcihpID0gMDsgaSA8IGdjTGVuOyBpKyspe1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFbZ2NbaV1dO1xuICAgICAgICB9XG4gICAgICAgIGdjLnNwbGljZSgwLCBnY0xlbik7XG4gICAgfVxuICAgIHJldHVybiBsb25nZXN0O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlIHRvIGF2b2lkIGFudGktYWxpYXNpbmcgYmx1clxuICogQHBhcmFtIGNoYXJ0IC0gVGhlIGNoYXJ0IGluc3RhbmNlLlxuICogQHBhcmFtIHBpeGVsIC0gQSBwaXhlbCB2YWx1ZS5cbiAqIEBwYXJhbSB3aWR0aCAtIFRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBhbGlnbmVkIHBpeGVsIHZhbHVlLlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfYWxpZ25QaXhlbChjaGFydCwgcGl4ZWwsIHdpZHRoKSB7XG4gICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IGNoYXJ0LmN1cnJlbnREZXZpY2VQaXhlbFJhdGlvO1xuICAgIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoICE9PSAwID8gTWF0aC5tYXgod2lkdGggLyAyLCAwLjUpIDogMDtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCgocGl4ZWwgLSBoYWxmV2lkdGgpICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvICsgaGFsZldpZHRoO1xufVxuLyoqXG4gKiBDbGVhcnMgdGhlIGVudGlyZSBjYW52YXMuXG4gKi8gZnVuY3Rpb24gY2xlYXJDYW52YXMoY2FudmFzLCBjdHgpIHtcbiAgICBpZiAoIWN0eCAmJiAhY2FudmFzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3R4ID0gY3R4IHx8IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgLy8gY2FudmFzLndpZHRoIGFuZCBjYW52YXMuaGVpZ2h0IGRvIG5vdCBjb25zaWRlciB0aGUgY2FudmFzIHRyYW5zZm9ybSxcbiAgICAvLyB3aGlsZSBjbGVhclJlY3QgZG9lc1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSgpO1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuZnVuY3Rpb24gZHJhd1BvaW50KGN0eCwgb3B0aW9ucywgeCwgeSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCBudWxsKTtcbn1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiBkcmF3UG9pbnRMZWdlbmQoY3R4LCBvcHRpb25zLCB4LCB5LCB3KSB7XG4gICAgbGV0IHR5cGUsIHhPZmZzZXQsIHlPZmZzZXQsIHNpemUsIGNvcm5lclJhZGl1cywgd2lkdGgsIHhPZmZzZXRXLCB5T2Zmc2V0VztcbiAgICBjb25zdCBzdHlsZSA9IG9wdGlvbnMucG9pbnRTdHlsZTtcbiAgICBjb25zdCByb3RhdGlvbiA9IG9wdGlvbnMucm90YXRpb247XG4gICAgY29uc3QgcmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XG4gICAgbGV0IHJhZCA9IChyb3RhdGlvbiB8fCAwKSAqIFJBRF9QRVJfREVHO1xuICAgIGlmIChzdHlsZSAmJiB0eXBlb2Ygc3R5bGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHR5cGUgPSBzdHlsZS50b1N0cmluZygpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgSFRNTEltYWdlRWxlbWVudF0nIHx8IHR5cGUgPT09ICdbb2JqZWN0IEhUTUxDYW52YXNFbGVtZW50XScpIHtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShyYWQpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShzdHlsZSwgLXN0eWxlLndpZHRoIC8gMiwgLXN0eWxlLmhlaWdodCAvIDIsIHN0eWxlLndpZHRoLCBzdHlsZS5oZWlnaHQpO1xuICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNOYU4ocmFkaXVzKSB8fCByYWRpdXMgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBzd2l0Y2goc3R5bGUpe1xuICAgICAgICAvLyBEZWZhdWx0IGluY2x1ZGVzIGNpcmNsZVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICBjdHguZWxsaXBzZSh4LCB5LCB3IC8gMiwgcmFkaXVzLCAwLCAwLCBUQVUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgVEFVKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd0cmlhbmdsZSc6XG4gICAgICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHJhZGl1cztcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIE1hdGguc2luKHJhZCkgKiB3aWR0aCwgeSAtIE1hdGguY29zKHJhZCkgKiByYWRpdXMpO1xuICAgICAgICAgICAgcmFkICs9IFRXT19USElSRFNfUEk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyBNYXRoLnNpbihyYWQpICogd2lkdGgsIHkgLSBNYXRoLmNvcyhyYWQpICogcmFkaXVzKTtcbiAgICAgICAgICAgIHJhZCArPSBUV09fVEhJUkRTX1BJO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5zaW4ocmFkKSAqIHdpZHRoLCB5IC0gTWF0aC5jb3MocmFkKSAqIHJhZGl1cyk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVjdFJvdW5kZWQnOlxuICAgICAgICAgICAgLy8gTk9URTogdGhlIHJvdW5kZWQgcmVjdCBpbXBsZW1lbnRhdGlvbiBjaGFuZ2VkIHRvIHVzZSBgYXJjYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAvLyBgcXVhZHJhdGljQ3VydmVUb2Agc2luY2UgaXQgZ2VuZXJhdGVzIGJldHRlciByZXN1bHRzIHdoZW4gcmVjdCBpc1xuICAgICAgICAgICAgLy8gYWxtb3N0IGEgY2lyY2xlLiAwLjUxNiAoaW5zdGVhZCBvZiAwLjUpIHByb2R1Y2VzIHJlc3VsdHMgd2l0aCB2aXN1YWxseVxuICAgICAgICAgICAgLy8gY2xvc2VyIHByb3BvcnRpb24gdG8gdGhlIHByZXZpb3VzIGltcGwgYW5kIGl0IGlzIGluc2NyaWJlZCBpbiB0aGVcbiAgICAgICAgICAgIC8vIGNpcmNsZSB3aXRoIGByYWRpdXNgLiBGb3IgbW9yZSBkZXRhaWxzLCBzZWUgdGhlIGZvbGxvd2luZyBQUnM6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNTU5N1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzU4NThcbiAgICAgICAgICAgIGNvcm5lclJhZGl1cyA9IHJhZGl1cyAqIDAuNTE2O1xuICAgICAgICAgICAgc2l6ZSA9IHJhZGl1cyAtIGNvcm5lclJhZGl1cztcbiAgICAgICAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQgKyBRVUFSVEVSX1BJKSAqIHNpemU7XG4gICAgICAgICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCArIFFVQVJURVJfUEkpICogKHcgPyB3IC8gMiAtIGNvcm5lclJhZGl1cyA6IHNpemUpO1xuICAgICAgICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCArIFFVQVJURVJfUEkpICogc2l6ZTtcbiAgICAgICAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkICsgUVVBUlRFUl9QSSkgKiAodyA/IHcgLyAyIC0gY29ybmVyUmFkaXVzIDogc2l6ZSk7XG4gICAgICAgICAgICBjdHguYXJjKHggLSB4T2Zmc2V0VywgeSAtIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkIC0gUEksIHJhZCAtIEhBTEZfUEkpO1xuICAgICAgICAgICAgY3R4LmFyYyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0LCBjb3JuZXJSYWRpdXMsIHJhZCAtIEhBTEZfUEksIHJhZCk7XG4gICAgICAgICAgICBjdHguYXJjKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQsIGNvcm5lclJhZGl1cywgcmFkLCByYWQgKyBIQUxGX1BJKTtcbiAgICAgICAgICAgIGN0eC5hcmMoeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCwgY29ybmVyUmFkaXVzLCByYWQgKyBIQUxGX1BJLCByYWQgKyBQSSk7XG4gICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVjdCc6XG4gICAgICAgICAgICBpZiAoIXJvdGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IE1hdGguU1FSVDFfMiAqIHJhZGl1cztcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHcgPyB3IC8gMiA6IHNpemU7XG4gICAgICAgICAgICAgICAgY3R4LnJlY3QoeCAtIHdpZHRoLCB5IC0gc2l6ZSwgMiAqIHdpZHRoLCAyICogc2l6ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLyBjYXNlICdyZWN0Um90JzpcbiAgICAgICAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHlPZmZzZXRXLCB5IC0geE9mZnNldCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjcm9zc1JvdCc6XG4gICAgICAgICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqLyBjYXNlICdjcm9zcyc6XG4gICAgICAgICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgICAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc3Rhcic6XG4gICAgICAgICAgICB4T2Zmc2V0VyA9IE1hdGguY29zKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgICAgICAgIHhPZmZzZXQgPSBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0VyA9IE1hdGguc2luKHJhZCkgKiAodyA/IHcgLyAyIDogcmFkaXVzKTtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCAtIHhPZmZzZXRXLCB5IC0geU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0VywgeSArIHlPZmZzZXQpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4ICsgeU9mZnNldFcsIHkgLSB4T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCAtIHlPZmZzZXRXLCB5ICsgeE9mZnNldCk7XG4gICAgICAgICAgICByYWQgKz0gUVVBUlRFUl9QSTtcbiAgICAgICAgICAgIHhPZmZzZXRXID0gTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgeE9mZnNldCA9IE1hdGguY29zKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gTWF0aC5zaW4ocmFkKSAqIHJhZGl1cztcbiAgICAgICAgICAgIHlPZmZzZXRXID0gTWF0aC5zaW4ocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpO1xuICAgICAgICAgICAgY3R4Lm1vdmVUbyh4IC0geE9mZnNldFcsIHkgLSB5T2Zmc2V0KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCArIHhPZmZzZXRXLCB5ICsgeU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggKyB5T2Zmc2V0VywgeSAtIHhPZmZzZXQpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0geU9mZnNldFcsIHkgKyB4T2Zmc2V0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaW5lJzpcbiAgICAgICAgICAgIHhPZmZzZXQgPSB3ID8gdyAvIDIgOiBNYXRoLmNvcyhyYWQpICogcmFkaXVzO1xuICAgICAgICAgICAgeU9mZnNldCA9IE1hdGguc2luKHJhZCkgKiByYWRpdXM7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHggLSB4T2Zmc2V0LCB5IC0geU9mZnNldCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB4T2Zmc2V0LCB5ICsgeU9mZnNldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGFzaCc6XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgTWF0aC5jb3MocmFkKSAqICh3ID8gdyAvIDIgOiByYWRpdXMpLCB5ICsgTWF0aC5zaW4ocmFkKSAqIHJhZGl1cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBmYWxzZTpcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjdHguZmlsbCgpO1xuICAgIGlmIChvcHRpb25zLmJvcmRlcldpZHRoID4gMCkge1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBvaW50IGlzIGluc2lkZSB0aGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gcG9pbnQgLSBUaGUgcG9pbnQgdG8gdGVzdFxuICogQHBhcmFtIGFyZWEgLSBUaGUgcmVjdGFuZ2xlXG4gKiBAcGFyYW0gbWFyZ2luIC0gYWxsb3dlZCBtYXJnaW5cbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2lzUG9pbnRJbkFyZWEocG9pbnQsIGFyZWEsIG1hcmdpbikge1xuICAgIG1hcmdpbiA9IG1hcmdpbiB8fCAwLjU7IC8vIG1hcmdpbiAtIGRlZmF1bHQgaXMgdG8gbWF0Y2ggcm91bmRlZCBkZWNpbWFsc1xuICAgIHJldHVybiAhYXJlYSB8fCBwb2ludCAmJiBwb2ludC54ID4gYXJlYS5sZWZ0IC0gbWFyZ2luICYmIHBvaW50LnggPCBhcmVhLnJpZ2h0ICsgbWFyZ2luICYmIHBvaW50LnkgPiBhcmVhLnRvcCAtIG1hcmdpbiAmJiBwb2ludC55IDwgYXJlYS5ib3R0b20gKyBtYXJnaW47XG59XG5mdW5jdGlvbiBjbGlwQXJlYShjdHgsIGFyZWEpIHtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgucmVjdChhcmVhLmxlZnQsIGFyZWEudG9wLCBhcmVhLnJpZ2h0IC0gYXJlYS5sZWZ0LCBhcmVhLmJvdHRvbSAtIGFyZWEudG9wKTtcbiAgICBjdHguY2xpcCgpO1xufVxuZnVuY3Rpb24gdW5jbGlwQXJlYShjdHgpIHtcbiAgICBjdHgucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9zdGVwcGVkTGluZVRvKGN0eCwgcHJldmlvdXMsIHRhcmdldCwgZmxpcCwgbW9kZSkge1xuICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgICAgcmV0dXJuIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbiAgICB9XG4gICAgaWYgKG1vZGUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIGNvbnN0IG1pZHBvaW50ID0gKHByZXZpb3VzLnggKyB0YXJnZXQueCkgLyAyLjA7XG4gICAgICAgIGN0eC5saW5lVG8obWlkcG9pbnQsIHByZXZpb3VzLnkpO1xuICAgICAgICBjdHgubGluZVRvKG1pZHBvaW50LCB0YXJnZXQueSk7XG4gICAgfSBlbHNlIGlmIChtb2RlID09PSAnYWZ0ZXInICE9PSAhIWZsaXApIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwcmV2aW91cy54LCB0YXJnZXQueSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmxpbmVUbyh0YXJnZXQueCwgcHJldmlvdXMueSk7XG4gICAgfVxuICAgIGN0eC5saW5lVG8odGFyZ2V0LngsIHRhcmdldC55KTtcbn1cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfYmV6aWVyQ3VydmVUbyhjdHgsIHByZXZpb3VzLCB0YXJnZXQsIGZsaXApIHtcbiAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICAgIHJldHVybiBjdHgubGluZVRvKHRhcmdldC54LCB0YXJnZXQueSk7XG4gICAgfVxuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGZsaXAgPyBwcmV2aW91cy5jcDF4IDogcHJldmlvdXMuY3AyeCwgZmxpcCA/IHByZXZpb3VzLmNwMXkgOiBwcmV2aW91cy5jcDJ5LCBmbGlwID8gdGFyZ2V0LmNwMnggOiB0YXJnZXQuY3AxeCwgZmxpcCA/IHRhcmdldC5jcDJ5IDogdGFyZ2V0LmNwMXksIHRhcmdldC54LCB0YXJnZXQueSk7XG59XG5mdW5jdGlvbiBzZXRSZW5kZXJPcHRzKGN0eCwgb3B0cykge1xuICAgIGlmIChvcHRzLnRyYW5zbGF0aW9uKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUob3B0cy50cmFuc2xhdGlvblswXSwgb3B0cy50cmFuc2xhdGlvblsxXSk7XG4gICAgfVxuICAgIGlmICghaXNOdWxsT3JVbmRlZihvcHRzLnJvdGF0aW9uKSkge1xuICAgICAgICBjdHgucm90YXRlKG9wdHMucm90YXRpb24pO1xuICAgIH1cbiAgICBpZiAob3B0cy5jb2xvcikge1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gb3B0cy5jb2xvcjtcbiAgICB9XG4gICAgaWYgKG9wdHMudGV4dEFsaWduKSB7XG4gICAgICAgIGN0eC50ZXh0QWxpZ24gPSBvcHRzLnRleHRBbGlnbjtcbiAgICB9XG4gICAgaWYgKG9wdHMudGV4dEJhc2VsaW5lKSB7XG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSBvcHRzLnRleHRCYXNlbGluZTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZWNvcmF0ZVRleHQoY3R4LCB4LCB5LCBsaW5lLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMuc3RyaWtldGhyb3VnaCB8fCBvcHRzLnVuZGVybGluZSkge1xuICAgICAgICAvKipcbiAgICAgKiBOb3cgdGhhdCBJRTExIHN1cHBvcnQgaGFzIGJlZW4gZHJvcHBlZCwgd2UgY2FuIHVzZSBtb3JlXG4gICAgICogb2YgdGhlIFRleHRNZXRyaWNzIG9iamVjdC4gVGhlIGFjdHVhbCBib3VuZGluZyBib3hlc1xuICAgICAqIGFyZSB1bmZsYWdnZWQgaW4gQ2hyb21lLCBGaXJlZm94LCBFZGdlLCBhbmQgU2FmYXJpIHNvIHRoZXlcbiAgICAgKiBjYW4gYmUgc2FmZWx5IHVzZWQuXG4gICAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UZXh0TWV0cmljcyNCcm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICAgKi8gY29uc3QgbWV0cmljcyA9IGN0eC5tZWFzdXJlVGV4dChsaW5lKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IHggLSBtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdDtcbiAgICAgICAgY29uc3QgcmlnaHQgPSB4ICsgbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0O1xuICAgICAgICBjb25zdCB0b3AgPSB5IC0gbWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudDtcbiAgICAgICAgY29uc3QgYm90dG9tID0geSArIG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50O1xuICAgICAgICBjb25zdCB5RGVjb3JhdGlvbiA9IG9wdHMuc3RyaWtldGhyb3VnaCA/ICh0b3AgKyBib3R0b20pIC8gMiA6IGJvdHRvbTtcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gb3B0cy5kZWNvcmF0aW9uV2lkdGggfHwgMjtcbiAgICAgICAgY3R4Lm1vdmVUbyhsZWZ0LCB5RGVjb3JhdGlvbik7XG4gICAgICAgIGN0eC5saW5lVG8ocmlnaHQsIHlEZWNvcmF0aW9uKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRyYXdCYWNrZHJvcChjdHgsIG9wdHMpIHtcbiAgICBjb25zdCBvbGRDb2xvciA9IGN0eC5maWxsU3R5bGU7XG4gICAgY3R4LmZpbGxTdHlsZSA9IG9wdHMuY29sb3I7XG4gICAgY3R4LmZpbGxSZWN0KG9wdHMubGVmdCwgb3B0cy50b3AsIG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gb2xkQ29sb3I7XG59XG4vKipcbiAqIFJlbmRlciB0ZXh0IG9udG8gdGhlIGNhbnZhc1xuICovIGZ1bmN0aW9uIHJlbmRlclRleHQoY3R4LCB0ZXh0LCB4LCB5LCBmb250LCBvcHRzID0ge30pIHtcbiAgICBjb25zdCBsaW5lcyA9IGlzQXJyYXkodGV4dCkgPyB0ZXh0IDogW1xuICAgICAgICB0ZXh0XG4gICAgXTtcbiAgICBjb25zdCBzdHJva2UgPSBvcHRzLnN0cm9rZVdpZHRoID4gMCAmJiBvcHRzLnN0cm9rZUNvbG9yICE9PSAnJztcbiAgICBsZXQgaSwgbGluZTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG4gICAgc2V0UmVuZGVyT3B0cyhjdHgsIG9wdHMpO1xuICAgIGZvcihpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKXtcbiAgICAgICAgbGluZSA9IGxpbmVzW2ldO1xuICAgICAgICBpZiAob3B0cy5iYWNrZHJvcCkge1xuICAgICAgICAgICAgZHJhd0JhY2tkcm9wKGN0eCwgb3B0cy5iYWNrZHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cm9rZSkge1xuICAgICAgICAgICAgaWYgKG9wdHMuc3Ryb2tlQ29sb3IpIHtcbiAgICAgICAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBvcHRzLnN0cm9rZUNvbG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmKG9wdHMuc3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IG9wdHMuc3Ryb2tlV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCB4LCB5LCBvcHRzLm1heFdpZHRoKTtcbiAgICAgICAgfVxuICAgICAgICBjdHguZmlsbFRleHQobGluZSwgeCwgeSwgb3B0cy5tYXhXaWR0aCk7XG4gICAgICAgIGRlY29yYXRlVGV4dChjdHgsIHgsIHksIGxpbmUsIG9wdHMpO1xuICAgICAgICB5ICs9IE51bWJlcihmb250LmxpbmVIZWlnaHQpO1xuICAgIH1cbiAgICBjdHgucmVzdG9yZSgpO1xufVxuLyoqXG4gKiBBZGQgYSBwYXRoIG9mIGEgcmVjdGFuZ2xlIHdpdGggcm91bmRlZCBjb3JuZXJzIHRvIHRoZSBjdXJyZW50IHN1Yi1wYXRoXG4gKiBAcGFyYW0gY3R4IC0gQ29udGV4dFxuICogQHBhcmFtIHJlY3QgLSBCb3VuZGluZyByZWN0XG4gKi8gZnVuY3Rpb24gYWRkUm91bmRlZFJlY3RQYXRoKGN0eCwgcmVjdCkge1xuICAgIGNvbnN0IHsgeCAsIHkgLCB3ICwgaCAsIHJhZGl1cyAgfSA9IHJlY3Q7XG4gICAgLy8gdG9wIGxlZnQgYXJjXG4gICAgY3R4LmFyYyh4ICsgcmFkaXVzLnRvcExlZnQsIHkgKyByYWRpdXMudG9wTGVmdCwgcmFkaXVzLnRvcExlZnQsIDEuNSAqIFBJLCBQSSwgdHJ1ZSk7XG4gICAgLy8gbGluZSBmcm9tIHRvcCBsZWZ0IHRvIGJvdHRvbSBsZWZ0XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21MZWZ0KTtcbiAgICAvLyBib3R0b20gbGVmdCBhcmNcbiAgICBjdHguYXJjKHggKyByYWRpdXMuYm90dG9tTGVmdCwgeSArIGggLSByYWRpdXMuYm90dG9tTGVmdCwgcmFkaXVzLmJvdHRvbUxlZnQsIFBJLCBIQUxGX1BJLCB0cnVlKTtcbiAgICAvLyBsaW5lIGZyb20gYm90dG9tIGxlZnQgdG8gYm90dG9tIHJpZ2h0XG4gICAgY3R4LmxpbmVUbyh4ICsgdyAtIHJhZGl1cy5ib3R0b21SaWdodCwgeSArIGgpO1xuICAgIC8vIGJvdHRvbSByaWdodCBhcmNcbiAgICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLmJvdHRvbVJpZ2h0LCB5ICsgaCAtIHJhZGl1cy5ib3R0b21SaWdodCwgcmFkaXVzLmJvdHRvbVJpZ2h0LCBIQUxGX1BJLCAwLCB0cnVlKTtcbiAgICAvLyBsaW5lIGZyb20gYm90dG9tIHJpZ2h0IHRvIHRvcCByaWdodFxuICAgIGN0eC5saW5lVG8oeCArIHcsIHkgKyByYWRpdXMudG9wUmlnaHQpO1xuICAgIC8vIHRvcCByaWdodCBhcmNcbiAgICBjdHguYXJjKHggKyB3IC0gcmFkaXVzLnRvcFJpZ2h0LCB5ICsgcmFkaXVzLnRvcFJpZ2h0LCByYWRpdXMudG9wUmlnaHQsIDAsIC1IQUxGX1BJLCB0cnVlKTtcbiAgICAvLyBsaW5lIGZyb20gdG9wIHJpZ2h0IHRvIHRvcCBsZWZ0XG4gICAgY3R4LmxpbmVUbyh4ICsgcmFkaXVzLnRvcExlZnQsIHkpO1xufVxuXG5jb25zdCBMSU5FX0hFSUdIVCA9IC9eKG5vcm1hbHwoXFxkKyg/OlxcLlxcZCspPykocHh8ZW18JSk/KSQvO1xuY29uc3QgRk9OVF9TVFlMRSA9IC9eKG5vcm1hbHxpdGFsaWN8aW5pdGlhbHxpbmhlcml0fHVuc2V0fChvYmxpcXVlKCAtP1swLTldP1swLTldZGVnKT8pKSQvO1xuLyoqXG4gKiBAYWxpYXMgQ2hhcnQuaGVscGVycy5vcHRpb25zXG4gKiBAbmFtZXNwYWNlXG4gKi8gLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gbGluZSBoZWlnaHQgYHZhbHVlYCBpbiBwaXhlbHMgZm9yIGEgc3BlY2lmaWMgZm9udCBgc2l6ZWAuXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgbGluZUhlaWdodCB0byBwYXJzZSAoZWcuIDEuNiwgJzE0cHgnLCAnNzUlJywgJzEuNmVtJykuXG4gKiBAcGFyYW0gc2l6ZSAtIFRoZSBmb250IHNpemUgKGluIHBpeGVscykgdXNlZCB0byByZXNvbHZlIHJlbGF0aXZlIGB2YWx1ZWAuXG4gKiBAcmV0dXJucyBUaGUgZWZmZWN0aXZlIGxpbmUgaGVpZ2h0IGluIHBpeGVscyAoc2l6ZSAqIDEuMiBpZiB2YWx1ZSBpcyBpbnZhbGlkKS5cbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2xpbmUtaGVpZ2h0XG4gKiBAc2luY2UgMi43LjBcbiAqLyBmdW5jdGlvbiB0b0xpbmVIZWlnaHQodmFsdWUsIHNpemUpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gKCcnICsgdmFsdWUpLm1hdGNoKExJTkVfSEVJR0hUKTtcbiAgICBpZiAoIW1hdGNoZXMgfHwgbWF0Y2hlc1sxXSA9PT0gJ25vcm1hbCcpIHtcbiAgICAgICAgcmV0dXJuIHNpemUgKiAxLjI7XG4gICAgfVxuICAgIHZhbHVlID0gK21hdGNoZXNbMl07XG4gICAgc3dpdGNoKG1hdGNoZXNbM10pe1xuICAgICAgICBjYXNlICdweCc6XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGNhc2UgJyUnOlxuICAgICAgICAgICAgdmFsdWUgLz0gMTAwO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBzaXplICogdmFsdWU7XG59XG5jb25zdCBudW1iZXJPclplcm8gPSAodik9Pit2IHx8IDA7XG5mdW5jdGlvbiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgcHJvcHMpIHtcbiAgICBjb25zdCByZXQgPSB7fTtcbiAgICBjb25zdCBvYmpQcm9wcyA9IGlzT2JqZWN0KHByb3BzKTtcbiAgICBjb25zdCBrZXlzID0gb2JqUHJvcHMgPyBPYmplY3Qua2V5cyhwcm9wcykgOiBwcm9wcztcbiAgICBjb25zdCByZWFkID0gaXNPYmplY3QodmFsdWUpID8gb2JqUHJvcHMgPyAocHJvcCk9PnZhbHVlT3JEZWZhdWx0KHZhbHVlW3Byb3BdLCB2YWx1ZVtwcm9wc1twcm9wXV0pIDogKHByb3ApPT52YWx1ZVtwcm9wXSA6ICgpPT52YWx1ZTtcbiAgICBmb3IgKGNvbnN0IHByb3Agb2Yga2V5cyl7XG4gICAgICAgIHJldFtwcm9wXSA9IG51bWJlck9yWmVybyhyZWFkKHByb3ApKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn1cbi8qKlxuICogQ29udmVydHMgdGhlIGdpdmVuIHZhbHVlIGludG8gYSBUUkJMIG9iamVjdC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0KVxuICogQHNpbmNlIDMuMC4wXG4gKi8gZnVuY3Rpb24gdG9UUkJMKHZhbHVlKSB7XG4gICAgcmV0dXJuIF9yZWFkVmFsdWVUb1Byb3BzKHZhbHVlLCB7XG4gICAgICAgIHRvcDogJ3knLFxuICAgICAgICByaWdodDogJ3gnLFxuICAgICAgICBib3R0b206ICd5JyxcbiAgICAgICAgbGVmdDogJ3gnXG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIHRoZSBnaXZlbiB2YWx1ZSBpbnRvIGEgVFJCTCBjb3JuZXJzIG9iamVjdCAoc2ltaWxhciB3aXRoIGNzcyBib3JkZXItcmFkaXVzKS5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvcm5lciBjb21wb25lbnRzLFxuICogIGVsc2UsIGlmIGFuIG9iamVjdCwgdXNlIGRlZmluZWQgcHJvcGVydGllcyBhbmQgc2V0cyB1bmRlZmluZWQgb25lcyB0byAwLlxuICogQHJldHVybnMgVGhlIFRSQkwgY29ybmVyIHZhbHVlcyAodG9wTGVmdCwgdG9wUmlnaHQsIGJvdHRvbUxlZnQsIGJvdHRvbVJpZ2h0KVxuICogQHNpbmNlIDMuMC4wXG4gKi8gZnVuY3Rpb24gdG9UUkJMQ29ybmVycyh2YWx1ZSkge1xuICAgIHJldHVybiBfcmVhZFZhbHVlVG9Qcm9wcyh2YWx1ZSwgW1xuICAgICAgICAndG9wTGVmdCcsXG4gICAgICAgICd0b3BSaWdodCcsXG4gICAgICAgICdib3R0b21MZWZ0JyxcbiAgICAgICAgJ2JvdHRvbVJpZ2h0J1xuICAgIF0pO1xufVxuLyoqXG4gKiBDb252ZXJ0cyB0aGUgZ2l2ZW4gdmFsdWUgaW50byBhIHBhZGRpbmcgb2JqZWN0IHdpdGggcHJlLWNvbXB1dGVkIHdpZHRoL2hlaWdodC5cbiAqIEBwYXJhbSB2YWx1ZSAtIElmIGEgbnVtYmVyLCBzZXQgdGhlIHZhbHVlIHRvIGFsbCBUUkJMIGNvbXBvbmVudCxcbiAqICBlbHNlLCBpZiBhbiBvYmplY3QsIHVzZSBkZWZpbmVkIHByb3BlcnRpZXMgYW5kIHNldHMgdW5kZWZpbmVkIG9uZXMgdG8gMC5cbiAqICB4IC8geSBhcmUgc2hvcnRoYW5kcyBmb3Igc2FtZSB2YWx1ZSBmb3IgbGVmdC9yaWdodCBhbmQgdG9wL2JvdHRvbS5cbiAqIEByZXR1cm5zIFRoZSBwYWRkaW5nIHZhbHVlcyAodG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCB3aWR0aCwgaGVpZ2h0KVxuICogQHNpbmNlIDIuNy4wXG4gKi8gZnVuY3Rpb24gdG9QYWRkaW5nKHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdG9UUkJMKHZhbHVlKTtcbiAgICBvYmoud2lkdGggPSBvYmoubGVmdCArIG9iai5yaWdodDtcbiAgICBvYmouaGVpZ2h0ID0gb2JqLnRvcCArIG9iai5ib3R0b207XG4gICAgcmV0dXJuIG9iajtcbn1cbi8qKlxuICogUGFyc2VzIGZvbnQgb3B0aW9ucyBhbmQgcmV0dXJucyB0aGUgZm9udCBvYmplY3QuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZm9udCBvcHRpb25zIHRvIGJlIHBhcnNlZC5cbiAqIEBwYXJhbSBmYWxsYmFjayAtIEEgb2JqZWN0IHRoYXQgY29udGFpbnMgZmFsbGJhY2sgZm9udCBvcHRpb25zLlxuICogQHJldHVybiBUaGUgZm9udCBvYmplY3QuXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHRvRm9udChvcHRpb25zLCBmYWxsYmFjaykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGZhbGxiYWNrID0gZmFsbGJhY2sgfHwgZGVmYXVsdHMuZm9udDtcbiAgICBsZXQgc2l6ZSA9IHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMuc2l6ZSwgZmFsbGJhY2suc2l6ZSk7XG4gICAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgICAgICBzaXplID0gcGFyc2VJbnQoc2l6ZSwgMTApO1xuICAgIH1cbiAgICBsZXQgc3R5bGUgPSB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLnN0eWxlLCBmYWxsYmFjay5zdHlsZSk7XG4gICAgaWYgKHN0eWxlICYmICEoJycgKyBzdHlsZSkubWF0Y2goRk9OVF9TVFlMRSkpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnZhbGlkIGZvbnQgc3R5bGUgc3BlY2lmaWVkOiBcIicgKyBzdHlsZSArICdcIicpO1xuICAgICAgICBzdHlsZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLmZhbWlseSwgZmFsbGJhY2suZmFtaWx5KSxcbiAgICAgICAgbGluZUhlaWdodDogdG9MaW5lSGVpZ2h0KHZhbHVlT3JEZWZhdWx0KG9wdGlvbnMubGluZUhlaWdodCwgZmFsbGJhY2subGluZUhlaWdodCksIHNpemUpLFxuICAgICAgICBzaXplLFxuICAgICAgICBzdHlsZSxcbiAgICAgICAgd2VpZ2h0OiB2YWx1ZU9yRGVmYXVsdChvcHRpb25zLndlaWdodCwgZmFsbGJhY2sud2VpZ2h0KSxcbiAgICAgICAgc3RyaW5nOiAnJ1xuICAgIH07XG4gICAgZm9udC5zdHJpbmcgPSB0b0ZvbnRTdHJpbmcoZm9udCk7XG4gICAgcmV0dXJuIGZvbnQ7XG59XG4vKipcbiAqIEV2YWx1YXRlcyB0aGUgZ2l2ZW4gYGlucHV0c2Agc2VxdWVudGlhbGx5IGFuZCByZXR1cm5zIHRoZSBmaXJzdCBkZWZpbmVkIHZhbHVlLlxuICogQHBhcmFtIGlucHV0cyAtIEFuIGFycmF5IG9mIHZhbHVlcywgZmFsbGluZyBiYWNrIHRvIHRoZSBsYXN0IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCB0aGUgdmFsdWVcbiAqIGlzIGNhbGxlZCB3aXRoIGBjb250ZXh0YCBhcyBmaXJzdCBhcmd1bWVudCBhbmQgdGhlIHJlc3VsdCBiZWNvbWVzIHRoZSBuZXcgaW5wdXQuXG4gKiBAcGFyYW0gaW5kZXggLSBJZiBkZWZpbmVkIGFuZCB0aGUgY3VycmVudCB2YWx1ZSBpcyBhbiBhcnJheSwgdGhlIHZhbHVlXG4gKiBhdCBgaW5kZXhgIGJlY29tZSB0aGUgbmV3IGlucHV0LlxuICogQHBhcmFtIGluZm8gLSBvYmplY3QgdG8gcmV0dXJuIGluZm9ybWF0aW9uIGFib3V0IHJlc29sdXRpb24gaW5cbiAqIEBwYXJhbSBpbmZvLmNhY2hlYWJsZSAtIFdpbGwgYmUgc2V0IHRvIGBmYWxzZWAgaWYgb3B0aW9uIGlzIG5vdCBjYWNoZWFibGUuXG4gKiBAc2luY2UgMi43LjBcbiAqLyBmdW5jdGlvbiByZXNvbHZlKGlucHV0cywgY29udGV4dCwgaW5kZXgsIGluZm8pIHtcbiAgICBsZXQgY2FjaGVhYmxlID0gdHJ1ZTtcbiAgICBsZXQgaSwgaWxlbiwgdmFsdWU7XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gaW5wdXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSl7XG4gICAgICAgIHZhbHVlID0gaW5wdXRzW2ldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUoY29udGV4dCk7XG4gICAgICAgICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVtpbmRleCAlIHZhbHVlLmxlbmd0aF07XG4gICAgICAgICAgICBjYWNoZWFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGluZm8gJiYgIWNhY2hlYWJsZSkge1xuICAgICAgICAgICAgICAgIGluZm8uY2FjaGVhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBwYXJhbSBtaW5tYXhcbiAqIEBwYXJhbSBncmFjZVxuICogQHBhcmFtIGJlZ2luQXRaZXJvXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9hZGRHcmFjZShtaW5tYXgsIGdyYWNlLCBiZWdpbkF0WmVybykge1xuICAgIGNvbnN0IHsgbWluICwgbWF4ICB9ID0gbWlubWF4O1xuICAgIGNvbnN0IGNoYW5nZSA9IHRvRGltZW5zaW9uKGdyYWNlLCAobWF4IC0gbWluKSAvIDIpO1xuICAgIGNvbnN0IGtlZXBaZXJvID0gKHZhbHVlLCBhZGQpPT5iZWdpbkF0WmVybyAmJiB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSArIGFkZDtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW46IGtlZXBaZXJvKG1pbiwgLU1hdGguYWJzKGNoYW5nZSkpLFxuICAgICAgICBtYXg6IGtlZXBaZXJvKG1heCwgY2hhbmdlKVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0KHBhcmVudENvbnRleHQsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKHBhcmVudENvbnRleHQpLCBjb250ZXh0KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgUHJveHkgZm9yIHJlc29sdmluZyByYXcgdmFsdWVzIGZvciBvcHRpb25zLlxuICogQHBhcmFtIHNjb3BlcyAtIFRoZSBvcHRpb24gc2NvcGVzIHRvIGxvb2sgZm9yIHZhbHVlcywgaW4gcmVzb2x1dGlvbiBvcmRlclxuICogQHBhcmFtIHByZWZpeGVzIC0gVGhlIHByZWZpeGVzIGZvciB2YWx1ZXMsIGluIHJlc29sdXRpb24gb3JkZXIuXG4gKiBAcGFyYW0gcm9vdFNjb3BlcyAtIFRoZSByb290IG9wdGlvbiBzY29wZXNcbiAqIEBwYXJhbSBmYWxsYmFjayAtIFBhcmVudCBzY29wZXMgZmFsbGJhY2tcbiAqIEBwYXJhbSBnZXRUYXJnZXQgLSBjYWxsYmFjayBmb3IgZ2V0dGluZyB0aGUgdGFyZ2V0IGZvciBjaGFuZ2VkIHZhbHVlc1xuICogQHJldHVybnMgUHJveHlcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2NyZWF0ZVJlc29sdmVyKHNjb3BlcywgcHJlZml4ZXMgPSBbXG4gICAgJydcbl0sIHJvb3RTY29wZXMsIGZhbGxiYWNrLCBnZXRUYXJnZXQgPSAoKT0+c2NvcGVzWzBdKSB7XG4gICAgY29uc3QgZmluYWxSb290U2NvcGVzID0gcm9vdFNjb3BlcyB8fCBzY29wZXM7XG4gICAgaWYgKHR5cGVvZiBmYWxsYmFjayA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZmFsbGJhY2sgPSBfcmVzb2x2ZSgnX2ZhbGxiYWNrJywgc2NvcGVzKTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSB7XG4gICAgICAgIFtTeW1ib2wudG9TdHJpbmdUYWddOiAnT2JqZWN0JyxcbiAgICAgICAgX2NhY2hlYWJsZTogdHJ1ZSxcbiAgICAgICAgX3Njb3Blczogc2NvcGVzLFxuICAgICAgICBfcm9vdFNjb3BlczogZmluYWxSb290U2NvcGVzLFxuICAgICAgICBfZmFsbGJhY2s6IGZhbGxiYWNrLFxuICAgICAgICBfZ2V0VGFyZ2V0OiBnZXRUYXJnZXQsXG4gICAgICAgIG92ZXJyaWRlOiAoc2NvcGUpPT5fY3JlYXRlUmVzb2x2ZXIoW1xuICAgICAgICAgICAgICAgIHNjb3BlLFxuICAgICAgICAgICAgICAgIC4uLnNjb3Blc1xuICAgICAgICAgICAgXSwgcHJlZml4ZXMsIGZpbmFsUm9vdFNjb3BlcywgZmFsbGJhY2spXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFByb3h5KGNhY2hlLCB7XG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgdGhlIGRlbGV0ZSBvcGVyYXRvci5cbiAgICAgKi8gZGVsZXRlUHJvcGVydHkgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgICAgICAgIGRlbGV0ZSB0YXJnZXQuX2tleXM7IC8vIHJlbW92ZSBjYWNoZWQga2V5c1xuICAgICAgICAgICAgZGVsZXRlIHNjb3Blc1swXVtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gdG9wIGxldmVsIHNjb3BlXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBnZXR0aW5nIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKi8gZ2V0ICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBfY2FjaGVkKHRhcmdldCwgcHJvcCwgKCk9Pl9yZXNvbHZlV2l0aFByZWZpeGVzKHByb3AsIHByZWZpeGVzLCBzY29wZXMsIHRhcmdldCkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IuXG4gICAgICogQWxzbyB1c2VkIGJ5IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5cbiAgICAgKi8gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQuX3Njb3Blc1swXSwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mLlxuICAgICAqLyBnZXRQcm90b3R5cGVPZiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRQcm90b3R5cGVPZihzY29wZXNbMF0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHRoZSBpbiBvcGVyYXRvci5cbiAgICAgKi8gaGFzICh0YXJnZXQsIHByb3ApIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpLmluY2x1ZGVzKHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqLyBvd25LZXlzICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRLZXlzRnJvbUFsbFNjb3Blcyh0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqLyBzZXQgKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2UgPSB0YXJnZXQuX3N0b3JhZ2UgfHwgKHRhcmdldC5fc3RvcmFnZSA9IGdldFRhcmdldCgpKTtcbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHN0b3JhZ2VbcHJvcF0gPSB2YWx1ZTsgLy8gc2V0IHRvIHRvcCBsZXZlbCBzY29wZSArIGNhY2hlXG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0Ll9rZXlzOyAvLyByZW1vdmUgY2FjaGVkIGtleXNcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYW4gUHJveHkgZm9yIHJlc29sdmluZyBvcHRpb24gdmFsdWVzIHdpdGggY29udGV4dC5cbiAqIEBwYXJhbSBwcm94eSAtIFRoZSBQcm94eSByZXR1cm5lZCBieSBgX2NyZWF0ZVJlc29sdmVyYFxuICogQHBhcmFtIGNvbnRleHQgLSBDb250ZXh0IG9iamVjdCBmb3Igc2NyaXB0YWJsZS9pbmRleGFibGUgb3B0aW9uc1xuICogQHBhcmFtIHN1YlByb3h5IC0gVGhlIHByb3h5IHByb3ZpZGVkIGZvciBzY3JpcHRhYmxlIG9wdGlvbnNcbiAqIEBwYXJhbSBkZXNjcmlwdG9yRGVmYXVsdHMgLSBEZWZhdWx0cyBmb3IgZGVzY3JpcHRvcnNcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2F0dGFjaENvbnRleHQocHJveHksIGNvbnRleHQsIHN1YlByb3h5LCBkZXNjcmlwdG9yRGVmYXVsdHMpIHtcbiAgICBjb25zdCBjYWNoZSA9IHtcbiAgICAgICAgX2NhY2hlYWJsZTogZmFsc2UsXG4gICAgICAgIF9wcm94eTogcHJveHksXG4gICAgICAgIF9jb250ZXh0OiBjb250ZXh0LFxuICAgICAgICBfc3ViUHJveHk6IHN1YlByb3h5LFxuICAgICAgICBfc3RhY2s6IG5ldyBTZXQoKSxcbiAgICAgICAgX2Rlc2NyaXB0b3JzOiBfZGVzY3JpcHRvcnMocHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cyksXG4gICAgICAgIHNldENvbnRleHQ6IChjdHgpPT5fYXR0YWNoQ29udGV4dChwcm94eSwgY3R4LCBzdWJQcm94eSwgZGVzY3JpcHRvckRlZmF1bHRzKSxcbiAgICAgICAgb3ZlcnJpZGU6IChzY29wZSk9Pl9hdHRhY2hDb250ZXh0KHByb3h5Lm92ZXJyaWRlKHNjb3BlKSwgY29udGV4dCwgc3ViUHJveHksIGRlc2NyaXB0b3JEZWZhdWx0cylcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJveHkoY2FjaGUsIHtcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgZGVsZXRlIG9wZXJhdG9yLlxuICAgICAqLyBkZWxldGVQcm9wZXJ0eSAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICBkZWxldGUgdGFyZ2V0W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBjYWNoZVxuICAgICAgICAgICAgZGVsZXRlIHByb3h5W3Byb3BdOyAvLyByZW1vdmUgZnJvbSBwcm94eVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgZ2V0dGluZyBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICovIGdldCAodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgcmV0dXJuIF9jYWNoZWQodGFyZ2V0LCBwcm9wLCAoKT0+X3Jlc29sdmVXaXRoQ29udGV4dCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAqIEEgdHJhcCBmb3IgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvci5cbiAgICAgKiBBbHNvIHVzZWQgYnkgT2JqZWN0Lmhhc093blByb3BlcnR5LlxuICAgICAqLyBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgKHRhcmdldCwgcHJvcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5fZGVzY3JpcHRvcnMuYWxsS2V5cyA/IFJlZmxlY3QuaGFzKHByb3h5LCBwcm9wKSA/IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgfSA6IHVuZGVmaW5lZCA6IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3h5LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciBPYmplY3QuZ2V0UHJvdG90eXBlT2YuXG4gICAgICovIGdldFByb3RvdHlwZU9mICgpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldFByb3RvdHlwZU9mKHByb3h5KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICogQSB0cmFwIGZvciB0aGUgaW4gb3BlcmF0b3IuXG4gICAgICovIGhhcyAodGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXMocHJveHksIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIGFuZCBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzLlxuICAgICAqLyBvd25LZXlzICgpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXMocHJveHkpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgKiBBIHRyYXAgZm9yIHNldHRpbmcgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqLyBzZXQgKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIHByb3h5W3Byb3BdID0gdmFsdWU7IC8vIHNldCB0byBwcm94eVxuICAgICAgICAgICAgZGVsZXRlIHRhcmdldFtwcm9wXTsgLy8gcmVtb3ZlIGZyb20gY2FjaGVcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2Rlc2NyaXB0b3JzKHByb3h5LCBkZWZhdWx0cyA9IHtcbiAgICBzY3JpcHRhYmxlOiB0cnVlLFxuICAgIGluZGV4YWJsZTogdHJ1ZVxufSkge1xuICAgIGNvbnN0IHsgX3NjcmlwdGFibGUgPWRlZmF1bHRzLnNjcmlwdGFibGUgLCBfaW5kZXhhYmxlID1kZWZhdWx0cy5pbmRleGFibGUgLCBfYWxsS2V5cyA9ZGVmYXVsdHMuYWxsS2V5cyAgfSA9IHByb3h5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFsbEtleXM6IF9hbGxLZXlzLFxuICAgICAgICBzY3JpcHRhYmxlOiBfc2NyaXB0YWJsZSxcbiAgICAgICAgaW5kZXhhYmxlOiBfaW5kZXhhYmxlLFxuICAgICAgICBpc1NjcmlwdGFibGU6IGlzRnVuY3Rpb24oX3NjcmlwdGFibGUpID8gX3NjcmlwdGFibGUgOiAoKT0+X3NjcmlwdGFibGUsXG4gICAgICAgIGlzSW5kZXhhYmxlOiBpc0Z1bmN0aW9uKF9pbmRleGFibGUpID8gX2luZGV4YWJsZSA6ICgpPT5faW5kZXhhYmxlXG4gICAgfTtcbn1cbmNvbnN0IHJlYWRLZXkgPSAocHJlZml4LCBuYW1lKT0+cHJlZml4ID8gcHJlZml4ICsgX2NhcGl0YWxpemUobmFtZSkgOiBuYW1lO1xuY29uc3QgbmVlZHNTdWJSZXNvbHZlciA9IChwcm9wLCB2YWx1ZSk9PmlzT2JqZWN0KHZhbHVlKSAmJiBwcm9wICE9PSAnYWRhcHRlcnMnICYmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBudWxsIHx8IHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xuZnVuY3Rpb24gX2NhY2hlZCh0YXJnZXQsIHByb3AsIHJlc29sdmUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRhcmdldCwgcHJvcCkgfHwgcHJvcCA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0W3Byb3BdO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHJlc29sdmUoKTtcbiAgICAvLyBjYWNoZSB0aGUgcmVzb2x2ZWQgdmFsdWVcbiAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhDb250ZXh0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICBjb25zdCB7IF9wcm94eSAsIF9jb250ZXh0ICwgX3N1YlByb3h5ICwgX2Rlc2NyaXB0b3JzOiBkZXNjcmlwdG9ycyAgfSA9IHRhcmdldDtcbiAgICBsZXQgdmFsdWUgPSBfcHJveHlbcHJvcF07IC8vIHJlc29sdmUgZnJvbSBwcm94eVxuICAgIC8vIHJlc29sdmUgd2l0aCBjb250ZXh0XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpICYmIGRlc2NyaXB0b3JzLmlzU2NyaXB0YWJsZShwcm9wKSkge1xuICAgICAgICB2YWx1ZSA9IF9yZXNvbHZlU2NyaXB0YWJsZShwcm9wLCB2YWx1ZSwgdGFyZ2V0LCByZWNlaXZlcik7XG4gICAgfVxuICAgIGlmIChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGRlc2NyaXB0b3JzLmlzSW5kZXhhYmxlKTtcbiAgICB9XG4gICAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgIC8vIGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhbiBvYmplY3QsIGNyZWF0ZSBhIHN1YiByZXNvbHZlciBmb3IgaXRcbiAgICAgICAgdmFsdWUgPSBfYXR0YWNoQ29udGV4dCh2YWx1ZSwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gX3Jlc29sdmVTY3JpcHRhYmxlKHByb3AsIGdldFZhbHVlLCB0YXJnZXQsIHJlY2VpdmVyKSB7XG4gICAgY29uc3QgeyBfcHJveHkgLCBfY29udGV4dCAsIF9zdWJQcm94eSAsIF9zdGFjayAgfSA9IHRhcmdldDtcbiAgICBpZiAoX3N0YWNrLmhhcyhwcm9wKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlY3Vyc2lvbiBkZXRlY3RlZDogJyArIEFycmF5LmZyb20oX3N0YWNrKS5qb2luKCctPicpICsgJy0+JyArIHByb3ApO1xuICAgIH1cbiAgICBfc3RhY2suYWRkKHByb3ApO1xuICAgIGxldCB2YWx1ZSA9IGdldFZhbHVlKF9jb250ZXh0LCBfc3ViUHJveHkgfHwgcmVjZWl2ZXIpO1xuICAgIF9zdGFjay5kZWxldGUocHJvcCk7XG4gICAgaWYgKG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgIC8vIFdoZW4gc2NyaXB0YWJsZSBvcHRpb24gcmV0dXJucyBhbiBvYmplY3QsIGNyZWF0ZSBhIHJlc29sdmVyIG9uIHRoYXQuXG4gICAgICAgIHZhbHVlID0gY3JlYXRlU3ViUmVzb2x2ZXIoX3Byb3h5Ll9zY29wZXMsIF9wcm94eSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBfcmVzb2x2ZUFycmF5KHByb3AsIHZhbHVlLCB0YXJnZXQsIGlzSW5kZXhhYmxlKSB7XG4gICAgY29uc3QgeyBfcHJveHkgLCBfY29udGV4dCAsIF9zdWJQcm94eSAsIF9kZXNjcmlwdG9yczogZGVzY3JpcHRvcnMgIH0gPSB0YXJnZXQ7XG4gICAgaWYgKHR5cGVvZiBfY29udGV4dC5pbmRleCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNJbmRleGFibGUocHJvcCkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlW19jb250ZXh0LmluZGV4ICUgdmFsdWUubGVuZ3RoXTtcbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlWzBdKSkge1xuICAgICAgICAvLyBBcnJheSBvZiBvYmplY3RzLCByZXR1cm4gYXJyYXkgb3IgcmVzb2x2ZXJzXG4gICAgICAgIGNvbnN0IGFyciA9IHZhbHVlO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBfcHJveHkuX3Njb3Blcy5maWx0ZXIoKHMpPT5zICE9PSBhcnIpO1xuICAgICAgICB2YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKXtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyID0gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBfcHJveHksIHByb3AsIGl0ZW0pO1xuICAgICAgICAgICAgdmFsdWUucHVzaChfYXR0YWNoQ29udGV4dChyZXNvbHZlciwgX2NvbnRleHQsIF9zdWJQcm94eSAmJiBfc3ViUHJveHlbcHJvcF0sIGRlc2NyaXB0b3JzKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZhbGxiYWNrKGZhbGxiYWNrLCBwcm9wLCB2YWx1ZSkge1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGZhbGxiYWNrKSA/IGZhbGxiYWNrKHByb3AsIHZhbHVlKSA6IGZhbGxiYWNrO1xufVxuY29uc3QgZ2V0U2NvcGUgPSAoa2V5LCBwYXJlbnQpPT5rZXkgPT09IHRydWUgPyBwYXJlbnQgOiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyA/IHJlc29sdmVPYmplY3RLZXkocGFyZW50LCBrZXkpIDogdW5kZWZpbmVkO1xuZnVuY3Rpb24gYWRkU2NvcGVzKHNldCwgcGFyZW50U2NvcGVzLCBrZXksIHBhcmVudEZhbGxiYWNrLCB2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgcGFyZW50IG9mIHBhcmVudFNjb3Blcyl7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gZ2V0U2NvcGUoa2V5LCBwYXJlbnQpO1xuICAgICAgICBpZiAoc2NvcGUpIHtcbiAgICAgICAgICAgIHNldC5hZGQoc2NvcGUpO1xuICAgICAgICAgICAgY29uc3QgZmFsbGJhY2sgPSByZXNvbHZlRmFsbGJhY2soc2NvcGUuX2ZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBrZXkgJiYgZmFsbGJhY2sgIT09IHBhcmVudEZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB3ZSByZWFjaCB0aGUgZGVzY3JpcHRvciB0aGF0IGRlZmluZXMgYSBuZXcgX2ZhbGxiYWNrLCByZXR1cm4gdGhhdC5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgd2lsbCByZXN1bWUgdG8gdGhhdCBuZXcgc2NvcGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHNjb3BlID09PSBmYWxzZSAmJiB0eXBlb2YgcGFyZW50RmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGtleSAhPT0gcGFyZW50RmFsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGBmYWxzZWAgcmVzdWx0cyB0byBgZmFsc2VgLCB3aGVuIGZhbGxpbmcgYmFjayB0byBkaWZmZXJlbnQga2V5LlxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUgYGludGVyYWN0aW9uYCBmcm9tIGBob3ZlcmAgb3IgYHBsdWdpbnMudG9vbHRpcGAgYW5kIGBhbmltYXRpb25gIGZyb20gYGFuaW1hdGlvbnNgXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVTdWJSZXNvbHZlcihwYXJlbnRTY29wZXMsIHJlc29sdmVyLCBwcm9wLCB2YWx1ZSkge1xuICAgIGNvbnN0IHJvb3RTY29wZXMgPSByZXNvbHZlci5fcm9vdFNjb3BlcztcbiAgICBjb25zdCBmYWxsYmFjayA9IHJlc29sdmVGYWxsYmFjayhyZXNvbHZlci5fZmFsbGJhY2ssIHByb3AsIHZhbHVlKTtcbiAgICBjb25zdCBhbGxTY29wZXMgPSBbXG4gICAgICAgIC4uLnBhcmVudFNjb3BlcyxcbiAgICAgICAgLi4ucm9vdFNjb3Blc1xuICAgIF07XG4gICAgY29uc3Qgc2V0ID0gbmV3IFNldCgpO1xuICAgIHNldC5hZGQodmFsdWUpO1xuICAgIGxldCBrZXkgPSBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBwcm9wLCBmYWxsYmFjayB8fCBwcm9wLCB2YWx1ZSk7XG4gICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZmFsbGJhY2sgIT09ICd1bmRlZmluZWQnICYmIGZhbGxiYWNrICE9PSBwcm9wKSB7XG4gICAgICAgIGtleSA9IGFkZFNjb3Blc0Zyb21LZXkoc2V0LCBhbGxTY29wZXMsIGZhbGxiYWNrLCBrZXksIHZhbHVlKTtcbiAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlUmVzb2x2ZXIoQXJyYXkuZnJvbShzZXQpLCBbXG4gICAgICAgICcnXG4gICAgXSwgcm9vdFNjb3BlcywgZmFsbGJhY2ssICgpPT5zdWJHZXRUYXJnZXQocmVzb2x2ZXIsIHByb3AsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBhZGRTY29wZXNGcm9tS2V5KHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKSB7XG4gICAgd2hpbGUoa2V5KXtcbiAgICAgICAga2V5ID0gYWRkU2NvcGVzKHNldCwgYWxsU2NvcGVzLCBrZXksIGZhbGxiYWNrLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleTtcbn1cbmZ1bmN0aW9uIHN1YkdldFRhcmdldChyZXNvbHZlciwgcHJvcCwgdmFsdWUpIHtcbiAgICBjb25zdCBwYXJlbnQgPSByZXNvbHZlci5fZ2V0VGFyZ2V0KCk7XG4gICAgaWYgKCEocHJvcCBpbiBwYXJlbnQpKSB7XG4gICAgICAgIHBhcmVudFtwcm9wXSA9IHt9O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBwYXJlbnRbcHJvcF07XG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgLy8gRm9yIGFycmF5IG9mIG9iamVjdHMsIHRoZSBvYmplY3QgaXMgdXNlZCB0byBzdG9yZSB1cGRhdGVkIHZhbHVlc1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQgfHwge307XG59XG5mdW5jdGlvbiBfcmVzb2x2ZVdpdGhQcmVmaXhlcyhwcm9wLCBwcmVmaXhlcywgc2NvcGVzLCBwcm94eSkge1xuICAgIGxldCB2YWx1ZTtcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcyl7XG4gICAgICAgIHZhbHVlID0gX3Jlc29sdmUocmVhZEtleShwcmVmaXgsIHByb3ApLCBzY29wZXMpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG5lZWRzU3ViUmVzb2x2ZXIocHJvcCwgdmFsdWUpID8gY3JlYXRlU3ViUmVzb2x2ZXIoc2NvcGVzLCBwcm94eSwgcHJvcCwgdmFsdWUpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBfcmVzb2x2ZShrZXksIHNjb3Blcykge1xuICAgIGZvciAoY29uc3Qgc2NvcGUgb2Ygc2NvcGVzKXtcbiAgICAgICAgaWYgKCFzY29wZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBzY29wZVtrZXldO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0S2V5c0Zyb21BbGxTY29wZXModGFyZ2V0KSB7XG4gICAgbGV0IGtleXMgPSB0YXJnZXQuX2tleXM7XG4gICAgaWYgKCFrZXlzKSB7XG4gICAgICAgIGtleXMgPSB0YXJnZXQuX2tleXMgPSByZXNvbHZlS2V5c0Zyb21BbGxTY29wZXModGFyZ2V0Ll9zY29wZXMpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5cztcbn1cbmZ1bmN0aW9uIHJlc29sdmVLZXlzRnJvbUFsbFNjb3BlcyhzY29wZXMpIHtcbiAgICBjb25zdCBzZXQgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpe1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY29wZSkuZmlsdGVyKChrKT0+IWsuc3RhcnRzV2l0aCgnXycpKSl7XG4gICAgICAgICAgICBzZXQuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20oc2V0KTtcbn1cbmZ1bmN0aW9uIF9wYXJzZU9iamVjdERhdGFSYWRpYWxTY2FsZShtZXRhLCBkYXRhLCBzdGFydCwgY291bnQpIHtcbiAgICBjb25zdCB7IGlTY2FsZSAgfSA9IG1ldGE7XG4gICAgY29uc3QgeyBrZXkgPSdyJyAgfSA9IHRoaXMuX3BhcnNpbmc7XG4gICAgY29uc3QgcGFyc2VkID0gbmV3IEFycmF5KGNvdW50KTtcbiAgICBsZXQgaSwgaWxlbiwgaW5kZXgsIGl0ZW07XG4gICAgZm9yKGkgPSAwLCBpbGVuID0gY291bnQ7IGkgPCBpbGVuOyArK2kpe1xuICAgICAgICBpbmRleCA9IGkgKyBzdGFydDtcbiAgICAgICAgaXRlbSA9IGRhdGFbaW5kZXhdO1xuICAgICAgICBwYXJzZWRbaV0gPSB7XG4gICAgICAgICAgICByOiBpU2NhbGUucGFyc2UocmVzb2x2ZU9iamVjdEtleShpdGVtLCBrZXkpLCBpbmRleClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZDtcbn1cblxuY29uc3QgRVBTSUxPTiA9IE51bWJlci5FUFNJTE9OIHx8IDFlLTE0O1xuY29uc3QgZ2V0UG9pbnQgPSAocG9pbnRzLCBpKT0+aSA8IHBvaW50cy5sZW5ndGggJiYgIXBvaW50c1tpXS5za2lwICYmIHBvaW50c1tpXTtcbmNvbnN0IGdldFZhbHVlQXhpcyA9IChpbmRleEF4aXMpPT5pbmRleEF4aXMgPT09ICd4JyA/ICd5JyA6ICd4JztcbmZ1bmN0aW9uIHNwbGluZUN1cnZlKGZpcnN0UG9pbnQsIG1pZGRsZVBvaW50LCBhZnRlclBvaW50LCB0KSB7XG4gICAgLy8gUHJvcHMgdG8gUm9iIFNwZW5jZXIgYXQgc2NhbGVkIGlubm92YXRpb24gZm9yIGhpcyBwb3N0IG9uIHNwbGluaW5nIGJldHdlZW4gcG9pbnRzXG4gICAgLy8gaHR0cDovL3NjYWxlZGlubm92YXRpb24uY29tL2FuYWx5dGljcy9zcGxpbmVzL2Fib3V0U3BsaW5lcy5odG1sXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBtdXN0IGFsc28gcmVzcGVjdCBcInNraXBwZWRcIiBwb2ludHNcbiAgICBjb25zdCBwcmV2aW91cyA9IGZpcnN0UG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogZmlyc3RQb2ludDtcbiAgICBjb25zdCBjdXJyZW50ID0gbWlkZGxlUG9pbnQ7XG4gICAgY29uc3QgbmV4dCA9IGFmdGVyUG9pbnQuc2tpcCA/IG1pZGRsZVBvaW50IDogYWZ0ZXJQb2ludDtcbiAgICBjb25zdCBkMDEgPSBkaXN0YW5jZUJldHdlZW5Qb2ludHMoY3VycmVudCwgcHJldmlvdXMpO1xuICAgIGNvbnN0IGQxMiA9IGRpc3RhbmNlQmV0d2VlblBvaW50cyhuZXh0LCBjdXJyZW50KTtcbiAgICBsZXQgczAxID0gZDAxIC8gKGQwMSArIGQxMik7XG4gICAgbGV0IHMxMiA9IGQxMiAvIChkMDEgKyBkMTIpO1xuICAgIC8vIElmIGFsbCBwb2ludHMgYXJlIHRoZSBzYW1lLCBzMDEgJiBzMDIgd2lsbCBiZSBpbmZcbiAgICBzMDEgPSBpc05hTihzMDEpID8gMCA6IHMwMTtcbiAgICBzMTIgPSBpc05hTihzMTIpID8gMCA6IHMxMjtcbiAgICBjb25zdCBmYSA9IHQgKiBzMDE7IC8vIHNjYWxpbmcgZmFjdG9yIGZvciB0cmlhbmdsZSBUYVxuICAgIGNvbnN0IGZiID0gdCAqIHMxMjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcmV2aW91czoge1xuICAgICAgICAgICAgeDogY3VycmVudC54IC0gZmEgKiAobmV4dC54IC0gcHJldmlvdXMueCksXG4gICAgICAgICAgICB5OiBjdXJyZW50LnkgLSBmYSAqIChuZXh0LnkgLSBwcmV2aW91cy55KVxuICAgICAgICB9LFxuICAgICAgICBuZXh0OiB7XG4gICAgICAgICAgICB4OiBjdXJyZW50LnggKyBmYiAqIChuZXh0LnggLSBwcmV2aW91cy54KSxcbiAgICAgICAgICAgIHk6IGN1cnJlbnQueSArIGZiICogKG5leHQueSAtIHByZXZpb3VzLnkpXG4gICAgICAgIH1cbiAgICB9O1xufVxuLyoqXG4gKiBBZGp1c3QgdGFuZ2VudHMgdG8gZW5zdXJlIG1vbm90b25pYyBwcm9wZXJ0aWVzXG4gKi8gZnVuY3Rpb24gbW9ub3RvbmVBZGp1c3QocG9pbnRzLCBkZWx0YUssIG1LKSB7XG4gICAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgYWxwaGFLLCBiZXRhSywgdGF1Sywgc3F1YXJlZE1hZ25pdHVkZSwgcG9pbnRDdXJyZW50O1xuICAgIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuIC0gMTsgKytpKXtcbiAgICAgICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICAgICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgICAgICBpZiAoIXBvaW50Q3VycmVudCB8fCAhcG9pbnRBZnRlcikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbW9zdEVxdWFscyhkZWx0YUtbaV0sIDAsIEVQU0lMT04pKSB7XG4gICAgICAgICAgICBtS1tpXSA9IG1LW2kgKyAxXSA9IDA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBhbHBoYUsgPSBtS1tpXSAvIGRlbHRhS1tpXTtcbiAgICAgICAgYmV0YUsgPSBtS1tpICsgMV0gLyBkZWx0YUtbaV07XG4gICAgICAgIHNxdWFyZWRNYWduaXR1ZGUgPSBNYXRoLnBvdyhhbHBoYUssIDIpICsgTWF0aC5wb3coYmV0YUssIDIpO1xuICAgICAgICBpZiAoc3F1YXJlZE1hZ25pdHVkZSA8PSA5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0YXVLID0gMyAvIE1hdGguc3FydChzcXVhcmVkTWFnbml0dWRlKTtcbiAgICAgICAgbUtbaV0gPSBhbHBoYUsgKiB0YXVLICogZGVsdGFLW2ldO1xuICAgICAgICBtS1tpICsgMV0gPSBiZXRhSyAqIHRhdUsgKiBkZWx0YUtbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyA9ICd4Jykge1xuICAgIGNvbnN0IHZhbHVlQXhpcyA9IGdldFZhbHVlQXhpcyhpbmRleEF4aXMpO1xuICAgIGNvbnN0IHBvaW50c0xlbiA9IHBvaW50cy5sZW5ndGg7XG4gICAgbGV0IGRlbHRhLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICAgIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgcG9pbnRzTGVuOyArK2kpe1xuICAgICAgICBwb2ludEJlZm9yZSA9IHBvaW50Q3VycmVudDtcbiAgICAgICAgcG9pbnRDdXJyZW50ID0gcG9pbnRBZnRlcjtcbiAgICAgICAgcG9pbnRBZnRlciA9IGdldFBvaW50KHBvaW50cywgaSArIDEpO1xuICAgICAgICBpZiAoIXBvaW50Q3VycmVudCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaVBpeGVsID0gcG9pbnRDdXJyZW50W2luZGV4QXhpc107XG4gICAgICAgIGNvbnN0IHZQaXhlbCA9IHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdO1xuICAgICAgICBpZiAocG9pbnRCZWZvcmUpIHtcbiAgICAgICAgICAgIGRlbHRhID0gKGlQaXhlbCAtIHBvaW50QmVmb3JlW2luZGV4QXhpc10pIC8gMztcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AxJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgLSBkZWx0YTtcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AxJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgLSBkZWx0YSAqIG1LW2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb2ludEFmdGVyKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChwb2ludEFmdGVyW2luZGV4QXhpc10gLSBpUGl4ZWwpIC8gMztcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AyJHtpbmRleEF4aXN9YF0gPSBpUGl4ZWwgKyBkZWx0YTtcbiAgICAgICAgICAgIHBvaW50Q3VycmVudFtgY3AyJHt2YWx1ZUF4aXN9YF0gPSB2UGl4ZWwgKyBkZWx0YSAqIG1LW2ldO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgQsOpemllciBjb250cm9sIHBvaW50cyBpbiBhIHNpbWlsYXIgd2F5IHRoYW4gfHNwbGluZUN1cnZlfCxcbiAqIGJ1dCBwcmVzZXJ2ZXMgbW9ub3RvbmljaXR5IG9mIHRoZSBwcm92aWRlZCBkYXRhIGFuZCBlbnN1cmVzIG5vIGxvY2FsIGV4dHJlbXVtcyBhcmUgYWRkZWRcbiAqIGJldHdlZW4gdGhlIGRhdGFzZXQgZGlzY3JldGUgcG9pbnRzIGR1ZSB0byB0aGUgaW50ZXJwb2xhdGlvbi5cbiAqIFNlZSA6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01vbm90b25lX2N1YmljX2ludGVycG9sYXRpb25cbiAqLyBmdW5jdGlvbiBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzID0gJ3gnKSB7XG4gICAgY29uc3QgdmFsdWVBeGlzID0gZ2V0VmFsdWVBeGlzKGluZGV4QXhpcyk7XG4gICAgY29uc3QgcG9pbnRzTGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICBjb25zdCBkZWx0YUsgPSBBcnJheShwb2ludHNMZW4pLmZpbGwoMCk7XG4gICAgY29uc3QgbUsgPSBBcnJheShwb2ludHNMZW4pO1xuICAgIC8vIENhbGN1bGF0ZSBzbG9wZXMgKGRlbHRhSykgYW5kIGluaXRpYWxpemUgdGFuZ2VudHMgKG1LKVxuICAgIGxldCBpLCBwb2ludEJlZm9yZSwgcG9pbnRDdXJyZW50O1xuICAgIGxldCBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCAwKTtcbiAgICBmb3IoaSA9IDA7IGkgPCBwb2ludHNMZW47ICsraSl7XG4gICAgICAgIHBvaW50QmVmb3JlID0gcG9pbnRDdXJyZW50O1xuICAgICAgICBwb2ludEN1cnJlbnQgPSBwb2ludEFmdGVyO1xuICAgICAgICBwb2ludEFmdGVyID0gZ2V0UG9pbnQocG9pbnRzLCBpICsgMSk7XG4gICAgICAgIGlmICghcG9pbnRDdXJyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9pbnRBZnRlcikge1xuICAgICAgICAgICAgY29uc3Qgc2xvcGVEZWx0YSA9IHBvaW50QWZ0ZXJbaW5kZXhBeGlzXSAtIHBvaW50Q3VycmVudFtpbmRleEF4aXNdO1xuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgdHdvIHBvaW50cyB0aGF0IGFwcGVhciBhdCB0aGUgc2FtZSB4IHBpeGVsLCBzbG9wZURlbHRhWCBpcyAwXG4gICAgICAgICAgICBkZWx0YUtbaV0gPSBzbG9wZURlbHRhICE9PSAwID8gKHBvaW50QWZ0ZXJbdmFsdWVBeGlzXSAtIHBvaW50Q3VycmVudFt2YWx1ZUF4aXNdKSAvIHNsb3BlRGVsdGEgOiAwO1xuICAgICAgICB9XG4gICAgICAgIG1LW2ldID0gIXBvaW50QmVmb3JlID8gZGVsdGFLW2ldIDogIXBvaW50QWZ0ZXIgPyBkZWx0YUtbaSAtIDFdIDogc2lnbihkZWx0YUtbaSAtIDFdKSAhPT0gc2lnbihkZWx0YUtbaV0pID8gMCA6IChkZWx0YUtbaSAtIDFdICsgZGVsdGFLW2ldKSAvIDI7XG4gICAgfVxuICAgIG1vbm90b25lQWRqdXN0KHBvaW50cywgZGVsdGFLLCBtSyk7XG4gICAgbW9ub3RvbmVDb21wdXRlKHBvaW50cywgbUssIGluZGV4QXhpcyk7XG59XG5mdW5jdGlvbiBjYXBDb250cm9sUG9pbnQocHQsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKHB0LCBtYXgpLCBtaW4pO1xufVxuZnVuY3Rpb24gY2FwQmV6aWVyUG9pbnRzKHBvaW50cywgYXJlYSkge1xuICAgIGxldCBpLCBpbGVuLCBwb2ludCwgaW5BcmVhLCBpbkFyZWFQcmV2O1xuICAgIGxldCBpbkFyZWFOZXh0ID0gX2lzUG9pbnRJbkFyZWEocG9pbnRzWzBdLCBhcmVhKTtcbiAgICBmb3IoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgaW5BcmVhUHJldiA9IGluQXJlYTtcbiAgICAgICAgaW5BcmVhID0gaW5BcmVhTmV4dDtcbiAgICAgICAgaW5BcmVhTmV4dCA9IGkgPCBpbGVuIC0gMSAmJiBfaXNQb2ludEluQXJlYShwb2ludHNbaSArIDFdLCBhcmVhKTtcbiAgICAgICAgaWYgKCFpbkFyZWEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAoaW5BcmVhUHJldikge1xuICAgICAgICAgICAgcG9pbnQuY3AxeCA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF4LCBhcmVhLmxlZnQsIGFyZWEucmlnaHQpO1xuICAgICAgICAgICAgcG9pbnQuY3AxeSA9IGNhcENvbnRyb2xQb2ludChwb2ludC5jcDF5LCBhcmVhLnRvcCwgYXJlYS5ib3R0b20pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbkFyZWFOZXh0KSB7XG4gICAgICAgICAgICBwb2ludC5jcDJ4ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMngsIGFyZWEubGVmdCwgYXJlYS5yaWdodCk7XG4gICAgICAgICAgICBwb2ludC5jcDJ5ID0gY2FwQ29udHJvbFBvaW50KHBvaW50LmNwMnksIGFyZWEudG9wLCBhcmVhLmJvdHRvbSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3VwZGF0ZUJlemllckNvbnRyb2xQb2ludHMocG9pbnRzLCBvcHRpb25zLCBhcmVhLCBsb29wLCBpbmRleEF4aXMpIHtcbiAgICBsZXQgaSwgaWxlbiwgcG9pbnQsIGNvbnRyb2xQb2ludHM7XG4gICAgLy8gT25seSBjb25zaWRlciBwb2ludHMgdGhhdCBhcmUgZHJhd24gaW4gY2FzZSB0aGUgc3BhbkdhcHMgb3B0aW9uIGlzIHVzZWRcbiAgICBpZiAob3B0aW9ucy5zcGFuR2Fwcykge1xuICAgICAgICBwb2ludHMgPSBwb2ludHMuZmlsdGVyKChwdCk9PiFwdC5za2lwKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY3ViaWNJbnRlcnBvbGF0aW9uTW9kZSA9PT0gJ21vbm90b25lJykge1xuICAgICAgICBzcGxpbmVDdXJ2ZU1vbm90b25lKHBvaW50cywgaW5kZXhBeGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcHJldiA9IGxvb3AgPyBwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdIDogcG9pbnRzWzBdO1xuICAgICAgICBmb3IoaSA9IDAsIGlsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgICAgICAgY29udHJvbFBvaW50cyA9IHNwbGluZUN1cnZlKHByZXYsIHBvaW50LCBwb2ludHNbTWF0aC5taW4oaSArIDEsIGlsZW4gLSAobG9vcCA/IDAgOiAxKSkgJSBpbGVuXSwgb3B0aW9ucy50ZW5zaW9uKTtcbiAgICAgICAgICAgIHBvaW50LmNwMXggPSBjb250cm9sUG9pbnRzLnByZXZpb3VzLng7XG4gICAgICAgICAgICBwb2ludC5jcDF5ID0gY29udHJvbFBvaW50cy5wcmV2aW91cy55O1xuICAgICAgICAgICAgcG9pbnQuY3AyeCA9IGNvbnRyb2xQb2ludHMubmV4dC54O1xuICAgICAgICAgICAgcG9pbnQuY3AyeSA9IGNvbnRyb2xQb2ludHMubmV4dC55O1xuICAgICAgICAgICAgcHJldiA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNhcEJlemllclBvaW50cykge1xuICAgICAgICBjYXBCZXppZXJQb2ludHMocG9pbnRzLCBhcmVhKTtcbiAgICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqLyBmdW5jdGlvbiBfaXNEb21TdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX2dldFBhcmVudE5vZGUoZG9tTm9kZSkge1xuICAgIGxldCBwYXJlbnQgPSBkb21Ob2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgU2hhZG93Um9vdF0nKSB7XG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50O1xufVxuLyoqXG4gKiBjb252ZXJ0IG1heC13aWR0aC9tYXgtaGVpZ2h0IHZhbHVlcyB0aGF0IG1heSBiZSBwZXJjZW50YWdlcyBpbnRvIGEgbnVtYmVyXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIHBhcnNlTWF4U3R5bGUoc3R5bGVWYWx1ZSwgbm9kZSwgcGFyZW50UHJvcGVydHkpIHtcbiAgICBsZXQgdmFsdWVJblBpeGVscztcbiAgICBpZiAodHlwZW9mIHN0eWxlVmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhbHVlSW5QaXhlbHMgPSBwYXJzZUludChzdHlsZVZhbHVlLCAxMCk7XG4gICAgICAgIGlmIChzdHlsZVZhbHVlLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIHBlcmNlbnRhZ2UgKiBzaXplIGluIGRpbWVuc2lvblxuICAgICAgICAgICAgdmFsdWVJblBpeGVscyA9IHZhbHVlSW5QaXhlbHMgLyAxMDAgKiBub2RlLnBhcmVudE5vZGVbcGFyZW50UHJvcGVydHldO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVJblBpeGVscyA9IHN0eWxlVmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZUluUGl4ZWxzO1xufVxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9IChlbGVtZW50KT0+ZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG5mdW5jdGlvbiBnZXRTdHlsZShlbCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZShlbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG59XG5jb25zdCBwb3NpdGlvbnMgPSBbXG4gICAgJ3RvcCcsXG4gICAgJ3JpZ2h0JyxcbiAgICAnYm90dG9tJyxcbiAgICAnbGVmdCdcbl07XG5mdW5jdGlvbiBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGVzLCBzdHlsZSwgc3VmZml4KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgc3VmZml4ID0gc3VmZml4ID8gJy0nICsgc3VmZml4IDogJyc7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IDQ7IGkrKyl7XG4gICAgICAgIGNvbnN0IHBvcyA9IHBvc2l0aW9uc1tpXTtcbiAgICAgICAgcmVzdWx0W3Bvc10gPSBwYXJzZUZsb2F0KHN0eWxlc1tzdHlsZSArICctJyArIHBvcyArIHN1ZmZpeF0pIHx8IDA7XG4gICAgfVxuICAgIHJlc3VsdC53aWR0aCA9IHJlc3VsdC5sZWZ0ICsgcmVzdWx0LnJpZ2h0O1xuICAgIHJlc3VsdC5oZWlnaHQgPSByZXN1bHQudG9wICsgcmVzdWx0LmJvdHRvbTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgdXNlT2Zmc2V0UG9zID0gKHgsIHksIHRhcmdldCk9Pih4ID4gMCB8fCB5ID4gMCkgJiYgKCF0YXJnZXQgfHwgIXRhcmdldC5zaGFkb3dSb290KTtcbi8qKlxuICogQHBhcmFtIGVcbiAqIEBwYXJhbSBjYW52YXNcbiAqIEByZXR1cm5zIENhbnZhcyBwb3NpdGlvblxuICovIGZ1bmN0aW9uIGdldENhbnZhc1Bvc2l0aW9uKGUsIGNhbnZhcykge1xuICAgIGNvbnN0IHRvdWNoZXMgPSBlLnRvdWNoZXM7XG4gICAgY29uc3Qgc291cmNlID0gdG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA/IHRvdWNoZXNbMF0gOiBlO1xuICAgIGNvbnN0IHsgb2Zmc2V0WCAsIG9mZnNldFkgIH0gPSBzb3VyY2U7XG4gICAgbGV0IGJveCA9IGZhbHNlO1xuICAgIGxldCB4LCB5O1xuICAgIGlmICh1c2VPZmZzZXRQb3Mob2Zmc2V0WCwgb2Zmc2V0WSwgZS50YXJnZXQpKSB7XG4gICAgICAgIHggPSBvZmZzZXRYO1xuICAgICAgICB5ID0gb2Zmc2V0WTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB4ID0gc291cmNlLmNsaWVudFggLSByZWN0LmxlZnQ7XG4gICAgICAgIHkgPSBzb3VyY2UuY2xpZW50WSAtIHJlY3QudG9wO1xuICAgICAgICBib3ggPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICBib3hcbiAgICB9O1xufVxuLyoqXG4gKiBHZXRzIGFuIGV2ZW50J3MgeCwgeSBjb29yZGluYXRlcywgcmVsYXRpdmUgdG8gdGhlIGNoYXJ0IGFyZWFcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIGNoYXJ0XG4gKiBAcmV0dXJucyB4IGFuZCB5IGNvb3JkaW5hdGVzIG9mIHRoZSBldmVudFxuICovIGZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb24oZXZlbnQsIGNoYXJ0KSB7XG4gICAgaWYgKCduYXRpdmUnIGluIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgY29uc3QgeyBjYW52YXMgLCBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyAgfSA9IGNoYXJ0O1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpO1xuICAgIGNvbnN0IGJvcmRlckJveCA9IHN0eWxlLmJveFNpemluZyA9PT0gJ2JvcmRlci1ib3gnO1xuICAgIGNvbnN0IHBhZGRpbmdzID0gZ2V0UG9zaXRpb25lZFN0eWxlKHN0eWxlLCAncGFkZGluZycpO1xuICAgIGNvbnN0IGJvcmRlcnMgPSBnZXRQb3NpdGlvbmVkU3R5bGUoc3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICBjb25zdCB7IHggLCB5ICwgYm94ICB9ID0gZ2V0Q2FudmFzUG9zaXRpb24oZXZlbnQsIGNhbnZhcyk7XG4gICAgY29uc3QgeE9mZnNldCA9IHBhZGRpbmdzLmxlZnQgKyAoYm94ICYmIGJvcmRlcnMubGVmdCk7XG4gICAgY29uc3QgeU9mZnNldCA9IHBhZGRpbmdzLnRvcCArIChib3ggJiYgYm9yZGVycy50b3ApO1xuICAgIGxldCB7IHdpZHRoICwgaGVpZ2h0ICB9ID0gY2hhcnQ7XG4gICAgaWYgKGJvcmRlckJveCkge1xuICAgICAgICB3aWR0aCAtPSBwYWRkaW5ncy53aWR0aCArIGJvcmRlcnMud2lkdGg7XG4gICAgICAgIGhlaWdodCAtPSBwYWRkaW5ncy5oZWlnaHQgKyBib3JkZXJzLmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogTWF0aC5yb3VuZCgoeCAtIHhPZmZzZXQpIC8gd2lkdGggKiBjYW52YXMud2lkdGggLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbyksXG4gICAgICAgIHk6IE1hdGgucm91bmQoKHkgLSB5T2Zmc2V0KSAvIGhlaWdodCAqIGNhbnZhcy5oZWlnaHQgLyBjdXJyZW50RGV2aWNlUGl4ZWxSYXRpbylcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmVyU2l6ZShjYW52YXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgbWF4V2lkdGgsIG1heEhlaWdodDtcbiAgICBpZiAod2lkdGggPT09IHVuZGVmaW5lZCB8fCBoZWlnaHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBjYW52YXMgJiYgX2dldFBhcmVudE5vZGUoY2FudmFzKTtcbiAgICAgICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgICAgICAgIHdpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IC8vIHRoaXMgaXMgdGhlIGJvcmRlciBib3ggb2YgdGhlIGNvbnRhaW5lclxuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNvbnRhaW5lcik7XG4gICAgICAgICAgICBjb25zdCBjb250YWluZXJCb3JkZXIgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdib3JkZXInLCAnd2lkdGgnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lclBhZGRpbmcgPSBnZXRQb3NpdGlvbmVkU3R5bGUoY29udGFpbmVyU3R5bGUsICdwYWRkaW5nJyk7XG4gICAgICAgICAgICB3aWR0aCA9IHJlY3Qud2lkdGggLSBjb250YWluZXJQYWRkaW5nLndpZHRoIC0gY29udGFpbmVyQm9yZGVyLndpZHRoO1xuICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLSBjb250YWluZXJQYWRkaW5nLmhlaWdodCAtIGNvbnRhaW5lckJvcmRlci5oZWlnaHQ7XG4gICAgICAgICAgICBtYXhXaWR0aCA9IHBhcnNlTWF4U3R5bGUoY29udGFpbmVyU3R5bGUubWF4V2lkdGgsIGNvbnRhaW5lciwgJ2NsaWVudFdpZHRoJyk7XG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKGNvbnRhaW5lclN0eWxlLm1heEhlaWdodCwgY29udGFpbmVyLCAnY2xpZW50SGVpZ2h0Jyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgbWF4V2lkdGg6IG1heFdpZHRoIHx8IElORklOSVRZLFxuICAgICAgICBtYXhIZWlnaHQ6IG1heEhlaWdodCB8fCBJTkZJTklUWVxuICAgIH07XG59XG5jb25zdCByb3VuZDEgPSAodik9Pk1hdGgucm91bmQodiAqIDEwKSAvIDEwO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIGdldE1heGltdW1TaXplKGNhbnZhcywgYmJXaWR0aCwgYmJIZWlnaHQsIGFzcGVjdFJhdGlvKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGNhbnZhcyk7XG4gICAgY29uc3QgbWFyZ2lucyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ21hcmdpbicpO1xuICAgIGNvbnN0IG1heFdpZHRoID0gcGFyc2VNYXhTdHlsZShzdHlsZS5tYXhXaWR0aCwgY2FudmFzLCAnY2xpZW50V2lkdGgnKSB8fCBJTkZJTklUWTtcbiAgICBjb25zdCBtYXhIZWlnaHQgPSBwYXJzZU1heFN0eWxlKHN0eWxlLm1heEhlaWdodCwgY2FudmFzLCAnY2xpZW50SGVpZ2h0JykgfHwgSU5GSU5JVFk7XG4gICAgY29uc3QgY29udGFpbmVyU2l6ZSA9IGdldENvbnRhaW5lclNpemUoY2FudmFzLCBiYldpZHRoLCBiYkhlaWdodCk7XG4gICAgbGV0IHsgd2lkdGggLCBoZWlnaHQgIH0gPSBjb250YWluZXJTaXplO1xuICAgIGlmIChzdHlsZS5ib3hTaXppbmcgPT09ICdjb250ZW50LWJveCcpIHtcbiAgICAgICAgY29uc3QgYm9yZGVycyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ2JvcmRlcicsICd3aWR0aCcpO1xuICAgICAgICBjb25zdCBwYWRkaW5ncyA9IGdldFBvc2l0aW9uZWRTdHlsZShzdHlsZSwgJ3BhZGRpbmcnKTtcbiAgICAgICAgd2lkdGggLT0gcGFkZGluZ3Mud2lkdGggKyBib3JkZXJzLndpZHRoO1xuICAgICAgICBoZWlnaHQgLT0gcGFkZGluZ3MuaGVpZ2h0ICsgYm9yZGVycy5oZWlnaHQ7XG4gICAgfVxuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgd2lkdGggLSBtYXJnaW5zLndpZHRoKTtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCBhc3BlY3RSYXRpbyA/IHdpZHRoIC8gYXNwZWN0UmF0aW8gOiBoZWlnaHQgLSBtYXJnaW5zLmhlaWdodCk7XG4gICAgd2lkdGggPSByb3VuZDEoTWF0aC5taW4od2lkdGgsIG1heFdpZHRoLCBjb250YWluZXJTaXplLm1heFdpZHRoKSk7XG4gICAgaGVpZ2h0ID0gcm91bmQxKE1hdGgubWluKGhlaWdodCwgbWF4SGVpZ2h0LCBjb250YWluZXJTaXplLm1heEhlaWdodCkpO1xuICAgIGlmICh3aWR0aCAmJiAhaGVpZ2h0KSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy80NjU5XG4gICAgICAgIC8vIElmIHRoZSBjYW52YXMgaGFzIHdpZHRoLCBidXQgbm8gaGVpZ2h0LCBkZWZhdWx0IHRvIGFzcGVjdFJhdGlvIG9mIDIgKGNhbnZhcyBkZWZhdWx0KVxuICAgICAgICBoZWlnaHQgPSByb3VuZDEod2lkdGggLyAyKTtcbiAgICB9XG4gICAgY29uc3QgbWFpbnRhaW5IZWlnaHQgPSBiYldpZHRoICE9PSB1bmRlZmluZWQgfHwgYmJIZWlnaHQgIT09IHVuZGVmaW5lZDtcbiAgICBpZiAobWFpbnRhaW5IZWlnaHQgJiYgYXNwZWN0UmF0aW8gJiYgY29udGFpbmVyU2l6ZS5oZWlnaHQgJiYgaGVpZ2h0ID4gY29udGFpbmVyU2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgaGVpZ2h0ID0gY29udGFpbmVyU2l6ZS5oZWlnaHQ7XG4gICAgICAgIHdpZHRoID0gcm91bmQxKE1hdGguZmxvb3IoaGVpZ2h0ICogYXNwZWN0UmF0aW8pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgIH07XG59XG4vKipcbiAqIEBwYXJhbSBjaGFydFxuICogQHBhcmFtIGZvcmNlUmF0aW9cbiAqIEBwYXJhbSBmb3JjZVN0eWxlXG4gKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBjYW52YXMgY29udGV4dCBzaXplIG9yIHRyYW5zZm9ybWF0aW9uIGhhcyBjaGFuZ2VkLlxuICovIGZ1bmN0aW9uIHJldGluYVNjYWxlKGNoYXJ0LCBmb3JjZVJhdGlvLCBmb3JjZVN0eWxlKSB7XG4gICAgY29uc3QgcGl4ZWxSYXRpbyA9IGZvcmNlUmF0aW8gfHwgMTtcbiAgICBjb25zdCBkZXZpY2VIZWlnaHQgPSBNYXRoLmZsb29yKGNoYXJ0LmhlaWdodCAqIHBpeGVsUmF0aW8pO1xuICAgIGNvbnN0IGRldmljZVdpZHRoID0gTWF0aC5mbG9vcihjaGFydC53aWR0aCAqIHBpeGVsUmF0aW8pO1xuICAgIGNoYXJ0LmhlaWdodCA9IE1hdGguZmxvb3IoY2hhcnQuaGVpZ2h0KTtcbiAgICBjaGFydC53aWR0aCA9IE1hdGguZmxvb3IoY2hhcnQud2lkdGgpO1xuICAgIGNvbnN0IGNhbnZhcyA9IGNoYXJ0LmNhbnZhcztcbiAgICAvLyBJZiBubyBzdHlsZSBoYXMgYmVlbiBzZXQgb24gdGhlIGNhbnZhcywgdGhlIHJlbmRlciBzaXplIGlzIHVzZWQgYXMgZGlzcGxheSBzaXplLFxuICAgIC8vIG1ha2luZyB0aGUgY2hhcnQgdmlzdWFsbHkgYmlnZ2VyLCBzbyBsZXQncyBlbmZvcmNlIGl0IHRvIHRoZSBcImNvcnJlY3RcIiB2YWx1ZXMuXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL0NoYXJ0LmpzL2lzc3Vlcy8zNTc1XG4gICAgaWYgKGNhbnZhcy5zdHlsZSAmJiAoZm9yY2VTdHlsZSB8fCAhY2FudmFzLnN0eWxlLmhlaWdodCAmJiAhY2FudmFzLnN0eWxlLndpZHRoKSkge1xuICAgICAgICBjYW52YXMuc3R5bGUuaGVpZ2h0ID0gYCR7Y2hhcnQuaGVpZ2h0fXB4YDtcbiAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gYCR7Y2hhcnQud2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAoY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gIT09IHBpeGVsUmF0aW8gfHwgY2FudmFzLmhlaWdodCAhPT0gZGV2aWNlSGVpZ2h0IHx8IGNhbnZhcy53aWR0aCAhPT0gZGV2aWNlV2lkdGgpIHtcbiAgICAgICAgY2hhcnQuY3VycmVudERldmljZVBpeGVsUmF0aW8gPSBwaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gZGV2aWNlSGVpZ2h0O1xuICAgICAgICBjYW52YXMud2lkdGggPSBkZXZpY2VXaWR0aDtcbiAgICAgICAgY2hhcnQuY3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogRGV0ZWN0cyBzdXBwb3J0IGZvciBvcHRpb25zIG9iamVjdCBhcmd1bWVudCBpbiBhZGRFdmVudExpc3RlbmVyLlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjU2FmZWx5X2RldGVjdGluZ19vcHRpb25fc3VwcG9ydFxuICogQHByaXZhdGVcbiAqLyBjb25zdCBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gZnVuY3Rpb24oKSB7XG4gICAgbGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgZ2V0IHBhc3NpdmUgKCkge1xuICAgICAgICAgICAgICAgIHBhc3NpdmVTdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKF9pc0RvbVN1cHBvcnRlZCgpKSB7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBjb250aW51ZSByZWdhcmRsZXNzIG9mIGVycm9yXG4gICAgfVxuICAgIHJldHVybiBwYXNzaXZlU3VwcG9ydGVkO1xufSgpO1xuLyoqXG4gKiBUaGUgXCJ1c2VkXCIgc2l6ZSBpcyB0aGUgZmluYWwgdmFsdWUgb2YgYSBkaW1lbnNpb24gcHJvcGVydHkgYWZ0ZXIgYWxsIGNhbGN1bGF0aW9ucyBoYXZlXG4gKiBiZWVuIHBlcmZvcm1lZC4gVGhpcyBtZXRob2QgdXNlcyB0aGUgY29tcHV0ZWQgc3R5bGUgb2YgYGVsZW1lbnRgIGJ1dCByZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgdGhlIGNvbXB1dGVkIHN0eWxlIGlzIG5vdCBleHByZXNzZWQgaW4gcGl4ZWxzLiBUaGF0IGNhbiBoYXBwZW4gaW4gc29tZSBjYXNlcyB3aGVyZVxuICogYGVsZW1lbnRgIGhhcyBhIHNpemUgcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBhbmQgdGhpcyBsYXN0IG9uZSBpcyBub3QgeWV0IGRpc3BsYXllZCxcbiAqIGZvciBleGFtcGxlIGJlY2F1c2Ugb2YgYGRpc3BsYXk6IG5vbmVgIG9uIGEgcGFyZW50IG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy91c2VkX3ZhbHVlXG4gKiBAcmV0dXJucyBTaXplIGluIHBpeGVscyBvciB1bmRlZmluZWQgaWYgdW5rbm93bi5cbiAqLyBmdW5jdGlvbiByZWFkVXNlZFNpemUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFN0eWxlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgICBjb25zdCBtYXRjaGVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goL14oXFxkKykoXFwuXFxkKyk/cHgkLyk7XG4gICAgcmV0dXJuIG1hdGNoZXMgPyArbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9wb2ludEluTGluZShwMSwgcDIsIHQsIG1vZGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBwMS54ICsgdCAqIChwMi54IC0gcDEueCksXG4gICAgICAgIHk6IHAxLnkgKyB0ICogKHAyLnkgLSBwMS55KVxuICAgIH07XG59XG4vKipcbiAqIEBwcml2YXRlXG4gKi8gZnVuY3Rpb24gX3N0ZXBwZWRJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHAxLnggKyB0ICogKHAyLnggLSBwMS54KSxcbiAgICAgICAgeTogbW9kZSA9PT0gJ21pZGRsZScgPyB0IDwgMC41ID8gcDEueSA6IHAyLnkgOiBtb2RlID09PSAnYWZ0ZXInID8gdCA8IDEgPyBwMS55IDogcDIueSA6IHQgPiAwID8gcDIueSA6IHAxLnlcbiAgICB9O1xufVxuLyoqXG4gKiBAcHJpdmF0ZVxuICovIGZ1bmN0aW9uIF9iZXppZXJJbnRlcnBvbGF0aW9uKHAxLCBwMiwgdCwgbW9kZSkge1xuICAgIGNvbnN0IGNwMSA9IHtcbiAgICAgICAgeDogcDEuY3AyeCxcbiAgICAgICAgeTogcDEuY3AyeVxuICAgIH07XG4gICAgY29uc3QgY3AyID0ge1xuICAgICAgICB4OiBwMi5jcDF4LFxuICAgICAgICB5OiBwMi5jcDF5XG4gICAgfTtcbiAgICBjb25zdCBhID0gX3BvaW50SW5MaW5lKHAxLCBjcDEsIHQpO1xuICAgIGNvbnN0IGIgPSBfcG9pbnRJbkxpbmUoY3AxLCBjcDIsIHQpO1xuICAgIGNvbnN0IGMgPSBfcG9pbnRJbkxpbmUoY3AyLCBwMiwgdCk7XG4gICAgY29uc3QgZCA9IF9wb2ludEluTGluZShhLCBiLCB0KTtcbiAgICBjb25zdCBlID0gX3BvaW50SW5MaW5lKGIsIGMsIHQpO1xuICAgIHJldHVybiBfcG9pbnRJbkxpbmUoZCwgZSwgdCk7XG59XG5cbmNvbnN0IGdldFJpZ2h0VG9MZWZ0QWRhcHRlciA9IGZ1bmN0aW9uKHJlY3RYLCB3aWR0aCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiByZWN0WCArIHJlY3RYICsgd2lkdGggLSB4O1xuICAgICAgICB9LFxuICAgICAgICBzZXRXaWR0aCAodykge1xuICAgICAgICAgICAgd2lkdGggPSB3O1xuICAgICAgICB9LFxuICAgICAgICB0ZXh0QWxpZ24gKGFsaWduKSB7XG4gICAgICAgICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFsaWduO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsaWduID09PSAncmlnaHQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgICAgfSxcbiAgICAgICAgeFBsdXMgKHgsIHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4geCAtIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBsZWZ0Rm9yTHRyICh4LCBpdGVtV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB4IC0gaXRlbVdpZHRoO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5jb25zdCBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4ICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0V2lkdGggKHcpIHt9LFxuICAgICAgICB0ZXh0QWxpZ24gKGFsaWduKSB7XG4gICAgICAgICAgICByZXR1cm4gYWxpZ247XG4gICAgICAgIH0sXG4gICAgICAgIHhQbHVzICh4LCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHggKyB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdEZvckx0ciAoeCwgX2l0ZW1XaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmZ1bmN0aW9uIGdldFJ0bEFkYXB0ZXIocnRsLCByZWN0WCwgd2lkdGgpIHtcbiAgICByZXR1cm4gcnRsID8gZ2V0UmlnaHRUb0xlZnRBZGFwdGVyKHJlY3RYLCB3aWR0aCkgOiBnZXRMZWZ0VG9SaWdodEFkYXB0ZXIoKTtcbn1cbmZ1bmN0aW9uIG92ZXJyaWRlVGV4dERpcmVjdGlvbihjdHgsIGRpcmVjdGlvbikge1xuICAgIGxldCBzdHlsZSwgb3JpZ2luYWw7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2x0cicgfHwgZGlyZWN0aW9uID09PSAncnRsJykge1xuICAgICAgICBzdHlsZSA9IGN0eC5jYW52YXMuc3R5bGU7XG4gICAgICAgIG9yaWdpbmFsID0gW1xuICAgICAgICAgICAgc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJyksXG4gICAgICAgICAgICBzdHlsZS5nZXRQcm9wZXJ0eVByaW9yaXR5KCdkaXJlY3Rpb24nKVxuICAgICAgICBdO1xuICAgICAgICBzdHlsZS5zZXRQcm9wZXJ0eSgnZGlyZWN0aW9uJywgZGlyZWN0aW9uLCAnaW1wb3J0YW50Jyk7XG4gICAgICAgIGN0eC5wcmV2VGV4dERpcmVjdGlvbiA9IG9yaWdpbmFsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVUZXh0RGlyZWN0aW9uKGN0eCwgb3JpZ2luYWwpIHtcbiAgICBpZiAob3JpZ2luYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBkZWxldGUgY3R4LnByZXZUZXh0RGlyZWN0aW9uO1xuICAgICAgICBjdHguY2FudmFzLnN0eWxlLnNldFByb3BlcnR5KCdkaXJlY3Rpb24nLCBvcmlnaW5hbFswXSwgb3JpZ2luYWxbMV0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvcGVydHlGbihwcm9wZXJ0eSkge1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJ2FuZ2xlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmV0d2VlbjogX2FuZ2xlQmV0d2VlbixcbiAgICAgICAgICAgIGNvbXBhcmU6IF9hbmdsZURpZmYsXG4gICAgICAgICAgICBub3JtYWxpemU6IF9ub3JtYWxpemVBbmdsZVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiZXR3ZWVuOiBfaXNCZXR3ZWVuLFxuICAgICAgICBjb21wYXJlOiAoYSwgYik9PmEgLSBiLFxuICAgICAgICBub3JtYWxpemU6ICh4KT0+eFxuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVTZWdtZW50KHsgc3RhcnQgLCBlbmQgLCBjb3VudCAsIGxvb3AgLCBzdHlsZSAgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCAlIGNvdW50LFxuICAgICAgICBlbmQ6IGVuZCAlIGNvdW50LFxuICAgICAgICBsb29wOiBsb29wICYmIChlbmQgLSBzdGFydCArIDEpICUgY291bnQgPT09IDAsXG4gICAgICAgIHN0eWxlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlZ21lbnQoc2VnbWVudCwgcG9pbnRzLCBib3VuZHMpIHtcbiAgICBjb25zdCB7IHByb3BlcnR5ICwgc3RhcnQ6IHN0YXJ0Qm91bmQgLCBlbmQ6IGVuZEJvdW5kICB9ID0gYm91bmRzO1xuICAgIGNvbnN0IHsgYmV0d2VlbiAsIG5vcm1hbGl6ZSAgfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICAgIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBsZXQgeyBzdGFydCAsIGVuZCAsIGxvb3AgIH0gPSBzZWdtZW50O1xuICAgIGxldCBpLCBpbGVuO1xuICAgIGlmIChsb29wKSB7XG4gICAgICAgIHN0YXJ0ICs9IGNvdW50O1xuICAgICAgICBlbmQgKz0gY291bnQ7XG4gICAgICAgIGZvcihpID0gMCwgaWxlbiA9IGNvdW50OyBpIDwgaWxlbjsgKytpKXtcbiAgICAgICAgICAgIGlmICghYmV0d2Vlbihub3JtYWxpemUocG9pbnRzW3N0YXJ0ICUgY291bnRdW3Byb3BlcnR5XSksIHN0YXJ0Qm91bmQsIGVuZEJvdW5kKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgICAgIGVuZC0tO1xuICAgICAgICB9XG4gICAgICAgIHN0YXJ0ICU9IGNvdW50O1xuICAgICAgICBlbmQgJT0gY291bnQ7XG4gICAgfVxuICAgIGlmIChlbmQgPCBzdGFydCkge1xuICAgICAgICBlbmQgKz0gY291bnQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIGxvb3AsXG4gICAgICAgIHN0eWxlOiBzZWdtZW50LnN0eWxlXG4gICAgfTtcbn1cbiBmdW5jdGlvbiBfYm91bmRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKSB7XG4gICAgaWYgKCFib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHNlZ21lbnRcbiAgICAgICAgXTtcbiAgICB9XG4gICAgY29uc3QgeyBwcm9wZXJ0eSAsIHN0YXJ0OiBzdGFydEJvdW5kICwgZW5kOiBlbmRCb3VuZCAgfSA9IGJvdW5kcztcbiAgICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgeyBjb21wYXJlICwgYmV0d2VlbiAsIG5vcm1hbGl6ZSAgfSA9IHByb3BlcnR5Rm4ocHJvcGVydHkpO1xuICAgIGNvbnN0IHsgc3RhcnQgLCBlbmQgLCBsb29wICwgc3R5bGUgIH0gPSBnZXRTZWdtZW50KHNlZ21lbnQsIHBvaW50cywgYm91bmRzKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaW5zaWRlID0gZmFsc2U7XG4gICAgbGV0IHN1YlN0YXJ0ID0gbnVsbDtcbiAgICBsZXQgdmFsdWUsIHBvaW50LCBwcmV2VmFsdWU7XG4gICAgY29uc3Qgc3RhcnRJc0JlZm9yZSA9ICgpPT5iZXR3ZWVuKHN0YXJ0Qm91bmQsIHByZXZWYWx1ZSwgdmFsdWUpICYmIGNvbXBhcmUoc3RhcnRCb3VuZCwgcHJldlZhbHVlKSAhPT0gMDtcbiAgICBjb25zdCBlbmRJc0JlZm9yZSA9ICgpPT5jb21wYXJlKGVuZEJvdW5kLCB2YWx1ZSkgPT09IDAgfHwgYmV0d2VlbihlbmRCb3VuZCwgcHJldlZhbHVlLCB2YWx1ZSk7XG4gICAgY29uc3Qgc2hvdWxkU3RhcnQgPSAoKT0+aW5zaWRlIHx8IHN0YXJ0SXNCZWZvcmUoKTtcbiAgICBjb25zdCBzaG91bGRTdG9wID0gKCk9PiFpbnNpZGUgfHwgZW5kSXNCZWZvcmUoKTtcbiAgICBmb3IobGV0IGkgPSBzdGFydCwgcHJldiA9IHN0YXJ0OyBpIDw9IGVuZDsgKytpKXtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaSAlIGNvdW50XTtcbiAgICAgICAgaWYgKHBvaW50LnNraXApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gbm9ybWFsaXplKHBvaW50W3Byb3BlcnR5XSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gcHJldlZhbHVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpbnNpZGUgPSBiZXR3ZWVuKHZhbHVlLCBzdGFydEJvdW5kLCBlbmRCb3VuZCk7XG4gICAgICAgIGlmIChzdWJTdGFydCA9PT0gbnVsbCAmJiBzaG91bGRTdGFydCgpKSB7XG4gICAgICAgICAgICBzdWJTdGFydCA9IGNvbXBhcmUodmFsdWUsIHN0YXJ0Qm91bmQpID09PSAwID8gaSA6IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1YlN0YXJ0ICE9PSBudWxsICYmIHNob3VsZFN0b3AoKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IHN1YlN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogaSxcbiAgICAgICAgICAgICAgICBsb29wLFxuICAgICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBzdWJTdGFydCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGk7XG4gICAgICAgIHByZXZWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBpZiAoc3ViU3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9ybWFsaXplU2VnbWVudCh7XG4gICAgICAgICAgICBzdGFydDogc3ViU3RhcnQsXG4gICAgICAgICAgICBlbmQsXG4gICAgICAgICAgICBsb29wLFxuICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICBzdHlsZVxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4gZnVuY3Rpb24gX2JvdW5kU2VnbWVudHMobGluZSwgYm91bmRzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qgc2VnbWVudHMgPSBsaW5lLnNlZ21lbnRzO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGNvbnN0IHN1YiA9IF9ib3VuZFNlZ21lbnQoc2VnbWVudHNbaV0sIGxpbmUucG9pbnRzLCBib3VuZHMpO1xuICAgICAgICBpZiAoc3ViLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4uc3ViKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIGZ1bmN0aW9uIGZpbmRTdGFydEFuZEVuZChwb2ludHMsIGNvdW50LCBsb29wLCBzcGFuR2Fwcykge1xuICAgIGxldCBzdGFydCA9IDA7XG4gICAgbGV0IGVuZCA9IGNvdW50IC0gMTtcbiAgICBpZiAobG9vcCAmJiAhc3BhbkdhcHMpIHtcbiAgICAgICAgd2hpbGUoc3RhcnQgPCBjb3VudCAmJiAhcG9pbnRzW3N0YXJ0XS5za2lwKXtcbiAgICAgICAgICAgIHN0YXJ0Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUoc3RhcnQgPCBjb3VudCAmJiBwb2ludHNbc3RhcnRdLnNraXApe1xuICAgICAgICBzdGFydCsrO1xuICAgIH1cbiAgICBzdGFydCAlPSBjb3VudDtcbiAgICBpZiAobG9vcCkge1xuICAgICAgICBlbmQgKz0gc3RhcnQ7XG4gICAgfVxuICAgIHdoaWxlKGVuZCA+IHN0YXJ0ICYmIHBvaW50c1tlbmQgJSBjb3VudF0uc2tpcCl7XG4gICAgICAgIGVuZC0tO1xuICAgIH1cbiAgICBlbmQgJT0gY291bnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQsXG4gICAgICAgIGVuZFxuICAgIH07XG59XG4gZnVuY3Rpb24gc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGxvb3ApIHtcbiAgICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IGxhc3QgPSBzdGFydDtcbiAgICBsZXQgcHJldiA9IHBvaW50c1tzdGFydF07XG4gICAgbGV0IGVuZDtcbiAgICBmb3IoZW5kID0gc3RhcnQgKyAxOyBlbmQgPD0gbWF4OyArK2VuZCl7XG4gICAgICAgIGNvbnN0IGN1ciA9IHBvaW50c1tlbmQgJSBjb3VudF07XG4gICAgICAgIGlmIChjdXIuc2tpcCB8fCBjdXIuc3RvcCkge1xuICAgICAgICAgICAgaWYgKCFwcmV2LnNraXApIHtcbiAgICAgICAgICAgICAgICBsb29wID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQgJSBjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAoZW5kIC0gMSkgJSBjb3VudCxcbiAgICAgICAgICAgICAgICAgICAgbG9vcFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gbGFzdCA9IGN1ci5zdG9wID8gZW5kIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3QgPSBlbmQ7XG4gICAgICAgICAgICBpZiAocHJldi5za2lwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGN1cjtcbiAgICB9XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0ICUgY291bnQsXG4gICAgICAgICAgICBlbmQ6IGxhc3QgJSBjb3VudCxcbiAgICAgICAgICAgIGxvb3BcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4gZnVuY3Rpb24gX2NvbXB1dGVTZWdtZW50cyhsaW5lLCBzZWdtZW50T3B0aW9ucykge1xuICAgIGNvbnN0IHBvaW50cyA9IGxpbmUucG9pbnRzO1xuICAgIGNvbnN0IHNwYW5HYXBzID0gbGluZS5vcHRpb25zLnNwYW5HYXBzO1xuICAgIGNvbnN0IGNvdW50ID0gcG9pbnRzLmxlbmd0aDtcbiAgICBpZiAoIWNvdW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgbG9vcCA9ICEhbGluZS5fbG9vcDtcbiAgICBjb25zdCB7IHN0YXJ0ICwgZW5kICB9ID0gZmluZFN0YXJ0QW5kRW5kKHBvaW50cywgY291bnQsIGxvb3AsIHNwYW5HYXBzKTtcbiAgICBpZiAoc3BhbkdhcHMgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZCxcbiAgICAgICAgICAgICAgICBsb29wXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBtYXggPSBlbmQgPCBzdGFydCA/IGVuZCArIGNvdW50IDogZW5kO1xuICAgIGNvbnN0IGNvbXBsZXRlTG9vcCA9ICEhbGluZS5fZnVsbExvb3AgJiYgc3RhcnQgPT09IDAgJiYgZW5kID09PSBjb3VudCAtIDE7XG4gICAgcmV0dXJuIHNwbGl0QnlTdHlsZXMobGluZSwgc29saWRTZWdtZW50cyhwb2ludHMsIHN0YXJ0LCBtYXgsIGNvbXBsZXRlTG9vcCksIHBvaW50cywgc2VnbWVudE9wdGlvbnMpO1xufVxuIGZ1bmN0aW9uIHNwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgICBpZiAoIXNlZ21lbnRPcHRpb25zIHx8ICFzZWdtZW50T3B0aW9ucy5zZXRDb250ZXh0IHx8ICFwb2ludHMpIHtcbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH1cbiAgICByZXR1cm4gZG9TcGxpdEJ5U3R5bGVzKGxpbmUsIHNlZ21lbnRzLCBwb2ludHMsIHNlZ21lbnRPcHRpb25zKTtcbn1cbiBmdW5jdGlvbiBkb1NwbGl0QnlTdHlsZXMobGluZSwgc2VnbWVudHMsIHBvaW50cywgc2VnbWVudE9wdGlvbnMpIHtcbiAgICBjb25zdCBjaGFydENvbnRleHQgPSBsaW5lLl9jaGFydC5nZXRDb250ZXh0KCk7XG4gICAgY29uc3QgYmFzZVN0eWxlID0gcmVhZFN0eWxlKGxpbmUub3B0aW9ucyk7XG4gICAgY29uc3QgeyBfZGF0YXNldEluZGV4OiBkYXRhc2V0SW5kZXggLCBvcHRpb25zOiB7IHNwYW5HYXBzICB9ICB9ID0gbGluZTtcbiAgICBjb25zdCBjb3VudCA9IHBvaW50cy5sZW5ndGg7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbGV0IHByZXZTdHlsZSA9IGJhc2VTdHlsZTtcbiAgICBsZXQgc3RhcnQgPSBzZWdtZW50c1swXS5zdGFydDtcbiAgICBsZXQgaSA9IHN0YXJ0O1xuICAgIGZ1bmN0aW9uIGFkZFN0eWxlKHMsIGUsIGwsIHN0KSB7XG4gICAgICAgIGNvbnN0IGRpciA9IHNwYW5HYXBzID8gLTEgOiAxO1xuICAgICAgICBpZiAocyA9PT0gZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHMgKz0gY291bnQ7XG4gICAgICAgIHdoaWxlKHBvaW50c1tzICUgY291bnRdLnNraXApe1xuICAgICAgICAgICAgcyAtPSBkaXI7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUocG9pbnRzW2UgJSBjb3VudF0uc2tpcCl7XG4gICAgICAgICAgICBlICs9IGRpcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocyAlIGNvdW50ICE9PSBlICUgY291bnQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogcyAlIGNvdW50LFxuICAgICAgICAgICAgICAgIGVuZDogZSAlIGNvdW50LFxuICAgICAgICAgICAgICAgIGxvb3A6IGwsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByZXZTdHlsZSA9IHN0O1xuICAgICAgICAgICAgc3RhcnQgPSBlICUgY291bnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKXtcbiAgICAgICAgc3RhcnQgPSBzcGFuR2FwcyA/IHN0YXJ0IDogc2VnbWVudC5zdGFydDtcbiAgICAgICAgbGV0IHByZXYgPSBwb2ludHNbc3RhcnQgJSBjb3VudF07XG4gICAgICAgIGxldCBzdHlsZTtcbiAgICAgICAgZm9yKGkgPSBzdGFydCArIDE7IGkgPD0gc2VnbWVudC5lbmQ7IGkrKyl7XG4gICAgICAgICAgICBjb25zdCBwdCA9IHBvaW50c1tpICUgY291bnRdO1xuICAgICAgICAgICAgc3R5bGUgPSByZWFkU3R5bGUoc2VnbWVudE9wdGlvbnMuc2V0Q29udGV4dChjcmVhdGVDb250ZXh0KGNoYXJ0Q29udGV4dCwge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzZWdtZW50JyxcbiAgICAgICAgICAgICAgICBwMDogcHJldixcbiAgICAgICAgICAgICAgICBwMTogcHQsXG4gICAgICAgICAgICAgICAgcDBEYXRhSW5kZXg6IChpIC0gMSkgJSBjb3VudCxcbiAgICAgICAgICAgICAgICBwMURhdGFJbmRleDogaSAlIGNvdW50LFxuICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIGlmIChzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkpIHtcbiAgICAgICAgICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXYgPSBwdDtcbiAgICAgICAgICAgIHByZXZTdHlsZSA9IHN0eWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA8IGkgLSAxKSB7XG4gICAgICAgICAgICBhZGRTdHlsZShzdGFydCwgaSAtIDEsIHNlZ21lbnQubG9vcCwgcHJldlN0eWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcmVhZFN0eWxlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBib3JkZXJDYXBTdHlsZTogb3B0aW9ucy5ib3JkZXJDYXBTdHlsZSxcbiAgICAgICAgYm9yZGVyRGFzaDogb3B0aW9ucy5ib3JkZXJEYXNoLFxuICAgICAgICBib3JkZXJEYXNoT2Zmc2V0OiBvcHRpb25zLmJvcmRlckRhc2hPZmZzZXQsXG4gICAgICAgIGJvcmRlckpvaW5TdHlsZTogb3B0aW9ucy5ib3JkZXJKb2luU3R5bGUsXG4gICAgICAgIGJvcmRlcldpZHRoOiBvcHRpb25zLmJvcmRlcldpZHRoLFxuICAgICAgICBib3JkZXJDb2xvcjogb3B0aW9ucy5ib3JkZXJDb2xvclxuICAgIH07XG59XG5mdW5jdGlvbiBzdHlsZUNoYW5nZWQoc3R5bGUsIHByZXZTdHlsZSkge1xuICAgIGlmICghcHJldlN0eWxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgY2FjaGUgPSBbXTtcbiAgICBjb25zdCByZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc1BhdHRlcm5PckdyYWRpZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FjaGUuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICBjYWNoZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FjaGUuaW5kZXhPZih2YWx1ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3R5bGUsIHJlcGxhY2VyKSAhPT0gSlNPTi5zdHJpbmdpZnkocHJldlN0eWxlLCByZXBsYWNlcik7XG59XG5cbmZ1bmN0aW9uIGdldFNpemVGb3JBcmVhKHNjYWxlLCBjaGFydEFyZWEsIGZpZWxkKSB7XG4gICAgcmV0dXJuIHNjYWxlLm9wdGlvbnMuY2xpcCA/IHNjYWxlW2ZpZWxkXSA6IGNoYXJ0QXJlYVtmaWVsZF07XG59XG5mdW5jdGlvbiBnZXREYXRhc2V0QXJlYShtZXRhLCBjaGFydEFyZWEpIHtcbiAgICBjb25zdCB7IHhTY2FsZSAsIHlTY2FsZSAgfSA9IG1ldGE7XG4gICAgaWYgKHhTY2FsZSAmJiB5U2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAnbGVmdCcpLFxuICAgICAgICAgICAgcmlnaHQ6IGdldFNpemVGb3JBcmVhKHhTY2FsZSwgY2hhcnRBcmVhLCAncmlnaHQnKSxcbiAgICAgICAgICAgIHRvcDogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICd0b3AnKSxcbiAgICAgICAgICAgIGJvdHRvbTogZ2V0U2l6ZUZvckFyZWEoeVNjYWxlLCBjaGFydEFyZWEsICdib3R0b20nKVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gY2hhcnRBcmVhO1xufVxuZnVuY3Rpb24gZ2V0RGF0YXNldENsaXBBcmVhKGNoYXJ0LCBtZXRhKSB7XG4gICAgY29uc3QgY2xpcCA9IG1ldGEuX2NsaXA7XG4gICAgaWYgKGNsaXAuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhcmVhID0gZ2V0RGF0YXNldEFyZWEobWV0YSwgY2hhcnQuY2hhcnRBcmVhKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBjbGlwLmxlZnQgPT09IGZhbHNlID8gMCA6IGFyZWEubGVmdCAtIChjbGlwLmxlZnQgPT09IHRydWUgPyAwIDogY2xpcC5sZWZ0KSxcbiAgICAgICAgcmlnaHQ6IGNsaXAucmlnaHQgPT09IGZhbHNlID8gY2hhcnQud2lkdGggOiBhcmVhLnJpZ2h0ICsgKGNsaXAucmlnaHQgPT09IHRydWUgPyAwIDogY2xpcC5yaWdodCksXG4gICAgICAgIHRvcDogY2xpcC50b3AgPT09IGZhbHNlID8gMCA6IGFyZWEudG9wIC0gKGNsaXAudG9wID09PSB0cnVlID8gMCA6IGNsaXAudG9wKSxcbiAgICAgICAgYm90dG9tOiBjbGlwLmJvdHRvbSA9PT0gZmFsc2UgPyBjaGFydC5oZWlnaHQgOiBhcmVhLmJvdHRvbSArIChjbGlwLmJvdHRvbSA9PT0gdHJ1ZSA/IDAgOiBjbGlwLmJvdHRvbSlcbiAgICB9O1xufVxuXG5leHBvcnQgeyB1bmNsaXBBcmVhIGFzICQsIF9ybG9va3VwQnlLZXkgYXMgQSwgX2xvb2t1cEJ5S2V5IGFzIEIsIF9pc1BvaW50SW5BcmVhIGFzIEMsIGdldEFuZ2xlRnJvbVBvaW50IGFzIEQsIHRvUGFkZGluZyBhcyBFLCBlYWNoIGFzIEYsIGdldE1heGltdW1TaXplIGFzIEcsIEhBTEZfUEkgYXMgSCwgX2dldFBhcmVudE5vZGUgYXMgSSwgcmVhZFVzZWRTaXplIGFzIEosIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMgYXMgSywgdGhyb3R0bGVkIGFzIEwsIF9pc0RvbVN1cHBvcnRlZCBhcyBNLCBfZmFjdG9yaXplIGFzIE4sIGZpbml0ZU9yRGVmYXVsdCBhcyBPLCBQSSBhcyBQLCBjYWxsYmFjayBhcyBRLCBfYWRkR3JhY2UgYXMgUiwgX2xpbWl0VmFsdWUgYXMgUywgVEFVIGFzIFQsIHRvRGVncmVlcyBhcyBVLCBfbWVhc3VyZVRleHQgYXMgViwgX2ludDE2UmFuZ2UgYXMgVywgX2FsaWduUGl4ZWwgYXMgWCwgY2xpcEFyZWEgYXMgWSwgcmVuZGVyVGV4dCBhcyBaLCBfYXJyYXlVbmlxdWUgYXMgXywgcmVzb2x2ZSBhcyBhLCBnZXRTdHlsZSBhcyBhJCwgdG9Gb250IGFzIGEwLCBfdG9MZWZ0UmlnaHRDZW50ZXIgYXMgYTEsIF9hbGlnblN0YXJ0RW5kIGFzIGEyLCBvdmVycmlkZXMgYXMgYTMsIG1lcmdlIGFzIGE0LCBfY2FwaXRhbGl6ZSBhcyBhNSwgZGVzY3JpcHRvcnMgYXMgYTYsIGlzRnVuY3Rpb24gYXMgYTcsIF9hdHRhY2hDb250ZXh0IGFzIGE4LCBfY3JlYXRlUmVzb2x2ZXIgYXMgYTksIGdldFJ0bEFkYXB0ZXIgYXMgYUEsIG92ZXJyaWRlVGV4dERpcmVjdGlvbiBhcyBhQiwgX3RleHRYIGFzIGFDLCByZXN0b3JlVGV4dERpcmVjdGlvbiBhcyBhRCwgZHJhd1BvaW50TGVnZW5kIGFzIGFFLCBkaXN0YW5jZUJldHdlZW5Qb2ludHMgYXMgYUYsIG5vb3AgYXMgYUcsIF9zZXRNaW5BbmRNYXhCeUtleSBhcyBhSCwgbmljZU51bSBhcyBhSSwgYWxtb3N0V2hvbGUgYXMgYUosIGFsbW9zdEVxdWFscyBhcyBhSywgX2RlY2ltYWxQbGFjZXMgYXMgYUwsIFRpY2tzIGFzIGFNLCBsb2cxMCBhcyBhTiwgX2xvbmdlc3RUZXh0IGFzIGFPLCBfZmlsdGVyQmV0d2VlbiBhcyBhUCwgX2xvb2t1cCBhcyBhUSwgaXNQYXR0ZXJuT3JHcmFkaWVudCBhcyBhUiwgZ2V0SG92ZXJDb2xvciBhcyBhUywgY2xvbmUgYXMgYVQsIF9tZXJnZXIgYXMgYVUsIF9tZXJnZXJJZiBhcyBhViwgX2RlcHJlY2F0ZWQgYXMgYVcsIF9zcGxpdEtleSBhcyBhWCwgdG9Gb250U3RyaW5nIGFzIGFZLCBzcGxpbmVDdXJ2ZSBhcyBhWiwgc3BsaW5lQ3VydmVNb25vdG9uZSBhcyBhXywgX2Rlc2NyaXB0b3JzIGFzIGFhLCBtZXJnZUlmIGFzIGFiLCB1aWQgYXMgYWMsIGRlYm91bmNlIGFzIGFkLCByZXRpbmFTY2FsZSBhcyBhZSwgY2xlYXJDYW52YXMgYXMgYWYsIHNldHNFcXVhbCBhcyBhZywgZ2V0RGF0YXNldENsaXBBcmVhIGFzIGFoLCBfZWxlbWVudHNFcXVhbCBhcyBhaSwgX2lzQ2xpY2tFdmVudCBhcyBhaiwgX2lzQmV0d2VlbiBhcyBhaywgX3JlYWRWYWx1ZVRvUHJvcHMgYXMgYWwsIF91cGRhdGVCZXppZXJDb250cm9sUG9pbnRzIGFzIGFtLCBfY29tcHV0ZVNlZ21lbnRzIGFzIGFuLCBfYm91bmRTZWdtZW50cyBhcyBhbywgX3N0ZXBwZWRJbnRlcnBvbGF0aW9uIGFzIGFwLCBfYmV6aWVySW50ZXJwb2xhdGlvbiBhcyBhcSwgX3BvaW50SW5MaW5lIGFzIGFyLCBfc3RlcHBlZExpbmVUbyBhcyBhcywgX2JlemllckN1cnZlVG8gYXMgYXQsIGRyYXdQb2ludCBhcyBhdSwgYWRkUm91bmRlZFJlY3RQYXRoIGFzIGF2LCB0b1RSQkwgYXMgYXcsIHRvVFJCTENvcm5lcnMgYXMgYXgsIF9ib3VuZFNlZ21lbnQgYXMgYXksIF9ub3JtYWxpemVBbmdsZSBhcyBheiwgaXNBcnJheSBhcyBiLCBmb250U3RyaW5nIGFzIGIwLCB0b0xpbmVIZWlnaHQgYXMgYjEsIFBJVEFVIGFzIGIyLCBJTkZJTklUWSBhcyBiMywgUkFEX1BFUl9ERUcgYXMgYjQsIFFVQVJURVJfUEkgYXMgYjUsIFRXT19USElSRFNfUEkgYXMgYjYsIF9hbmdsZURpZmYgYXMgYjcsIGNvbG9yIGFzIGMsIGRlZmF1bHRzIGFzIGQsIGVmZmVjdHMgYXMgZSwgcmVzb2x2ZU9iamVjdEtleSBhcyBmLCBpc051bWJlckZpbml0ZSBhcyBnLCBkZWZpbmVkIGFzIGgsIGlzT2JqZWN0IGFzIGksIGNyZWF0ZUNvbnRleHQgYXMgaiwgaXNOdWxsT3JVbmRlZiBhcyBrLCBsaXN0ZW5BcnJheUV2ZW50cyBhcyBsLCB0b1BlcmNlbnRhZ2UgYXMgbSwgdG9EaW1lbnNpb24gYXMgbiwgZm9ybWF0TnVtYmVyIGFzIG8sIF9hbmdsZUJldHdlZW4gYXMgcCwgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMgYXMgcSwgcmVxdWVzdEFuaW1GcmFtZSBhcyByLCBzaWduIGFzIHMsIHRvUmFkaWFucyBhcyB0LCB1bmxpc3RlbkFycmF5RXZlbnRzIGFzIHUsIHZhbHVlT3JEZWZhdWx0IGFzIHYsIF9zY2FsZVJhbmdlc0NoYW5nZWQgYXMgdywgaXNOdW1iZXIgYXMgeCwgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlIGFzIHksIGdldFJlbGF0aXZlUG9zaXRpb24gYXMgeiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5kYXRhc2V0LmpzLm1hcFxuIiwiLyohXG4gKiBDaGFydC5qcyB2NC40LjlcbiAqIGh0dHBzOi8vd3d3LmNoYXJ0anMub3JnXG4gKiAoYykgMjAyNSBDaGFydC5qcyBDb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICovXG5leHBvcnQgeyBIIGFzIEhBTEZfUEksIGIzIGFzIElORklOSVRZLCBQIGFzIFBJLCBiMiBhcyBQSVRBVSwgYjUgYXMgUVVBUlRFUl9QSSwgYjQgYXMgUkFEX1BFUl9ERUcsIFQgYXMgVEFVLCBiNiBhcyBUV09fVEhJUkRTX1BJLCBSIGFzIF9hZGRHcmFjZSwgWCBhcyBfYWxpZ25QaXhlbCwgYTIgYXMgX2FsaWduU3RhcnRFbmQsIHAgYXMgX2FuZ2xlQmV0d2VlbiwgYjcgYXMgX2FuZ2xlRGlmZiwgXyBhcyBfYXJyYXlVbmlxdWUsIGE4IGFzIF9hdHRhY2hDb250ZXh0LCBhdCBhcyBfYmV6aWVyQ3VydmVUbywgYXEgYXMgX2JlemllckludGVycG9sYXRpb24sIGF5IGFzIF9ib3VuZFNlZ21lbnQsIGFvIGFzIF9ib3VuZFNlZ21lbnRzLCBhNSBhcyBfY2FwaXRhbGl6ZSwgYW4gYXMgX2NvbXB1dGVTZWdtZW50cywgYTkgYXMgX2NyZWF0ZVJlc29sdmVyLCBhTCBhcyBfZGVjaW1hbFBsYWNlcywgYVcgYXMgX2RlcHJlY2F0ZWQsIGFhIGFzIF9kZXNjcmlwdG9ycywgYWkgYXMgX2VsZW1lbnRzRXF1YWwsIE4gYXMgX2ZhY3Rvcml6ZSwgYVAgYXMgX2ZpbHRlckJldHdlZW4sIEkgYXMgX2dldFBhcmVudE5vZGUsIHEgYXMgX2dldFN0YXJ0QW5kQ291bnRPZlZpc2libGVQb2ludHMsIFcgYXMgX2ludDE2UmFuZ2UsIGFrIGFzIF9pc0JldHdlZW4sIGFqIGFzIF9pc0NsaWNrRXZlbnQsIE0gYXMgX2lzRG9tU3VwcG9ydGVkLCBDIGFzIF9pc1BvaW50SW5BcmVhLCBTIGFzIF9saW1pdFZhbHVlLCBhTyBhcyBfbG9uZ2VzdFRleHQsIGFRIGFzIF9sb29rdXAsIEIgYXMgX2xvb2t1cEJ5S2V5LCBWIGFzIF9tZWFzdXJlVGV4dCwgYVUgYXMgX21lcmdlciwgYVYgYXMgX21lcmdlcklmLCBheiBhcyBfbm9ybWFsaXplQW5nbGUsIHkgYXMgX3BhcnNlT2JqZWN0RGF0YVJhZGlhbFNjYWxlLCBhciBhcyBfcG9pbnRJbkxpbmUsIGFsIGFzIF9yZWFkVmFsdWVUb1Byb3BzLCBBIGFzIF9ybG9va3VwQnlLZXksIHcgYXMgX3NjYWxlUmFuZ2VzQ2hhbmdlZCwgYUggYXMgX3NldE1pbkFuZE1heEJ5S2V5LCBhWCBhcyBfc3BsaXRLZXksIGFwIGFzIF9zdGVwcGVkSW50ZXJwb2xhdGlvbiwgYXMgYXMgX3N0ZXBwZWRMaW5lVG8sIGFDIGFzIF90ZXh0WCwgYTEgYXMgX3RvTGVmdFJpZ2h0Q2VudGVyLCBhbSBhcyBfdXBkYXRlQmV6aWVyQ29udHJvbFBvaW50cywgYXYgYXMgYWRkUm91bmRlZFJlY3RQYXRoLCBhSyBhcyBhbG1vc3RFcXVhbHMsIGFKIGFzIGFsbW9zdFdob2xlLCBRIGFzIGNhbGxiYWNrLCBhZiBhcyBjbGVhckNhbnZhcywgWSBhcyBjbGlwQXJlYSwgYVQgYXMgY2xvbmUsIGMgYXMgY29sb3IsIGogYXMgY3JlYXRlQ29udGV4dCwgYWQgYXMgZGVib3VuY2UsIGggYXMgZGVmaW5lZCwgYUYgYXMgZGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCBhdSBhcyBkcmF3UG9pbnQsIGFFIGFzIGRyYXdQb2ludExlZ2VuZCwgRiBhcyBlYWNoLCBlIGFzIGVhc2luZ0VmZmVjdHMsIE8gYXMgZmluaXRlT3JEZWZhdWx0LCBiMCBhcyBmb250U3RyaW5nLCBvIGFzIGZvcm1hdE51bWJlciwgRCBhcyBnZXRBbmdsZUZyb21Qb2ludCwgYWggYXMgZ2V0RGF0YXNldENsaXBBcmVhLCBhUyBhcyBnZXRIb3ZlckNvbG9yLCBHIGFzIGdldE1heGltdW1TaXplLCB6IGFzIGdldFJlbGF0aXZlUG9zaXRpb24sIGFBIGFzIGdldFJ0bEFkYXB0ZXIsIGEkIGFzIGdldFN0eWxlLCBiIGFzIGlzQXJyYXksIGcgYXMgaXNGaW5pdGUsIGE3IGFzIGlzRnVuY3Rpb24sIGsgYXMgaXNOdWxsT3JVbmRlZiwgeCBhcyBpc051bWJlciwgaSBhcyBpc09iamVjdCwgYVIgYXMgaXNQYXR0ZXJuT3JHcmFkaWVudCwgbCBhcyBsaXN0ZW5BcnJheUV2ZW50cywgYU4gYXMgbG9nMTAsIGE0IGFzIG1lcmdlLCBhYiBhcyBtZXJnZUlmLCBhSSBhcyBuaWNlTnVtLCBhRyBhcyBub29wLCBhQiBhcyBvdmVycmlkZVRleHREaXJlY3Rpb24sIEogYXMgcmVhZFVzZWRTaXplLCBaIGFzIHJlbmRlclRleHQsIHIgYXMgcmVxdWVzdEFuaW1GcmFtZSwgYSBhcyByZXNvbHZlLCBmIGFzIHJlc29sdmVPYmplY3RLZXksIGFEIGFzIHJlc3RvcmVUZXh0RGlyZWN0aW9uLCBhZSBhcyByZXRpbmFTY2FsZSwgYWcgYXMgc2V0c0VxdWFsLCBzIGFzIHNpZ24sIGFaIGFzIHNwbGluZUN1cnZlLCBhXyBhcyBzcGxpbmVDdXJ2ZU1vbm90b25lLCBLIGFzIHN1cHBvcnRzRXZlbnRMaXN0ZW5lck9wdGlvbnMsIEwgYXMgdGhyb3R0bGVkLCBVIGFzIHRvRGVncmVlcywgbiBhcyB0b0RpbWVuc2lvbiwgYTAgYXMgdG9Gb250LCBhWSBhcyB0b0ZvbnRTdHJpbmcsIGIxIGFzIHRvTGluZUhlaWdodCwgRSBhcyB0b1BhZGRpbmcsIG0gYXMgdG9QZXJjZW50YWdlLCB0IGFzIHRvUmFkaWFucywgYXcgYXMgdG9UUkJMLCBheCBhcyB0b1RSQkxDb3JuZXJzLCBhYyBhcyB1aWQsICQgYXMgdW5jbGlwQXJlYSwgdSBhcyB1bmxpc3RlbkFycmF5RXZlbnRzLCB2IGFzIHZhbHVlT3JEZWZhdWx0IH0gZnJvbSAnLi9jaHVua3MvaGVscGVycy5kYXRhc2V0LmpzJztcbmltcG9ydCAnQGt1cmtsZS9jb2xvcic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oZWxwZXJzLmpzLm1hcFxuIiwiZXhwb3J0ICogZnJvbSAnLi4vZGlzdC9oZWxwZXJzLmpzJztcbiIsIi8qIVxuICogY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyB2Mi4yLjBcbiAqIGh0dHBzOi8vY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy5uZXRsaWZ5LmFwcFxuICogKGMpIDIwMTctMjAyMiBjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKi9cbmltcG9ydCB7IGlzTnVsbE9yVW5kZWYsIG1lcmdlLCB0b0ZvbnQsIHJlc29sdmUsIHRvUGFkZGluZywgdmFsdWVPckRlZmF1bHQsIGNhbGxiYWNrLCBpc09iamVjdCwgZWFjaCB9IGZyb20gJ2NoYXJ0LmpzL2hlbHBlcnMnO1xuaW1wb3J0IHsgZGVmYXVsdHMgYXMgZGVmYXVsdHMkMSwgQXJjRWxlbWVudCwgUG9pbnRFbGVtZW50LCBCYXJFbGVtZW50IH0gZnJvbSAnY2hhcnQuanMnO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgfVxuXG4gICAgLy8gZGV2aWNlUGl4ZWxSYXRpbyBpcyB1bmRlZmluZWQgb24gSUUxMFxuICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMDIwNDE4MC84ODM3ODg3XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscy9pc3N1ZXMvODVcbiAgICB2YXIgc2NyZWVuID0gd2luZG93LnNjcmVlbjtcbiAgICBpZiAoc2NyZWVuKSB7XG4gICAgICByZXR1cm4gKHNjcmVlbi5kZXZpY2VYRFBJIHx8IDEpIC8gKHNjcmVlbi5sb2dpY2FsWERQSSB8fCAxKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMTtcbn0oKSk7XG5cbnZhciB1dGlscyA9IHtcbiAgLy8gQHRvZG8gbW92ZSB0aGlzIGluIENoYXJ0LmhlbHBlcnMudG9UZXh0TGluZXNcbiAgdG9UZXh0TGluZXM6IGZ1bmN0aW9uKGlucHV0cykge1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIHZhciBpbnB1dDtcblxuICAgIGlucHV0cyA9IFtdLmNvbmNhdChpbnB1dHMpO1xuICAgIHdoaWxlIChpbnB1dHMubGVuZ3RoKSB7XG4gICAgICBpbnB1dCA9IGlucHV0cy5wb3AoKTtcbiAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQuYXBwbHkobGluZXMsIGlucHV0LnNwbGl0KCdcXG4nKSk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGlucHV0cy5wdXNoLmFwcGx5KGlucHV0cywgaW5wdXQpO1xuICAgICAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZihpbnB1dHMpKSB7XG4gICAgICAgIGxpbmVzLnVuc2hpZnQoJycgKyBpbnB1dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVzO1xuICB9LFxuXG4gIC8vIEB0b2RvIG1vdmUgdGhpcyBpbiBDaGFydC5oZWxwZXJzLmNhbnZhcy50ZXh0U2l6ZVxuICAvLyBAdG9kbyBjYWNoZSBjYWxscyBvZiBtZWFzdXJlVGV4dCBpZiBmb250IGRvZXNuJ3QgY2hhbmdlPyFcbiAgdGV4dFNpemU6IGZ1bmN0aW9uKGN0eCwgbGluZXMsIGZvbnQpIHtcbiAgICB2YXIgaXRlbXMgPSBbXS5jb25jYXQobGluZXMpO1xuICAgIHZhciBpbGVuID0gaXRlbXMubGVuZ3RoO1xuICAgIHZhciBwcmV2ID0gY3R4LmZvbnQ7XG4gICAgdmFyIHdpZHRoID0gMDtcbiAgICB2YXIgaTtcblxuICAgIGN0eC5mb250ID0gZm9udC5zdHJpbmc7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KGN0eC5tZWFzdXJlVGV4dChpdGVtc1tpXSkud2lkdGgsIHdpZHRoKTtcbiAgICB9XG5cbiAgICBjdHguZm9udCA9IHByZXY7XG5cbiAgICByZXR1cm4ge1xuICAgICAgaGVpZ2h0OiBpbGVuICogZm9udC5saW5lSGVpZ2h0LFxuICAgICAgd2lkdGg6IHdpZHRoXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB2YWx1ZSBib3VuZGVkIGJ5IG1pbiBhbmQgbWF4LiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gbWF4KG1pbiwgbWluKHZhbHVlLCBtYXgpKS5cbiAgICogQHRvZG8gbW92ZSB0aGlzIG1ldGhvZCBpbiBDaGFydC5oZWxwZXJzLmJvdW5kXG4gICAqIGh0dHBzOi8vZG9jLnF0LmlvL3F0LTUvcXRnbG9iYWwuaHRtbCNxQm91bmRcbiAgICovXG4gIGJvdW5kOiBmdW5jdGlvbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih2YWx1ZSwgbWF4KSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcGFpciBbdmFsdWUsIHN0YXRlXSB3aGVyZSBzdGF0ZSBpczpcbiAgICogKiAtMTogdmFsdWUgaXMgb25seSBpbiBhMCAocmVtb3ZlZClcbiAgICogKiAgMTogdmFsdWUgaXMgb25seSBpbiBhMSAoYWRkZWQpXG4gICAqL1xuICBhcnJheURpZmY6IGZ1bmN0aW9uKGEwLCBhMSkge1xuICAgIHZhciBwcmV2ID0gYTAuc2xpY2UoKTtcbiAgICB2YXIgdXBkYXRlcyA9IFtdO1xuICAgIHZhciBpLCBqLCBpbGVuLCB2O1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGExLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgdiA9IGExW2ldO1xuICAgICAgaiA9IHByZXYuaW5kZXhPZih2KTtcblxuICAgICAgaWYgKGogPT09IC0xKSB7XG4gICAgICAgIHVwZGF0ZXMucHVzaChbdiwgMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldi5zcGxpY2UoaiwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IHByZXYubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICB1cGRhdGVzLnB1c2goW3ByZXZbaV0sIC0xXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFydGpzL2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMvaXNzdWVzLzcwXG4gICAqL1xuICByYXN0ZXJpemU6IGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZCh2ICogZGV2aWNlUGl4ZWxSYXRpbykgLyBkZXZpY2VQaXhlbFJhdGlvO1xuICB9XG59O1xuXG5mdW5jdGlvbiBvcmllbnQocG9pbnQsIG9yaWdpbikge1xuICB2YXIgeDAgPSBvcmlnaW4ueDtcbiAgdmFyIHkwID0gb3JpZ2luLnk7XG5cbiAgaWYgKHgwID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt4OiAwLCB5OiAtMX07XG4gIH1cbiAgaWYgKHkwID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHt4OiAxLCB5OiAwfTtcbiAgfVxuXG4gIHZhciBkeCA9IHBvaW50LnggLSB4MDtcbiAgdmFyIGR5ID0gcG9pbnQueSAtIHkwO1xuICB2YXIgbG4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIHJldHVybiB7XG4gICAgeDogbG4gPyBkeCAvIGxuIDogMCxcbiAgICB5OiBsbiA/IGR5IC8gbG4gOiAtMVxuICB9O1xufVxuXG5mdW5jdGlvbiBhbGlnbmVkKHgsIHksIHZ4LCB2eSwgYWxpZ24pIHtcbiAgc3dpdGNoIChhbGlnbikge1xuICBjYXNlICdjZW50ZXInOlxuICAgIHZ4ID0gdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICdib3R0b20nOlxuICAgIHZ4ID0gMDtcbiAgICB2eSA9IDE7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ3JpZ2h0JzpcbiAgICB2eCA9IDE7XG4gICAgdnkgPSAwO1xuICAgIGJyZWFrO1xuICBjYXNlICdsZWZ0JzpcbiAgICB2eCA9IC0xO1xuICAgIHZ5ID0gMDtcbiAgICBicmVhaztcbiAgY2FzZSAndG9wJzpcbiAgICB2eCA9IDA7XG4gICAgdnkgPSAtMTtcbiAgICBicmVhaztcbiAgY2FzZSAnc3RhcnQnOlxuICAgIHZ4ID0gLXZ4O1xuICAgIHZ5ID0gLXZ5O1xuICAgIGJyZWFrO1xuICBjYXNlICdlbmQnOlxuICAgIC8vIGtlZXAgbmF0dXJhbCBvcmllbnRhdGlvblxuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIC8vIGNsb2Nrd2lzZSByb3RhdGlvbiAoaW4gZGVncmVlKVxuICAgIGFsaWduICo9IChNYXRoLlBJIC8gMTgwKTtcbiAgICB2eCA9IE1hdGguY29zKGFsaWduKTtcbiAgICB2eSA9IE1hdGguc2luKGFsaWduKTtcbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiB5LFxuICAgIHZ4OiB2eCxcbiAgICB2eTogdnlcbiAgfTtcbn1cblxuLy8gTGluZSBjbGlwcGluZyAoQ29oZW7igJNTdXRoZXJsYW5kIGFsZ29yaXRobSlcbi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvaGVu4oCTU3V0aGVybGFuZF9hbGdvcml0aG1cblxudmFyIFJfSU5TSURFID0gMDtcbnZhciBSX0xFRlQgPSAxO1xudmFyIFJfUklHSFQgPSAyO1xudmFyIFJfQk9UVE9NID0gNDtcbnZhciBSX1RPUCA9IDg7XG5cbmZ1bmN0aW9uIHJlZ2lvbih4LCB5LCByZWN0KSB7XG4gIHZhciByZXMgPSBSX0lOU0lERTtcblxuICBpZiAoeCA8IHJlY3QubGVmdCkge1xuICAgIHJlcyB8PSBSX0xFRlQ7XG4gIH0gZWxzZSBpZiAoeCA+IHJlY3QucmlnaHQpIHtcbiAgICByZXMgfD0gUl9SSUdIVDtcbiAgfVxuICBpZiAoeSA8IHJlY3QudG9wKSB7XG4gICAgcmVzIHw9IFJfVE9QO1xuICB9IGVsc2UgaWYgKHkgPiByZWN0LmJvdHRvbSkge1xuICAgIHJlcyB8PSBSX0JPVFRPTTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59XG5cbmZ1bmN0aW9uIGNsaXBwZWQoc2VnbWVudCwgYXJlYSkge1xuICB2YXIgeDAgPSBzZWdtZW50LngwO1xuICB2YXIgeTAgPSBzZWdtZW50LnkwO1xuICB2YXIgeDEgPSBzZWdtZW50LngxO1xuICB2YXIgeTEgPSBzZWdtZW50LnkxO1xuICB2YXIgcjAgPSByZWdpb24oeDAsIHkwLCBhcmVhKTtcbiAgdmFyIHIxID0gcmVnaW9uKHgxLCB5MSwgYXJlYSk7XG4gIHZhciByLCB4LCB5O1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIShyMCB8IHIxKSB8fCAocjAgJiByMSkpIHtcbiAgICAgIC8vIGJvdGggcG9pbnRzIGluc2lkZSBvciBvbiB0aGUgc2FtZSBzaWRlOiBubyBjbGlwcGluZ1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gYXQgbGVhc3Qgb25lIHBvaW50IGlzIG91dHNpZGVcbiAgICByID0gcjAgfHwgcjE7XG5cbiAgICBpZiAociAmIFJfVE9QKSB7XG4gICAgICB4ID0geDAgKyAoeDEgLSB4MCkgKiAoYXJlYS50b3AgLSB5MCkgLyAoeTEgLSB5MCk7XG4gICAgICB5ID0gYXJlYS50b3A7XG4gICAgfSBlbHNlIGlmIChyICYgUl9CT1RUT00pIHtcbiAgICAgIHggPSB4MCArICh4MSAtIHgwKSAqIChhcmVhLmJvdHRvbSAtIHkwKSAvICh5MSAtIHkwKTtcbiAgICAgIHkgPSBhcmVhLmJvdHRvbTtcbiAgICB9IGVsc2UgaWYgKHIgJiBSX1JJR0hUKSB7XG4gICAgICB5ID0geTAgKyAoeTEgLSB5MCkgKiAoYXJlYS5yaWdodCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICAgIHggPSBhcmVhLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAociAmIFJfTEVGVCkge1xuICAgICAgeSA9IHkwICsgKHkxIC0geTApICogKGFyZWEubGVmdCAtIHgwKSAvICh4MSAtIHgwKTtcbiAgICAgIHggPSBhcmVhLmxlZnQ7XG4gICAgfVxuXG4gICAgaWYgKHIgPT09IHIwKSB7XG4gICAgICB4MCA9IHg7XG4gICAgICB5MCA9IHk7XG4gICAgICByMCA9IHJlZ2lvbih4MCwgeTAsIGFyZWEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MSA9IHg7XG4gICAgICB5MSA9IHk7XG4gICAgICByMSA9IHJlZ2lvbih4MSwgeTEsIGFyZWEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDA6IHgwLFxuICAgIHgxOiB4MSxcbiAgICB5MDogeTAsXG4gICAgeTE6IHkxXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGUkMShyYW5nZSwgY29uZmlnKSB7XG4gIHZhciBhbmNob3IgPSBjb25maWcuYW5jaG9yO1xuICB2YXIgc2VnbWVudCA9IHJhbmdlO1xuICB2YXIgeCwgeTtcblxuICBpZiAoY29uZmlnLmNsYW1wKSB7XG4gICAgc2VnbWVudCA9IGNsaXBwZWQoc2VnbWVudCwgY29uZmlnLmFyZWEpO1xuICB9XG5cbiAgaWYgKGFuY2hvciA9PT0gJ3N0YXJ0Jykge1xuICAgIHggPSBzZWdtZW50LngwO1xuICAgIHkgPSBzZWdtZW50LnkwO1xuICB9IGVsc2UgaWYgKGFuY2hvciA9PT0gJ2VuZCcpIHtcbiAgICB4ID0gc2VnbWVudC54MTtcbiAgICB5ID0gc2VnbWVudC55MTtcbiAgfSBlbHNlIHtcbiAgICB4ID0gKHNlZ21lbnQueDAgKyBzZWdtZW50LngxKSAvIDI7XG4gICAgeSA9IChzZWdtZW50LnkwICsgc2VnbWVudC55MSkgLyAyO1xuICB9XG5cbiAgcmV0dXJuIGFsaWduZWQoeCwgeSwgcmFuZ2UudngsIHJhbmdlLnZ5LCBjb25maWcuYWxpZ24pO1xufVxuXG52YXIgcG9zaXRpb25lcnMgPSB7XG4gIGFyYzogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciBhbmdsZSA9IChlbC5zdGFydEFuZ2xlICsgZWwuZW5kQW5nbGUpIC8gMjtcbiAgICB2YXIgdnggPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgdmFyIHZ5ID0gTWF0aC5zaW4oYW5nbGUpO1xuICAgIHZhciByMCA9IGVsLmlubmVyUmFkaXVzO1xuICAgIHZhciByMSA9IGVsLm91dGVyUmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCArIHZ4ICogcjAsXG4gICAgICB5MDogZWwueSArIHZ5ICogcjAsXG4gICAgICB4MTogZWwueCArIHZ4ICogcjEsXG4gICAgICB5MTogZWwueSArIHZ5ICogcjEsXG4gICAgICB2eDogdngsXG4gICAgICB2eTogdnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIHBvaW50OiBmdW5jdGlvbihlbCwgY29uZmlnKSB7XG4gICAgdmFyIHYgPSBvcmllbnQoZWwsIGNvbmZpZy5vcmlnaW4pO1xuICAgIHZhciByeCA9IHYueCAqIGVsLm9wdGlvbnMucmFkaXVzO1xuICAgIHZhciByeSA9IHYueSAqIGVsLm9wdGlvbnMucmFkaXVzO1xuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogZWwueCAtIHJ4LFxuICAgICAgeTA6IGVsLnkgLSByeSxcbiAgICAgIHgxOiBlbC54ICsgcngsXG4gICAgICB5MTogZWwueSArIHJ5LFxuICAgICAgdng6IHYueCxcbiAgICAgIHZ5OiB2LnlcbiAgICB9LCBjb25maWcpO1xuICB9LFxuXG4gIGJhcjogZnVuY3Rpb24oZWwsIGNvbmZpZykge1xuICAgIHZhciB2ID0gb3JpZW50KGVsLCBjb25maWcub3JpZ2luKTtcbiAgICB2YXIgeCA9IGVsLng7XG4gICAgdmFyIHkgPSBlbC55O1xuICAgIHZhciBzeCA9IDA7XG4gICAgdmFyIHN5ID0gMDtcblxuICAgIGlmIChlbC5ob3Jpem9udGFsKSB7XG4gICAgICB4ID0gTWF0aC5taW4oZWwueCwgZWwuYmFzZSk7XG4gICAgICBzeCA9IE1hdGguYWJzKGVsLmJhc2UgLSBlbC54KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeSA9IE1hdGgubWluKGVsLnksIGVsLmJhc2UpO1xuICAgICAgc3kgPSBNYXRoLmFicyhlbC5iYXNlIC0gZWwueSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXB1dGUkMSh7XG4gICAgICB4MDogeCxcbiAgICAgIHkwOiB5ICsgc3ksXG4gICAgICB4MTogeCArIHN4LFxuICAgICAgeTE6IHksXG4gICAgICB2eDogdi54LFxuICAgICAgdnk6IHYueVxuICAgIH0sIGNvbmZpZyk7XG4gIH0sXG5cbiAgZmFsbGJhY2s6IGZ1bmN0aW9uKGVsLCBjb25maWcpIHtcbiAgICB2YXIgdiA9IG9yaWVudChlbCwgY29uZmlnLm9yaWdpbik7XG5cbiAgICByZXR1cm4gY29tcHV0ZSQxKHtcbiAgICAgIHgwOiBlbC54LFxuICAgICAgeTA6IGVsLnksXG4gICAgICB4MTogZWwueCArIChlbC53aWR0aCB8fCAwKSxcbiAgICAgIHkxOiBlbC55ICsgKGVsLmhlaWdodCB8fCAwKSxcbiAgICAgIHZ4OiB2LngsXG4gICAgICB2eTogdi55XG4gICAgfSwgY29uZmlnKTtcbiAgfVxufTtcblxudmFyIHJhc3Rlcml6ZSA9IHV0aWxzLnJhc3Rlcml6ZTtcblxuZnVuY3Rpb24gYm91bmRpbmdSZWN0cyhtb2RlbCkge1xuICB2YXIgYm9yZGVyV2lkdGggPSBtb2RlbC5ib3JkZXJXaWR0aCB8fCAwO1xuICB2YXIgcGFkZGluZyA9IG1vZGVsLnBhZGRpbmc7XG4gIHZhciB0aCA9IG1vZGVsLnNpemUuaGVpZ2h0O1xuICB2YXIgdHcgPSBtb2RlbC5zaXplLndpZHRoO1xuICB2YXIgdHggPSAtdHcgLyAyO1xuICB2YXIgdHkgPSAtdGggLyAyO1xuXG4gIHJldHVybiB7XG4gICAgZnJhbWU6IHtcbiAgICAgIHg6IHR4IC0gcGFkZGluZy5sZWZ0IC0gYm9yZGVyV2lkdGgsXG4gICAgICB5OiB0eSAtIHBhZGRpbmcudG9wIC0gYm9yZGVyV2lkdGgsXG4gICAgICB3OiB0dyArIHBhZGRpbmcud2lkdGggKyBib3JkZXJXaWR0aCAqIDIsXG4gICAgICBoOiB0aCArIHBhZGRpbmcuaGVpZ2h0ICsgYm9yZGVyV2lkdGggKiAyXG4gICAgfSxcbiAgICB0ZXh0OiB7XG4gICAgICB4OiB0eCxcbiAgICAgIHk6IHR5LFxuICAgICAgdzogdHcsXG4gICAgICBoOiB0aFxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGVPcmlnaW4oZWwsIGNvbnRleHQpIHtcbiAgdmFyIHNjYWxlID0gY29udGV4dC5jaGFydC5nZXREYXRhc2V0TWV0YShjb250ZXh0LmRhdGFzZXRJbmRleCkudlNjYWxlO1xuXG4gIGlmICghc2NhbGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChzY2FsZS54Q2VudGVyICE9PSB1bmRlZmluZWQgJiYgc2NhbGUueUNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHt4OiBzY2FsZS54Q2VudGVyLCB5OiBzY2FsZS55Q2VudGVyfTtcbiAgfVxuXG4gIHZhciBwaXhlbCA9IHNjYWxlLmdldEJhc2VQaXhlbCgpO1xuICByZXR1cm4gZWwuaG9yaXpvbnRhbCA/XG4gICAge3g6IHBpeGVsLCB5OiBudWxsfSA6XG4gICAge3g6IG51bGwsIHk6IHBpeGVsfTtcbn1cblxuZnVuY3Rpb24gZ2V0UG9zaXRpb25lcihlbCkge1xuICBpZiAoZWwgaW5zdGFuY2VvZiBBcmNFbGVtZW50KSB7XG4gICAgcmV0dXJuIHBvc2l0aW9uZXJzLmFyYztcbiAgfVxuICBpZiAoZWwgaW5zdGFuY2VvZiBQb2ludEVsZW1lbnQpIHtcbiAgICByZXR1cm4gcG9zaXRpb25lcnMucG9pbnQ7XG4gIH1cbiAgaWYgKGVsIGluc3RhbmNlb2YgQmFyRWxlbWVudCkge1xuICAgIHJldHVybiBwb3NpdGlvbmVycy5iYXI7XG4gIH1cbiAgcmV0dXJuIHBvc2l0aW9uZXJzLmZhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBkcmF3Um91bmRlZFJlY3QoY3R4LCB4LCB5LCB3LCBoLCByYWRpdXMpIHtcbiAgdmFyIEhBTEZfUEkgPSBNYXRoLlBJIC8gMjtcblxuICBpZiAocmFkaXVzKSB7XG4gICAgdmFyIHIgPSBNYXRoLm1pbihyYWRpdXMsIGggLyAyLCB3IC8gMik7XG4gICAgdmFyIGxlZnQgPSB4ICsgcjtcbiAgICB2YXIgdG9wID0geSArIHI7XG4gICAgdmFyIHJpZ2h0ID0geCArIHcgLSByO1xuICAgIHZhciBib3R0b20gPSB5ICsgaCAtIHI7XG5cbiAgICBjdHgubW92ZVRvKHgsIHRvcCk7XG4gICAgaWYgKGxlZnQgPCByaWdodCAmJiB0b3AgPCBib3R0b20pIHtcbiAgICAgIGN0eC5hcmMobGVmdCwgdG9wLCByLCAtTWF0aC5QSSwgLUhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgMCk7XG4gICAgICBjdHguYXJjKHJpZ2h0LCBib3R0b20sIHIsIDAsIEhBTEZfUEkpO1xuICAgICAgY3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIEhBTEZfUEksIE1hdGguUEkpO1xuICAgIH0gZWxzZSBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICBjdHgubW92ZVRvKGxlZnQsIHkpO1xuICAgICAgY3R4LmFyYyhyaWdodCwgdG9wLCByLCAtSEFMRl9QSSwgSEFMRl9QSSk7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgSEFMRl9QSSwgTWF0aC5QSSArIEhBTEZfUEkpO1xuICAgIH0gZWxzZSBpZiAodG9wIDwgYm90dG9tKSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIDApO1xuICAgICAgY3R4LmFyYyhsZWZ0LCBib3R0b20sIHIsIDAsIE1hdGguUEkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYXJjKGxlZnQsIHRvcCwgciwgLU1hdGguUEksIE1hdGguUEkpO1xuICAgIH1cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgfSBlbHNlIHtcbiAgICBjdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3RnJhbWUoY3R4LCByZWN0LCBtb2RlbCkge1xuICB2YXIgYmdDb2xvciA9IG1vZGVsLmJhY2tncm91bmRDb2xvcjtcbiAgdmFyIGJvcmRlckNvbG9yID0gbW9kZWwuYm9yZGVyQ29sb3I7XG4gIHZhciBib3JkZXJXaWR0aCA9IG1vZGVsLmJvcmRlcldpZHRoO1xuXG4gIGlmICghYmdDb2xvciAmJiAoIWJvcmRlckNvbG9yIHx8ICFib3JkZXJXaWR0aCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgZHJhd1JvdW5kZWRSZWN0KFxuICAgIGN0eCxcbiAgICByYXN0ZXJpemUocmVjdC54KSArIGJvcmRlcldpZHRoIC8gMixcbiAgICByYXN0ZXJpemUocmVjdC55KSArIGJvcmRlcldpZHRoIC8gMixcbiAgICByYXN0ZXJpemUocmVjdC53KSAtIGJvcmRlcldpZHRoLFxuICAgIHJhc3Rlcml6ZShyZWN0LmgpIC0gYm9yZGVyV2lkdGgsXG4gICAgbW9kZWwuYm9yZGVyUmFkaXVzKTtcblxuICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgaWYgKGJnQ29sb3IpIHtcbiAgICBjdHguZmlsbFN0eWxlID0gYmdDb2xvcjtcbiAgICBjdHguZmlsbCgpO1xuICB9XG5cbiAgaWYgKGJvcmRlckNvbG9yICYmIGJvcmRlcldpZHRoKSB7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYm9yZGVyQ29sb3I7XG4gICAgY3R4LmxpbmVXaWR0aCA9IGJvcmRlcldpZHRoO1xuICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgY3R4LnN0cm9rZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRleHRHZW9tZXRyeShyZWN0LCBhbGlnbiwgZm9udCkge1xuICB2YXIgaCA9IGZvbnQubGluZUhlaWdodDtcbiAgdmFyIHcgPSByZWN0Lnc7XG4gIHZhciB4ID0gcmVjdC54O1xuICB2YXIgeSA9IHJlY3QueSArIGggLyAyO1xuXG4gIGlmIChhbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4ICs9IHcgLyAyO1xuICB9IGVsc2UgaWYgKGFsaWduID09PSAnZW5kJyB8fCBhbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgIHggKz0gdztcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaDogaCxcbiAgICB3OiB3LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG5mdW5jdGlvbiBkcmF3VGV4dExpbmUoY3R4LCB0ZXh0LCBjZmcpIHtcbiAgdmFyIHNoYWRvdyA9IGN0eC5zaGFkb3dCbHVyO1xuICB2YXIgc3Ryb2tlZCA9IGNmZy5zdHJva2VkO1xuICB2YXIgeCA9IHJhc3Rlcml6ZShjZmcueCk7XG4gIHZhciB5ID0gcmFzdGVyaXplKGNmZy55KTtcbiAgdmFyIHcgPSByYXN0ZXJpemUoY2ZnLncpO1xuXG4gIGlmIChzdHJva2VkKSB7XG4gICAgY3R4LnN0cm9rZVRleHQodGV4dCwgeCwgeSwgdyk7XG4gIH1cblxuICBpZiAoY2ZnLmZpbGxlZCkge1xuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xuICAgICAgLy8gUHJldmVudCBkcmF3aW5nIHNoYWRvdyBvbiBib3RoIHRoZSB0ZXh0IHN0cm9rZSBhbmQgZmlsbCwgc29cbiAgICAgIC8vIGlmIHRoZSB0ZXh0IGlzIHN0cm9rZWQsIHJlbW92ZSB0aGUgc2hhZG93IGZvciB0aGUgdGV4dCBmaWxsLlxuICAgICAgY3R4LnNoYWRvd0JsdXIgPSAwO1xuICAgIH1cblxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4LCB5LCB3KTtcblxuICAgIGlmIChzaGFkb3cgJiYgc3Ryb2tlZCkge1xuICAgICAgY3R4LnNoYWRvd0JsdXIgPSBzaGFkb3c7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRyYXdUZXh0KGN0eCwgbGluZXMsIHJlY3QsIG1vZGVsKSB7XG4gIHZhciBhbGlnbiA9IG1vZGVsLnRleHRBbGlnbjtcbiAgdmFyIGNvbG9yID0gbW9kZWwuY29sb3I7XG4gIHZhciBmaWxsZWQgPSAhIWNvbG9yO1xuICB2YXIgZm9udCA9IG1vZGVsLmZvbnQ7XG4gIHZhciBpbGVuID0gbGluZXMubGVuZ3RoO1xuICB2YXIgc3Ryb2tlQ29sb3IgPSBtb2RlbC50ZXh0U3Ryb2tlQ29sb3I7XG4gIHZhciBzdHJva2VXaWR0aCA9IG1vZGVsLnRleHRTdHJva2VXaWR0aDtcbiAgdmFyIHN0cm9rZWQgPSBzdHJva2VDb2xvciAmJiBzdHJva2VXaWR0aDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFpbGVuIHx8ICghZmlsbGVkICYmICFzdHJva2VkKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEFkanVzdCBjb29yZGluYXRlcyBiYXNlZCBvbiB0ZXh0IGFsaWdubWVudCBhbmQgbGluZSBoZWlnaHRcbiAgcmVjdCA9IHRleHRHZW9tZXRyeShyZWN0LCBhbGlnbiwgZm9udCk7XG5cbiAgY3R4LmZvbnQgPSBmb250LnN0cmluZztcbiAgY3R4LnRleHRBbGlnbiA9IGFsaWduO1xuICBjdHgudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gIGN0eC5zaGFkb3dCbHVyID0gbW9kZWwudGV4dFNoYWRvd0JsdXI7XG4gIGN0eC5zaGFkb3dDb2xvciA9IG1vZGVsLnRleHRTaGFkb3dDb2xvcjtcblxuICBpZiAoZmlsbGVkKSB7XG4gICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICB9XG4gIGlmIChzdHJva2VkKSB7XG4gICAgY3R4LmxpbmVKb2luID0gJ3JvdW5kJztcbiAgICBjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3I7XG4gIH1cblxuICBmb3IgKGkgPSAwLCBpbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgZHJhd1RleHRMaW5lKGN0eCwgbGluZXNbaV0sIHtcbiAgICAgIHN0cm9rZWQ6IHN0cm9rZWQsXG4gICAgICBmaWxsZWQ6IGZpbGxlZCxcbiAgICAgIHc6IHJlY3QudyxcbiAgICAgIHg6IHJlY3QueCxcbiAgICAgIHk6IHJlY3QueSArIHJlY3QuaCAqIGlcbiAgICB9KTtcbiAgfVxufVxuXG52YXIgTGFiZWwgPSBmdW5jdGlvbihjb25maWcsIGN0eCwgZWwsIGluZGV4KSB7XG4gIHZhciBtZSA9IHRoaXM7XG5cbiAgbWUuX2NvbmZpZyA9IGNvbmZpZztcbiAgbWUuX2luZGV4ID0gaW5kZXg7XG4gIG1lLl9tb2RlbCA9IG51bGw7XG4gIG1lLl9yZWN0cyA9IG51bGw7XG4gIG1lLl9jdHggPSBjdHg7XG4gIG1lLl9lbCA9IGVsO1xufTtcblxubWVyZ2UoTGFiZWwucHJvdG90eXBlLCB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21vZGVsaXplOiBmdW5jdGlvbihkaXNwbGF5LCBsaW5lcywgY29uZmlnLCBjb250ZXh0KSB7XG4gICAgdmFyIG1lID0gdGhpcztcbiAgICB2YXIgaW5kZXggPSBtZS5faW5kZXg7XG4gICAgdmFyIGZvbnQgPSB0b0ZvbnQocmVzb2x2ZShbY29uZmlnLmZvbnQsIHt9XSwgY29udGV4dCwgaW5kZXgpKTtcbiAgICB2YXIgY29sb3IgPSByZXNvbHZlKFtjb25maWcuY29sb3IsIGRlZmF1bHRzJDEuY29sb3JdLCBjb250ZXh0LCBpbmRleCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWxpZ246IHJlc29sdmUoW2NvbmZpZy5hbGlnbiwgJ2NlbnRlciddLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBhbmNob3I6IHJlc29sdmUoW2NvbmZpZy5hbmNob3IsICdjZW50ZXInXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYXJlYTogY29udGV4dC5jaGFydC5jaGFydEFyZWEsXG4gICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlc29sdmUoW2NvbmZpZy5iYWNrZ3JvdW5kQ29sb3IsIG51bGxdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBib3JkZXJDb2xvcjogcmVzb2x2ZShbY29uZmlnLmJvcmRlckNvbG9yLCBudWxsXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyUmFkaXVzOiByZXNvbHZlKFtjb25maWcuYm9yZGVyUmFkaXVzLCAwXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgYm9yZGVyV2lkdGg6IHJlc29sdmUoW2NvbmZpZy5ib3JkZXJXaWR0aCwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIGNsYW1wOiByZXNvbHZlKFtjb25maWcuY2xhbXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY2xpcDogcmVzb2x2ZShbY29uZmlnLmNsaXAsIGZhbHNlXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgZGlzcGxheTogZGlzcGxheSxcbiAgICAgIGZvbnQ6IGZvbnQsXG4gICAgICBsaW5lczogbGluZXMsXG4gICAgICBvZmZzZXQ6IHJlc29sdmUoW2NvbmZpZy5vZmZzZXQsIDRdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICBvcGFjaXR5OiByZXNvbHZlKFtjb25maWcub3BhY2l0eSwgMV0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIG9yaWdpbjogZ2V0U2NhbGVPcmlnaW4obWUuX2VsLCBjb250ZXh0KSxcbiAgICAgIHBhZGRpbmc6IHRvUGFkZGluZyhyZXNvbHZlKFtjb25maWcucGFkZGluZywgNF0sIGNvbnRleHQsIGluZGV4KSksXG4gICAgICBwb3NpdGlvbmVyOiBnZXRQb3NpdGlvbmVyKG1lLl9lbCksXG4gICAgICByb3RhdGlvbjogcmVzb2x2ZShbY29uZmlnLnJvdGF0aW9uLCAwXSwgY29udGV4dCwgaW5kZXgpICogKE1hdGguUEkgLyAxODApLFxuICAgICAgc2l6ZTogdXRpbHMudGV4dFNpemUobWUuX2N0eCwgbGluZXMsIGZvbnQpLFxuICAgICAgdGV4dEFsaWduOiByZXNvbHZlKFtjb25maWcudGV4dEFsaWduLCAnc3RhcnQnXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFNoYWRvd0JsdXI6IHJlc29sdmUoW2NvbmZpZy50ZXh0U2hhZG93Qmx1ciwgMF0sIGNvbnRleHQsIGluZGV4KSxcbiAgICAgIHRleHRTaGFkb3dDb2xvcjogcmVzb2x2ZShbY29uZmlnLnRleHRTaGFkb3dDb2xvciwgY29sb3JdLCBjb250ZXh0LCBpbmRleCksXG4gICAgICB0ZXh0U3Ryb2tlQ29sb3I6IHJlc29sdmUoW2NvbmZpZy50ZXh0U3Ryb2tlQ29sb3IsIGNvbG9yXSwgY29udGV4dCwgaW5kZXgpLFxuICAgICAgdGV4dFN0cm9rZVdpZHRoOiByZXNvbHZlKFtjb25maWcudGV4dFN0cm9rZVdpZHRoLCAwXSwgY29udGV4dCwgaW5kZXgpXG4gICAgfTtcbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBtb2RlbCA9IG51bGw7XG4gICAgdmFyIHJlY3RzID0gbnVsbDtcbiAgICB2YXIgaW5kZXggPSBtZS5faW5kZXg7XG4gICAgdmFyIGNvbmZpZyA9IG1lLl9jb25maWc7XG4gICAgdmFyIHZhbHVlLCBsYWJlbCwgbGluZXM7XG5cbiAgICAvLyBXZSBmaXJzdCByZXNvbHZlIHRoZSBkaXNwbGF5IG9wdGlvbiAoc2VwYXJhdGVseSkgdG8gYXZvaWQgY29tcHV0aW5nXG4gICAgLy8gb3RoZXIgb3B0aW9ucyBpbiBjYXNlIHRoZSBsYWJlbCBpcyBoaWRkZW4gKGkuZS4gZGlzcGxheTogZmFsc2UpLlxuICAgIHZhciBkaXNwbGF5ID0gcmVzb2x2ZShbY29uZmlnLmRpc3BsYXksIHRydWVdLCBjb250ZXh0LCBpbmRleCk7XG5cbiAgICBpZiAoZGlzcGxheSkge1xuICAgICAgdmFsdWUgPSBjb250ZXh0LmRhdGFzZXQuZGF0YVtpbmRleF07XG4gICAgICBsYWJlbCA9IHZhbHVlT3JEZWZhdWx0KGNhbGxiYWNrKGNvbmZpZy5mb3JtYXR0ZXIsIFt2YWx1ZSwgY29udGV4dF0pLCB2YWx1ZSk7XG4gICAgICBsaW5lcyA9IGlzTnVsbE9yVW5kZWYobGFiZWwpID8gW10gOiB1dGlscy50b1RleHRMaW5lcyhsYWJlbCk7XG5cbiAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcbiAgICAgICAgbW9kZWwgPSBtZS5fbW9kZWxpemUoZGlzcGxheSwgbGluZXMsIGNvbmZpZywgY29udGV4dCk7XG4gICAgICAgIHJlY3RzID0gYm91bmRpbmdSZWN0cyhtb2RlbCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWUuX21vZGVsID0gbW9kZWw7XG4gICAgbWUuX3JlY3RzID0gcmVjdHM7XG4gIH0sXG5cbiAgZ2VvbWV0cnk6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWN0cyA/IHRoaXMuX3JlY3RzLmZyYW1lIDoge307XG4gIH0sXG5cbiAgcm90YXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tb2RlbCA/IHRoaXMuX21vZGVsLnJvdGF0aW9uIDogMDtcbiAgfSxcblxuICB2aXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbW9kZWwgJiYgdGhpcy5fbW9kZWwub3BhY2l0eTtcbiAgfSxcblxuICBtb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vZGVsO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBjZW50ZXIpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciBjdHggPSBjaGFydC5jdHg7XG4gICAgdmFyIG1vZGVsID0gbWUuX21vZGVsO1xuICAgIHZhciByZWN0cyA9IG1lLl9yZWN0cztcbiAgICB2YXIgYXJlYTtcblxuICAgIGlmICghdGhpcy52aXNpYmxlKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjdHguc2F2ZSgpO1xuXG4gICAgaWYgKG1vZGVsLmNsaXApIHtcbiAgICAgIGFyZWEgPSBtb2RlbC5hcmVhO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnJlY3QoXG4gICAgICAgIGFyZWEubGVmdCxcbiAgICAgICAgYXJlYS50b3AsXG4gICAgICAgIGFyZWEucmlnaHQgLSBhcmVhLmxlZnQsXG4gICAgICAgIGFyZWEuYm90dG9tIC0gYXJlYS50b3ApO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICB9XG5cbiAgICBjdHguZ2xvYmFsQWxwaGEgPSB1dGlscy5ib3VuZCgwLCBtb2RlbC5vcGFjaXR5LCAxKTtcbiAgICBjdHgudHJhbnNsYXRlKHJhc3Rlcml6ZShjZW50ZXIueCksIHJhc3Rlcml6ZShjZW50ZXIueSkpO1xuICAgIGN0eC5yb3RhdGUobW9kZWwucm90YXRpb24pO1xuXG4gICAgZHJhd0ZyYW1lKGN0eCwgcmVjdHMuZnJhbWUsIG1vZGVsKTtcbiAgICBkcmF3VGV4dChjdHgsIG1vZGVsLmxpbmVzLCByZWN0cy50ZXh0LCBtb2RlbCk7XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG59KTtcblxudmFyIE1JTl9JTlRFR0VSID0gTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIgfHwgLTkwMDcxOTkyNTQ3NDA5OTE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXMvbm8tbnVtYmVyLW1pbnNhZmVpbnRlZ2VyXG52YXIgTUFYX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcy9uby1udW1iZXItbWF4c2FmZWludGVnZXJcblxuZnVuY3Rpb24gcm90YXRlZChwb2ludCwgY2VudGVyLCBhbmdsZSkge1xuICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICB2YXIgc2luID0gTWF0aC5zaW4oYW5nbGUpO1xuICB2YXIgY3ggPSBjZW50ZXIueDtcbiAgdmFyIGN5ID0gY2VudGVyLnk7XG5cbiAgcmV0dXJuIHtcbiAgICB4OiBjeCArIGNvcyAqIChwb2ludC54IC0gY3gpIC0gc2luICogKHBvaW50LnkgLSBjeSksXG4gICAgeTogY3kgKyBzaW4gKiAocG9pbnQueCAtIGN4KSArIGNvcyAqIChwb2ludC55IC0gY3kpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHByb2plY3RlZChwb2ludHMsIGF4aXMpIHtcbiAgdmFyIG1pbiA9IE1BWF9JTlRFR0VSO1xuICB2YXIgbWF4ID0gTUlOX0lOVEVHRVI7XG4gIHZhciBvcmlnaW4gPSBheGlzLm9yaWdpbjtcbiAgdmFyIGksIHB0LCB2eCwgdnksIGRwO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBwdCA9IHBvaW50c1tpXTtcbiAgICB2eCA9IHB0LnggLSBvcmlnaW4ueDtcbiAgICB2eSA9IHB0LnkgLSBvcmlnaW4ueTtcbiAgICBkcCA9IGF4aXMudnggKiB2eCArIGF4aXMudnkgKiB2eTtcbiAgICBtaW4gPSBNYXRoLm1pbihtaW4sIGRwKTtcbiAgICBtYXggPSBNYXRoLm1heChtYXgsIGRwKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXhcbiAgfTtcbn1cblxuZnVuY3Rpb24gdG9BeGlzKHAwLCBwMSkge1xuICB2YXIgdnggPSBwMS54IC0gcDAueDtcbiAgdmFyIHZ5ID0gcDEueSAtIHAwLnk7XG4gIHZhciBsbiA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cbiAgcmV0dXJuIHtcbiAgICB2eDogKHAxLnggLSBwMC54KSAvIGxuLFxuICAgIHZ5OiAocDEueSAtIHAwLnkpIC8gbG4sXG4gICAgb3JpZ2luOiBwMCxcbiAgICBsbjogbG5cbiAgfTtcbn1cblxudmFyIEhpdEJveCA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9yb3RhdGlvbiA9IDA7XG4gIHRoaXMuX3JlY3QgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHc6IDAsXG4gICAgaDogMFxuICB9O1xufTtcblxubWVyZ2UoSGl0Qm94LnByb3RvdHlwZSwge1xuICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gdGhpcy5fcmVjdDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogci54ICsgci53IC8gMixcbiAgICAgIHk6IHIueSArIHIuaCAvIDJcbiAgICB9O1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24oY2VudGVyLCByZWN0LCByb3RhdGlvbikge1xuICAgIHRoaXMuX3JvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5fcmVjdCA9IHtcbiAgICAgIHg6IHJlY3QueCArIGNlbnRlci54LFxuICAgICAgeTogcmVjdC55ICsgY2VudGVyLnksXG4gICAgICB3OiByZWN0LncsXG4gICAgICBoOiByZWN0LmhcbiAgICB9O1xuICB9LFxuXG4gIGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuICAgIHZhciBtZSA9IHRoaXM7XG4gICAgdmFyIG1hcmdpbiA9IDE7XG4gICAgdmFyIHJlY3QgPSBtZS5fcmVjdDtcblxuICAgIHBvaW50ID0gcm90YXRlZChwb2ludCwgbWUuY2VudGVyKCksIC1tZS5fcm90YXRpb24pO1xuXG4gICAgcmV0dXJuICEocG9pbnQueCA8IHJlY3QueCAtIG1hcmdpblxuICAgICAgfHwgcG9pbnQueSA8IHJlY3QueSAtIG1hcmdpblxuICAgICAgfHwgcG9pbnQueCA+IHJlY3QueCArIHJlY3QudyArIG1hcmdpbiAqIDJcbiAgICAgIHx8IHBvaW50LnkgPiByZWN0LnkgKyByZWN0LmggKyBtYXJnaW4gKiAyKTtcbiAgfSxcblxuICAvLyBTZXBhcmF0aW5nIEF4aXMgVGhlb3JlbVxuICAvLyBodHRwczovL2dhbWVkZXZlbG9wbWVudC50dXRzcGx1cy5jb20vdHV0b3JpYWxzL2NvbGxpc2lvbi1kZXRlY3Rpb24tdXNpbmctdGhlLXNlcGFyYXRpbmctYXhpcy10aGVvcmVtLS1nYW1lZGV2LTE2OVxuICBpbnRlcnNlY3RzOiBmdW5jdGlvbihvdGhlcikge1xuICAgIHZhciByMCA9IHRoaXMuX3BvaW50cygpO1xuICAgIHZhciByMSA9IG90aGVyLl9wb2ludHMoKTtcbiAgICB2YXIgYXhlcyA9IFtcbiAgICAgIHRvQXhpcyhyMFswXSwgcjBbMV0pLFxuICAgICAgdG9BeGlzKHIwWzBdLCByMFszXSlcbiAgICBdO1xuICAgIHZhciBpLCBwcjAsIHByMTtcblxuICAgIGlmICh0aGlzLl9yb3RhdGlvbiAhPT0gb3RoZXIuX3JvdGF0aW9uKSB7XG4gICAgICAvLyBPbmx5IHNlcGFyYXRlIHdpdGggcjEgYXhpcyBpZiB0aGUgcm90YXRpb24gaXMgZGlmZmVyZW50LFxuICAgICAgLy8gZWxzZSBpdCdzIGVub3VnaCB0byBzZXBhcmF0ZSByMCBhbmQgcjEgd2l0aCByMCBheGlzIG9ubHkhXG4gICAgICBheGVzLnB1c2goXG4gICAgICAgIHRvQXhpcyhyMVswXSwgcjFbMV0pLFxuICAgICAgICB0b0F4aXMocjFbMF0sIHIxWzNdKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgcHIwID0gcHJvamVjdGVkKHIwLCBheGVzW2ldKTtcbiAgICAgIHByMSA9IHByb2plY3RlZChyMSwgYXhlc1tpXSk7XG5cbiAgICAgIGlmIChwcjAubWF4IDwgcHIxLm1pbiB8fCBwcjEubWF4IDwgcHIwLm1pbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcG9pbnRzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbWUgPSB0aGlzO1xuICAgIHZhciByZWN0ID0gbWUuX3JlY3Q7XG4gICAgdmFyIGFuZ2xlID0gbWUuX3JvdGF0aW9uO1xuICAgIHZhciBjZW50ZXIgPSBtZS5jZW50ZXIoKTtcblxuICAgIHJldHVybiBbXG4gICAgICByb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueX0sIGNlbnRlciwgYW5nbGUpLFxuICAgICAgcm90YXRlZCh7eDogcmVjdC54ICsgcmVjdC53LCB5OiByZWN0Lnl9LCBjZW50ZXIsIGFuZ2xlKSxcbiAgICAgIHJvdGF0ZWQoe3g6IHJlY3QueCArIHJlY3QudywgeTogcmVjdC55ICsgcmVjdC5ofSwgY2VudGVyLCBhbmdsZSksXG4gICAgICByb3RhdGVkKHt4OiByZWN0LngsIHk6IHJlY3QueSArIHJlY3QuaH0sIGNlbnRlciwgYW5nbGUpXG4gICAgXTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvb3JkaW5hdGVzKGVsLCBtb2RlbCwgZ2VvbWV0cnkpIHtcbiAgdmFyIHBvaW50ID0gbW9kZWwucG9zaXRpb25lcihlbCwgbW9kZWwpO1xuICB2YXIgdnggPSBwb2ludC52eDtcbiAgdmFyIHZ5ID0gcG9pbnQudnk7XG5cbiAgaWYgKCF2eCAmJiAhdnkpIHtcbiAgICAvLyBpZiBhbGlnbmVkIGNlbnRlciwgd2UgZG9uJ3Qgd2FudCB0byBvZmZzZXQgdGhlIGNlbnRlciBwb2ludFxuICAgIHJldHVybiB7eDogcG9pbnQueCwgeTogcG9pbnQueX07XG4gIH1cblxuICB2YXIgdyA9IGdlb21ldHJ5Lnc7XG4gIHZhciBoID0gZ2VvbWV0cnkuaDtcblxuICAvLyB0YWtlIGluIGFjY291bnQgdGhlIGxhYmVsIHJvdGF0aW9uXG4gIHZhciByb3RhdGlvbiA9IG1vZGVsLnJvdGF0aW9uO1xuICB2YXIgZHggPSBNYXRoLmFicyh3IC8gMiAqIE1hdGguY29zKHJvdGF0aW9uKSkgKyBNYXRoLmFicyhoIC8gMiAqIE1hdGguc2luKHJvdGF0aW9uKSk7XG4gIHZhciBkeSA9IE1hdGguYWJzKHcgLyAyICogTWF0aC5zaW4ocm90YXRpb24pKSArIE1hdGguYWJzKGggLyAyICogTWF0aC5jb3Mocm90YXRpb24pKTtcblxuICAvLyBzY2FsZSB0aGUgdW5pdCB2ZWN0b3IgKHZ4LCB2eSkgdG8gZ2V0IGF0IGxlYXN0IGR4IG9yIGR5IGVxdWFsIHRvXG4gIC8vIHcgb3IgaCByZXNwZWN0aXZlbHkgKGVsc2Ugd2Ugd291bGQgY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSB0byB0aGVcbiAgLy8gZWxsaXBzZSBpbnNjcmliZWQgaW4gdGhlIGJvdW5kaW5nIHJlY3QpXG4gIHZhciB2cyA9IDEgLyBNYXRoLm1heChNYXRoLmFicyh2eCksIE1hdGguYWJzKHZ5KSk7XG4gIGR4ICo9IHZ4ICogdnM7XG4gIGR5ICo9IHZ5ICogdnM7XG5cbiAgLy8gZmluYWxseSwgaW5jbHVkZSB0aGUgZXhwbGljaXQgb2Zmc2V0XG4gIGR4ICs9IG1vZGVsLm9mZnNldCAqIHZ4O1xuICBkeSArPSBtb2RlbC5vZmZzZXQgKiB2eTtcblxuICByZXR1cm4ge1xuICAgIHg6IHBvaW50LnggKyBkeCxcbiAgICB5OiBwb2ludC55ICsgZHlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29sbGlkZShsYWJlbHMsIGNvbGxpZGVyKSB7XG4gIHZhciBpLCBqLCBzMCwgczE7XG5cbiAgLy8gSU1QT1JUQU5UIEl0ZXJhdGUgaW4gdGhlIHJldmVyc2Ugb3JkZXIgc2luY2UgaXRlbXMgYXQgdGhlIGVuZCBvZiB0aGVcbiAgLy8gbGlzdCBoYXZlIGFuIGhpZ2hlciB3ZWlnaHQvcHJpb3JpdHkgYW5kIHRodXMgc2hvdWxkIGJlIGxlc3MgaW1wYWN0ZWRcbiAgLy8gYnkgdGhlIG92ZXJsYXBwaW5nIHN0cmF0ZWd5LlxuXG4gIGZvciAoaSA9IGxhYmVscy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHMwID0gbGFiZWxzW2ldLiRsYXlvdXQ7XG5cbiAgICBmb3IgKGogPSBpIC0gMTsgaiA+PSAwICYmIHMwLl92aXNpYmxlOyAtLWopIHtcbiAgICAgIHMxID0gbGFiZWxzW2pdLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzMS5fdmlzaWJsZSAmJiBzMC5fYm94LmludGVyc2VjdHMoczEuX2JveCkpIHtcbiAgICAgICAgY29sbGlkZXIoczAsIHMxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGFiZWxzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlKGxhYmVscykge1xuICB2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyLCBwcm94eTtcblxuICAvLyBJbml0aWFsaXplIGxhYmVscyBmb3Igb3ZlcmxhcCBkZXRlY3Rpb25cbiAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG5cbiAgICBpZiAoc3RhdGUuX3Zpc2libGUpIHtcbiAgICAgIC8vIENoYXJ0LmpzIDMgcmVtb3ZlZCBlbC5fbW9kZWwgaW4gZmF2b3Igb2YgZ2V0UHJvcHMoKSwgbWFraW5nIGhhcmRlciB0b1xuICAgICAgLy8gYWJzdHJhY3QgcmVhZGluZyB2YWx1ZXMgaW4gcG9zaXRpb25lcnMuIEFsc28sIHVzaW5nIHN0cmluZyBhcnJheXMgdG9cbiAgICAgIC8vIHJlYWQgdmFsdWVzIChpLmUuIHZhciB7YSxiLGN9ID0gZWwuZ2V0UHJvcHMoW1wiYVwiLFwiYlwiLFwiY1wiXSkpIHdvdWxkIG1ha2VcbiAgICAgIC8vIHBvc2l0aW9uZXJzIGluZWZmaWNpZW50IGluIHRoZSBub3JtYWwgY2FzZSAoaS5lLiBub3QgdGhlIGZpbmFsIHZhbHVlcylcbiAgICAgIC8vIGFuZCB0aGUgY29kZSBhIGJpdCB1Z2x5LCBzbyBsZXQncyB1c2UgYSBQcm94eSBpbnN0ZWFkLlxuICAgICAgcHJveHkgPSBuZXcgUHJveHkobGFiZWwuX2VsLCB7Z2V0OiAoZWwsIHApID0+IGVsLmdldFByb3BzKFtwXSwgdHJ1ZSlbcF19KTtcblxuICAgICAgZ2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuICAgICAgY2VudGVyID0gY29vcmRpbmF0ZXMocHJveHksIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcbiAgICAgIHN0YXRlLl9ib3gudXBkYXRlKGNlbnRlciwgZ2VvbWV0cnksIGxhYmVsLnJvdGF0aW9uKCkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEF1dG8gaGlkZSBvdmVybGFwcGluZyBsYWJlbHNcbiAgcmV0dXJuIGNvbGxpZGUobGFiZWxzLCBmdW5jdGlvbihzMCwgczEpIHtcbiAgICB2YXIgaDAgPSBzMC5faGlkYWJsZTtcbiAgICB2YXIgaDEgPSBzMS5faGlkYWJsZTtcblxuICAgIGlmICgoaDAgJiYgaDEpIHx8IGgxKSB7XG4gICAgICBzMS5fdmlzaWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaDApIHtcbiAgICAgIHMwLl92aXNpYmxlID0gZmFsc2U7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIGxheW91dCA9IHtcbiAgcHJlcGFyZTogZnVuY3Rpb24oZGF0YXNldHMpIHtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIGksIGosIGlsZW4sIGpsZW4sIGxhYmVsO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGRhdGFzZXRzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgZm9yIChqID0gMCwgamxlbiA9IGRhdGFzZXRzW2ldLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICBsYWJlbCA9IGRhdGFzZXRzW2ldW2pdO1xuICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIGxhYmVsLiRsYXlvdXQgPSB7XG4gICAgICAgICAgX2JveDogbmV3IEhpdEJveCgpLFxuICAgICAgICAgIF9oaWRhYmxlOiBmYWxzZSxcbiAgICAgICAgICBfdmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICBfc2V0OiBpLFxuICAgICAgICAgIF9pZHg6IGxhYmVsLl9pbmRleFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8gTmV3IGB6YCBvcHRpb246IGxhYmVscyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduXG4gICAgLy8gb2YgdG9wIG9mIHRoZSBvbmVzIHdpdGggYSBsb3dlciBpbmRleC4gTG93ZXN0IHotaW5kZXggbGFiZWxzXG4gICAgLy8gYXJlIGFsc28gZGlzY2FyZGVkIGZpcnN0IHdoZW4gaGlkaW5nIG92ZXJsYXBwaW5nIGxhYmVscy5cbiAgICBsYWJlbHMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICB2YXIgc2EgPSBhLiRsYXlvdXQ7XG4gICAgICB2YXIgc2IgPSBiLiRsYXlvdXQ7XG5cbiAgICAgIHJldHVybiBzYS5faWR4ID09PSBzYi5faWR4XG4gICAgICAgID8gc2IuX3NldCAtIHNhLl9zZXRcbiAgICAgICAgOiBzYi5faWR4IC0gc2EuX2lkeDtcbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlKGxhYmVscyk7XG5cbiAgICByZXR1cm4gbGFiZWxzO1xuICB9LFxuXG4gIHVwZGF0ZTogZnVuY3Rpb24obGFiZWxzKSB7XG4gICAgdmFyIGRpcnR5ID0gZmFsc2U7XG4gICAgdmFyIGksIGlsZW4sIGxhYmVsLCBtb2RlbCwgc3RhdGU7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gbGFiZWxzLmxlbmd0aDsgaSA8IGlsZW47ICsraSkge1xuICAgICAgbGFiZWwgPSBsYWJlbHNbaV07XG4gICAgICBtb2RlbCA9IGxhYmVsLm1vZGVsKCk7XG4gICAgICBzdGF0ZSA9IGxhYmVsLiRsYXlvdXQ7XG4gICAgICBzdGF0ZS5faGlkYWJsZSA9IG1vZGVsICYmIG1vZGVsLmRpc3BsYXkgPT09ICdhdXRvJztcbiAgICAgIHN0YXRlLl92aXNpYmxlID0gbGFiZWwudmlzaWJsZSgpO1xuICAgICAgZGlydHkgfD0gc3RhdGUuX2hpZGFibGU7XG4gICAgfVxuXG4gICAgaWYgKGRpcnR5KSB7XG4gICAgICBjb21wdXRlKGxhYmVscyk7XG4gICAgfVxuICB9LFxuXG4gIGxvb2t1cDogZnVuY3Rpb24obGFiZWxzLCBwb2ludCkge1xuICAgIHZhciBpLCBzdGF0ZTtcblxuICAgIC8vIElNUE9SVEFOVCBJdGVyYXRlIGluIHRoZSByZXZlcnNlIG9yZGVyIHNpbmNlIGl0ZW1zIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgbGlzdCBoYXZlIGFuIGhpZ2hlciB6LWluZGV4LCB0aHVzIHNob3VsZCBiZSBwaWNrZWQgZmlyc3QuXG5cbiAgICBmb3IgKGkgPSBsYWJlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHN0YXRlID0gbGFiZWxzW2ldLiRsYXlvdXQ7XG5cbiAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS5fdmlzaWJsZSAmJiBzdGF0ZS5fYm94LmNvbnRhaW5zKHBvaW50KSkge1xuICAgICAgICByZXR1cm4gbGFiZWxzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKGNoYXJ0LCBsYWJlbHMpIHtcbiAgICB2YXIgaSwgaWxlbiwgbGFiZWwsIHN0YXRlLCBnZW9tZXRyeSwgY2VudGVyO1xuXG4gICAgZm9yIChpID0gMCwgaWxlbiA9IGxhYmVscy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIGxhYmVsID0gbGFiZWxzW2ldO1xuICAgICAgc3RhdGUgPSBsYWJlbC4kbGF5b3V0O1xuXG4gICAgICBpZiAoc3RhdGUuX3Zpc2libGUpIHtcbiAgICAgICAgZ2VvbWV0cnkgPSBsYWJlbC5nZW9tZXRyeSgpO1xuICAgICAgICBjZW50ZXIgPSBjb29yZGluYXRlcyhsYWJlbC5fZWwsIGxhYmVsLm1vZGVsKCksIGdlb21ldHJ5KTtcbiAgICAgICAgc3RhdGUuX2JveC51cGRhdGUoY2VudGVyLCBnZW9tZXRyeSwgbGFiZWwucm90YXRpb24oKSk7XG4gICAgICAgIGxhYmVsLmRyYXcoY2hhcnQsIGNlbnRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZm9ybWF0dGVyID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKGlzTnVsbE9yVW5kZWYodmFsdWUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbGFiZWwgPSB2YWx1ZTtcbiAgdmFyIGtleXMsIGtsZW4sIGs7XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUubGFiZWwpKSB7XG4gICAgICBsYWJlbCA9IHZhbHVlLmxhYmVsO1xuICAgIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWYodmFsdWUucikpIHtcbiAgICAgIGxhYmVsID0gdmFsdWUucjtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWwgPSAnJztcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gICAgICBmb3IgKGsgPSAwLCBrbGVuID0ga2V5cy5sZW5ndGg7IGsgPCBrbGVuOyArK2spIHtcbiAgICAgICAgbGFiZWwgKz0gKGsgIT09IDAgPyAnLCAnIDogJycpICsga2V5c1trXSArICc6ICcgKyB2YWx1ZVtrZXlzW2tdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJycgKyBsYWJlbDtcbn07XG5cbi8qKlxuICogSU1QT1JUQU5UOiBtYWtlIHN1cmUgdG8gYWxzbyB1cGRhdGUgdGVzdHMgYW5kIFR5cGVTY3JpcHQgZGVmaW5pdGlvblxuICogZmlsZXMgKGAvdGVzdC9zcGVjcy9kZWZhdWx0cy5zcGVjLmpzYCBhbmQgYC90eXBlcy9vcHRpb25zLmQudHNgKVxuICovXG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWxpZ246ICdjZW50ZXInLFxuICBhbmNob3I6ICdjZW50ZXInLFxuICBiYWNrZ3JvdW5kQ29sb3I6IG51bGwsXG4gIGJvcmRlckNvbG9yOiBudWxsLFxuICBib3JkZXJSYWRpdXM6IDAsXG4gIGJvcmRlcldpZHRoOiAwLFxuICBjbGFtcDogZmFsc2UsXG4gIGNsaXA6IGZhbHNlLFxuICBjb2xvcjogdW5kZWZpbmVkLFxuICBkaXNwbGF5OiB0cnVlLFxuICBmb250OiB7XG4gICAgZmFtaWx5OiB1bmRlZmluZWQsXG4gICAgbGluZUhlaWdodDogMS4yLFxuICAgIHNpemU6IHVuZGVmaW5lZCxcbiAgICBzdHlsZTogdW5kZWZpbmVkLFxuICAgIHdlaWdodDogbnVsbFxuICB9LFxuICBmb3JtYXR0ZXI6IGZvcm1hdHRlcixcbiAgbGFiZWxzOiB1bmRlZmluZWQsXG4gIGxpc3RlbmVyczoge30sXG4gIG9mZnNldDogNCxcbiAgb3BhY2l0eTogMSxcbiAgcGFkZGluZzoge1xuICAgIHRvcDogNCxcbiAgICByaWdodDogNCxcbiAgICBib3R0b206IDQsXG4gICAgbGVmdDogNFxuICB9LFxuICByb3RhdGlvbjogMCxcbiAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICB0ZXh0U3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuICB0ZXh0U2hhZG93Qmx1cjogMCxcbiAgdGV4dFNoYWRvd0NvbG9yOiB1bmRlZmluZWRcbn07XG5cbi8qKlxuICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9DaGFydC5qcy9pc3N1ZXMvNDE3NlxuICovXG5cbnZhciBFWFBBTkRPX0tFWSA9ICckZGF0YWxhYmVscyc7XG52YXIgREVGQVVMVF9LRVkgPSAnJGRlZmF1bHQnO1xuXG5mdW5jdGlvbiBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucykge1xuICB2YXIgb3ZlcnJpZGUgPSBkYXRhc2V0LmRhdGFsYWJlbHM7XG4gIHZhciBsaXN0ZW5lcnMgPSB7fTtcbiAgdmFyIGNvbmZpZ3MgPSBbXTtcbiAgdmFyIGxhYmVscywga2V5cztcblxuICBpZiAob3ZlcnJpZGUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgb3ZlcnJpZGUgPSB7fTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBtZXJnZSh7fSwgW29wdGlvbnMsIG92ZXJyaWRlXSk7XG4gIGxhYmVscyA9IG9wdGlvbnMubGFiZWxzIHx8IHt9O1xuICBrZXlzID0gT2JqZWN0LmtleXMobGFiZWxzKTtcbiAgZGVsZXRlIG9wdGlvbnMubGFiZWxzO1xuXG4gIGlmIChrZXlzLmxlbmd0aCkge1xuICAgIGtleXMuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgIGlmIChsYWJlbHNba2V5XSkge1xuICAgICAgICBjb25maWdzLnB1c2gobWVyZ2Uoe30sIFtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGxhYmVsc1trZXldLFxuICAgICAgICAgIHtfa2V5OiBrZXl9XG4gICAgICAgIF0pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZWZhdWx0IGxhYmVsIGlmIG5vIFwibmFtZWRcIiBsYWJlbCBkZWZpbmVkLlxuICAgIGNvbmZpZ3MucHVzaChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGxpc3RlbmVyczogezxldmVudC10eXBlPjogezxsYWJlbC1rZXk+OiA8Zm4+fX1cbiAgbGlzdGVuZXJzID0gY29uZmlncy5yZWR1Y2UoZnVuY3Rpb24odGFyZ2V0LCBjb25maWcpIHtcbiAgICBlYWNoKGNvbmZpZy5saXN0ZW5lcnMgfHwge30sIGZ1bmN0aW9uKGZuLCBldmVudCkge1xuICAgICAgdGFyZ2V0W2V2ZW50XSA9IHRhcmdldFtldmVudF0gfHwge307XG4gICAgICB0YXJnZXRbZXZlbnRdW2NvbmZpZy5fa2V5IHx8IERFRkFVTFRfS0VZXSA9IGZuO1xuICAgIH0pO1xuXG4gICAgZGVsZXRlIGNvbmZpZy5saXN0ZW5lcnM7XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSwge30pO1xuXG4gIHJldHVybiB7XG4gICAgbGFiZWxzOiBjb25maWdzLFxuICAgIGxpc3RlbmVyczogbGlzdGVuZXJzXG4gIH07XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycywgbGFiZWwsIGV2ZW50KSB7XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSBsYWJlbC4kY29udGV4dDtcbiAgdmFyIGdyb3VwcyA9IGxhYmVsLiRncm91cHM7XG4gIHZhciBjYWxsYmFjayQxO1xuXG4gIGlmICghbGlzdGVuZXJzW2dyb3Vwcy5fc2V0XSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGNhbGxiYWNrJDEgPSBsaXN0ZW5lcnNbZ3JvdXBzLl9zZXRdW2dyb3Vwcy5fa2V5XTtcbiAgaWYgKCFjYWxsYmFjayQxKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNhbGxiYWNrKGNhbGxiYWNrJDEsIFtjb250ZXh0LCBldmVudF0pID09PSB0cnVlKSB7XG4gICAgLy8gVXNlcnMgYXJlIGFsbG93ZWQgdG8gdHdlYWsgdGhlIGdpdmVuIGNvbnRleHQgYnkgaW5qZWN0aW5nIHZhbHVlcyB0aGF0IGNhbiBiZVxuICAgIC8vIHVzZWQgaW4gc2NyaXB0YWJsZSBvcHRpb25zIHRvIGRpc3BsYXkgbGFiZWxzIGRpZmZlcmVudGx5IGJhc2VkIG9uIHRoZSBjdXJyZW50XG4gICAgLy8gZXZlbnQgKGUuZy4gaGlnaGxpZ2h0IGFuIGhvdmVyZWQgbGFiZWwpLiBUaGF0J3Mgd2h5IHdlIHVwZGF0ZSB0aGUgbGFiZWwgd2l0aFxuICAgIC8vIHRoZSBvdXRwdXQgY29udGV4dCBhbmQgc2NoZWR1bGUgYSBuZXcgY2hhcnQgcmVuZGVyIGJ5IHNldHRpbmcgaXQgZGlydHkuXG4gICAgY2hhcnRbRVhQQU5ET19LRVldLl9kaXJ0eSA9IHRydWU7XG4gICAgbGFiZWwudXBkYXRlKGNvbnRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwsIGV2ZW50KSB7XG4gIHZhciBlbnRlciwgbGVhdmU7XG5cbiAgaWYgKCFwcmV2aW91cyAmJiAhbGFiZWwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXByZXZpb3VzKSB7XG4gICAgZW50ZXIgPSB0cnVlO1xuICB9IGVsc2UgaWYgKCFsYWJlbCkge1xuICAgIGxlYXZlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChwcmV2aW91cyAhPT0gbGFiZWwpIHtcbiAgICBsZWF2ZSA9IGVudGVyID0gdHJ1ZTtcbiAgfVxuXG4gIGlmIChsZWF2ZSkge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGxpc3RlbmVycy5sZWF2ZSwgcHJldmlvdXMsIGV2ZW50KTtcbiAgfVxuICBpZiAoZW50ZXIpIHtcbiAgICBkaXNwYXRjaEV2ZW50KGNoYXJ0LCBsaXN0ZW5lcnMuZW50ZXIsIGxhYmVsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlTW92ZUV2ZW50cyhjaGFydCwgZXZlbnQpIHtcbiAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gIHZhciBsaXN0ZW5lcnMgPSBleHBhbmRvLl9saXN0ZW5lcnM7XG4gIHZhciBwcmV2aW91cywgbGFiZWw7XG5cbiAgaWYgKCFsaXN0ZW5lcnMuZW50ZXIgJiYgIWxpc3RlbmVycy5sZWF2ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChldmVudC50eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIGxhYmVsID0gbGF5b3V0Lmxvb2t1cChleHBhbmRvLl9sYWJlbHMsIGV2ZW50KTtcbiAgfSBlbHNlIGlmIChldmVudC50eXBlICE9PSAnbW91c2VvdXQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcHJldmlvdXMgPSBleHBhbmRvLl9ob3ZlcmVkO1xuICBleHBhbmRvLl9ob3ZlcmVkID0gbGFiZWw7XG4gIGRpc3BhdGNoTW92ZUV2ZW50cyhjaGFydCwgbGlzdGVuZXJzLCBwcmV2aW91cywgbGFiZWwsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlQ2xpY2tFdmVudHMoY2hhcnQsIGV2ZW50KSB7XG4gIHZhciBleHBhbmRvID0gY2hhcnRbRVhQQU5ET19LRVldO1xuICB2YXIgaGFuZGxlcnMgPSBleHBhbmRvLl9saXN0ZW5lcnMuY2xpY2s7XG4gIHZhciBsYWJlbCA9IGhhbmRsZXJzICYmIGxheW91dC5sb29rdXAoZXhwYW5kby5fbGFiZWxzLCBldmVudCk7XG4gIGlmIChsYWJlbCkge1xuICAgIGRpc3BhdGNoRXZlbnQoY2hhcnQsIGhhbmRsZXJzLCBsYWJlbCwgZXZlbnQpO1xuICB9XG59XG5cbnZhciBwbHVnaW4gPSB7XG4gIGlkOiAnZGF0YWxhYmVscycsXG5cbiAgZGVmYXVsdHM6IGRlZmF1bHRzLFxuXG4gIGJlZm9yZUluaXQ6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgY2hhcnRbRVhQQU5ET19LRVldID0ge1xuICAgICAgX2FjdGl2ZXM6IFtdXG4gICAgfTtcbiAgfSxcblxuICBiZWZvcmVVcGRhdGU6IGZ1bmN0aW9uKGNoYXJ0KSB7XG4gICAgdmFyIGV4cGFuZG8gPSBjaGFydFtFWFBBTkRPX0tFWV07XG4gICAgZXhwYW5kby5fbGlzdGVuZWQgPSBmYWxzZTtcbiAgICBleHBhbmRvLl9saXN0ZW5lcnMgPSB7fTsgICAgIC8vIHs8ZXZlbnQtdHlwZT46IHs8ZGF0YXNldC1pbmRleD46IHs8bGFiZWwta2V5PjogPGZuPn19fVxuICAgIGV4cGFuZG8uX2RhdGFzZXRzID0gW107ICAgICAgLy8gcGVyIGRhdGFzZXQgbGFiZWxzOiBbTGFiZWxbXV1cbiAgICBleHBhbmRvLl9sYWJlbHMgPSBbXTsgICAgICAgIC8vIGxheW91dGVkIGxhYmVsczogTGFiZWxbXVxuICB9LFxuXG4gIGFmdGVyRGF0YXNldFVwZGF0ZTogZnVuY3Rpb24oY2hhcnQsIGFyZ3MsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0YXNldEluZGV4ID0gYXJncy5pbmRleDtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICB2YXIgbGFiZWxzID0gZXhwYW5kby5fZGF0YXNldHNbZGF0YXNldEluZGV4XSA9IFtdO1xuICAgIHZhciB2aXNpYmxlID0gY2hhcnQuaXNEYXRhc2V0VmlzaWJsZShkYXRhc2V0SW5kZXgpO1xuICAgIHZhciBkYXRhc2V0ID0gY2hhcnQuZGF0YS5kYXRhc2V0c1tkYXRhc2V0SW5kZXhdO1xuICAgIHZhciBjb25maWcgPSBjb25maWd1cmUoZGF0YXNldCwgb3B0aW9ucyk7XG4gICAgdmFyIGVsZW1lbnRzID0gYXJncy5tZXRhLmRhdGEgfHwgW107XG4gICAgdmFyIGN0eCA9IGNoYXJ0LmN0eDtcbiAgICB2YXIgaSwgaiwgaWxlbiwgamxlbiwgY2ZnLCBrZXksIGVsLCBsYWJlbDtcblxuICAgIGN0eC5zYXZlKCk7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gZWxlbWVudHMubGVuZ3RoOyBpIDwgaWxlbjsgKytpKSB7XG4gICAgICBlbCA9IGVsZW1lbnRzW2ldO1xuICAgICAgZWxbRVhQQU5ET19LRVldID0gW107XG5cbiAgICAgIGlmICh2aXNpYmxlICYmIGVsICYmIGNoYXJ0LmdldERhdGFWaXNpYmlsaXR5KGkpICYmICFlbC5za2lwKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGpsZW4gPSBjb25maWcubGFiZWxzLmxlbmd0aDsgaiA8IGpsZW47ICsraikge1xuICAgICAgICAgIGNmZyA9IGNvbmZpZy5sYWJlbHNbal07XG4gICAgICAgICAga2V5ID0gY2ZnLl9rZXk7XG5cbiAgICAgICAgICBsYWJlbCA9IG5ldyBMYWJlbChjZmcsIGN0eCwgZWwsIGkpO1xuICAgICAgICAgIGxhYmVsLiRncm91cHMgPSB7XG4gICAgICAgICAgICBfc2V0OiBkYXRhc2V0SW5kZXgsXG4gICAgICAgICAgICBfa2V5OiBrZXkgfHwgREVGQVVMVF9LRVlcbiAgICAgICAgICB9O1xuICAgICAgICAgIGxhYmVsLiRjb250ZXh0ID0ge1xuICAgICAgICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgICAgICAgIGNoYXJ0OiBjaGFydCxcbiAgICAgICAgICAgIGRhdGFJbmRleDogaSxcbiAgICAgICAgICAgIGRhdGFzZXQ6IGRhdGFzZXQsXG4gICAgICAgICAgICBkYXRhc2V0SW5kZXg6IGRhdGFzZXRJbmRleFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuICAgICAgICAgIGVsW0VYUEFORE9fS0VZXS5wdXNoKGxhYmVsKTtcbiAgICAgICAgICBsYWJlbHMucHVzaChsYWJlbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgLy8gU3RvcmUgbGlzdGVuZXJzIGF0IHRoZSBjaGFydCBsZXZlbCBhbmQgcGVyIGV2ZW50IHR5cGUgdG8gb3B0aW1pemVcbiAgICAvLyBjYXNlcyB3aGVyZSBubyBsaXN0ZW5lcnMgYXJlIHJlZ2lzdGVyZWQgZm9yIGEgc3BlY2lmaWMgZXZlbnQuXG4gICAgbWVyZ2UoZXhwYW5kby5fbGlzdGVuZXJzLCBjb25maWcubGlzdGVuZXJzLCB7XG4gICAgICBtZXJnZXI6IGZ1bmN0aW9uKGV2ZW50LCB0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbZXZlbnRdID0gdGFyZ2V0W2V2ZW50XSB8fCB7fTtcbiAgICAgICAgdGFyZ2V0W2V2ZW50XVthcmdzLmluZGV4XSA9IHNvdXJjZVtldmVudF07XG4gICAgICAgIGV4cGFuZG8uX2xpc3RlbmVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBjaGFydFtFWFBBTkRPX0tFWV0uX2xhYmVscyA9IGxheW91dC5wcmVwYXJlKGNoYXJ0W0VYUEFORE9fS0VZXS5fZGF0YXNldHMpO1xuICB9LFxuXG4gIC8vIERyYXcgbGFiZWxzIG9uIHRvcCBvZiBhbGwgZGF0YXNldCBlbGVtZW50c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8yOVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hhcnRqcy9jaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzL2lzc3Vlcy8zMlxuICBhZnRlckRhdGFzZXRzRHJhdzogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICBsYXlvdXQuZHJhdyhjaGFydCwgY2hhcnRbRVhQQU5ET19LRVldLl9sYWJlbHMpO1xuICB9LFxuXG4gIGJlZm9yZUV2ZW50OiBmdW5jdGlvbihjaGFydCwgYXJncykge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGxpc3RlbmVyIHJlZ2lzdGVyZWQgZm9yIHRoaXMgY2hhcnQsIGBsaXN0ZW5lZGAgd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBtZWFuaW5nIHdlIGNhbiBpbW1lZGlhdGVseSBpZ25vcmUgdGhlIGluY29taW5nIGV2ZW50IGFuZCBhdm9pZCB1c2VsZXNzIGV4dHJhXG4gICAgLy8gY29tcHV0YXRpb24gZm9yIHVzZXJzIHdobyBkb24ndCBpbXBsZW1lbnQgbGFiZWwgaW50ZXJhY3Rpb25zLlxuICAgIGlmIChjaGFydFtFWFBBTkRPX0tFWV0uX2xpc3RlbmVkKSB7XG4gICAgICB2YXIgZXZlbnQgPSBhcmdzLmV2ZW50O1xuICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICBjYXNlICdtb3VzZW1vdmUnOlxuICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICBoYW5kbGVNb3ZlRXZlbnRzKGNoYXJ0LCBldmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnY2xpY2snOlxuICAgICAgICBoYW5kbGVDbGlja0V2ZW50cyhjaGFydCwgZXZlbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgYWZ0ZXJFdmVudDogZnVuY3Rpb24oY2hhcnQpIHtcbiAgICB2YXIgZXhwYW5kbyA9IGNoYXJ0W0VYUEFORE9fS0VZXTtcbiAgICB2YXIgcHJldmlvdXMgPSBleHBhbmRvLl9hY3RpdmVzO1xuICAgIHZhciBhY3RpdmVzID0gZXhwYW5kby5fYWN0aXZlcyA9IGNoYXJ0LmdldEFjdGl2ZUVsZW1lbnRzKCk7XG4gICAgdmFyIHVwZGF0ZXMgPSB1dGlscy5hcnJheURpZmYocHJldmlvdXMsIGFjdGl2ZXMpO1xuICAgIHZhciBpLCBpbGVuLCBqLCBqbGVuLCB1cGRhdGUsIGxhYmVsLCBsYWJlbHM7XG5cbiAgICBmb3IgKGkgPSAwLCBpbGVuID0gdXBkYXRlcy5sZW5ndGg7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZXNbaV07XG4gICAgICBpZiAodXBkYXRlWzFdKSB7XG4gICAgICAgIGxhYmVscyA9IHVwZGF0ZVswXS5lbGVtZW50W0VYUEFORE9fS0VZXSB8fCBbXTtcbiAgICAgICAgZm9yIChqID0gMCwgamxlbiA9IGxhYmVscy5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICBsYWJlbCA9IGxhYmVsc1tqXTtcbiAgICAgICAgICBsYWJlbC4kY29udGV4dC5hY3RpdmUgPSAodXBkYXRlWzFdID09PSAxKTtcbiAgICAgICAgICBsYWJlbC51cGRhdGUobGFiZWwuJGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4cGFuZG8uX2RpcnR5IHx8IHVwZGF0ZXMubGVuZ3RoKSB7XG4gICAgICBsYXlvdXQudXBkYXRlKGV4cGFuZG8uX2xhYmVscyk7XG4gICAgICBjaGFydC5yZW5kZXIoKTtcbiAgICB9XG5cbiAgICBkZWxldGUgZXhwYW5kby5fZGlydHk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IHBsdWdpbiBhcyBkZWZhdWx0IH07XG4iLCIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL3NvdXJjZU1hcHMuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBgI2J1ZGdldC10YWJsZSB7XG4gIGJvcmRlci1yYWRpdXM6IDVweDtcbn1cblxuI2J1ZGdldC10YWJsZSxcbnRoLFxudGQge1xuICBib3JkZXI6IDFweCBzb2xpZDtcbiAgYm9yZGVyLWNvbGxhcHNlOiBjb2xsYXBzZTtcbn1cbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL2J1ZGdldC10YWJsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxrQkFBa0I7QUFDcEI7O0FBRUE7OztFQUdFLGlCQUFpQjtFQUNqQix5QkFBeUI7QUFDM0JcIixcInNvdXJjZXNDb250ZW50XCI6W1wiI2J1ZGdldC10YWJsZSB7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxufVxcblxcbiNidWRnZXQtdGFibGUsXFxudGgsXFxudGQge1xcbiAgYm9yZGVyOiAxcHggc29saWQ7XFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1xcbn1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgYC8qIGZvcm0gY3NzIHN0YXJ0ICovXHJcbmJvZHkge1xyXG4gIGZvbnQtZmFtaWx5OiBBcmlhbCwgc2Fucy1zZXJpZjtcclxufVxyXG4vKiBoZWFkZXIgKi9cclxuLmhlYWRlci1zZWMge1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgcGFkZGluZzogMjBweCAwcHg7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcclxufVxyXG4uYnRucyB7XHJcbiAgYmFja2dyb3VuZC1jb2xvcjogI2QwYjg3MDtcclxuICBjb2xvcjogd2hpdGU7XHJcbiAgYm9yZGVyOiBub25lO1xyXG4gIGZvbnQtc2l6ZTogMTZweDtcclxuICBmb250LXdlaWdodDogYm9sZDtcclxuICBib3JkZXItcmFkaXVzOiA1MHB4O1xyXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4zcyBlYXNlLWluLW91dDtcclxuICB3aWR0aDogNDVweDtcclxuICBoZWlnaHQ6IDQ1cHg7XHJcbiAgei1pbmRleDogNDtcclxufVxyXG4uZG93bmxvYWQgaSB7XHJcbiAgZm9udC1zaXplOiAxOHB4O1xyXG59XHJcbi50YWJsZS1kZXNpZ24gaDUge1xyXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XHJcbiAgY29sb3I6ICNkMGI4NzA7XHJcbn1cclxuI3llYXJseVRhYmxlcyB0aCxcclxudGQge1xyXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcclxuICBwYWRkaW5nOiAxOHB4IDEwcHggIWltcG9ydGFudDtcclxufVxyXG4jeWVhcmx5VGFibGVzIHRhYmxlIHtcclxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbn1cclxuLnRhYmxlIHtcclxuICAtLWJzLXRhYmxlLWJnOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xyXG59XHJcbiN5ZWFybHlUYWJsZXMgdGgge1xyXG4gIGZvbnQtc2l6ZTogMTlweDtcclxuICBmb250LXdlaWdodDogNzAwO1xyXG4gIGNvbG9yOiAjZDBiODcwO1xyXG59XHJcbmNhbnZhcyB7XHJcbiAgd2lkdGg6IDEwMCUgIWltcG9ydGFudDtcclxuICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcclxuICBwYWRkaW5nOiAyMHB4O1xyXG4gIG9iamVjdC1maXQ6IGNvbnRhaW47XHJcbn1cclxuXHJcbi5sb2dvIGltZyB7XHJcbiAgd2lkdGg6IDE1MHB4O1xyXG59XHJcblxyXG4uaWNvbmJhciB1bCB7XHJcbiAgbGlzdC1zdHlsZTogbm9uZTtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGdhcDogMTVweDtcclxufVxyXG5cclxuLmljb24taXRlbSB7XHJcbiAgd2lkdGg6IDM2cHg7XHJcbiAgaGVpZ2h0OiAzNnB4O1xyXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcclxuICBiYWNrZ3JvdW5kOiAjZDBiODcwO1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICB0cmFuc2l0aW9uOiAwLjNzO1xyXG59XHJcbi5pY29uLWl0ZW0gYSB7XHJcbiAgZGlzcGxheTogZmxleDtcclxuICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xyXG4gIHdpZHRoOiAxMDAlO1xyXG4gIGhlaWdodDogMTAwJTtcclxufVxyXG5cclxuLmljb24taXRlbSBzdmcge1xyXG4gIGZpbGw6IHdoaXRlO1xyXG4gIHdpZHRoOiAyMHB4O1xyXG4gIGhlaWdodDogMjBweDtcclxufVxyXG4udWstbmF2YmFyLXRvZ2dsZSB7XHJcbiAgcGFkZGluZzogMCAwO1xyXG4gIGNvbG9yOiAjMmYyZjJmO1xyXG4gIGZvbnQtd2VpZ2h0OiAzMDA7XHJcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XHJcbn1cclxuXHJcbi8qIGNzcyBzdGFydCAqL1xyXG4ubmF2LXBpbGxzIC5uYXYtbGluay5hY3RpdmUge1xyXG4gIGJhY2tncm91bmQtY29sb3I6ICMwMDAwMDBhMztcclxuICBjb2xvcjogd2hpdGU7XHJcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xyXG4gIHBhZGRpbmc6IDE0cHggMzBweDtcclxuICBmb250LXdlaWdodDogNjAwO1xyXG59XHJcbi5uYXYtcGlsbHMgLm5hdi1saW5rIHtcclxuICBjb2xvcjogYmxhY2s7XHJcbn1cclxuLmNhcmQge1xyXG4gIGJvcmRlci1yYWRpdXM6IDEycHg7XHJcbiAgYm94LXNoYWRvdzogMHB4IDBweCAxNnB4IDBweCAjMDAwMDAwNDA7XHJcbn1cclxuLmlucHV0LWdyb3VwLXRleHQge1xyXG4gIGJhY2tncm91bmQtY29sb3I6ICMyMDZiYTQ7XHJcbiAgY29sb3I6IHdoaXRlO1xyXG4gIGJvcmRlcjogbm9uZTtcclxuICBiYWNrZ3JvdW5kOiBibGFjaztcclxufVxyXG4uY2FyZCBidXR0b24ge1xyXG4gIGJhY2tncm91bmQtY29sb3I6IGJsYWNrO1xyXG4gIHBhZGRpbmc6IDE0cHggMjBweDtcclxuICBmb250LXNpemU6IDE2cHg7XHJcbn1cclxuLmNhcmQgYnV0dG9uOmhvdmVyIHtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcclxufVxyXG4uY2FyZC0xIHtcclxuICBiYWNrZ3JvdW5kOiAjMjA2YmE0O1xyXG4gIG1hcmdpbi1ibG9jazogNDBweCAhaW1wb3J0YW50O1xyXG59XHJcbi5mb3JtLWNvbnRyb2wge1xyXG4gIHBhZGRpbmc6IDIwcHggMC43NXJlbTtcclxufVxyXG4uY2FyZC0yIHtcclxuICBwYWRkaW5nOiAyMHB4O1xyXG59XHJcbi5jYXJkLTItaW5uZXIgaDQge1xyXG4gIGZvbnQtc2l6ZTogMjZweDtcclxuICBmb250LXdlaWdodDogNzAwO1xyXG4gIGNvbG9yOiAjZDBiODcwO1xyXG59XHJcblxyXG4uY2FyZC1zZXJ2aWNlIHtcclxuICBnYXA6IDIwcHg7XHJcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XHJcbn1cclxuLnRhYi1jb250ZW50IGgxIHtcclxuICBmb250LXNpemU6IDQwcHg7XHJcbiAgY29sb3I6ICNkMGI4NzA7XHJcbiAgZm9udC13ZWlnaHQ6IDcwMDtcclxuICB0ZXh0LXRyYW5zZm9ybTogY2FwaXRhbGl6ZTtcclxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcclxuICBwb3NpdGlvbjogcmVsYXRpdmU7XHJcbn1cclxuLnJlc3VsdCB7XHJcbiAgZm9udC1zaXplOiAyNHB4O1xyXG4gIGZvbnQtd2VpZ2h0OiA1MDA7XHJcbn1cclxuLmNhcmQtMi1pbm5lciB7XHJcbiAgcGFkZGluZy1ibG9jazogNDBweCAhaW1wb3J0YW50O1xyXG4gIGhlaWdodDogMTAwJTtcclxuICBib3gtc2hhZG93OiByZ2JhKDAsIDAsIDAsIDAuMDIpIDBweCAxcHggM3B4IDBweCxcclxuICAgIHJnYmEoMjcsIDMxLCAzNSwgMC4xNSkgMHB4IDBweCAwcHggMXB4O1xyXG59XHJcblxyXG4uY2FyZC0yLWlubmVyIGg1IHtcclxuICBmb250LXNpemU6IDIycHg7XHJcbiAgZm9udC13ZWlnaHQ6IDcwMDtcclxuICBwYWRkaW5nLWJvdHRvbTogMjBweDtcclxufVxyXG4uY2FyZC0yLWlubmVyIHAge1xyXG4gIGZvbnQtc2l6ZTogMjJweDtcclxuICBmb250LXdlaWdodDogNzAwO1xyXG59XHJcbi5pbnB1dC1jaXJjbGUgc3BhbiB7XHJcbiAgcGFkZGluZzogMnB4IDEycHg7XHJcbiAgcG9zaXRpb246IGFic29sdXRlO1xyXG4gIHRvcDogMTJweDtcclxuICByaWdodDogMTVweDtcclxuICBjb2xvcjogd2hpdGU7XHJcbiAgYm9yZGVyLXJhZGl1czogMzRweDtcclxuICBiYWNrZ3JvdW5kOiBsaWdodGdyYXk7XHJcbiAgY3Vyc29yOiBwb2ludGVyICFpbXBvcnRhbnQ7XHJcbn1cclxuLmZvcm0tZmxvYXRpbmcge1xyXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcclxuICB3aWR0aDogMTAwJTtcclxufVxyXG5pbnB1dDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcclxuaW5wdXQ6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xyXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcclxuICBtYXJnaW46IDA7XHJcbn1cclxuLmVycm9yIHtcclxuICB0ZXh0LWFsaWduOiBzdGFydCAhaW1wb3J0YW50O1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAgcGFkZGluZzogMTBweDtcclxuICBjb2xvcjogIzg1MjgyODtcclxuICBmb250LXNpemU6IDE2cHg7XHJcbiAgZm9udC13ZWlnaHQ6IDYwMDtcclxufVxyXG4vKiBGaXJlZm94ICovXHJcbmlucHV0W3R5cGU9J251bWJlciddIHtcclxuICAtbW96LWFwcGVhcmFuY2U6IHRleHRmaWVsZDtcclxufVxyXG4uZm9ybS1jb250cm9sIHtcclxuICBwYWRkaW5nOiA4cHggMC43NXJlbTtcclxufVxyXG4uYWNjb3JkaW9uLWJvZHkge1xyXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xyXG59XHJcbi5hY2NvcmRpb24tYnV0dG9uOm5vdCguY29sbGFwc2VkKSB7XHJcbiAgY29sb3I6IHdoaXRlO1xyXG4gIGJhY2tncm91bmQtY29sb3I6ICNkMGI4NzAgIWltcG9ydGFudDtcclxuICBib3gtc2hhZG93OiBpbnNldCAwIGNhbGMoLTEgKiB2YXIoLS1icy1hY2NvcmRpb24tYm9yZGVyLXdpZHRoKSkgMFxyXG4gICAgdmFyKC0tYnMtYWNjb3JkaW9uLWJvcmRlci1jb2xvcik7XHJcbiAgZm9udC13ZWlnaHQ6IDYwMDtcclxufVxyXG4uYWNjb3JkaW9uLWJ1dHRvbjpub3QoLmNvbGxhcHNlZCk6OmFmdGVyIHtcclxuICBmaWx0ZXI6IGJyaWdodG5lc3MoMCkgaW52ZXJ0KDEpO1xyXG59XHJcbi50YWItY29udGVudCBoMTo6YWZ0ZXIge1xyXG4gIGNvbnRlbnQ6ICcnO1xyXG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjMDAwO1xyXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcclxuICB3aWR0aDogNDAlO1xyXG4gIGxlZnQ6IDA7XHJcbiAgYm90dG9tOiAxcHg7XHJcbiAgbGVmdDogNTAlO1xyXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDApO1xyXG59XHJcbi5zcGFjZSB7XHJcbiAgd2lkdGg6IDc3JTtcclxuICBtYXJnaW46IDIwcHggYXV0bztcclxufVxyXG5cclxuLyogZm9vdGVyICovXHJcbmZvb3RlciB7XHJcbiAgYmFja2dyb3VuZDogIzJmMmYyZjtcclxuICBjb2xvcjogI2ZmZjtcclxuICBwYWRkaW5nOiAxMHB4O1xyXG4gIG1hcmdpbi10b3A6IDRyZW07XHJcbn1cclxuLmZvb3Rlci1zZWMge1xyXG4gIGRpc3BsYXk6IGZsZXg7XHJcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xyXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XHJcbiAgZmxleC13cmFwOiB3cmFwO1xyXG59XHJcbi5jb3B5cmlnaHQgcCB7XHJcbiAgZm9udC1zaXplOiAxN3B4O1xyXG4gIGxpbmUtaGVpZ2h0OiAxLjI7XHJcbiAgY29sb3I6ICNiMGE0YWM7XHJcbiAgZm9udC13ZWlnaHQ6IDMwMDtcclxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XHJcbn1cclxuLndlYnNpdGUgcCB7XHJcbiAgZm9udC1zaXplOiAxNXB4O1xyXG4gIGNvbG9yOiAjZDBiODcwO1xyXG59XHJcbi53ZWJzaXRlIGEge1xyXG4gIGZvbnQtc2l6ZTogMTVweDtcclxuICBjb2xvcjogI2IwYTRhYyAhaW1wb3J0YW50O1xyXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcclxufVxyXG4uZm9vdGVyLWl0ZW0ge1xyXG4gIG1hcmdpbjogNXB4IDA7XHJcbn1cclxuLyogcHJvamVjdGlvbiBjc3Mgc3RhcnQgKi9cclxuZGl2I3Byb2plY3Rpb25zIGgzIHtcclxuICBwYWRkaW5nLWJsb2NrOiAyM3B4O1xyXG4gIGZvbnQtc2l6ZTogMjZweDtcclxuICBmb250LXdlaWdodDogNzAwO1xyXG59XHJcbmRpdiNwcm9qZWN0aW9ucyB1bCBsaSB7XHJcbiAgbGlzdC1zdHlsZTogbm9uZTtcclxuICBmb250LXNpemU6IDIwcHg7XHJcbn1cclxucC5keW5hbWljUGFyYSB7XHJcbiAgZm9udC1zaXplOiAyNHB4ICFpbXBvcnRhbnQ7XHJcbiAgY29sb3I6ICNkMGI4NzA7XHJcbn1cclxuLyogZHJvcGRvd24gY3NzICovXHJcbnNlbGVjdCN0aW1lRHVyYXRpb24ge1xyXG4gIHdpZHRoOiAxNSU7XHJcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XHJcbiAgZm9udC13ZWlnaHQ6IDcwMDtcclxuICBjb2xvcjogI2QwYjg3MDtcclxuICBwYWRkaW5nOiAxOHB4O1xyXG4gIGJvcmRlcjogMnB4IHNvbGlkO1xyXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC44KTtcclxufVxyXG4vKi0tIHJlc3BvbmlzdmUgLS0qL1xyXG5AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA5OTFweCkge1xyXG4gIHNlbGVjdCN0aW1lRHVyYXRpb24ge1xyXG4gICAgd2lkdGg6IDQ1JTtcclxuICAgIG1hcmdpbi10b3A6IDQwcHg7XHJcbiAgfVxyXG4gIC5yb3cubW9iLWJsb2NrID4gZGl2IHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gIH1cclxuICAucm93Lm1vYi1ibG9jayB7XHJcbiAgICBkaXNwbGF5OiBibG9jaztcclxuICB9XHJcbiAgLnNwYWNlIHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gIH1cclxufVxyXG5AbWVkaWEgKG1heC13aWR0aDogNzYwcHgpIHtcclxuICAuZm9vdGVyLXNlYyB7XHJcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlciAhaW1wb3J0YW50O1xyXG4gIH1cclxufVxyXG5AbWVkaWEgKG1heC13aWR0aDogNTAwcHgpIHtcclxuICBzZWxlY3QjdGltZUR1cmF0aW9uIHtcclxuICAgIHdpZHRoOiAxMDAlO1xyXG4gICAgbWFyZ2luLXRvcDogNDBweDtcclxuICB9XHJcbiAgLmljb25iYXIge1xyXG4gICAgZGlzcGxheTogbm9uZTtcclxuICB9XHJcbiAgLmhlYWRlci1zZWMge1xyXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgfVxyXG59XHJcbi5kcm9wcyB7XHJcbiAgd2lkdGg6IDE1JTtcclxuICBtYXJnaW4tbGVmdDogYXV0bztcclxuICBmb250LXdlaWdodDogNzAwO1xyXG4gIGNvbG9yOiAjZDBiODcwO1xyXG4gIHBhZGRpbmc6IDE4cHggIWltcG9ydGFudDtcclxuICBib3JkZXI6IDJweCBzb2xpZDtcclxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOCk7XHJcbn1cclxuLyogXHJcbi5wcmludC1idXR0b24ge1xyXG4gIHBhZGRpbmc6IDEwcHggMjBweDtcclxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDBiODcwO1xyXG4gIGNvbG9yOiB3aGl0ZTtcclxuICBib3JkZXI6IG5vbmU7XHJcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xyXG4gIGN1cnNvcjogcG9pbnRlcjtcclxuICBtYXJnaW4tdG9wOiAyMHB4O1xyXG59ICovXHJcblxyXG4vKiBQcmludCBTdHlsZXMgKi9cclxuQG1lZGlhIHByaW50IHtcclxuICAucHJpbnQtYnV0dG9uLFxyXG4gIC5uYXZpZ2F0aW9uLWJhcixcclxuICAuc2lkZWJhcixcclxuICAuZm9vdGVyIHtcclxuICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDsgLyogaGlkZSBuYXZiYXJzLCBmb290ZXJzLCBidXR0b25zLCBldGMuICovXHJcbiAgfVxyXG5cclxuICBib2R5IHtcclxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xyXG4gICAgY29sb3I6IGJsYWNrO1xyXG4gIH1cclxuXHJcbiAgLyogT3B0aW9uYWw6IGFkanVzdCBsYXlvdXQgZm9yIHByaW50aW5nICovXHJcbiAgLm1haW4tY29udGVudCB7XHJcbiAgICB3aWR0aDogMTAwJTtcclxuICAgIHBhZGRpbmc6IDA7XHJcbiAgICBtYXJnaW46IDA7XHJcbiAgfVxyXG5cclxuICBodG1sLFxyXG4gIGJvZHkge1xyXG4gICAgaGVpZ2h0OiBhdXRvO1xyXG4gIH1cclxufVxyXG4vKiBAbWVkaWEgKG1heC13aWR0aDogOTkxcHgpIHtcclxuICAucHJpbnQtYnV0dG9uIHtcclxuICAgIHRvcDogLTIycHg7XHJcbiAgICB3aWR0aDogNTBweDtcclxuICB9XHJcbn0gKi9cclxuLmJ0bi1mbGV4IHtcclxuICBkaXNwbGF5OiBmbGV4O1xyXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XHJcbiAgZ2FwOiAyMHB4O1xyXG4gIGFsaWduLWl0ZW1zOiBlbmQ7XHJcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcclxuICBwb3NpdGlvbjogYWJzb2x1dGU7XHJcbiAgdG9wOiAtMjVweDtcclxuICByaWdodDogMDtcclxufVxyXG5cclxuaHRtbCB7XHJcbiAgdmlzaWJpbGl0eTogdmlzaWJsZTtcclxuICBvcGFjaXR5OiAxO1xyXG59XHJcbmAsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vc3JjL3N0eWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSxtQkFBbUI7QUFDbkI7RUFDRSw4QkFBOEI7QUFDaEM7QUFDQSxXQUFXO0FBQ1g7RUFDRSxhQUFhO0VBQ2IsOEJBQThCO0VBQzlCLG1CQUFtQjtFQUNuQixpQkFBaUI7RUFDakIsc0JBQXNCO0FBQ3hCO0FBQ0E7RUFDRSx5QkFBeUI7RUFDekIsWUFBWTtFQUNaLFlBQVk7RUFDWixlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLG1CQUFtQjtFQUNuQix1Q0FBdUM7RUFDdkMsV0FBVztFQUNYLFlBQVk7RUFDWixVQUFVO0FBQ1o7QUFDQTtFQUNFLGVBQWU7QUFDakI7QUFDQTtFQUNFLGdCQUFnQjtFQUNoQixjQUFjO0FBQ2hCO0FBQ0E7O0VBRUUsa0JBQWtC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Q1gsVUFBVTtJQUNWLFNBQVM7RUFDWDs7RUFFQTs7SUFFRSxZQUFZO0VBQ2Q7QUFDRjtBQUNBOzs7OztHQUtHO0FBQ0g7RUFDRSxhQUFhO0VBQ2IseUJBQXlCO0VBQ3pCLFNBQVM7RUFDVCxnQkFBZ0I7RUFDaEIsc0JBQXNCO0VBQ3RCLGtCQUFrQjtFQUNsQixVQUFVO0VBQ1YsUUFBUTtBQUNWOztBQUVBO0VBQ0UsbUJBQW1CO0VBQ25CLFVBQVU7QUFDWlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBmb3JtIGNzcyBzdGFydCAqL1xcclxcbmJvZHkge1xcclxcbiAgZm9udC1mYW1pbHk6IEFyaWFsLCBzYW5zLXNlcmlmO1xcclxcbn1cXHJcXG4vKiBoZWFkZXIgKi9cXHJcXG4uaGVhZGVyLXNlYyB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xcclxcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXHJcXG4gIHBhZGRpbmc6IDIwcHggMHB4O1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2ZmZjtcXHJcXG59XFxyXFxuLmJ0bnMge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogI2QwYjg3MDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIGZvbnQtc2l6ZTogMTZweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNTBweDtcXHJcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMC4zcyBlYXNlLWluLW91dDtcXHJcXG4gIHdpZHRoOiA0NXB4O1xcclxcbiAgaGVpZ2h0OiA0NXB4O1xcclxcbiAgei1pbmRleDogNDtcXHJcXG59XFxyXFxuLmRvd25sb2FkIGkge1xcclxcbiAgZm9udC1zaXplOiAxOHB4O1xcclxcbn1cXHJcXG4udGFibGUtZGVzaWduIGg1IHtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxuICBjb2xvcjogI2QwYjg3MDtcXHJcXG59XFxyXFxuI3llYXJseVRhYmxlcyB0aCxcXHJcXG50ZCB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICBwYWRkaW5nOiAxOHB4IDEwcHggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuI3llYXJseVRhYmxlcyB0YWJsZSB7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxufVxcclxcbi50YWJsZSB7XFxyXFxuICAtLWJzLXRhYmxlLWJnOiB0cmFuc3BhcmVudCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG4jeWVhcmx5VGFibGVzIHRoIHtcXHJcXG4gIGZvbnQtc2l6ZTogMTlweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxyXFxuICBjb2xvcjogI2QwYjg3MDtcXHJcXG59XFxyXFxuY2FudmFzIHtcXHJcXG4gIHdpZHRoOiAxMDAlICFpbXBvcnRhbnQ7XFxyXFxuICBoZWlnaHQ6IDEwMCUgIWltcG9ydGFudDtcXHJcXG4gIHBhZGRpbmc6IDIwcHg7XFxyXFxuICBvYmplY3QtZml0OiBjb250YWluO1xcclxcbn1cXHJcXG5cXHJcXG4ubG9nbyBpbWcge1xcclxcbiAgd2lkdGg6IDE1MHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uaWNvbmJhciB1bCB7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGdhcDogMTVweDtcXHJcXG59XFxyXFxuXFxyXFxuLmljb24taXRlbSB7XFxyXFxuICB3aWR0aDogMzZweDtcXHJcXG4gIGhlaWdodDogMzZweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXHJcXG4gIGJhY2tncm91bmQ6ICNkMGI4NzA7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgdHJhbnNpdGlvbjogMC4zcztcXHJcXG59XFxyXFxuLmljb24taXRlbSBhIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICB3aWR0aDogMTAwJTtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuLmljb24taXRlbSBzdmcge1xcclxcbiAgZmlsbDogd2hpdGU7XFxyXFxuICB3aWR0aDogMjBweDtcXHJcXG4gIGhlaWdodDogMjBweDtcXHJcXG59XFxyXFxuLnVrLW5hdmJhci10b2dnbGUge1xcclxcbiAgcGFkZGluZzogMCAwO1xcclxcbiAgY29sb3I6ICMyZjJmMmY7XFxyXFxuICBmb250LXdlaWdodDogMzAwO1xcclxcbiAgdGV4dC10cmFuc2Zvcm06IG5vbmU7XFxyXFxufVxcclxcblxcclxcbi8qIGNzcyBzdGFydCAqL1xcclxcbi5uYXYtcGlsbHMgLm5hdi1saW5rLmFjdGl2ZSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwMDAwYTM7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxyXFxuICBwYWRkaW5nOiAxNHB4IDMwcHg7XFxyXFxuICBmb250LXdlaWdodDogNjAwO1xcclxcbn1cXHJcXG4ubmF2LXBpbGxzIC5uYXYtbGluayB7XFxyXFxuICBjb2xvcjogYmxhY2s7XFxyXFxufVxcclxcbi5jYXJkIHtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDEycHg7XFxyXFxuICBib3gtc2hhZG93OiAwcHggMHB4IDE2cHggMHB4ICMwMDAwMDA0MDtcXHJcXG59XFxyXFxuLmlucHV0LWdyb3VwLXRleHQge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogIzIwNmJhNDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIGJhY2tncm91bmQ6IGJsYWNrO1xcclxcbn1cXHJcXG4uY2FyZCBidXR0b24ge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogYmxhY2s7XFxyXFxuICBwYWRkaW5nOiAxNHB4IDIwcHg7XFxyXFxuICBmb250LXNpemU6IDE2cHg7XFxyXFxufVxcclxcbi5jYXJkIGJ1dHRvbjpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBibGFjaztcXHJcXG59XFxyXFxuLmNhcmQtMSB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMjA2YmE0O1xcclxcbiAgbWFyZ2luLWJsb2NrOiA0MHB4ICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcbi5mb3JtLWNvbnRyb2wge1xcclxcbiAgcGFkZGluZzogMjBweCAwLjc1cmVtO1xcclxcbn1cXHJcXG4uY2FyZC0yIHtcXHJcXG4gIHBhZGRpbmc6IDIwcHg7XFxyXFxufVxcclxcbi5jYXJkLTItaW5uZXIgaDQge1xcclxcbiAgZm9udC1zaXplOiAyNnB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGNvbG9yOiAjZDBiODcwO1xcclxcbn1cXHJcXG5cXHJcXG4uY2FyZC1zZXJ2aWNlIHtcXHJcXG4gIGdhcDogMjBweDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xcclxcbn1cXHJcXG4udGFiLWNvbnRlbnQgaDEge1xcclxcbiAgZm9udC1zaXplOiA0MHB4O1xcclxcbiAgY29sb3I6ICNkMGI4NzA7XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgdGV4dC10cmFuc2Zvcm06IGNhcGl0YWxpemU7XFxyXFxuICBwYWRkaW5nLWJvdHRvbTogMTBweDtcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG59XFxyXFxuLnJlc3VsdCB7XFxyXFxuICBmb250LXNpemU6IDI0cHg7XFxyXFxuICBmb250LXdlaWdodDogNTAwO1xcclxcbn1cXHJcXG4uY2FyZC0yLWlubmVyIHtcXHJcXG4gIHBhZGRpbmctYmxvY2s6IDQwcHggIWltcG9ydGFudDtcXHJcXG4gIGhlaWdodDogMTAwJTtcXHJcXG4gIGJveC1zaGFkb3c6IHJnYmEoMCwgMCwgMCwgMC4wMikgMHB4IDFweCAzcHggMHB4LFxcclxcbiAgICByZ2JhKDI3LCAzMSwgMzUsIDAuMTUpIDBweCAwcHggMHB4IDFweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNhcmQtMi1pbm5lciBoNSB7XFxyXFxuICBmb250LXNpemU6IDIycHg7XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgcGFkZGluZy1ib3R0b206IDIwcHg7XFxyXFxufVxcclxcbi5jYXJkLTItaW5uZXIgcCB7XFxyXFxuICBmb250LXNpemU6IDIycHg7XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbn1cXHJcXG4uaW5wdXQtY2lyY2xlIHNwYW4ge1xcclxcbiAgcGFkZGluZzogMnB4IDEycHg7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICB0b3A6IDEycHg7XFxyXFxuICByaWdodDogMTVweDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDM0cHg7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaWdodGdyYXk7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXIgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuLmZvcm0tZmxvYXRpbmcge1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxufVxcclxcbmlucHV0Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxcclxcbmlucHV0Ojotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG59XFxyXFxuLmVycm9yIHtcXHJcXG4gIHRleHQtYWxpZ246IHN0YXJ0ICFpbXBvcnRhbnQ7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIGNvbG9yOiAjODUyODI4O1xcclxcbiAgZm9udC1zaXplOiAxNnB4O1xcclxcbiAgZm9udC13ZWlnaHQ6IDYwMDtcXHJcXG59XFxyXFxuLyogRmlyZWZveCAqL1xcclxcbmlucHV0W3R5cGU9J251bWJlciddIHtcXHJcXG4gIC1tb3otYXBwZWFyYW5jZTogdGV4dGZpZWxkO1xcclxcbn1cXHJcXG4uZm9ybS1jb250cm9sIHtcXHJcXG4gIHBhZGRpbmc6IDhweCAwLjc1cmVtO1xcclxcbn1cXHJcXG4uYWNjb3JkaW9uLWJvZHkge1xcclxcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxyXFxufVxcclxcbi5hY2NvcmRpb24tYnV0dG9uOm5vdCguY29sbGFwc2VkKSB7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDBiODcwICFpbXBvcnRhbnQ7XFxyXFxuICBib3gtc2hhZG93OiBpbnNldCAwIGNhbGMoLTEgKiB2YXIoLS1icy1hY2NvcmRpb24tYm9yZGVyLXdpZHRoKSkgMFxcclxcbiAgICB2YXIoLS1icy1hY2NvcmRpb24tYm9yZGVyLWNvbG9yKTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA2MDA7XFxyXFxufVxcclxcbi5hY2NvcmRpb24tYnV0dG9uOm5vdCguY29sbGFwc2VkKTo6YWZ0ZXIge1xcclxcbiAgZmlsdGVyOiBicmlnaHRuZXNzKDApIGludmVydCgxKTtcXHJcXG59XFxyXFxuLnRhYi1jb250ZW50IGgxOjphZnRlciB7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCAjMDAwO1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgd2lkdGg6IDQwJTtcXHJcXG4gIGxlZnQ6IDA7XFxyXFxuICBib3R0b206IDFweDtcXHJcXG4gIGxlZnQ6IDUwJTtcXHJcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDApO1xcclxcbn1cXHJcXG4uc3BhY2Uge1xcclxcbiAgd2lkdGg6IDc3JTtcXHJcXG4gIG1hcmdpbjogMjBweCBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4vKiBmb290ZXIgKi9cXHJcXG5mb290ZXIge1xcclxcbiAgYmFja2dyb3VuZDogIzJmMmYyZjtcXHJcXG4gIGNvbG9yOiAjZmZmO1xcclxcbiAgcGFkZGluZzogMTBweDtcXHJcXG4gIG1hcmdpbi10b3A6IDRyZW07XFxyXFxufVxcclxcbi5mb290ZXItc2VjIHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XFxyXFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcclxcbiAgZmxleC13cmFwOiB3cmFwO1xcclxcbn1cXHJcXG4uY29weXJpZ2h0IHAge1xcclxcbiAgZm9udC1zaXplOiAxN3B4O1xcclxcbiAgbGluZS1oZWlnaHQ6IDEuMjtcXHJcXG4gIGNvbG9yOiAjYjBhNGFjO1xcclxcbiAgZm9udC13ZWlnaHQ6IDMwMDtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG59XFxyXFxuLndlYnNpdGUgcCB7XFxyXFxuICBmb250LXNpemU6IDE1cHg7XFxyXFxuICBjb2xvcjogI2QwYjg3MDtcXHJcXG59XFxyXFxuLndlYnNpdGUgYSB7XFxyXFxuICBmb250LXNpemU6IDE1cHg7XFxyXFxuICBjb2xvcjogI2IwYTRhYyAhaW1wb3J0YW50O1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbn1cXHJcXG4uZm9vdGVyLWl0ZW0ge1xcclxcbiAgbWFyZ2luOiA1cHggMDtcXHJcXG59XFxyXFxuLyogcHJvamVjdGlvbiBjc3Mgc3RhcnQgKi9cXHJcXG5kaXYjcHJvamVjdGlvbnMgaDMge1xcclxcbiAgcGFkZGluZy1ibG9jazogMjNweDtcXHJcXG4gIGZvbnQtc2l6ZTogMjZweDtcXHJcXG4gIGZvbnQtd2VpZ2h0OiA3MDA7XFxyXFxufVxcclxcbmRpdiNwcm9qZWN0aW9ucyB1bCBsaSB7XFxyXFxuICBsaXN0LXN0eWxlOiBub25lO1xcclxcbiAgZm9udC1zaXplOiAyMHB4O1xcclxcbn1cXHJcXG5wLmR5bmFtaWNQYXJhIHtcXHJcXG4gIGZvbnQtc2l6ZTogMjRweCAhaW1wb3J0YW50O1xcclxcbiAgY29sb3I6ICNkMGI4NzA7XFxyXFxufVxcclxcbi8qIGRyb3Bkb3duIGNzcyAqL1xcclxcbnNlbGVjdCN0aW1lRHVyYXRpb24ge1xcclxcbiAgd2lkdGg6IDE1JTtcXHJcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcclxcbiAgZm9udC13ZWlnaHQ6IDcwMDtcXHJcXG4gIGNvbG9yOiAjZDBiODcwO1xcclxcbiAgcGFkZGluZzogMThweDtcXHJcXG4gIGJvcmRlcjogMnB4IHNvbGlkO1xcclxcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjgpO1xcclxcbn1cXHJcXG4vKi0tIHJlc3BvbmlzdmUgLS0qL1xcclxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6IDk5MXB4KSB7XFxyXFxuICBzZWxlY3QjdGltZUR1cmF0aW9uIHtcXHJcXG4gICAgd2lkdGg6IDQ1JTtcXHJcXG4gICAgbWFyZ2luLXRvcDogNDBweDtcXHJcXG4gIH1cXHJcXG4gIC5yb3cubW9iLWJsb2NrID4gZGl2IHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxuICAucm93Lm1vYi1ibG9jayB7XFxyXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcclxcbiAgfVxcclxcbiAgLnNwYWNlIHtcXHJcXG4gICAgd2lkdGg6IDEwMCU7XFxyXFxuICB9XFxyXFxufVxcclxcbkBtZWRpYSAobWF4LXdpZHRoOiA3NjBweCkge1xcclxcbiAgLmZvb3Rlci1zZWMge1xcclxcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlciAhaW1wb3J0YW50O1xcclxcbiAgfVxcclxcbn1cXHJcXG5AbWVkaWEgKG1heC13aWR0aDogNTAwcHgpIHtcXHJcXG4gIHNlbGVjdCN0aW1lRHVyYXRpb24ge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgbWFyZ2luLXRvcDogNDBweDtcXHJcXG4gIH1cXHJcXG4gIC5pY29uYmFyIHtcXHJcXG4gICAgZGlzcGxheTogbm9uZTtcXHJcXG4gIH1cXHJcXG4gIC5oZWFkZXItc2VjIHtcXHJcXG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxyXFxuICB9XFxyXFxufVxcclxcbi5kcm9wcyB7XFxyXFxuICB3aWR0aDogMTUlO1xcclxcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxyXFxuICBmb250LXdlaWdodDogNzAwO1xcclxcbiAgY29sb3I6ICNkMGI4NzA7XFxyXFxuICBwYWRkaW5nOiAxOHB4ICFpbXBvcnRhbnQ7XFxyXFxuICBib3JkZXI6IDJweCBzb2xpZDtcXHJcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC44KTtcXHJcXG59XFxyXFxuLyogXFxyXFxuLnByaW50LWJ1dHRvbiB7XFxyXFxuICBwYWRkaW5nOiAxMHB4IDIwcHg7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDBiODcwO1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgbWFyZ2luLXRvcDogMjBweDtcXHJcXG59ICovXFxyXFxuXFxyXFxuLyogUHJpbnQgU3R5bGVzICovXFxyXFxuQG1lZGlhIHByaW50IHtcXHJcXG4gIC5wcmludC1idXR0b24sXFxyXFxuICAubmF2aWdhdGlvbi1iYXIsXFxyXFxuICAuc2lkZWJhcixcXHJcXG4gIC5mb290ZXIge1xcclxcbiAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7IC8qIGhpZGUgbmF2YmFycywgZm9vdGVycywgYnV0dG9ucywgZXRjLiAqL1xcclxcbiAgfVxcclxcblxcclxcbiAgYm9keSB7XFxyXFxuICAgIGJhY2tncm91bmQ6IHdoaXRlO1xcclxcbiAgICBjb2xvcjogYmxhY2s7XFxyXFxuICB9XFxyXFxuXFxyXFxuICAvKiBPcHRpb25hbDogYWRqdXN0IGxheW91dCBmb3IgcHJpbnRpbmcgKi9cXHJcXG4gIC5tYWluLWNvbnRlbnQge1xcclxcbiAgICB3aWR0aDogMTAwJTtcXHJcXG4gICAgcGFkZGluZzogMDtcXHJcXG4gICAgbWFyZ2luOiAwO1xcclxcbiAgfVxcclxcblxcclxcbiAgaHRtbCxcXHJcXG4gIGJvZHkge1xcclxcbiAgICBoZWlnaHQ6IGF1dG87XFxyXFxuICB9XFxyXFxufVxcclxcbi8qIEBtZWRpYSAobWF4LXdpZHRoOiA5OTFweCkge1xcclxcbiAgLnByaW50LWJ1dHRvbiB7XFxyXFxuICAgIHRvcDogLTIycHg7XFxyXFxuICAgIHdpZHRoOiA1MHB4O1xcclxcbiAgfVxcclxcbn0gKi9cXHJcXG4uYnRuLWZsZXgge1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XFxyXFxuICBnYXA6IDIwcHg7XFxyXFxuICBhbGlnbi1pdGVtczogZW5kO1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIHRvcDogLTI1cHg7XFxyXFxuICByaWdodDogMDtcXHJcXG59XFxyXFxuXFxyXFxuaHRtbCB7XFxyXFxuICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xcclxcbiAgb3BhY2l0eTogMTtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHN0eWxlc0luRE9NID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gIHZhciByZXN1bHQgPSAtMTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucykge1xuICB2YXIgaWRDb3VudE1hcCA9IHt9O1xuICB2YXIgaWRlbnRpZmllcnMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG4gICAgaWYgKGluZGV4QnlJZGVudGlmaWVyICE9PSAtMSkge1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnJlZmVyZW5jZXMrKztcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4QnlJZGVudGlmaWVyXS51cGRhdGVyKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB1cGRhdGVyID0gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucyk7XG4gICAgICBvcHRpb25zLmJ5SW5kZXggPSBpO1xuICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKGksIDAsIHtcbiAgICAgICAgaWRlbnRpZmllcjogaWRlbnRpZmllcixcbiAgICAgICAgdXBkYXRlcjogdXBkYXRlcixcbiAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlkZW50aWZpZXJzLnB1c2goaWRlbnRpZmllcik7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gYWRkRWxlbWVudFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICB2YXIgYXBpID0gb3B0aW9ucy5kb21BUEkob3B0aW9ucyk7XG4gIGFwaS51cGRhdGUob2JqKTtcbiAgdmFyIHVwZGF0ZXIgPSBmdW5jdGlvbiB1cGRhdGVyKG5ld09iaikge1xuICAgIGlmIChuZXdPYmopIHtcbiAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXAgJiYgbmV3T2JqLnN1cHBvcnRzID09PSBvYmouc3VwcG9ydHMgJiYgbmV3T2JqLmxheWVyID09PSBvYmoubGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gdXBkYXRlcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpc3QsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICB2YXIgbGFzdElkZW50aWZpZXJzID0gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpO1xuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcbiAgICBuZXdMaXN0ID0gbmV3TGlzdCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuICAgIHZhciBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBfaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tfaV07XG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuICAgICAgaWYgKHN0eWxlc0luRE9NW19pbmRleF0ucmVmZXJlbmNlcyA9PT0gMCkge1xuICAgICAgICBzdHlsZXNJbkRPTVtfaW5kZXhdLnVwZGF0ZXIoKTtcbiAgICAgICAgc3R5bGVzSW5ET00uc3BsaWNlKF9pbmRleCwgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTtcblxuICAgIC8vIFNwZWNpYWwgY2FzZSB0byByZXR1cm4gaGVhZCBvZiBpZnJhbWUgaW5zdGVhZCBvZiBpZnJhbWUgaXRzZWxmXG4gICAgaWYgKHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCAmJiBzdHlsZVRhcmdldCBpbnN0YW5jZW9mIHdpbmRvdy5IVE1MSUZyYW1lRWxlbWVudCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcbiAgICAgICAgLy8gZHVlIHRvIGNyb3NzLW9yaWdpbiByZXN0cmljdGlvbnNcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBzdHlsZVRhcmdldC5jb250ZW50RG9jdW1lbnQuaGVhZDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuICByZXR1cm4gbWVtb1t0YXJnZXRdO1xufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydEJ5U2VsZWN0b3IoaW5zZXJ0LCBzdHlsZSkge1xuICB2YXIgdGFyZ2V0ID0gZ2V0VGFyZ2V0KGluc2VydCk7XG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuICB0YXJnZXQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBpbnNlcnRCeVNlbGVjdG9yOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xuICBvcHRpb25zLnNldEF0dHJpYnV0ZXMoZWxlbWVudCwgb3B0aW9ucy5hdHRyaWJ1dGVzKTtcbiAgb3B0aW9ucy5pbnNlcnQoZWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcbiAgaWYgKG5vbmNlKSB7XG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcIm5vbmNlXCIsIG5vbmNlKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXM7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopIHtcbiAgdmFyIGNzcyA9IFwiXCI7XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG4gIGlmIChvYmoubWVkaWEpIHtcbiAgICBjc3MgKz0gXCJAbWVkaWEgXCIuY29uY2F0KG9iai5tZWRpYSwgXCIge1wiKTtcbiAgfVxuICB2YXIgbmVlZExheWVyID0gdHlwZW9mIG9iai5sYXllciAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuICBjc3MgKz0gb2JqLmNzcztcbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cbiAgdmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfVxuXG4gIC8vIEZvciBvbGQgSUVcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuICBvcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtKGNzcywgc3R5bGVFbGVtZW50LCBvcHRpb25zLm9wdGlvbnMpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudCk7XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuZnVuY3Rpb24gZG9tQVBJKG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybiB7XG4gICAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSgpIHt9LFxuICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgIH07XG4gIH1cbiAgdmFyIHN0eWxlRWxlbWVudCA9IG9wdGlvbnMuaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpO1xuICByZXR1cm4ge1xuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG9iaikge1xuICAgICAgYXBwbHkoc3R5bGVFbGVtZW50LCBvcHRpb25zLCBvYmopO1xuICAgIH0sXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcbiAgICB9XG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0eWxlVGFnVHJhbnNmb3JtOyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9idWRnZXQtdGFibGUuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vYnVkZ2V0LXRhYmxlLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsImltcG9ydCBmb3JtYXROdW1iZXIgZnJvbSAnLi4vdXRpbHMvZm9ybWF0LW51bWJlcic7XG5pbXBvcnQgcmVuZGVyQXNzZXRCcmVha2Rvd25DaGFydCBmcm9tICcuLi9jaGFydHMvYXNzZXQtYnJlYWtkb3duLWNoYXJ0JztcbmltcG9ydCByZW5kZXJJbmNvbWVTb3VyY2VQaWUgZnJvbSAnLi4vY2hhcnRzL2luY29tZS1zb3VyY2UtY2hhcnQnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYWxjdWxhdGVSZXRpcmVtZW50KCkge1xuICBsZXQgY3VycmVudEFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJyZW50QWdlJyk7XG4gIGxldCByZXRpcmVtZW50QWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JldGlyZW1lbnRBZ2UnKTtcbiAgbGV0IGV4cGVjdGVkTGlmZXNwYW4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhwZWN0ZWRMaWZlc3BhbicpO1xuICBsZXQgY3VycmVudFNhdmluZ3MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VycmVudFNhdmluZ3MnKTtcbiAgbGV0IG1vbnRobHlDb250cmlidXRpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vbnRobHlDb250cmlidXRpb25zJyk7XG4gIGxldCBhbm51YWxSZXR1cm4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5udWFsUmV0dXJuJyk7XG4gIGxldCBpbmZsYXRpb25SYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luZmxhdGlvblJhdGUnKTtcbiAgbGV0IGRlc2lyZWRJbmNvbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVzaXJlZEluY29tZScpO1xuICBsZXQgcmVhbEVzdGF0ZUFwcHJlY2lhdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICdyZWFsRXN0YXRlQXBwcmVjaWF0aW9uJ1xuICApO1xuICBsZXQgbW9ydGdhZ2VCYWxhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vcnRnYWdlQmFsYW5jZScpO1xuICBsZXQgd2hvbGVMaWZlSW5zdXJhbmNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dob2xlTGlmZUluc3VyYW5jZScpO1xuICBsZXQgbGlmZUluc3VyYW5jZU1vbnRobHlDb250cmlidXRpb25zID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgJ2xpZmVJbnN1cmFuY2VNb250aGx5Q29udHJpYnV0aW9ucydcbiAgKTtcbiAgbGV0IG1vcnRnYWdlVGVybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb3J0Z2FnZVRlcm0nKTtcbiAgbGV0IG1vcnRnYWdlSW50ZXJlc3RSYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vcnRnYWdlSW50ZXJlc3RSYXRlJyk7XG4gIC8vIPCfhpUgTmV3IGlucHV0cyBmb3IgU3RvY2sgYW5kIFJlYWwgRXN0YXRlXG4gIGxldCBjdXJyZW50U3RvY2tWYWx1ZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXJyZW50U3RvY2tWYWx1ZScpO1xuICBsZXQgY3VycmVudFJlYWxFc3RhdGVFcXVpdHkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAnY3VycmVudFJlYWxFc3RhdGVFcXVpdHknXG4gICk7XG4gIGxldCBzdG9ja0dyb3d0aFJhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RvY2tHcm93dGhSYXRlJyk7XG5cbiAgLy8g4pyFIEVycm9yIG1lc3NhZ2VzXG4gIGxldCBlcnJvcnMgPSB7XG4gICAgY3VycmVudEFnZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yQ3VycmVudEFnZScpLFxuICAgIHJldGlyZW1lbnRBZ2U6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvclJldGlyZW1lbnRBZ2UnKSxcbiAgICBleHBlY3RlZExpZmVzcGFuOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JFeHBlY3RlZExpZmVzcGFuJyksXG4gICAgY3VycmVudFNhdmluZ3M6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvckN1cnJlbnRTYXZpbmdzJyksXG4gICAgbW9udGhseUNvbnRyaWJ1dGlvbnM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvck1vbnRobHlDb250cmlidXRpb25zJyksXG4gICAgYW5udWFsUmV0dXJuOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JBbm51YWxSZXR1cm4nKSxcbiAgICBpbmZsYXRpb25SYXRlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JJbmZsYXRpb25SYXRlJyksXG4gICAgZGVzaXJlZEluY29tZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yRGVzaXJlZEluY29tZScpLFxuICAgIGN1cnJlbnRTdG9ja1ZhbHVlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JDdXJyZW50U3RvY2tWYWx1ZScpLFxuICAgIGN1cnJlbnRSZWFsRXN0YXRlRXF1aXR5OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAgICdlcnJvckN1cnJlbnRSZWFsRXN0YXRlRXF1aXR5J1xuICAgICksXG4gICAgcmVhbEVzdGF0ZUFwcHJlY2lhdGlvbjogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAnZXJyb3JSZWFsRXN0YXRlQXBwcmVjaWF0aW9uJ1xuICAgICksXG4gICAgbW9ydGdhZ2VCYWxhbmNlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3Jtb3J0Z2FnZUJhbGFuY2UnKSxcbiAgICB3aG9sZUxpZmVJbnN1cmFuY2U6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvcndob2xlTGlmZUluc3VyYW5jZScpLFxuICAgIGxpZmVJbnN1cmFuY2VNb250aGx5Q29udHJpYnV0aW9uczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXG4gICAgICAnZXJyb3JMaWZlSW5zdXJhbmNlTW9udGhseUNvbnRyaWJ1dGlvbnMnXG4gICAgKSxcbiAgICBtb3J0Z2FnZVRlcm06IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvck1vcnRnYWdlVGVybScpLFxuICAgIG1vcnRnYWdlSW50ZXJlc3RSYXRlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JNb3J0Z2FnZUludGVyZXN0UmF0ZScpLFxuICAgIHN0b2NrR3Jvd3RoUmF0ZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yU3RvY2tHcm93dGhSYXRlJyksXG4gIH07XG4gIC8vIOKchSBDbGVhciBwcmV2aW91cyBlcnJvcnNcbiAgT2JqZWN0LnZhbHVlcyhlcnJvcnMpLmZvckVhY2goKGVycm9yKSA9PiAoZXJyb3IuaW5uZXJUZXh0ID0gJycpKTtcblxuICBsZXQgaXNWYWxpZCA9IHRydWU7XG5cbiAgLy8g4pyFIFZhbGlkYXRpb24gZnVuY3Rpb25cbiAgZnVuY3Rpb24gdmFsaWRhdGVJbnB1dChcbiAgICBpbnB1dCxcbiAgICBlcnJvckZpZWxkLFxuICAgIGZpZWxkTmFtZSxcbiAgICBtaW4gPSAwLFxuICAgIG1heCA9IEluZmluaXR5XG4gICkge1xuICAgIGxldCB2YWx1ZSA9IHBhcnNlRmxvYXQoaW5wdXQudmFsdWUpIHx8IDA7IC8vIEZhbGxiYWNrIHRvIDAgaWYgZW1wdHlcbiAgICBpZiAodmFsdWUgPCBtaW4gfHwgdmFsdWUgPiBtYXgpIHtcbiAgICAgIGVycm9yRmllbGQuaW5uZXJUZXh0ID0gYCR7ZmllbGROYW1lfSBtdXN0IGJlIGEgdmFsaWQgbnVtYmVyICgke21pbn0gLSAke21heH0pLmA7XG4gICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLy8g4pyFIFZhbGlkYXRlIGFsbCBpbnB1dHNcbiAgdmFsaWRhdGVJbnB1dChjdXJyZW50QWdlLCBlcnJvcnMuY3VycmVudEFnZSwgJ0N1cnJlbnQgQWdlJywgMTgsIDEwMCk7XG4gIHZhbGlkYXRlSW5wdXQocmV0aXJlbWVudEFnZSwgZXJyb3JzLnJldGlyZW1lbnRBZ2UsICdSZXRpcmVtZW50IEFnZScsIDE4LCAxMDApO1xuICB2YWxpZGF0ZUlucHV0KFxuICAgIGV4cGVjdGVkTGlmZXNwYW4sXG4gICAgZXJyb3JzLmV4cGVjdGVkTGlmZXNwYW4sXG4gICAgJ0V4cGVjdGVkIExpZmVzcGFuJyxcbiAgICBwYXJzZUludChjdXJyZW50QWdlLnZhbHVlLCAxMCkgfHwgMTgsXG4gICAgMTIwXG4gICk7XG5cbiAgdmFsaWRhdGVJbnB1dChjdXJyZW50U2F2aW5ncywgZXJyb3JzLmN1cnJlbnRTYXZpbmdzLCAnQ3VycmVudCBTYXZpbmdzJywgMCk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgbW9udGhseUNvbnRyaWJ1dGlvbnMsXG4gICAgZXJyb3JzLm1vbnRobHlDb250cmlidXRpb25zLFxuICAgICdNb250aGx5IENvbnRyaWJ1dGlvbnMnLFxuICAgIDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBhbm51YWxSZXR1cm4sXG4gICAgZXJyb3JzLmFubnVhbFJldHVybixcbiAgICAnRXhwZWN0ZWQgQW5udWFsIFJldHVybiAoJSknLFxuICAgIDAsXG4gICAgMTAwXG4gICk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgaW5mbGF0aW9uUmF0ZSxcbiAgICBlcnJvcnMuaW5mbGF0aW9uUmF0ZSxcbiAgICAnSW5mbGF0aW9uIFJhdGUgKCUpJyxcbiAgICAwLFxuICAgIDEwMFxuICApO1xuICB2YWxpZGF0ZUlucHV0KFxuICAgIGRlc2lyZWRJbmNvbWUsXG4gICAgZXJyb3JzLmRlc2lyZWRJbmNvbWUsXG4gICAgJ0Rlc2lyZWQgUmV0aXJlbWVudCBJbmNvbWUnLFxuICAgIDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBjdXJyZW50U3RvY2tWYWx1ZSxcbiAgICBlcnJvcnMuY3VycmVudFN0b2NrVmFsdWUsXG4gICAgJ0N1cnJlbnQgU3RvY2sgVmFsdWUnLFxuICAgIDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBjdXJyZW50UmVhbEVzdGF0ZUVxdWl0eSxcbiAgICBlcnJvcnMuY3VycmVudFJlYWxFc3RhdGVFcXVpdHksXG4gICAgJ0N1cnJlbnQgUmVhbCBFc3RhdGUgRXF1aXR5JyxcbiAgICAwXG4gICk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgcmVhbEVzdGF0ZUFwcHJlY2lhdGlvbixcbiAgICBlcnJvcnMucmVhbEVzdGF0ZUFwcHJlY2lhdGlvbixcbiAgICAnUmVhbCBFc3RhdGUgQXBwcmVjaWF0aW9uICglKScsXG4gICAgMCxcbiAgICAxMDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChtb3J0Z2FnZUJhbGFuY2UsIGVycm9ycy5tb3J0Z2FnZUJhbGFuY2UsICdNb3J0Z2FnZSBCYWxhbmNlJywgMCk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgd2hvbGVMaWZlSW5zdXJhbmNlLFxuICAgIGVycm9ycy53aG9sZUxpZmVJbnN1cmFuY2UsXG4gICAgJ1dob2xlIExpZmUgSW5zdXJhbmNlJyxcbiAgICAwXG4gICk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgbGlmZUluc3VyYW5jZU1vbnRobHlDb250cmlidXRpb25zLFxuICAgIGVycm9ycy5saWZlSW5zdXJhbmNlTW9udGhseUNvbnRyaWJ1dGlvbnMsXG4gICAgJ0xpZmUgSW5zdXJhbmNlIE1vbnRobHkgQ29udHJpYnV0aW9ucycsXG4gICAgMFxuICApO1xuICAvLyB2YWxpZGF0ZUlucHV0KG1vcnRnYWdlVGVybSwgZXJyb3JzLm1vcnRnYWdlVGVybSwgXCJNb3J0Z2FnZSBUZXJtXCIsIDEsIDUwKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBtb3J0Z2FnZUludGVyZXN0UmF0ZSxcbiAgICBlcnJvcnMubW9ydGdhZ2VJbnRlcmVzdFJhdGUsXG4gICAgJ01vcnRnYWdlIEludGVyZXN0IFJhdGUnLFxuICAgIDAsXG4gICAgMTAwXG4gICk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgc3RvY2tHcm93dGhSYXRlLFxuICAgIGVycm9ycy5zdG9ja0dyb3d0aFJhdGUsXG4gICAgJ1N0b2NrIEdyb3d0aCBSYXRlICglKScsXG4gICAgMCxcbiAgICAxMDBcbiAgKTtcblxuICBpZiAocGFyc2VJbnQoY3VycmVudEFnZS52YWx1ZSkgPj0gcGFyc2VJbnQocmV0aXJlbWVudEFnZS52YWx1ZSkpIHtcbiAgICBlcnJvcnMucmV0aXJlbWVudEFnZS5pbm5lclRleHQgPVxuICAgICAgJ1JldGlyZW1lbnQgYWdlIG11c3QgYmUgZ3JlYXRlciB0aGFuIGN1cnJlbnQgYWdlLic7XG4gICAgaXNWYWxpZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKCFpc1ZhbGlkKSByZXR1cm47XG5cbiAgLy8g4pyFIFZhcmlhYmxlcyBmb3IgY2FsY3VsYXRpb25cbiAgbGV0IHllYXJzVG9SZXRpcmVtZW50ID1cbiAgICBwYXJzZUludChyZXRpcmVtZW50QWdlLnZhbHVlKSAtIHBhcnNlSW50KGN1cnJlbnRBZ2UudmFsdWUpO1xuICBsZXQgbiA9IDEyOyAvLyBNb250aGx5IGNvbXBvdW5kaW5nXG4gIGxldCByID0gKHBhcnNlRmxvYXQoYW5udWFsUmV0dXJuLnZhbHVlKSB8fCAwKSAvIDEwMCAvIG47IC8vIEhhbmRsZSBlbXB0eSByZXR1cm4gZ3JhY2VmdWxseVxuICBsZXQgdCA9IHllYXJzVG9SZXRpcmVtZW50ICogbjtcblxuICAvLyDinIUgRnV0dXJlIFZhbHVlIENhbGN1bGF0aW9ucyAoQXZvaWQgTmFOKVxuICBsZXQgZnZDdXJyZW50U2F2aW5ncyA9XG4gICAgKHBhcnNlRmxvYXQoY3VycmVudFNhdmluZ3MudmFsdWUpIHx8IDApICpcbiAgICBNYXRoLnBvdyhcbiAgICAgIDEgKyAocGFyc2VGbG9hdChhbm51YWxSZXR1cm4udmFsdWUpIHx8IDApIC8gMTAwLFxuICAgICAgeWVhcnNUb1JldGlyZW1lbnRcbiAgICApO1xuXG4gIGxldCBmdkNvbnRyaWJ1dGlvbnMgPVxuICAgIHIgIT09IDBcbiAgICAgID8gKHBhcnNlRmxvYXQobW9udGhseUNvbnRyaWJ1dGlvbnMudmFsdWUpIHx8IDApICpcbiAgICAgICAgKCgoTWF0aC5wb3coMSArIHIsIHQpIC0gMSkgLyByKSAqICgxICsgcikpXG4gICAgICA6IDA7XG5cbiAgLy8g4pyFIFN0b2NrIGFuZCBSZWFsIEVzdGF0ZSBhcHByZWNpYXRpb24gKEF2b2lkIE5hTilcbiAgbGV0IGZ2U3RvY2sgPVxuICAgIChwYXJzZUZsb2F0KGN1cnJlbnRTdG9ja1ZhbHVlLnZhbHVlKSB8fCAwKSAqXG4gICAgTWF0aC5wb3coMSArIDAuMDMsIHllYXJzVG9SZXRpcmVtZW50KTtcblxuICBsZXQgcmVhbEVzdGF0ZVJhdGUgPSAocGFyc2VGbG9hdChyZWFsRXN0YXRlQXBwcmVjaWF0aW9uLnZhbHVlKSB8fCAwKSAvIDEwMDtcbiAgbGV0IGFkanVzdGVkTW9ydGdhZ2UgPSBwYXJzZUZsb2F0KG1vcnRnYWdlQmFsYW5jZS52YWx1ZSkgfHwgMDtcblxuICAvLyBSZWFsIGVzdGF0ZSBlcXVpdHk6IG93bmVkIHBvcnRpb24gb2YgZXF1aXR5IG1pbnVzIG93bmVkIG1vcnRnYWdlXG4gIGxldCBmdlJlYWxFc3RhdGUgPVxuICAgIChwYXJzZUZsb2F0KGN1cnJlbnRSZWFsRXN0YXRlRXF1aXR5LnZhbHVlKSB8fCAwKSAqXG4gICAgTWF0aC5wb3coMSArIHJlYWxFc3RhdGVSYXRlLCB5ZWFyc1RvUmV0aXJlbWVudCk7XG5cbiAgaWYgKGlzTmFOKGZ2UmVhbEVzdGF0ZSkpIGZ2UmVhbEVzdGF0ZSA9IDA7XG4gIC8vIOKchSBUb3RhbCBTYXZpbmdzIChDaGVjayBmb3IgTmFOIGFuZCBmYWxsYmFjayB0byAwKVxuICBsZXQgbGlmZUluc3VyYW5jZU1vbnRobHkgPVxuICAgIHBhcnNlRmxvYXQobGlmZUluc3VyYW5jZU1vbnRobHlDb250cmlidXRpb25zLnZhbHVlKSB8fCAwO1xuICBsZXQgZnZMaWZlSW5zdXJhbmNlQ29udHJpYnV0aW9ucyA9XG4gICAgciAhPT0gMFxuICAgICAgPyBsaWZlSW5zdXJhbmNlTW9udGhseSAqICgoTWF0aC5wb3coMSArIHIsIHQpIC0gMSkgLyByKSAqICgxICsgcilcbiAgICAgIDogMDtcbiAgbGV0IGN1cnJlbnRXaG9sZUxpZmVWYWx1ZSA9IHBhcnNlRmxvYXQod2hvbGVMaWZlSW5zdXJhbmNlLnZhbHVlKSB8fCAwO1xuICBsZXQgZnZXaG9sZUxpZmVMdW1wU3VtID0gY3VycmVudFdob2xlTGlmZVZhbHVlICogTWF0aC5wb3coMSArIHIsIHQpO1xuICBsZXQgZnZXaG9sZUxpZmVJbnN1cmFuY2UgPSBmdldob2xlTGlmZUx1bXBTdW0gKyBmdkxpZmVJbnN1cmFuY2VDb250cmlidXRpb25zO1xuXG4gIGxldCB0b3RhbFNhdmluZ3MgPVxuICAgIChpc05hTihmdkN1cnJlbnRTYXZpbmdzKSA/IDAgOiBmdkN1cnJlbnRTYXZpbmdzKSArXG4gICAgKGlzTmFOKGZ2Q29udHJpYnV0aW9ucykgPyAwIDogZnZDb250cmlidXRpb25zKSArXG4gICAgKGlzTmFOKGZ2U3RvY2spID8gMCA6IGZ2U3RvY2spICtcbiAgICAoaXNOYU4oZnZSZWFsRXN0YXRlKSA/IDAgOiBmdlJlYWxFc3RhdGUpICtcbiAgICBmdldob2xlTGlmZUluc3VyYW5jZTtcbiAgLy8g8J+GlSBBZGQgcmVtYWluaW5nIG1vcnRnYWdlIHBheW1lbnRzIHRvIHNhdmluZ3MgaWYgaXQgZW5kcyBiZWZvcmUgcmV0aXJlbWVudFxuICBjb25zdCBtb3J0Z2FnZUVuZFllYXJzID0gbW9ydGdhZ2VUZXJtIC8gMTI7XG4gIGlmIChtb3J0Z2FnZUVuZFllYXJzIDwgeWVhcnNUb1JldGlyZW1lbnQpIHtcbiAgICBjb25zdCByZW1haW5pbmdZZWFycyA9IHllYXJzVG9SZXRpcmVtZW50IC0gbW9ydGdhZ2VFbmRZZWFycztcbiAgICBjb25zdCBmdXR1cmVFeHRyYVNhdmluZ3MgPVxuICAgICAgciAhPT0gMFxuICAgICAgICA/IG1vbnRobHlQYXltZW50ICpcbiAgICAgICAgICAxMiAqXG4gICAgICAgICAgKChNYXRoLnBvdygxICsgciwgcmVtYWluaW5nWWVhcnMgKiBuKSAtIDEpIC8gcikgKlxuICAgICAgICAgICgxICsgcilcbiAgICAgICAgOiAwO1xuICAgIHRvdGFsU2F2aW5ncyArPSBpc05hTihmdXR1cmVFeHRyYVNhdmluZ3MpID8gMCA6IGZ1dHVyZUV4dHJhU2F2aW5ncztcbiAgfVxuXG4gIC8vIOKchSBBZGp1c3RlZCBJbmNvbWUgd2l0aCBJbmZsYXRpb24gKEZhbGxiYWNrIHRvIDApXG4gIGxldCBhZGp1c3RlZEluY29tZSA9XG4gICAgKHBhcnNlRmxvYXQoZGVzaXJlZEluY29tZS52YWx1ZSkgfHwgMCkgKlxuICAgIE1hdGgucG93KFxuICAgICAgMSArIChwYXJzZUZsb2F0KGluZmxhdGlvblJhdGUudmFsdWUpIHx8IDApIC8gMTAwLFxuICAgICAgeWVhcnNUb1JldGlyZW1lbnRcbiAgICApO1xuXG4gIC8vIOKchSBUaW1lLWJhc2VkIHByb2plY3Rpb25zIGZvciBhbGwgYXNzZXRzXG4gIGxldCBwcm9qZWN0aW9ucyA9IFtdO1xuICBzdG9ja0dyb3d0aFJhdGUgPSBzdG9ja0dyb3d0aFJhdGUudmFsdWUgLyAxMDA7XG5cbiAgZm9yIChsZXQgaSA9IDU7IGkgPD0geWVhcnNUb1JldGlyZW1lbnQ7IGkgKz0gNSkge1xuICAgIGNvbnN0IHJlYWxFc3RhdGVWYWx1ZSA9XG4gICAgICAocGFyc2VGbG9hdChjdXJyZW50UmVhbEVzdGF0ZUVxdWl0eS52YWx1ZSkgfHwgMCkgKlxuICAgICAgTWF0aC5wb3coMSArIHJlYWxFc3RhdGVSYXRlLCBpKTtcblxuICAgIGNvbnN0IHByaW5jaXBhbCA9IGFkanVzdGVkTW9ydGdhZ2U7XG4gICAgY29uc3QgdGVybU1vbnRocyA9IHBhcnNlRmxvYXQobW9ydGdhZ2VUZXJtLnZhbHVlIHx8IDApICogMTI7XG4gICAgY29uc3QgbW9udGhseVJhdGUgPSBwYXJzZUZsb2F0KG1vcnRnYWdlSW50ZXJlc3RSYXRlLnZhbHVlIHx8IDApIC8gMTAwIC8gMTI7XG5cbiAgICBjb25zdCBtb250aGx5UGF5bWVudCA9XG4gICAgICAocHJpbmNpcGFsICogKG1vbnRobHlSYXRlICogTWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCB0ZXJtTW9udGhzKSkpIC9cbiAgICAgIChNYXRoLnBvdygxICsgbW9udGhseVJhdGUsIHRlcm1Nb250aHMpIC0gMSk7XG4gICAgY29uc3QgbW9udGhzUGFpZCA9IE1hdGgubWluKGkgKiAxMiwgdGVybU1vbnRocyk7XG4gICAgY29uc3QgcmVtYWluaW5nTW9ydGdhZ2UgPVxuICAgICAgcHJpbmNpcGFsICogTWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCBtb250aHNQYWlkKSAtXG4gICAgICAobW9udGhseVBheW1lbnQgKiAoTWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCBtb250aHNQYWlkKSAtIDEpKSAvXG4gICAgICAgIG1vbnRobHlSYXRlO1xuXG4gICAgY29uc3QgbmV0UmVhbEVzdGF0ZSA9IGlzTmFOKHJlYWxFc3RhdGVWYWx1ZSAtIHJlbWFpbmluZ01vcnRnYWdlKVxuICAgICAgPyAwXG4gICAgICA6IHJlYWxFc3RhdGVWYWx1ZSAtIHJlbWFpbmluZ01vcnRnYWdlO1xuXG4gICAgLy8g8J+GlSBJZiBtb3J0Z2FnZSBpcyBwYWlkIG9mZiwgY2FsY3VsYXRlIHRoZSBleHRyYSBzYXZpbmdzXG4gICAgbGV0IGV4dHJhSW52ZXN0bWVudFZhbHVlID0gMDtcbiAgICBpZiAoaSAqIDEyID4gdGVybU1vbnRocykge1xuICAgICAgY29uc3QgZXh0cmFNb250aHMgPSBpICogMTIgLSB0ZXJtTW9udGhzO1xuICAgICAgY29uc3QgZXh0cmFNb250aGx5ID0gbW9udGhseVBheW1lbnQ7XG4gICAgICBjb25zdCBleHRyYVllYXJzID0gZXh0cmFNb250aHMgLyAxMjtcbiAgICAgIGV4dHJhSW52ZXN0bWVudFZhbHVlID1cbiAgICAgICAgciAhPT0gMFxuICAgICAgICAgID8gZXh0cmFNb250aGx5ICpcbiAgICAgICAgICAgIDEyICpcbiAgICAgICAgICAgICgoTWF0aC5wb3coMSArIHIsIGV4dHJhWWVhcnMgKiBuKSAtIDEpIC8gcikgKlxuICAgICAgICAgICAgKDEgKyByKVxuICAgICAgICAgIDogMDtcbiAgICB9XG5cbiAgICAvLyDwn6egIEluc3VyYW5jZSArIGV4dHJhIGludmVzdG1lbnQgRlZcbiAgICBjb25zdCBpbnN1cmFuY2VDb250cmlidXRpb25GViA9XG4gICAgICByICE9PSAwXG4gICAgICAgID8gbGlmZUluc3VyYW5jZU1vbnRobHkgKiAoKE1hdGgucG93KDEgKyByLCBpICogbikgLSAxKSAvIHIpICogKDEgKyByKVxuICAgICAgICA6IDA7XG4gICAgY29uc3QgcHJvamVjdGVkV2hvbGVMaWZlSW5zdXJhbmNlID1cbiAgICAgIChwYXJzZUZsb2F0KHdob2xlTGlmZUluc3VyYW5jZS52YWx1ZSkgfHwgMCkgKlxuICAgICAgTWF0aC5wb3coMSArIChwYXJzZUZsb2F0KGFubnVhbFJldHVybi52YWx1ZSkgfHwgMCkgLyAxMDAsIGkpO1xuICAgIGNvbnN0IHRvdGFsSW5zdXJhbmNlVmFsdWUgPVxuICAgICAgcHJvamVjdGVkV2hvbGVMaWZlSW5zdXJhbmNlICsgaW5zdXJhbmNlQ29udHJpYnV0aW9uRlY7XG5cbiAgICBwcm9qZWN0aW9ucy5wdXNoKHtcbiAgICAgIHllYXI6IGksXG4gICAgICBzdG9ja1ZhbHVlOlxuICAgICAgICAocGFyc2VGbG9hdChjdXJyZW50U3RvY2tWYWx1ZS52YWx1ZSkgfHwgMCkgKlxuICAgICAgICBNYXRoLnBvdygxICsgc3RvY2tHcm93dGhSYXRlLCBpKSxcbiAgICAgIHJlYWxFc3RhdGVWYWx1ZTogbmV0UmVhbEVzdGF0ZSxcbiAgICAgIGluc3VyYW5jZVZhbHVlOiB0b3RhbEluc3VyYW5jZVZhbHVlLFxuICAgICAgZXh0cmFJbnZlc3RtZW50VmFsdWU6IGlzTmFOKGV4dHJhSW52ZXN0bWVudFZhbHVlKVxuICAgICAgICA/IDBcbiAgICAgICAgOiBleHRyYUludmVzdG1lbnRWYWx1ZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8vIOKchSBXaXRoZHJhd2FsIFNpbXVsYXRpb25cbiAgbGV0IHdpdGhkcmF3YWxZZWFycyA9IDA7XG4gIGxldCByZW1haW5pbmdCYWxhbmNlID0gdG90YWxTYXZpbmdzO1xuICBsZXQgeWVhcmx5V2l0aGRyYXdhbCA9IGFkanVzdGVkSW5jb21lO1xuXG4gIHdoaWxlIChyZW1haW5pbmdCYWxhbmNlID4gMCkge1xuICAgIHdpdGhkcmF3YWxZZWFycysrO1xuXG4gICAgLy8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgIGlmICh3aXRoZHJhd2FsWWVhcnMgPiAxMDApIGJyZWFrO1xuXG4gICAgcmVtYWluaW5nQmFsYW5jZSAtPSB5ZWFybHlXaXRoZHJhd2FsO1xuICAgIHJlbWFpbmluZ0JhbGFuY2UgKj0gMSArIChwYXJzZUZsb2F0KGFubnVhbFJldHVybi52YWx1ZSkgfHwgMCkgLyAxMDA7XG4gICAgeWVhcmx5V2l0aGRyYXdhbCAqPSAxICsgKHBhcnNlRmxvYXQoaW5mbGF0aW9uUmF0ZS52YWx1ZSkgfHwgMCkgLyAxMDA7XG4gIH1cblxuICBleHBlY3RlZExpZmVzcGFuID0gZXhwZWN0ZWRMaWZlc3Bhbi52YWx1ZTtcbiAgbGV0IHJldGlyZW1lbnRZZWFycyA9IGV4cGVjdGVkTGlmZXNwYW4gLSBwYXJzZUludChyZXRpcmVtZW50QWdlLnZhbHVlKTtcbiAgbGV0IHNob3J0ZmFsbFN1cnBsdXNEaXYgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2hvcnQnKTtcbiAgbGV0IHNob3J0ZmFsbFN1cnBsdXM7XG5cbiAgaWYgKGFkanVzdGVkSW5jb21lID09PSAwIHx8IHRvdGFsU2F2aW5ncyA9PT0gMCkge1xuICAgIHNob3J0ZmFsbFN1cnBsdXMgPSAnJztcbiAgICBzaG9ydGZhbGxTdXJwbHVzRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjRkZGJztcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2hvcnRjYXAnKS5zdHlsZS5jb2xvciA9ICcnO1xuICB9IGVsc2UgaWYgKHdpdGhkcmF3YWxZZWFycyA+PSByZXRpcmVtZW50WWVhcnMpIHtcbiAgICBzaG9ydGZhbGxTdXJwbHVzID0gJ1N1cnBsdXMgKEZ1bmRzIGxhc3QgdGhyb3VnaG91dCByZXRpcmVtZW50KSc7XG4gICAgc2hvcnRmYWxsU3VycGx1c0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2QwYjg3MCc7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnNob3J0Y2FwJykuc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICB9IGVsc2Uge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zaG9ydGNhcCcpLnN0eWxlLmNvbG9yID0gJyNkMGI4NzAnO1xuICAgIHNob3J0ZmFsbFN1cnBsdXMgPSBgRnVuZHMgd29udCBsYXN0IHRocm91Z2hvdXQgdGhlIHJldGlyZW1lbnQgeWVhcnMsIHNob3J0IGJ5ICR7XG4gICAgICByZXRpcmVtZW50WWVhcnMgLSB3aXRoZHJhd2FsWWVhcnNcbiAgICB9IHllYXJzKWA7XG4gICAgc2hvcnRmYWxsU3VycGx1c0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2Y4NmQ2ZCc7XG4gIH1cblxuICAvLyDinIUgRGlzcGxheSBPdXRwdXRcbiAgaWYgKGFubnVhbFJldHVybi52YWx1ZSAhPSAnJykge1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3RhbFNhdmluZ3MnKS5pbm5lckhUTUwgPSBgJHtmb3JtYXROdW1iZXIoXG4gICAgICB0b3RhbFNhdmluZ3NcbiAgICApfWA7XG4gICAgbGV0IHRvdGFsU2F2aW5nc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsU2F2aW5ncycpO1xuICAgIGxldCB0b3RhbFNhdmluZ3NDYXJkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRvdGFsU2F2aW5nc0NhcmQnKTtcbiAgICBsZXQgdG90YWxTYXZpbmdzaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50b3RhbFNhdmluZ3NoZWFkJyk7XG4gICAgdG90YWxTYXZpbmdzRWwuc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgIHRvdGFsU2F2aW5nc2hlYWQuc3R5bGUuY29sb3IgPSAnYmxhY2snO1xuICAgIHRvdGFsU2F2aW5nc0NhcmQuc3R5bGUuYmFja2dyb3VuZCA9ICcjZDBiODcwJztcbiAgfVxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYW5udWFsV2l0aGRyYXdhbCcpLmlubmVySFRNTCA9IGAke2Zvcm1hdE51bWJlcihcbiAgICBhZGp1c3RlZEluY29tZVxuICApfWA7XG5cbiAgLy8gT25seSBkaXNwbGF5IHllYXJzIHVudGlsIGRlcGxldGlvbiBpZiBkZXNpcmVkIGluY29tZSBmaWxsZWRcbiAgaWYgKGRlc2lyZWRJbmNvbWUudmFsdWUgJiYgaW5mbGF0aW9uUmF0ZS52YWx1ZSkge1xuICAgIGxldCBkaXNwbGF5WWVhcnMgPSBpc05hTih3aXRoZHJhd2FsWWVhcnMpXG4gICAgICA/ICdOL0EnXG4gICAgICA6IHdpdGhkcmF3YWxZZWFycyA+IDEwMFxuICAgICAgPyAnPiAxMDAnXG4gICAgICA6IHdpdGhkcmF3YWxZZWFycztcblxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgJ3llYXJzVW50aWxEZXBsZXRpb24nXG4gICAgKS5pbm5lckhUTUwgPSBgJHtkaXNwbGF5WWVhcnN9YDtcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgneWVhcnNVbnRpbERlcGxldGlvbicpLmlubmVySFRNTCA9ICcnO1xuICB9XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzaG9ydGZhbGxTdXJwbHVzJykuaW5uZXJIVE1MID0gaXNOYU4od2l0aGRyYXdhbFllYXJzKVxuICAgID8gJ04vQSdcbiAgICA6IHNob3J0ZmFsbFN1cnBsdXM7XG5cbiAgLy8g4pyFIERpc3BsYXkgTmV3IFByb2plY3Rpb25zXG4gIGxldCBwcm9qZWN0aW9uc0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9qZWN0aW9ucycpO1xuICBwcm9qZWN0aW9uc0Rpdi5pbm5lckhUTUwgPSBgPGgzIGNsYXNzPVwiZHluYW1pY0hlYWRcIj5UaW1lLWJhc2VkIEFzc2V0IFByb2plY3Rpb25zOjwvaDM+YDtcbiAgcHJvamVjdGlvbnMuZm9yRWFjaCgocHJvaikgPT4ge1xuICAgIGNvbnN0IHRvdGFsID0gcHJvai5zdG9ja1ZhbHVlICsgcHJvai5yZWFsRXN0YXRlVmFsdWUgKyBwcm9qLmluc3VyYW5jZVZhbHVlO1xuXG4gICAgcHJvamVjdGlvbnNEaXYuaW5uZXJIVE1MICs9IGBcbiAgICAgICAgPHAgY2xhc3M9XCJkeW5hbWljUGFyYVwiPkluIDxzdHJvbmc+JHtwcm9qLnllYXJ9IHllYXJzOjwvc3Ryb25nPjwvcD5cbiAgICAgICAgPHVsPlxuICAgICAgICAgIDxsaSBjbGFzcz1cImR5bmFtaWNMaXN0XCI+U3RvY2sgVmFsdWU6ICR7Zm9ybWF0TnVtYmVyKFxuICAgICAgICAgICAgcHJvai5zdG9ja1ZhbHVlXG4gICAgICAgICAgKX08L2xpPlxuICAgICAgICAgIDxsaSBjbGFzcz1cImR5bmFtaWNMaXN0XCI+UmVhbCBFc3RhdGUgVmFsdWU6ICR7Zm9ybWF0TnVtYmVyKFxuICAgICAgICAgICAgcHJvai5yZWFsRXN0YXRlVmFsdWVcbiAgICAgICAgICApfTwvbGk+XG4gICAgICAgICAgPGxpIGNsYXNzPVwiZHluYW1pY0xpc3RcIj5MaWZlIEluc3VyYW5jZSBWYWx1ZTogJHtmb3JtYXROdW1iZXIoXG4gICAgICAgICAgICBwcm9qLmluc3VyYW5jZVZhbHVlXG4gICAgICAgICAgKX08L2xpPlxuICAgICAgICAgIDxsaSBjbGFzcz1cImR5bmFtaWNMaXN0XCI+PHN0cm9uZz5Ub3RhbCBWYWx1ZTogJHtmb3JtYXROdW1iZXIoXG4gICAgICAgICAgICB0b3RhbFxuICAgICAgICAgICl9PC9zdHJvbmc+PC9saT5cbiAgICAgICAgPC91bD5gO1xuICB9KTtcblxuICBpZiAoXG4gICAgZnZTdG9jayA+IDAgfHxcbiAgICBmdlJlYWxFc3RhdGUgPiAwIHx8XG4gICAgZnZXaG9sZUxpZmVJbnN1cmFuY2UgPiAwIHx8XG4gICAgZnZDb250cmlidXRpb25zID4gMFxuICApIHtcbiAgICByZW5kZXJBc3NldEJyZWFrZG93bkNoYXJ0KFxuICAgICAgZnZTdG9jayxcbiAgICAgIGZ2UmVhbEVzdGF0ZSxcbiAgICAgIGZ2V2hvbGVMaWZlSW5zdXJhbmNlLFxuICAgICAgZnZDdXJyZW50U2F2aW5ncyArIGZ2Q29udHJpYnV0aW9uc1xuICAgICk7XG4gICAgcmVuZGVySW5jb21lU291cmNlUGllKFxuICAgICAgZnZDb250cmlidXRpb25zLFxuICAgICAgZnZTdG9jayxcbiAgICAgIGZ2UmVhbEVzdGF0ZSxcbiAgICAgIGZ2V2hvbGVMaWZlSW5zdXJhbmNlXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IGZvcm1hdE51bWJlciBmcm9tICcuLi91dGlscy9mb3JtYXQtbnVtYmVyJztcbmltcG9ydCBmb3JtYXROdW1iZXJQZXJjZW50IGZyb20gJy4uL3V0aWxzL2Zvcm1hdC1udW1iZXItcGVyY2VudCc7XG5pbXBvcnQgcmVzZXRDYW52YXMgZnJvbSAnLi4vY2hhcnQtdXRpbHMvcmVzZXQtY2FudmFzJztcbmltcG9ydCBjcmVhdGVQcm9qZWN0Q29zdEJyZWFrZG93bkNoYXJ0IGZyb20gJy4uL2NoYXJ0cy9wcm9qZWN0LWNvc3QtYnJlYWtkb3duLWNoYXJ0JztcbmltcG9ydCBjcmVhdGVBUlZEaXN0cmlidXRpb25DaGFydCBmcm9tICcuLi9jaGFydHMvYXJ2LWRpc3RyaWJ1dGlvbi1jaGFydCc7XG5pbXBvcnQgaW50ZXJlc3RQcm9qZWN0RHVyYXRpb24gZnJvbSAnLi4vdXRpbHMvaW50ZXJlc3QtcHJvamVjdC1kdXJhdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbGN1bGF0ZUhvdXNlRmxpcCgpIHtcbiAgbGV0IHB1cmNoYXNlID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwdXJjaGFzZVByaWNlJykudmFsdWUpIHx8IDA7XG4gIGxldCByZW5vID0gcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVub0Nvc3RzJykudmFsdWUpIHx8IDA7XG4gIGxldCBob2xkaW5nID0gcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9sZGluZ0Nvc3RzJykudmFsdWUpIHx8IDA7XG4gIGxldCBhcnYgPSBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZnRlclJlcGFpclZhbHVlJykudmFsdWUpIHx8IDA7XG4gIGxldCBkZXNpcmVkUHJvZml0TWFyZ2luID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZXNpcmVkUHJvZml0TWFyZ2luJykudmFsdWUpIHx8IDA7XG4gIC8vIExvYW4gJiBHYXAgRmllbGRzXG4gIGxldCBpbnRlcmVzdFJhdGUgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hvdXNlaW50ZXJlc3RSYXRlJykudmFsdWUpIHx8IDA7XG4gIGxldCBsb2FuUG9pbnRzID0gcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hblBvaW50cycpLnZhbHVlKSB8fCAwO1xuICBsZXQgdGVybVllYXJzID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob3VzZUxvYW5ZZWFyJykudmFsdWUpIHx8IDA7XG4gIGxldCB0b3RhbFBheW1lbnRzID0gdGVybVllYXJzICogMTI7XG4gIGxldCBnYXBGdW5kaW5nUmF0ZSA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ2FwQ29zdHMnKS52YWx1ZSkgfHwgMDtcbiAgLy8gQWRkaXRpb25hbCBGaWVsZHNcbiAgbGV0IGRvd25QYXltZW50UGVyY2VudCA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93blBheW1lbnRQZXJjZW50JykudmFsdWUpIHx8IDA7XG4gIC8vIGxldCBjb21taXNzaW9uUGVyY2VudCA9IHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb21taXNzaW9uUGVyY2VudFwiKS52YWx1ZSkgfHwgMDtcbiAgbGV0IHJlc2FsZUNvc3RQZXJjZW50ID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZXNhbGVDb3N0cycpLnZhbHVlKSB8fCAwO1xuICBsZXQgcmVzYWxlQ29zdHMgPSAoYXJ2ICogcmVzYWxlQ29zdFBlcmNlbnQpIC8gMTAwO1xuICBsZXQgYWRkcmVzcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9wZXJ0eUFkZHJlc3MnKS52YWx1ZTtcbiAgbGV0IG1vbnRocyA9IHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2plY3RNb250aHMnKS52YWx1ZSkgfHwgMDtcbiAgbGV0IG1vbnRobHlSZW50ID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob3VzZU1vbnRobHlSZW50JykudmFsdWUpIHx8IDA7XG4gIGxldCBhbm51YWxQcm9wZXJ0eVRheGVzID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcm9wZXJ0eVRheGVzSEYnKS52YWx1ZSkgfHwgMDtcbiAgbGV0IGFubnVhbEluc3VyYW5jZSA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5zdXJhbmNlJykudmFsdWUpIHx8IDA7XG4gIGxldCBhbm51YWxNYWludGVuYW5jZSA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG91c2VBbm51YWxNYWludGVuYW5jZScpLnZhbHVlKSB8fCAwO1xuICBsZXQgYW5udWFsVXRpbGl0aWVzID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob3VzZUFubnVhbFV0aWxpdGllcycpLnZhbHVlKSB8fCAwO1xuXG4gIGxldCBkb3duUGF5bWVudFR5cGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93blBheW1lbnRUeXBlJykudmFsdWU7XG5cbiAgbGV0IGRvd25QYXltZW50QmFzZSA9XG4gICAgZG93blBheW1lbnRUeXBlID09PSAncHVyY2hhc2VBbmRSZW5vJyA/IHB1cmNoYXNlICsgcmVubyA6IHB1cmNoYXNlO1xuICBsZXQgY2xvc2luZyA9IHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NpbmdDb3N0cycpLnZhbHVlKSB8fCAwO1xuICBsZXQgZG93blBheW1lbnQgPSAoZG93blBheW1lbnRCYXNlICogZG93blBheW1lbnRQZXJjZW50KSAvIDEwMDtcbiAgbGV0IG1vbnRobHlSYXRlID0gaW50ZXJlc3RSYXRlIC8gMTAwIC8gMTI7XG4gIGxldCBsb2FuQW1vdW50ID1cbiAgICBkb3duUGF5bWVudFR5cGUgPT09ICdwdXJjaGFzZUFuZFJlbm8nXG4gICAgICA/IHB1cmNoYXNlICsgcmVubyAtIGRvd25QYXltZW50XG4gICAgICA6IHB1cmNoYXNlIC0gZG93blBheW1lbnQ7XG4gIGxldCBwcm9yYXRlZE1haW50ZW5hbmNlID0gKGFubnVhbE1haW50ZW5hbmNlIC8gMTIpICogbW9udGhzO1xuICBsZXQgcHJvcmF0ZWRVdGlsaXRpZXMgPSAoYW5udWFsVXRpbGl0aWVzIC8gMTIpICogbW9udGhzO1xuXG4gIC8vIGxldCBsb2FuSW50ZXJlc3QgPSAobG9hbkFtb3VudCAqIChpbnRlcmVzdFJhdGUgLyAxMDApKSAqIChtb250aHMgLyAxMik7XG4gIGxldCBsb2FuRmVlcyA9IChsb2FuQW1vdW50ICogbG9hblBvaW50cykgLyAxMDA7XG4gIGxldCBwcm9yYXRlZFRheGVzID0gKGFubnVhbFByb3BlcnR5VGF4ZXMgLyAxMikgKiBtb250aHM7XG4gIGxldCBwcm9yYXRlZEluc3VyYW5jZSA9IChhbm51YWxJbnN1cmFuY2UgLyAxMikgKiBtb250aHM7XG4gIGxldCBtb250aGx5TW9ydGdhZ2VQYXltZW50ID1cbiAgICB0ZXJtWWVhcnMgPiAwXG4gICAgICA/IChsb2FuQW1vdW50ICogbW9udGhseVJhdGUpIC9cbiAgICAgICAgKDEgLSBNYXRoLnBvdygxICsgbW9udGhseVJhdGUsIC10b3RhbFBheW1lbnRzKSlcbiAgICAgIDogMDtcbiAgbGV0IHRvdGFsTW9ydGdhZ2VQYWlkID0gbW9udGhseU1vcnRnYWdlUGF5bWVudCAqIG1vbnRocztcblxuICBsZXQgaW50ZXJlc3RQYWlkID0gaW50ZXJlc3RQcm9qZWN0RHVyYXRpb24oXG4gICAgbG9hbkFtb3VudCxcbiAgICBtb250aGx5TW9ydGdhZ2VQYXltZW50LFxuICAgIG1vbnRocyxcbiAgICBtb250aGx5UmF0ZVxuICApO1xuICBsZXQgbG9hbkludGVyZXN0ID0gaW50ZXJlc3RQYWlkO1xuICBsZXQgdG90YWxQcm9qZWN0Q29zdCA9XG4gICAgcHVyY2hhc2UgK1xuICAgIHJlbm8gK1xuICAgIGhvbGRpbmcgK1xuICAgIGNsb3NpbmcgK1xuICAgIHJlc2FsZUNvc3RzICtcbiAgICB0b3RhbE1vcnRnYWdlUGFpZCArXG4gICAgbG9hbkZlZXMgK1xuICAgIHByb3JhdGVkVGF4ZXMgK1xuICAgIHByb3JhdGVkSW5zdXJhbmNlICtcbiAgICBwcm9yYXRlZE1haW50ZW5hbmNlICtcbiAgICBwcm9yYXRlZFV0aWxpdGllcztcbiAgLy8gKipDb3JyZWN0ZWQgSW52ZXN0bWVudCBDYWxjdWxhdGlvbioqXG4gIGxldCBnYXBDb3N0cyA9IHRvdGFsUHJvamVjdENvc3QgLSAobG9hbkFtb3VudCArIGRvd25QYXltZW50KTtcbiAgbGV0IGdhcEZ1bmRpbmdGZWVzID0gZ2FwQ29zdHMgPiAwID8gKGdhcENvc3RzICogZ2FwRnVuZGluZ1JhdGUpIC8gMTAwIDogMDtcblxuICBsZXQgdG90YWxJbnZlc3RtZW50ID1cbiAgICBwdXJjaGFzZSArXG4gICAgcmVubyArXG4gICAgaG9sZGluZyArXG4gICAgY2xvc2luZyArXG4gICAgdG90YWxNb3J0Z2FnZVBhaWQgK1xuICAgIGxvYW5GZWVzICtcbiAgICBnYXBGdW5kaW5nRmVlcyArXG4gICAgcHJvcmF0ZWRUYXhlcyArXG4gICAgcHJvcmF0ZWRJbnN1cmFuY2UgK1xuICAgIHByb3JhdGVkTWFpbnRlbmFuY2UgK1xuICAgIHByb3JhdGVkVXRpbGl0aWVzO1xuXG4gIGxldCB0b3RhbENhc2hJbnZlc3RlZCA9XG4gICAgZG93blBheW1lbnQgK1xuICAgIChkb3duUGF5bWVudFR5cGUgIT09ICdwdXJjaGFzZUFuZFJlbm8nID8gcmVubyA6IDApICtcbiAgICBob2xkaW5nICtcbiAgICBjbG9zaW5nICtcbiAgICB0b3RhbE1vcnRnYWdlUGFpZCArXG4gICAgZ2FwRnVuZGluZ0ZlZXMgK1xuICAgIHByb3JhdGVkVGF4ZXMgK1xuICAgIHByb3JhdGVkSW5zdXJhbmNlICtcbiAgICBwcm9yYXRlZE1haW50ZW5hbmNlICtcbiAgICBwcm9yYXRlZFV0aWxpdGllcyArXG4gICAgbG9hbkZlZXM7XG5cbiAgLy8g4pyFIFByb2ZpdCBDYWxjdWxhdGlvblxuICBsZXQgZ3Jvc3NQcm9maXQgPSBhcnYgLSBwdXJjaGFzZTtcbiAgbGV0IG5ldFByb2ZpdCA9IGFydiAtIHRvdGFsSW52ZXN0bWVudCAtIHJlc2FsZUNvc3RzO1xuXG4gIC8vIOKchSBQcm9maXQgTWFyZ2luICYgQ2FzaC1vbi1DYXNoIFJldHVyblxuICBsZXQgcHJvZml0TWFyZ2luID0gYXJ2ID4gMCA/IChuZXRQcm9maXQgLyBhcnYpICogMTAwIDogMDtcbiAgbGV0IGNhc2hPbkNhc2hSZXR1cm4gPVxuICAgIHRvdGFsQ2FzaEludmVzdGVkID4gMCA/IChuZXRQcm9maXQgLyB0b3RhbENhc2hJbnZlc3RlZCkgKiAxMDAgOiAwO1xuXG4gIGxldCB0b3RhbEhvbGRpbmdFeHBlbnNlcyA9XG4gICAgaG9sZGluZyArXG4gICAgcHJvcmF0ZWRUYXhlcyArXG4gICAgcHJvcmF0ZWRJbnN1cmFuY2UgK1xuICAgIHByb3JhdGVkTWFpbnRlbmFuY2UgK1xuICAgIHByb3JhdGVkVXRpbGl0aWVzICtcbiAgICBsb2FuSW50ZXJlc3QgK1xuICAgIGdhcEZ1bmRpbmdGZWVzO1xuXG4gIC8vIOKchSBCcmVhay1ldmVuIFllYXJzIENhbGN1bGF0aW9uXG4gIGxldCBtb250aGx5UmVudGFsUHJvZml0ID0gKFxuICAgIGFydiAqIDAuMDEgLVxuICAgIHRvdGFsSG9sZGluZ0V4cGVuc2VzIC8gbW9udGhzXG4gICkudG9GaXhlZCgyKTtcbiAgbGV0IGJyZWFrRXZlblllYXJzID1cbiAgICBOdW1iZXIobW9udGhseVJlbnRhbFByb2ZpdCkgPiAwICYmIG5ldFByb2ZpdCA+IDBcbiAgICAgID8gKG5ldFByb2ZpdCAvIChOdW1iZXIobW9udGhseVJlbnRhbFByb2ZpdCkgKiAxMikpLnRvRml4ZWQoMilcbiAgICAgIDogJ04vQSc7XG5cbiAgbGV0IG1vbnRobHlIb2xkaW5nQ29zdCA9XG4gICAgbW9udGhzID4gMCA/ICh0b3RhbEhvbGRpbmdFeHBlbnNlcyAvIG1vbnRocykudG9GaXhlZCgyKSA6IDA7XG5cbiAgLy8g4pyFIEZsaXBwaW5nIHZzLiBSZW50YWwgQW5hbHlzaXNcbiAgbGV0IHJlbnRhbFZzRmxpcCA9XG4gICAgbmV0UHJvZml0ID4gMCAmJiBtb250aGx5UmVudCA+IDBcbiAgICAgID8gKG5ldFByb2ZpdCAvIG1vbnRobHlSZW50KS50b0ZpeGVkKDIpXG4gICAgICA6ICdOL0EnO1xuICAvLyDinIUgUHJvZml0IE1pbiAlIGFuZCAkIENhbGN1bGF0aW9uXG4gIGxldCBwcm9maXRNaW5QZXJjZW50ID0gKHByb2ZpdE1hcmdpbiAqIDAuOCkudG9GaXhlZCgyKTsgLy8gQXNzdW1pbmcgODAlIG9mIHByb2ZpdCBtYXJnaW4gYXMgbWluXG4gIGxldCBwcm9maXRNaW5Eb2xsYXIgPSAobmV0UHJvZml0ICogMC44KS50b0ZpeGVkKDIpOyAvLyA4MCUgb2YgdGhlIG5ldCBwcm9maXQgYXMgbWluXG4gIGxldCBwcm9qZWN0aW9uID0gKG5ldFByb2ZpdCAqIDAuOSkudG9GaXhlZCgyKTsgLy8gUHJvamVjdGlvbiBhdCA5MCUgb2YgdGhlIG5ldCBwcm9maXRcblxuICAvLyDinIUgRGVhbD8gTG9naWNcbiAgbGV0IGRlYWwgPVxuICAgIHByb2ZpdE1hcmdpbiA+PSBkZXNpcmVkUHJvZml0TWFyZ2luICYmIG5ldFByb2ZpdCA+IDAgPyAnWUVTJyA6ICdOTyc7XG4gIGxldCByZXF1aXJlZEFSViA9XG4gICAgZGVzaXJlZFByb2ZpdE1hcmdpbiA+IDBcbiAgICAgID8gdG90YWxJbnZlc3RtZW50IC8gKDEgLSBkZXNpcmVkUHJvZml0TWFyZ2luIC8gMTAwKVxuICAgICAgOiAwO1xuICBsZXQgdG90YWxJbnZlc3RtZW50RXhjbHVkaW5nUHVyY2hhc2UgPVxuICAgIHJlbm8gK1xuICAgIGhvbGRpbmcgK1xuICAgIGxvYW5JbnRlcmVzdCArXG4gICAgbG9hbkZlZXMgK1xuICAgIGdhcEZ1bmRpbmdGZWVzICtcbiAgICBwcm9yYXRlZFRheGVzICtcbiAgICBwcm9yYXRlZEluc3VyYW5jZSArXG4gICAgcHJvcmF0ZWRNYWludGVuYW5jZSArXG4gICAgcHJvcmF0ZWRVdGlsaXRpZXM7XG5cbiAgbGV0IHRhcmdldE5ldFByb2ZpdCA9XG4gICAgKHRvdGFsSW52ZXN0bWVudEV4Y2x1ZGluZ1B1cmNoYXNlICsgcHVyY2hhc2UpICogKGRlc2lyZWRQcm9maXRNYXJnaW4gLyAxMDApO1xuXG4gIC8vIEJ1dCBzaW5jZSB3ZSB3YW50IHRvIHNvbHZlIGZvciBwdXJjaGFzZSAobWF4UHVyY2hhc2VQcmljZSksIHdlIG5lZWQgdG8gcmVzdHJ1Y3R1cmU6XG4gIGxldCBhbGxPdGhlckNvc3RzID1cbiAgICByZW5vICtcbiAgICBob2xkaW5nICtcbiAgICBjbG9zaW5nICtcbiAgICByZXNhbGVDb3N0cyArXG4gICAgdG90YWxNb3J0Z2FnZVBhaWQgK1xuICAgIGxvYW5GZWVzICtcbiAgICBnYXBGdW5kaW5nRmVlcyArXG4gICAgcHJvcmF0ZWRUYXhlcyArXG4gICAgcHJvcmF0ZWRJbnN1cmFuY2UgK1xuICAgIHByb3JhdGVkTWFpbnRlbmFuY2UgK1xuICAgIHByb3JhdGVkVXRpbGl0aWVzO1xuXG4gIGxldCBtYXhQdXJjaGFzZVByaWNlID0gYXJ2ICogKDEgLSBkZXNpcmVkUHJvZml0TWFyZ2luIC8gMTAwKSAtIGFsbE90aGVyQ29zdHM7XG5cbiAgLy8g4pyFIERpc3BsYXkgUmVzdWx0c1xuICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImdyb3NzUHJvZml0XCIpLmlubmVyVGV4dCA9IGZvcm1hdE51bWJlcihncm9zc1Byb2ZpdCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3RhbEludmVzdG1lbnQnKS5pbm5lclRleHQgPVxuICAgIGZvcm1hdE51bWJlcih0b3RhbEludmVzdG1lbnQpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV0UHJvZml0JykuaW5uZXJUZXh0ID0gZm9ybWF0TnVtYmVyKG5ldFByb2ZpdCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3RhbENhc2hJbnZlc3RlZCcpLmlubmVyVGV4dCA9XG4gICAgZm9ybWF0TnVtYmVyKHRvdGFsQ2FzaEludmVzdGVkKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2ZpdE1hcmdpbicpLmlubmVyVGV4dCA9XG4gICAgZm9ybWF0TnVtYmVyUGVyY2VudChwcm9maXRNYXJnaW4pICsgJyUnO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FzaE9uQ2FzaFJldHVybicpLmlubmVyVGV4dCA9XG4gICAgZm9ybWF0TnVtYmVyUGVyY2VudChjYXNoT25DYXNoUmV0dXJuKSArICclJztcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2JyZWFrRXZlblllYXJzJykuaW5uZXJUZXh0ID0gYnJlYWtFdmVuWWVhcnM7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZW50YWxWc0ZsaXAnKS5pbm5lclRleHQgPVxuICAgIHJlbnRhbFZzRmxpcCAhPT0gJ04vQSdcbiAgICAgID8gcmVudGFsVnNGbGlwID4gbW9udGhzXG4gICAgICAgID8gYEJlc3QgdG8gZmxpcC4gJHtyZW50YWxWc0ZsaXB9IHJlbnRhbCBtb250aHMgdG8gbWF0Y2ggZmxpcCBwcm9maXQuYFxuICAgICAgICA6IGBCZXN0IHRvIHJlbnQuICR7cmVudGFsVnNGbGlwfSByZW50YWwgbW9udGhzIHRvIG1hdGNoIGZsaXAgcHJvZml0LmBcbiAgICAgIDogJ04vQSc7XG5cbiAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcm9maXRNaW5QZXJjZW50XCIpLmlubmVyVGV4dCA9IGAke3Byb2ZpdE1pblBlcmNlbnR9JWA7XG4gIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvZml0TWluRG9sbGFyXCIpLmlubmVyVGV4dCA9IGAke2Zvcm1hdE51bWJlcihwcm9maXRNaW5Eb2xsYXIpfWA7XG4gIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvamVjdGlvblwiKS5pbm5lclRleHQgPSBgJHtmb3JtYXROdW1iZXIocHJvamVjdGlvbil9YDtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlYWxTdGF0dXMnKS5pbm5lclRleHQgPSBkZWFsO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9udGhseUhvbGRpbmdDb3N0JykuaW5uZXJUZXh0ID0gYCR7Zm9ybWF0TnVtYmVyKFxuICAgIG1vbnRobHlIb2xkaW5nQ29zdFxuICApfWA7XG4gIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvcmF0ZWRUYXhlc1wiKS5pbm5lclRleHQgPSBmb3JtYXROdW1iZXIocHJvcmF0ZWRUYXhlcyk7XG4gIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJvcmF0ZWRJbnN1cmFuY2VcIikuaW5uZXJUZXh0ID0gZm9ybWF0TnVtYmVyKHByb3JhdGVkSW5zdXJhbmNlKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Rpc3BsYXllZEFkZHJlc3MnKS5pbm5lclRleHQgPSBhZGRyZXNzXG4gICAgPyBg8J+TjSAke2FkZHJlc3N9YFxuICAgIDogJyc7XG4gIGlmIChnYXBGdW5kaW5nUmF0ZSA+IDApIHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FsY3VsYXRlZEdhcENvc3QnKS5pbm5lclRleHQgPVxuICAgICAgZm9ybWF0TnVtYmVyKGdhcEZ1bmRpbmdGZWVzKTtcbiAgfVxuICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJlcXVpcmVkQVJWXCIpLmlubmVyVGV4dCA9IGZvcm1hdE51bWJlcihyZXF1aXJlZEFSVik7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYXhQdXJjaGFzZVByaWNlJykuaW5uZXJUZXh0ID1cbiAgICBtYXhQdXJjaGFzZVByaWNlID4gMCA/IGZvcm1hdE51bWJlcihtYXhQdXJjaGFzZVByaWNlKSA6IDA7XG5cbiAgLy8g4pyFIENvbG9yIENvZGUgQ2FyZHNcbiAgLy8gbGV0IGdyb3NzUHJvZml0Q2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ3Jvc3NQcm9maXRjYXJkXCIpO1xuICAvLyBncm9zc1Byb2ZpdENhcmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gZ3Jvc3NQcm9maXQgPj0gMCA/IFwiI2QwYjg3MFwiIDogXCIjZjg2ZDZkXCI7XG4gIC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIuZ3Jvc3Nwcm9cIikuc3R5bGUuY29sb3IgPSBncm9zc1Byb2ZpdCA+PSAwID8gXCJibGFja1wiIDogXCIjZDBiODcwXCI7XG5cbiAgbGV0IG5ldFByb2ZpdEVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25ldFByb2ZpdCcpO1xuICBsZXQgbmV0cHJvY2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5uZXRwcm9jYXJkJyk7XG4gIGxldCBuZXRwcm9jYXJkaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5uZXRwcm9jYXJkaGVhZCcpO1xuICBuZXRQcm9maXRFbC5zdHlsZS5jb2xvciA9IG5ldFByb2ZpdCA+IDAgPyAnYmxhY2snIDogJ2JsYWNrJzsgLy8gZ29sZCBpZiBwcm9maXQsIHJlZCBpZiBsb3NzXG4gIG5ldHByb2NhcmRoZWFkLnN0eWxlLmNvbG9yID0gbmV0UHJvZml0ID4gMCA/ICdibGFjaycgOiAnI2QwYjg3MCc7IC8vIGdvbGQgaWYgcHJvZml0LCByZWQgaWYgbG9zc1xuICBuZXRwcm9jYXJkLnN0eWxlLmJhY2tncm91bmQgPVxuICAgIG5ldFByb2ZpdCA9PT0gMCA/ICcjZmZmZmZmJyA6IG5ldFByb2ZpdCA+IDAgPyAnI2QwYjg3MCcgOiAnI2Y4NmQ2ZCc7XG5cbiAgbGV0IHByb2ZpdE1hcmdpbkVsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb2ZpdE1hcmdpbicpO1xuICBsZXQgcHJvbWFyY2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9tYXJjYXJkJyk7XG4gIGxldCBwcm9tYXJjYXJkaGVhZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5wcm9tYXJjYXJkaGVhZCcpO1xuICBwcm9maXRNYXJnaW5FbC5zdHlsZS5jb2xvciA9XG4gICAgcHJvZml0TWFyZ2luID49IGRlc2lyZWRQcm9maXRNYXJnaW4gPyAnYmxhY2snIDogJ2JsYWNrJztcbiAgcHJvbWFyY2FyZGhlYWQuc3R5bGUuY29sb3IgPVxuICAgIHByb2ZpdE1hcmdpbiA+PSBkZXNpcmVkUHJvZml0TWFyZ2luID8gJyNkMGI4NzAnIDogJ2JsYWNrJzsgLy8gZ29sZCBpZiBwcm9maXQsIHJlZCBpZiBsb3NzXG4gIHByb21hcmNhcmQuc3R5bGUuYmFja2dyb3VuZCA9XG4gICAgcHJvZml0TWFyZ2luID09PSAwXG4gICAgICA/ICcjZmZmZmZmJ1xuICAgICAgOiBwcm9maXRNYXJnaW4gPj0gZGVzaXJlZFByb2ZpdE1hcmdpblxuICAgICAgPyAnI2QwYjg3MCdcbiAgICAgIDogJyNmODZkNmQnO1xuXG4gIGxldCByZW50YWxWc0ZsaXBFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdyZW50YWxWc0ZsaXAnKTtcbiAgbGV0IHJ2ZmNhcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucnZmY2FyZCcpO1xuICBsZXQgcnZmY2FyZGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucnZmY2FyZGhlYWQnKTtcbiAgcmVudGFsVnNGbGlwRWwuc3R5bGUuY29sb3IgPVxuICAgIHJlbnRhbFZzRmxpcCAhPT0gJ04vQScgJiYgcmVudGFsVnNGbGlwID4gbW9udGhzID8gJ2JsYWNrJyA6ICdibGFjayc7XG4gIHJ2ZmNhcmRoZWFkLnN0eWxlLmNvbG9yID1cbiAgICByZW50YWxWc0ZsaXAgIT09ICdOL0EnICYmIHJlbnRhbFZzRmxpcCA+IG1vbnRocyA/ICdibGFjaycgOiAnI2QwYjg3MCc7IC8vIGdvbGQgaWYgcHJvZml0LCByZWQgaWYgbG9zc1xuICBydmZjYXJkLnN0eWxlLmJhY2tncm91bmQgPVxuICAgIHJlbnRhbFZzRmxpcCA9PT0gJ04vQSdcbiAgICAgID8gJyNmZmZmZmYnXG4gICAgICA6IHJlbnRhbFZzRmxpcCAhPT0gJ04vQScgJiYgcmVudGFsVnNGbGlwID4gbW9udGhzXG4gICAgICA/ICcjZDBiODcwJ1xuICAgICAgOiAnI2Y4NmQ2ZCc7XG5cbiAgbGV0IGRlYWxDYXJkZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZWFsQ2FyZGQnKTtcbiAgbGV0IGRlYWxDYXJkZGhlYWQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGVhbENhcmRkaGVhZCcpO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVhbFN0YXR1cycpLnN0eWxlLmNvbG9yID1cbiAgICBkZWFsID09PSAnWUVTJyA/ICdibGFjaycgOiAnYmxhY2snO1xuICBkZWFsQ2FyZGRoZWFkLnN0eWxlLmNvbG9yID0gZGVhbCA9PT0gJ1lFUycgPyAnYmxhY2snIDogJyNkMGI4NzAnOyAvLyBnb2xkIGlmIHByb2ZpdCwgcmVkIGlmIGxvc3NcbiAgZGVhbENhcmRkLnN0eWxlLmJhY2tncm91bmQgPSBkZWFsID09PSAnWUVTJyA/ICcjZDBiODcwJyA6ICcjZjg2ZDZkJztcbiAgLy8g4pyFIFJlc2V0IENoYXJ0cyBCZWZvcmUgUmVuZGVyaW5nXG4gIHJlc2V0Q2FudmFzKCdwcm9qZWN0Q29zdEJyZWFrZG93bkNoYXJ0Jyk7XG4gIHJlc2V0Q2FudmFzKCdhcnZEaXN0cmlidXRpb25DaGFydCcpO1xuXG4gIGNyZWF0ZVByb2plY3RDb3N0QnJlYWtkb3duQ2hhcnQoe1xuICAgIHB1cmNoYXNlLFxuICAgIHJlbm8sXG4gICAgaG9sZGluZyxcbiAgICBsb2FuSW50ZXJlc3QsXG4gICAgbG9hbkZlZXMsXG4gICAgcmVzYWxlQ29zdHMsXG4gICAgY2xvc2luZyxcbiAgICBwcm9yYXRlZFRheGVzLFxuICAgIHByb3JhdGVkSW5zdXJhbmNlLFxuICB9KTtcbiAgY3JlYXRlQVJWRGlzdHJpYnV0aW9uQ2hhcnQoe1xuICAgIGludmVzdG1lbnQ6IHRvdGFsSW52ZXN0bWVudCxcbiAgICByZXNhbGVDb3N0cyxcbiAgICBuZXRQcm9maXQsXG4gIH0pO1xufVxuIiwiaW1wb3J0IGZvcm1hdE51bWJlciBmcm9tICcuLi91dGlscy9mb3JtYXQtbnVtYmVyJztcbmltcG9ydCBmb3JtYXROdW1iZXJQZXJjZW50IGZyb20gJy4uL3V0aWxzL2Zvcm1hdC1udW1iZXItcGVyY2VudCc7XG5pbXBvcnQgcmVuZGVyUG9ydGZvbGlvUGllQ2hhcnQgZnJvbSAnLi4vY2hhcnRzL3BvcnRmb2xpby1jaGFydCc7XG5pbXBvcnQgcmVuZGVyQ2FzaEZsb3dQaWVDaGFydCBmcm9tICcuLi9jaGFydHMvY2FzaGZsb3ctY2hhcnQnO1xuaW1wb3J0IGdldFRhYmxlRGF0YSBmcm9tICcuLi91dGlscy90YWJsZS1kYXRhJztcbmltcG9ydCB1cGRhdGVUYWJsZVJhbmdlIGZyb20gJy4uL3V0aWxzL3VwZGF0ZS10YWJsZS1yYW5nZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNhbGN1bGF0ZVJlbnRhbFByb3BlcnR5KCkge1xuICAvLyBHZXQgdmFsdWVzIGFuZCBjb252ZXJ0IHRvIG51bWJlcnNcbiAgbGV0IHByb3BlcnR5UHJpY2UgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb3BlcnR5UHJpY2UnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBpbml0aWFsUmVub3ZhdGlvbnMgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luaXRpYWxSZW5vdmF0aW9ucycpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IGRvd25QYXltZW50UGVyY2VudCA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93blBheW1lbnQnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBkb3duUGF5bWVudCA9IChkb3duUGF5bWVudFBlcmNlbnQgLyAxMDApICogcHJvcGVydHlQcmljZTtcbiAgbGV0IGxvYW5UZXJtID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdsb2FuVGVybScpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IGludGVyZXN0UmF0ZSA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW50ZXJlc3RSYXRlJykudmFsdWUudHJpbSgpKSB8fCAwO1xuICBsZXQgbW9udGhseVJlbnQgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vbnRobHlSZW50JykudmFsdWUudHJpbSgpKSB8fCAwO1xuICBsZXQgdmFjYW5jeVJhdGUgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZhY2FuY3lSYXRlJykudmFsdWUudHJpbSgpKSB8fCAwO1xuICBsZXQgcHJvcGVydHlUYXhlcyA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJvcGVydHlUYXhlcycpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IGluc3VyYW5jZUNvc3RzID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnN1cmFuY2VDb3N0cycpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IG1haW50ZW5hbmNlQ29zdHMgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21haW50ZW5hbmNlQ29zdHMnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBtYW5hZ2VtZW50RmVlcyA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWFuYWdlbWVudEZlZXMnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCB1dGlsaXRpZXMgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3V0aWxpdGllcycpLnZhbHVlLnRyaW0oKSkgfHwgMDtcblxuICBsZXQgcmVub3ZhdGlvbnMgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Jlbm92YXRpb25zJykudmFsdWUudHJpbSgpKSB8fCAwO1xuICBsZXQgcmVudEdyb3d0aCA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVudEdyb3d0aCcpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IGNsb3NpbmdDb3N0c1BlcmNlbnQgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nsb3NpbmdDb3N0c1JlbnQnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBjbG9zaW5nQ29zdHMgPSAoY2xvc2luZ0Nvc3RzUGVyY2VudCAvIDEwMCkgKiBwcm9wZXJ0eVByaWNlO1xuICAvLyBnZXR0aW5nIHRpbWUgdmFsdWVcbiAgbGV0IHRpbWVEdXJhdGlvbiA9XG4gICAgcGFyc2VJbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVEdXJhdGlvbicpLnZhbHVlLnRyaW0oKSkgfHwgMTA7XG4gIGxldCBhcHByZWNpYXRpb25SYXRlID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhcHByZWNpYXRpb25SYXRlJykudmFsdWUudHJpbSgpKSB8fCAzO1xuXG4gIC8vIFJlZmVyZW5jZSBlcnJvciBzcGFuIGVsZW1lbnRzXG4gIGxldCBlcnJvcnMgPSB7XG4gICAgcHJvcGVydHlQcmljZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yUHJvcGVydHlQcmljZScpLFxuICAgIGluaXRpYWxSZW5vdmF0aW9uczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9ySW5pdGlhbFJlbm92YXRpb25zJyksXG4gICAgZG93blBheW1lbnQ6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvckRvd25QYXltZW50UGVyJyksXG4gICAgbG9hblRlcm06IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvckxvYW5UZXJtJyksXG4gICAgaW50ZXJlc3RSYXRlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JJbnRlcmVzdFJhdGUnKSxcbiAgICBtb250aGx5UmVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yTW9udGhseVJlbnQnKSxcbiAgICB2YWNhbmN5UmF0ZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yVmFjYW5jeVJhdGUnKSxcbiAgICBwcm9wZXJ0eVRheGVzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JQcm9wZXJ0eVRheGVzJyksXG4gICAgaW5zdXJhbmNlQ29zdHM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvckluc3VyYW5jZUNvc3RzJyksXG4gICAgbWFpbnRlbmFuY2VDb3N0czogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yTWFpbnRlbmFuY2VDb3N0cycpLFxuICAgIG1hbmFnZW1lbnRGZWVzOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXJyb3JNYW5hZ2VtZW50RmVlcycpLFxuICAgIHV0aWxpdGllczogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yVXRpbGl0aWVzJyksXG4gICAgcmVub3ZhdGlvbnM6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlcnJvclJlbm92YXRpb25zJyksXG4gICAgcmVudEdyb3d0aDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yUmVudEdyb3d0aCcpLFxuICAgIGNsb3NpbmdDb3N0czogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Vycm9yQ2xvc2luZ0Nvc3RzUmVudCcpLFxuICB9O1xuICAvLyBDbGVhciBwcmV2aW91cyBlcnJvciBtZXNzYWdlc1xuICBPYmplY3QudmFsdWVzKGVycm9ycykuZm9yRWFjaCgoZXJyb3IpID0+IChlcnJvci5pbm5lclRleHQgPSAnJykpO1xuXG4gIGxldCBpc1ZhbGlkID0gdHJ1ZTtcblxuICAvLyDwn5qoICoqVmFsaWRhdGlvbnMqKlxuICBmdW5jdGlvbiB2YWxpZGF0ZUlucHV0KFxuICAgIHZhbHVlLFxuICAgIGVycm9yRmllbGQsXG4gICAgZmllbGROYW1lLFxuICAgIG1pbiA9IDAsXG4gICAgbWF4ID0gSW5maW5pdHlcbiAgKSB7XG4gICAgaWYgKGZpZWxkTmFtZSA9PSAnRG93biBQYXltZW50ICglKScgJiYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSkge1xuICAgICAgZXJyb3JGaWVsZC5pbm5lclRleHQgPSBgJHtmaWVsZE5hbWV9IG11c3QgYmUgbGVzcyB0aGFuIDEwMCAuYDtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgZmllbGROYW1lID09ICdMb2FuIFRlcm0gKFllYXJzKScgJiZcbiAgICAgICh2YWx1ZSA8IG1pbiB8fCB2YWx1ZSA+IG1heClcbiAgICApIHtcbiAgICAgIGVycm9yRmllbGQuaW5uZXJUZXh0ID0gYCR7ZmllbGROYW1lfSBtdXN0IGJlIGxlc3MgdGhhbiAzMCAuYDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlIDwgbWluIHx8IHZhbHVlID4gbWF4KSB7XG4gICAgICAgIGVycm9yRmllbGQuaW5uZXJUZXh0ID0gYCR7ZmllbGROYW1lfSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAke21pbn0gLmA7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YWxpZGF0ZUlucHV0KHByb3BlcnR5UHJpY2UsIGVycm9ycy5wcm9wZXJ0eVByaWNlLCAnUHJvcGVydHkgUHJpY2UnLCAxMDAwKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBkb3duUGF5bWVudFBlcmNlbnQsXG4gICAgZXJyb3JzLmRvd25QYXltZW50LFxuICAgICdEb3duIFBheW1lbnQgKCUpJyxcbiAgICAwLFxuICAgIDEwMFxuICApO1xuICB2YWxpZGF0ZUlucHV0KGxvYW5UZXJtLCBlcnJvcnMubG9hblRlcm0sICdMb2FuIFRlcm0gKFllYXJzKScsIDEsIDMwKTtcbiAgdmFsaWRhdGVJbnB1dChpbnRlcmVzdFJhdGUsIGVycm9ycy5pbnRlcmVzdFJhdGUsICdJbnRlcmVzdCBSYXRlICglKScsIDAsIDEwMCk7XG4gIHZhbGlkYXRlSW5wdXQobW9udGhseVJlbnQsIGVycm9ycy5tb250aGx5UmVudCwgJ01vbnRobHkgUmVudCcsIDApO1xuICB2YWxpZGF0ZUlucHV0KHZhY2FuY3lSYXRlLCBlcnJvcnMudmFjYW5jeVJhdGUsICdWYWNhbmN5IFJhdGUgKCUpJywgMCwgMTAwKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBwcm9wZXJ0eVRheGVzLFxuICAgIGVycm9ycy5wcm9wZXJ0eVRheGVzLFxuICAgICdBbm51YWwgUHJvcGVydHkgVGF4ZXMnLFxuICAgIDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBpbnN1cmFuY2VDb3N0cyxcbiAgICBlcnJvcnMuaW5zdXJhbmNlQ29zdHMsXG4gICAgJ0FubnVhbCBJbnN1cmFuY2UgQ29zdHMnLFxuICAgIDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBtYWludGVuYW5jZUNvc3RzLFxuICAgIGVycm9ycy5tYWludGVuYW5jZUNvc3RzLFxuICAgICdBbm51YWwgTWFpbnRlbmFuY2UgQ29zdHMnLFxuICAgIDBcbiAgKTtcbiAgdmFsaWRhdGVJbnB1dChcbiAgICBtYW5hZ2VtZW50RmVlcyxcbiAgICBlcnJvcnMubWFuYWdlbWVudEZlZXMsXG4gICAgJ01hbmFnZW1lbnQgRmVlcyAoJSknLFxuICAgIDAsXG4gICAgMTAwXG4gICk7XG4gIHZhbGlkYXRlSW5wdXQodXRpbGl0aWVzLCBlcnJvcnMudXRpbGl0aWVzLCAnVXRpbGl0aWVzJywgMCk7XG4gIHZhbGlkYXRlSW5wdXQocmVub3ZhdGlvbnMsIGVycm9ycy5yZW5vdmF0aW9ucywgJ1Jlbm92YXRpb25zJywgMCk7XG4gIHZhbGlkYXRlSW5wdXQocmVudEdyb3d0aCwgZXJyb3JzLnJlbnRHcm93dGgsICdSZW50IEdyb3d0aCAoJSknLCAwLCAxMDApO1xuICB2YWxpZGF0ZUlucHV0KFxuICAgIGNsb3NpbmdDb3N0c1BlcmNlbnQsXG4gICAgZXJyb3JzLmNsb3NpbmdDb3N0cyxcbiAgICAnQ2xvc2luZyBDb3N0cyAoJSknLFxuICAgIDAsXG4gICAgMTAwXG4gICk7XG4gIHZhbGlkYXRlSW5wdXQoXG4gICAgaW5pdGlhbFJlbm92YXRpb25zLFxuICAgIGVycm9ycy5pbml0aWFsUmVub3ZhdGlvbnMsXG4gICAgJ0luaXRpYWwgUmVub3ZhdGlvbnMnLFxuICAgIDBcbiAgKTtcblxuICBpZiAoIWlzVmFsaWQpIHJldHVybjtcblxuICAvLyDinIUgTG9hbiBDYWxjdWxhdGlvblxuICBsZXQgbG9hbkFtb3VudCA9IHByb3BlcnR5UHJpY2UgLSBkb3duUGF5bWVudDtcbiAgbGV0IG1vbnRobHlSYXRlID0gaW50ZXJlc3RSYXRlIC8gMTAwIC8gMTI7XG4gIGxldCBudW1QYXltZW50cyA9IGxvYW5UZXJtICogMTI7XG5cbiAgbGV0IG1vcnRnYWdlUGF5bWVudCA9XG4gICAgbW9udGhseVJhdGUgPiAwXG4gICAgICA/IChsb2FuQW1vdW50ICogKG1vbnRobHlSYXRlICogTWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCBudW1QYXltZW50cykpKSAvXG4gICAgICAgIChNYXRoLnBvdygxICsgbW9udGhseVJhdGUsIG51bVBheW1lbnRzKSAtIDEpXG4gICAgICA6IGxvYW5UZXJtID4gMFxuICAgICAgPyBsb2FuQW1vdW50IC8gbnVtUGF5bWVudHNcbiAgICAgIDogMDtcblxuICAvLyDinIUgUmVudGFsIEluY29tZSBDYWxjdWxhdGlvblxuICBsZXQgZ3Jvc3NSZW50SW5jb21lID0gbW9udGhseVJlbnQgKiAxMjtcbiAgbGV0IHZhY2FuY3lMb3NzID0gZ3Jvc3NSZW50SW5jb21lICogKHZhY2FuY3lSYXRlIC8gMTAwKTtcbiAgbGV0IGFkanVzdGVkUmVudEluY29tZSA9IGdyb3NzUmVudEluY29tZSAtIHZhY2FuY3lMb3NzO1xuXG4gIC8vIOKchSBPcGVyYXRpbmcgRXhwZW5zZXMgQ2FsY3VsYXRpb25cbiAgbGV0IG9wZXJhdGluZ0V4cGVuc2VzID1cbiAgICBwcm9wZXJ0eVRheGVzICtcbiAgICBpbnN1cmFuY2VDb3N0cyArXG4gICAgbWFpbnRlbmFuY2VDb3N0cyArXG4gICAgYWRqdXN0ZWRSZW50SW5jb21lICogKG1hbmFnZW1lbnRGZWVzIC8gMTAwKSArXG4gICAgdXRpbGl0aWVzICtcbiAgICByZW5vdmF0aW9ucztcbiAgLy8g4pyFIE5PSSBDYWxjdWxhdGlvblxuICBsZXQgbm9pID0gYWRqdXN0ZWRSZW50SW5jb21lIC0gb3BlcmF0aW5nRXhwZW5zZXM7XG5cbiAgLy8g4pyFIEFubnVhbCBNb3J0Z2FnZSBQYXltZW50XG4gIGxldCBhbm51YWxNb3J0Z2FnZVBheW1lbnQgPSBtb3J0Z2FnZVBheW1lbnQgKiAxMjtcblxuICAvLyDinIUgQ2FzaCBGbG93IENhbGN1bGF0aW9uXG4gIGxldCBjYXNoRmxvd0FubnVhbCA9IG5vaSAtIGFubnVhbE1vcnRnYWdlUGF5bWVudDtcbiAgbGV0IGNhc2hGbG93TW9udGhseSA9IGNhc2hGbG93QW5udWFsIC8gMTI7XG5cbiAgLy8g4pyFIENhcCBSYXRlIENhbGN1bGF0aW9uXG4gIGxldCBjYXBSYXRlID0gKG5vaSAvIHByb3BlcnR5UHJpY2UpICogMTAwO1xuXG4gIC8vIOKchSBDYXNoLW9uLUNhc2ggUmV0dXJuIENhbGN1bGF0aW9uXG4gIGxldCB0b3RhbENhc2hJbnZlc3RlZCA9IGRvd25QYXltZW50ICsgY2xvc2luZ0Nvc3RzICsgaW5pdGlhbFJlbm92YXRpb25zO1xuICBsZXQgY29jUmV0dXJuID1cbiAgICB0b3RhbENhc2hJbnZlc3RlZCA+IDAgPyAoY2FzaEZsb3dBbm51YWwgLyB0b3RhbENhc2hJbnZlc3RlZCkgKiAxMDAgOiAwO1xuXG4gIC8vIOKchSBEZWJ0IFNlcnZpY2UgUmF0aW8gKERTUikgQ2FsY3VsYXRpb25cbiAgbGV0IGRlYnRTZXJ2aWNlUmF0aW8gPVxuICAgIGFubnVhbE1vcnRnYWdlUGF5bWVudCA+IDAgPyBub2kgLyBhbm51YWxNb3J0Z2FnZVBheW1lbnQgOiAwO1xuICAvLyBGb3IgY2hhcnRzIGFuZCB0YWJsZSBwcm9qZWN0aW9uc1xuICBsZXQgcmVudFByb2plY3Rpb25zID0gW107XG4gIGxldCBhZGp1c3RlZFJlbnRQcm9qZWN0aW9ucyA9IFtdO1xuXG4gIGxldCBtb250aGx5UHJvcGVydHlUYXhlcyA9IHByb3BlcnR5VGF4ZXMgLyAxMjtcbiAgbGV0IG1vbnRobHlJbnN1cmFuY2UgPSBpbnN1cmFuY2VDb3N0cyAvIDEyO1xuICBsZXQgbW9udGhseU1haW50ZW5hbmNlID0gbWFpbnRlbmFuY2VDb3N0cyAvIDEyO1xuICBsZXQgbW9udGhseU1hbmFnZW1lbnRGZWVzID1cbiAgICAoYWRqdXN0ZWRSZW50SW5jb21lICogKG1hbmFnZW1lbnRGZWVzIC8gMTAwKSkgLyAxMjtcbiAgbGV0IG1vbnRobHlVdGlsaXRpZXMgPSB1dGlsaXRpZXMgLyAxMjtcbiAgbGV0IG1vbnRobHlSZW5vdmF0aW9ucyA9IHJlbm92YXRpb25zIC8gMTI7XG5cbiAgbGV0IHRvdGFsTW9udGhseUNvc3RzID1cbiAgICBtb3J0Z2FnZVBheW1lbnQgK1xuICAgIG1vbnRobHlQcm9wZXJ0eVRheGVzICtcbiAgICBtb250aGx5SW5zdXJhbmNlICtcbiAgICBtb250aGx5TWFpbnRlbmFuY2UgK1xuICAgIG1vbnRobHlNYW5hZ2VtZW50RmVlcyArXG4gICAgbW9udGhseVV0aWxpdGllcyArXG4gICAgbW9udGhseVJlbm92YXRpb25zO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGltZUR1cmF0aW9uOyBpKyspIHtcbiAgICBsZXQgeWVhclJlbnQgPSBtb250aGx5UmVudCAqIDEyICogTWF0aC5wb3coMSArIHJlbnRHcm93dGggLyAxMDAsIGkpO1xuICAgIGxldCB5ZWFyVmFjYW5jeUxvc3MgPSB5ZWFyUmVudCAqICh2YWNhbmN5UmF0ZSAvIDEwMCk7XG4gICAgbGV0IHllYXJBZGp1c3RlZFJlbnQgPSB5ZWFyUmVudCAtIHllYXJWYWNhbmN5TG9zcztcbiAgICByZW50UHJvamVjdGlvbnMucHVzaCh5ZWFyUmVudCk7XG4gICAgYWRqdXN0ZWRSZW50UHJvamVjdGlvbnMucHVzaCh5ZWFyQWRqdXN0ZWRSZW50KTtcbiAgfVxuXG4gIC8vIOKchSBEaXNwbGF5IFJlc3VsdHNcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvYW5BbW91bnQnKS5pbm5lclRleHQgPSBmb3JtYXROdW1iZXIobG9hbkFtb3VudCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb3J0Z2FnZVBheW1lbnQnKS5pbm5lclRleHQgPVxuICAgIGZvcm1hdE51bWJlcih0b3RhbE1vbnRobHlDb3N0cyk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub2knKS5pbm5lclRleHQgPSBmb3JtYXROdW1iZXIobm9pKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nhc2hGbG93JykuaW5uZXJUZXh0ID0gZm9ybWF0TnVtYmVyKGNhc2hGbG93TW9udGhseSk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXBSYXRlJykuaW5uZXJUZXh0ID1cbiAgICBmb3JtYXROdW1iZXJQZXJjZW50KGNhcFJhdGUpICsgJyUnO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29jUmV0dXJuJykuaW5uZXJUZXh0ID1cbiAgICBmb3JtYXROdW1iZXJQZXJjZW50KGNvY1JldHVybikgKyAnJSc7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhbm51YWxDYXNoRmxvdycpLmlubmVyVGV4dCA9XG4gICAgZm9ybWF0TnVtYmVyKGNhc2hGbG93QW5udWFsKTtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nhc2hJbnZlc3RlZFJlbnQnKS5pbm5lclRleHQgPVxuICAgIGZvcm1hdE51bWJlcih0b3RhbENhc2hJbnZlc3RlZCk7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkZWJ0U2VydmljZVJhdGlvJykuaW5uZXJUZXh0ID1cbiAgICBkZWJ0U2VydmljZVJhdGlvLnRvRml4ZWQoMik7XG5cbiAgLy8gQ2hhbmdlIGJhY2tncm91bmQgY29sb3IgaWYgRFNSIGlzIGdyZWF0ZXIgdGhhbiAxLjJcbiAgbGV0IGRzckVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGVidGNhcmQnKTtcbiAgaWYgKGRlYnRTZXJ2aWNlUmF0aW8gPiAxLjIpIHtcbiAgICBkc3JFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZDBiODcwJztcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZHNzcicpLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcbiAgfSBlbHNlIHtcbiAgICBkc3JFbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2IoMjQ4LCAxMDksIDEwOSknOyAvLyBSZXNldCB0byBkZWZhdWx0IGlmIERTUiBpcyBub3QgPiAxLjJcbiAgfVxuICByZW5kZXJQb3J0Zm9saW9QaWVDaGFydChcbiAgICBhZGp1c3RlZFJlbnRJbmNvbWUsXG4gICAgb3BlcmF0aW5nRXhwZW5zZXMsXG4gICAgY2FzaEZsb3dBbm51YWwsXG4gICAgdGltZUR1cmF0aW9uXG4gICk7XG4gIHJlbmRlckNhc2hGbG93UGllQ2hhcnQoXG4gICAgYW5udWFsTW9ydGdhZ2VQYXltZW50LFxuICAgIG9wZXJhdGluZ0V4cGVuc2VzLFxuICAgIGNhc2hGbG93QW5udWFsLFxuICAgIHRpbWVEdXJhdGlvblxuICApO1xuICB2YXIgeWVhciA9IHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3llYXJzX3RibCcpLnZhbHVlLnRyaW0oKSkgfHwgMTtcbiAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ5ZWFyX2JcIikuaW5uZXJUZXh0ID0geWVhcjtcbiAgZ2V0VGFibGVEYXRhKHllYXIsIHRydWUpO1xuICB1cGRhdGVUYWJsZVJhbmdlKCk7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZXNldENhbnZhcyhpZCkge1xuICBsZXQgY2FudmFzV3JhcHBlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKS5wYXJlbnROb2RlO1xuICBjYW52YXNXcmFwcGVyLmlubmVySFRNTCA9IGA8Y2FudmFzIGlkPVwiJHtpZH1cIj48L2NhbnZhcz5gO1xufVxuIiwiaW1wb3J0IHsgQ2hhcnQsIHJlZ2lzdGVyYWJsZXMgfSBmcm9tICdjaGFydC5qcyc7XG5DaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcbmltcG9ydCBDaGFydERhdGFMYWJlbHMgZnJvbSAnY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZUFSVkRpc3RyaWJ1dGlvbkNoYXJ0KGRhdGEpIHtcbiAgY29uc3QgY3R4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FydkRpc3RyaWJ1dGlvbkNoYXJ0JykuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjb25zdCBsYWJlbHMgPSBbJ1RvdGFsIEludmVzdG1lbnQnLCAnUmVzYWxlIENvc3RzJywgJ05ldCBQcm9maXQnXTtcbiAgY29uc3QgdmFsdWVzID0gW2RhdGEuaW52ZXN0bWVudCwgZGF0YS5yZXNhbGVDb3N0cywgZGF0YS5uZXRQcm9maXRdO1xuICBjb25zdCB0b3RhbCA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcblxuICBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgdHlwZTogJ3BpZScsXG4gICAgZGF0YToge1xuICAgICAgbGFiZWxzOiBsYWJlbHMsXG4gICAgICBkYXRhc2V0czogW1xuICAgICAgICB7XG4gICAgICAgICAgZGF0YTogdmFsdWVzLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogWycjMjk4MGI5JywgJyNmMWM0MGYnLCAnIzJlY2M3MSddLFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDQsXG4gICAgICAgICAgaG92ZXJPZmZzZXQ6IDIwLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICBwbHVnaW5zOiB7XG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgZGlzcGxheTogdHJ1ZSxcbiAgICAgICAgICB0ZXh0OiAnQVJWIERpc3RyaWJ1dGlvbicsXG4gICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgc2l6ZTogMjAsXG4gICAgICAgICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgIH0sXG4gICAgICAgIGxlZ2VuZDoge1xuICAgICAgICAgIHBvc2l0aW9uOiAncmlnaHQnLFxuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgYm94V2lkdGg6IDE0LFxuICAgICAgICAgICAgcGFkZGluZzogMTYsXG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgIHNpemU6IDE0LFxuICAgICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICBsYWJlbDogZnVuY3Rpb24gKGN0eCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5wYXJzZWQ7XG4gICAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAoKHZhbHVlIC8gdG90YWwpICogMTAwKS50b0ZpeGVkKDIpO1xuICAgICAgICAgICAgICByZXR1cm4gYCR7XG4gICAgICAgICAgICAgICAgY3R4LmxhYmVsXG4gICAgICAgICAgICAgIH06ICQke3ZhbHVlLnRvTG9jYWxlU3RyaW5nKCl9ICgke3BlcmNlbnRhZ2V9JSlgO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgIHNpemU6IDE0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9ybWF0dGVyOiAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAodmFsdWUgLyB0b3RhbCkgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gYCR7cGVyY2VudGFnZS50b0ZpeGVkKDEpfSVgO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcGxheTogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5kYXRhc2V0LmRhdGFbY29udGV4dC5kYXRhSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9ICh2YWx1ZSAvIHRvdGFsKSAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlID49IDU7IC8vIFNob3cgb25seSBpZiB0aGUgc2xpY2UgaXMgNSUgb3IgbW9yZVxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0sXG4gICAgcGx1Z2luczogW0NoYXJ0RGF0YUxhYmVsc10sXG4gIH0pO1xufVxuIiwiaW1wb3J0IHsgQ2hhcnQsIHJlZ2lzdGVyYWJsZXMgfSBmcm9tICdjaGFydC5qcyc7XG5DaGFydC5yZWdpc3RlciguLi5yZWdpc3RlcmFibGVzKTtcbmltcG9ydCBDaGFydERhdGFMYWJlbHMgZnJvbSAnY2hhcnRqcy1wbHVnaW4tZGF0YWxhYmVscyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlbmRlckFzc2V0QnJlYWtkb3duQ2hhcnQoXG4gIGZ2U3RvY2ssXG4gIGZ2UmVhbEVzdGF0ZSxcbiAgZnZXaG9sZUxpZmVJbnN1cmFuY2UsXG4gIGZ2U2F2aW5nc1xuKSB7XG4gIGNvbnN0IGN0eCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhc3NldEJyZWFrZG93bkNoYXJ0JykuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjb25zdCB0b3RhbCA9IGZ2U3RvY2sgKyBmdlJlYWxFc3RhdGUgKyBmdldob2xlTGlmZUluc3VyYW5jZSArIGZ2U2F2aW5ncztcblxuICBjb25zdCBjaGFydERhdGEgPSB7XG4gICAgbGFiZWxzOiBbJ1N0b2NrcycsICdSZWFsIEVzdGF0ZScsICdXaG9sZSBMaWZlIEluc3VyYW5jZScsICdTYXZpbmdzJ10sXG4gICAgZGF0YXNldHM6IFtcbiAgICAgIHtcbiAgICAgICAgbGFiZWw6ICdBc3NldCBEaXN0cmlidXRpb24gYXQgUmV0aXJlbWVudCcsXG4gICAgICAgIGRhdGE6IFtmdlN0b2NrLCBmdlJlYWxFc3RhdGUsIGZ2V2hvbGVMaWZlSW5zdXJhbmNlLCBmdlNhdmluZ3NdLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IFsnI0YzOTY1NScsICcjQjc3Q0U5ICcsICcjNTVDQkU1ICcsICcjZTY3ZTIyJ10sXG4gICAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZmZmZicsXG4gICAgICAgIGJvcmRlcldpZHRoOiA0LFxuICAgICAgICBob3Zlck9mZnNldDogMjAsXG4gICAgICB9LFxuICAgIF0sXG4gIH07XG5cbiAgLy8gRGVzdHJveSBwcmV2aW91cyBjaGFydCBpbnN0YW5jZSBpZiBpdCBleGlzdHNcbiAgaWYgKHdpbmRvdy5hc3NldEJyZWFrZG93bkNoYXJ0IGluc3RhbmNlb2YgQ2hhcnQpIHtcbiAgICB3aW5kb3cuYXNzZXRCcmVha2Rvd25DaGFydC5kZXN0cm95KCk7XG4gIH1cblxuICB3aW5kb3cuYXNzZXRCcmVha2Rvd25DaGFydCA9IG5ldyBDaGFydChjdHgsIHtcbiAgICB0eXBlOiAncGllJyxcbiAgICBkYXRhOiBjaGFydERhdGEsXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgIHRleHQ6ICdBc3NldCBBbGxvY2F0aW9uIEJyZWFrZG93biBhdCBSZXRpcmVtZW50JyxcbiAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICBzaXplOiAyMCxcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgfSxcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBib3hXaWR0aDogMTQsXG4gICAgICAgICAgICBwYWRkaW5nOiAxNixcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LnBhcnNlZDtcbiAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9ICgodmFsdWUgLyB0b3RhbCkgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtcbiAgICAgICAgICAgICAgICBjdHgubGFiZWxcbiAgICAgICAgICAgICAgfTogJCR7dmFsdWUudG9Mb2NhbGVTdHJpbmcoKX0gKCR7cGVyY2VudGFnZX0lKWA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRhdGFsYWJlbHM6IHtcbiAgICAgICAgICBjb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9ICh2YWx1ZSAvIHRvdGFsKSAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBgJHtwZXJjZW50YWdlLnRvRml4ZWQoMSl9JWA7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNwbGF5OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjb250ZXh0LmRhdGFzZXQuZGF0YVtjb250ZXh0LmRhdGFJbmRleF07XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKHZhbHVlIC8gdG90YWwpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgPj0gNTsgLy8gT25seSBzaG93IGlmIDUlIG9yIG1vcmVcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHBsdWdpbnM6IFtDaGFydERhdGFMYWJlbHNdLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IENoYXJ0LCByZWdpc3RlcmFibGVzIH0gZnJvbSAnY2hhcnQuanMnO1xuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5pbXBvcnQgQ2hhcnREYXRhTGFiZWxzIGZyb20gJ2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW5kZXJDYXNoRmxvd1BpZUNoYXJ0KFxuICBtb3J0Z2FnZVBheW1lbnRBbm51YWwsXG4gIG9wZXJhdGluZ0V4cGVuc2VzLFxuICBjYXNoRmxvd0FubnVhbCxcbiAgdGltZUR1cmF0aW9uID0gMVxuKSB7XG4gIGNvbnN0IGN0eCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYXNoRmxvd1BpZUNoYXJ0JykuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBpZiAod2luZG93LmNhc2hGbG93UGllQ2hhcnQgaW5zdGFuY2VvZiBDaGFydCkge1xuICAgIHdpbmRvdy5jYXNoRmxvd1BpZUNoYXJ0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIFNjYWxlIGFsbCB2YWx1ZXMgYnkgdGltZSBkdXJhdGlvbiAoaW4geWVhcnMpXG4gIGNvbnN0IHNjYWxlZE1vcnRnYWdlID0gbW9ydGdhZ2VQYXltZW50QW5udWFsICogdGltZUR1cmF0aW9uO1xuICBjb25zdCBzY2FsZWRFeHBlbnNlcyA9IG9wZXJhdGluZ0V4cGVuc2VzICogdGltZUR1cmF0aW9uO1xuICBjb25zdCBzY2FsZWRDYXNoRmxvdyA9IGNhc2hGbG93QW5udWFsICogdGltZUR1cmF0aW9uO1xuXG4gIGNvbnN0IGxhYmVscyA9IFsnTW9ydGdhZ2UgUGF5bWVudHMnLCAnT3BlcmF0aW5nIEV4cGVuc2VzJ107XG4gIGNvbnN0IHZhbHVlcyA9IFtzY2FsZWRNb3J0Z2FnZSwgc2NhbGVkRXhwZW5zZXNdO1xuICBjb25zdCBjb2xvcnMgPSBbJyM1NUNCRTUnLCAnI0YzOTY1NSddO1xuXG4gIGNvbnN0IG5ldExhYmVsID0gc2NhbGVkQ2FzaEZsb3cgPj0gMCA/ICdOZXQgUHJvZml0JyA6ICdOZXQgTG9zcyc7XG4gIGNvbnN0IG5ldENvbG9yID0gc2NhbGVkQ2FzaEZsb3cgPj0gMCA/ICcjNENBRjUwJyA6ICcjRkY1NzIyJztcblxuICBsYWJlbHMucHVzaChuZXRMYWJlbCk7XG4gIHZhbHVlcy5wdXNoKE1hdGguYWJzKHNjYWxlZENhc2hGbG93KSk7XG4gIGNvbG9ycy5wdXNoKG5ldENvbG9yKTtcblxuICBjb25zdCB0b3RhbEZsb3cgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcblxuICB3aW5kb3cuY2FzaEZsb3dQaWVDaGFydCA9IG5ldyBDaGFydChjdHgsIHtcbiAgICB0eXBlOiAncGllJyxcbiAgICBkYXRhOiB7XG4gICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ0Nhc2ggRmxvdyBCcmVha2Rvd24nLFxuICAgICAgICAgIGRhdGE6IHZhbHVlcy5tYXAoKHZhbCkgPT4gdmFsLnRvRml4ZWQoMikpLFxuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLFxuICAgICAgICAgIGhvdmVyT2Zmc2V0OiAxNSxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMyxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZmYnLFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9LFxuICAgIG9wdGlvbnM6IHtcbiAgICAgIHJlc3BvbnNpdmU6IHRydWUsXG4gICAgICBpbnRlcmFjdGlvbjoge1xuICAgICAgICBtb2RlOiAnbmVhcmVzdCcsXG4gICAgICAgIGludGVyc2VjdDogZmFsc2UsXG4gICAgICB9LFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgdGV4dDogYENhc2ggRmxvdyBCcmVha2Rvd24gKE92ZXIgJHt0aW1lRHVyYXRpb259IFllYXIke1xuICAgICAgICAgICAgdGltZUR1cmF0aW9uID4gMSA/ICdzJyA6ICcnXG4gICAgICAgICAgfSlgLFxuICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHNpemU6IDIyLFxuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICB9LFxuICAgICAgICB0b29sdGlwOiB7XG4gICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICBtb2RlOiAnaW5kZXgnLFxuICAgICAgICAgIGludGVyc2VjdDogZmFsc2UsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjkpJyxcbiAgICAgICAgICB0aXRsZUZvbnQ6IHtcbiAgICAgICAgICAgIHNpemU6IDIwLFxuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBib2R5Rm9udDoge1xuICAgICAgICAgICAgc2l6ZTogMTYsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYWRkaW5nOiAxNCxcbiAgICAgICAgICBib3hQYWRkaW5nOiA2LFxuICAgICAgICAgIGJvcmRlckNvbG9yOiAnI2ZmZicsXG4gICAgICAgICAgYm9yZGVyV2lkdGg6IDEsXG4gICAgICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgICAgICBsYWJlbDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBjb250ZXh0LmxhYmVsIHx8ICcnO1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoY29udGV4dC5yYXcpO1xuICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKCh2YWx1ZSAvIHRvdGFsRmxvdykgKiAxMDApLnRvRml4ZWQoMik7XG4gICAgICAgICAgICAgIHJldHVybiBgJHtsYWJlbH06ICQke3ZhbHVlLnRvRml4ZWQoMil9ICgke3BlcmNlbnRhZ2V9JSlgO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFmdGVyQm9keTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYFRvdGFsOiAkJHt0b3RhbEZsb3cudG9GaXhlZCgyKX1gO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICBzaXplOiAxNixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib3hXaWR0aDogMjUsXG4gICAgICAgICAgICB1c2VQb2ludFN0eWxlOiB0cnVlLFxuICAgICAgICAgICAgcGFkZGluZzogMjAsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YWxhYmVsczoge1xuICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHNpemU6IDE0LFxuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gY29udGV4dC5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGEucmVkdWNlKFxuICAgICAgICAgICAgICAoYSwgYikgPT4gcGFyc2VGbG9hdChhKSArIHBhcnNlRmxvYXQoYiksXG4gICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKCh2YWx1ZSAvIHN1bSkgKiAxMDApLnRvRml4ZWQoMSk7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudGFnZSA+PSA1ID8gYCR7cGVyY2VudGFnZX0lYCA6ICcnO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGlvbjoge1xuICAgICAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAgICAgYW5pbWF0ZVNjYWxlOiB0cnVlLFxuICAgICAgICAgIGR1cmF0aW9uOiAxNTAwLFxuICAgICAgICAgIGVhc2luZzogJ2Vhc2VPdXRCb3VuY2UnLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9LFxuICAgIHBsdWdpbnM6IFtDaGFydERhdGFMYWJlbHNdLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IENoYXJ0LCByZWdpc3RlcmFibGVzIH0gZnJvbSAnY2hhcnQuanMnO1xuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5pbXBvcnQgQ2hhcnREYXRhTGFiZWxzIGZyb20gJ2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMnO1xuXG5sZXQgaW5jb21lU291cmNlQ2hhcnRJbnN0YW5jZTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVuZGVySW5jb21lU291cmNlUGllKFxuICBjb250cmlidXRpb25zLFxuICBzdG9jayxcbiAgcmVhbEVzdGF0ZSxcbiAgaW5zdXJhbmNlXG4pIHtcbiAgY29uc3QgY3R4ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luY29tZVNvdXJjZUNoYXJ0JykuZ2V0Q29udGV4dCgnMmQnKTtcblxuICBjb25zdCBkYXRhVmFsdWVzID0gW2NvbnRyaWJ1dGlvbnMsIHN0b2NrLCByZWFsRXN0YXRlLCBpbnN1cmFuY2VdO1xuICBjb25zdCB0b3RhbCA9IGRhdGFWYWx1ZXMucmVkdWNlKChhLCBiKSA9PiBhICsgYiwgMCk7XG5cbiAgaWYgKGluY29tZVNvdXJjZUNoYXJ0SW5zdGFuY2UpIHtcbiAgICBpbmNvbWVTb3VyY2VDaGFydEluc3RhbmNlLmRlc3Ryb3koKTtcbiAgfVxuXG4gIGluY29tZVNvdXJjZUNoYXJ0SW5zdGFuY2UgPSBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgdHlwZTogJ3BpZScsXG4gICAgZGF0YToge1xuICAgICAgbGFiZWxzOiBbJ0NvbnRyaWJ1dGlvbnMnLCAnU3RvY2snLCAnUmVhbCBFc3RhdGUnLCAnV2hvbGUgTGlmZSBJbnN1cmFuY2UnXSxcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBsYWJlbDogJ0luY29tZSBTb3VyY2UgQ29udHJpYnV0aW9uIGF0IFJldGlyZW1lbnQnLFxuICAgICAgICAgIGRhdGE6IGRhdGFWYWx1ZXMsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbJyM1NUNCRTUnLCAnI2U3NGMzYycsICcjRjM5NjU1JywgJyNCNzdDRTknXSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiA0LFxuICAgICAgICAgIGhvdmVyT2Zmc2V0OiAyMCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICB0aXRsZToge1xuICAgICAgICAgIGRpc3BsYXk6IHRydWUsXG4gICAgICAgICAgdGV4dDogYEluY29tZSBTb3VyY2VzIGF0IFJldGlyZW1lbnRgLFxuICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHNpemU6IDIwLFxuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGJveFdpZHRoOiAxNCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDE2LFxuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgbGFiZWw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHgucGFyc2VkO1xuICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKCh2YWx1ZSAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke1xuICAgICAgICAgICAgICAgIGN0eC5sYWJlbFxuICAgICAgICAgICAgICB9OiAkJHt2YWx1ZS50b0xvY2FsZVN0cmluZygpfSAoJHtwZXJjZW50YWdlfSUpYDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgZGF0YWxhYmVsczoge1xuICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKHZhbHVlIC8gdG90YWwpICogMTAwO1xuICAgICAgICAgICAgcmV0dXJuIHBlcmNlbnRhZ2UgPj0gNSA/IGAke3BlcmNlbnRhZ2UudG9GaXhlZCgxKX0lYCA6ICcnO1xuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgYW5pbWF0aW9uOiB7XG4gICAgICAgIGFuaW1hdGVSb3RhdGU6IHRydWUsXG4gICAgICAgIGFuaW1hdGVTY2FsZTogdHJ1ZSxcbiAgICAgICAgZHVyYXRpb246IDE1MDAsXG4gICAgICAgIGVhc2luZzogJ2Vhc2VPdXRCb3VuY2UnLFxuICAgICAgfSxcbiAgICB9LFxuICAgIHBsdWdpbnM6IFtDaGFydERhdGFMYWJlbHNdLFxuICB9KTtcbn1cbiIsImltcG9ydCB7IENoYXJ0LCByZWdpc3RlcmFibGVzIH0gZnJvbSAnY2hhcnQuanMnO1xuQ2hhcnQucmVnaXN0ZXIoLi4ucmVnaXN0ZXJhYmxlcyk7XG5pbXBvcnQgQ2hhcnREYXRhTGFiZWxzIGZyb20gJ2NoYXJ0anMtcGx1Z2luLWRhdGFsYWJlbHMnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZW5kZXJQb3J0Zm9saW9QaWVDaGFydChcbiAgYWRqdXN0ZWRSZW50SW5jb21lLFxuICBvcGVyYXRpbmdFeHBlbnNlcyxcbiAgY2FzaEZsb3dBbm51YWwsXG4gIHRpbWVEdXJhdGlvbiA9IDFcbikge1xuICBjb25zdCBjdHggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9ydGZvbGlvUGllQ2hhcnQnKS5nZXRDb250ZXh0KCcyZCcpO1xuXG4gIGlmICh3aW5kb3cucG9ydGZvbGlvUGllQ2hhcnQgaW5zdGFuY2VvZiBDaGFydCkge1xuICAgIHdpbmRvdy5wb3J0Zm9saW9QaWVDaGFydC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBTY2FsZSB2YWx1ZXMgYmFzZWQgb24gc2VsZWN0ZWQgZHVyYXRpb25cbiAgY29uc3Qgc2NhbGVkSW5jb21lID0gYWRqdXN0ZWRSZW50SW5jb21lICogdGltZUR1cmF0aW9uO1xuICBjb25zdCBzY2FsZWRFeHBlbnNlcyA9IG9wZXJhdGluZ0V4cGVuc2VzICogdGltZUR1cmF0aW9uO1xuICBjb25zdCBzY2FsZWRDYXNoRmxvdyA9IGNhc2hGbG93QW5udWFsICogdGltZUR1cmF0aW9uO1xuXG4gIGNvbnN0IGxhYmVscyA9IFsnSW5jb21lJywgJ0V4cGVuc2VzJ107XG4gIGNvbnN0IHZhbHVlcyA9IFtzY2FsZWRJbmNvbWUsIHNjYWxlZEV4cGVuc2VzXTtcbiAgY29uc3QgY29sb3JzID0gWycjQjc3Q0U5JywgJyM1NUNCRTUnXTtcblxuICBjb25zdCBwcm9maXRMYWJlbCA9IHNjYWxlZENhc2hGbG93ID49IDAgPyAnUHJvZml0JyA6ICdMb3NzJztcbiAgY29uc3QgcHJvZml0VmFsdWUgPSBNYXRoLmFicyhzY2FsZWRDYXNoRmxvdyk7XG4gIGNvbnN0IHByb2ZpdENvbG9yID0gc2NhbGVkQ2FzaEZsb3cgPj0gMCA/ICcjM0I4RDIxJyA6ICcjRjM5NjU1JztcblxuICBsYWJlbHMucHVzaChwcm9maXRMYWJlbCk7XG4gIHZhbHVlcy5wdXNoKHByb2ZpdFZhbHVlKTtcbiAgY29sb3JzLnB1c2gocHJvZml0Q29sb3IpO1xuXG4gIGNvbnN0IHRvdGFsID0gdmFsdWVzLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuXG4gIHdpbmRvdy5wb3J0Zm9saW9QaWVDaGFydCA9IG5ldyBDaGFydChjdHgsIHtcbiAgICB0eXBlOiAncGllJyxcbiAgICBkYXRhOiB7XG4gICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMsXG4gICAgICAgICAgYm9yZGVyQ29sb3I6ICcjZmZmJyxcbiAgICAgICAgICBib3JkZXJXaWR0aDogMixcbiAgICAgICAgICBob3Zlck9mZnNldDogMTIsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH0sXG4gICAgb3B0aW9uczoge1xuICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICAgIHBsdWdpbnM6IHtcbiAgICAgICAgbGVnZW5kOiB7XG4gICAgICAgICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgICAgICAgIGxhYmVsczoge1xuICAgICAgICAgICAgY29sb3I6ICdibGFjaycsXG4gICAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICAgIHNpemU6IDE0LFxuICAgICAgICAgICAgICBmYW1pbHk6ICdBcmlhbCwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGFkZGluZzogMTUsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgIHRleHQ6IGBQb3J0Zm9saW8gQ29tcG9zaXRpb24gKE92ZXIgJHt0aW1lRHVyYXRpb259IFllYXIke1xuICAgICAgICAgICAgdGltZUR1cmF0aW9uID4gMSA/ICdzJyA6ICcnXG4gICAgICAgICAgfSlgLFxuICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgIHNpemU6IDIwLFxuICAgICAgICAgICAgd2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICBmYW1pbHk6ICdBcmlhbCwgc2Fucy1zZXJpZicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb2xvcjogJyMzMzMnLFxuICAgICAgICAgIHBhZGRpbmc6IHtcbiAgICAgICAgICAgIHRvcDogMTAsXG4gICAgICAgICAgICBib3R0b206IDIwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHRvb2x0aXA6IHtcbiAgICAgICAgICBjYWxsYmFja3M6IHtcbiAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQoY29udGV4dC5yYXcpO1xuICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKCh2YWx1ZSAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2NvbnRleHQubGFiZWx9OiAkJHt2YWx1ZS50b0ZpeGVkKDIpfSAoJHtwZXJjZW50YWdlfSUpYDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhZnRlckJvZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGBUb3RhbDogJCR7dG90YWwudG9GaXhlZCgyKX1gO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgc2l6ZTogMTQsXG4gICAgICAgICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlLCBjb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YS5yZWR1Y2UoXG4gICAgICAgICAgICAgIChhLCBiKSA9PiBhICsgYixcbiAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAoKHZhbHVlIC8gc3VtKSAqIDEwMCkudG9GaXhlZCgxKTtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlID49IDUgPyBgJHtwZXJjZW50YWdlfSVgIDogJyc7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBwbHVnaW5zOiBbQ2hhcnREYXRhTGFiZWxzXSxcbiAgfSk7XG59XG4iLCJpbXBvcnQgeyBDaGFydCwgcmVnaXN0ZXJhYmxlcyB9IGZyb20gJ2NoYXJ0LmpzJztcbkNoYXJ0LnJlZ2lzdGVyKC4uLnJlZ2lzdGVyYWJsZXMpO1xuaW1wb3J0IENoYXJ0RGF0YUxhYmVscyBmcm9tICdjaGFydGpzLXBsdWdpbi1kYXRhbGFiZWxzJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlUHJvamVjdENvc3RCcmVha2Rvd25DaGFydChkYXRhKSB7XG4gIGNvbnN0IGN0eCA9IGRvY3VtZW50XG4gICAgLmdldEVsZW1lbnRCeUlkKCdwcm9qZWN0Q29zdEJyZWFrZG93bkNoYXJ0JylcbiAgICAuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAvLyBDb21iaW5lIGhvbGRpbmctcmVsYXRlZCBjb3N0cyBpbnRvIG9uZVxuICBjb25zdCBjb21iaW5lZEhvbGRpbmcgPVxuICAgIGRhdGEuaG9sZGluZyArXG4gICAgZGF0YS5sb2FuSW50ZXJlc3QgK1xuICAgIGRhdGEucHJvcmF0ZWRUYXhlcyArXG4gICAgZGF0YS5wcm9yYXRlZEluc3VyYW5jZTtcblxuICBjb25zdCBsYWJlbHMgPSBbXG4gICAgJ1B1cmNoYXNlJyxcbiAgICAnUmVub3ZhdGlvbicsXG4gICAgJ0hvbGRpbmcgKGluY2wuIGludGVyZXN0LCB0YXhlcywgaW5zdXJhbmNlKScsXG4gICAgJ0xvYW4gRmVlcycsXG4gICAgJ1Jlc2FsZSBDb3N0cycsXG4gICAgJ0Nsb3NpbmcgQ29zdHMnLFxuICBdO1xuXG4gIGNvbnN0IHZhbHVlcyA9IFtcbiAgICBkYXRhLnB1cmNoYXNlLFxuICAgIGRhdGEucmVubyxcbiAgICBjb21iaW5lZEhvbGRpbmcsXG4gICAgZGF0YS5sb2FuRmVlcyxcbiAgICBkYXRhLnJlc2FsZUNvc3RzLFxuICAgIGRhdGEuY2xvc2luZyxcbiAgXTtcblxuICBjb25zdCB0b3RhbCA9IHZhbHVlcy5yZWR1Y2UoKGEsIGIpID0+IGEgKyBiLCAwKTtcblxuICBuZXcgQ2hhcnQoY3R4LCB7XG4gICAgdHlwZTogJ2RvdWdobnV0JyxcbiAgICBkYXRhOiB7XG4gICAgICBsYWJlbHM6IGxhYmVscyxcbiAgICAgIGRhdGFzZXRzOiBbXG4gICAgICAgIHtcbiAgICAgICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBbXG4gICAgICAgICAgICAnI0YzOTY1NScsXG4gICAgICAgICAgICAnI0I3N0NFOScsXG4gICAgICAgICAgICAnIzU1Q0JFNScsXG4gICAgICAgICAgICAnI2U3NGMzYycsXG4gICAgICAgICAgICAnIzFhYmM5YycsXG4gICAgICAgICAgICAnI2U2N2UyMicsXG4gICAgICAgICAgXSxcbiAgICAgICAgICBib3JkZXJDb2xvcjogJyNmZmZmZmYnLFxuICAgICAgICAgIGJvcmRlcldpZHRoOiA0LFxuICAgICAgICAgIGhvdmVyT2Zmc2V0OiAyMCxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfSxcbiAgICBvcHRpb25zOiB7XG4gICAgICByZXNwb25zaXZlOiB0cnVlLFxuICAgICAgY3V0b3V0OiAnMCUnLFxuICAgICAgcGx1Z2luczoge1xuICAgICAgICBkYXRhbGFiZWxzOiB7XG4gICAgICAgICAgY29sb3I6ICcjZmZmZmZmJyxcbiAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICB3ZWlnaHQ6ICdib2xkJyxcbiAgICAgICAgICAgIHNpemU6IDE0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgZm9ybWF0dGVyOiAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBlcmNlbnRhZ2UgPSAodmFsdWUgLyB0b3RhbCkgKiAxMDA7XG4gICAgICAgICAgICByZXR1cm4gYCR7cGVyY2VudGFnZS50b0ZpeGVkKDEpfSVgO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZGlzcGxheTogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY29udGV4dC5kYXRhc2V0LmRhdGFbY29udGV4dC5kYXRhSW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9ICh2YWx1ZSAvIHRvdGFsKSAqIDEwMDtcbiAgICAgICAgICAgIHJldHVybiBwZXJjZW50YWdlID49IDU7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICBkaXNwbGF5OiB0cnVlLFxuICAgICAgICAgIHRleHQ6ICdQcm9qZWN0IENvc3QgQnJlYWtkb3duJyxcbiAgICAgICAgICBmb250OiB7XG4gICAgICAgICAgICBzaXplOiAyMCxcbiAgICAgICAgICAgIHdlaWdodDogJ2JvbGQnLFxuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBsZWdlbmQ6IHtcbiAgICAgICAgICBwb3NpdGlvbjogJ3JpZ2h0JyxcbiAgICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGJveFdpZHRoOiAxNCxcbiAgICAgICAgICAgIHBhZGRpbmc6IDE2LFxuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICBzaXplOiAxNCxcbiAgICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9vbHRpcDoge1xuICAgICAgICAgIGNhbGxiYWNrczoge1xuICAgICAgICAgICAgbGFiZWw6IGZ1bmN0aW9uIChjdHgpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHgucGFyc2VkO1xuICAgICAgICAgICAgICBjb25zdCBwZXJjZW50YWdlID0gKCh2YWx1ZSAvIHRvdGFsKSAqIDEwMCkudG9GaXhlZCgyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIGAke1xuICAgICAgICAgICAgICAgIGN0eC5sYWJlbFxuICAgICAgICAgICAgICB9OiAkJHt2YWx1ZS50b0xvY2FsZVN0cmluZygpfSAoJHtwZXJjZW50YWdlfSUpYDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSxcbiAgICBwbHVnaW5zOiBbQ2hhcnREYXRhTGFiZWxzXSxcbiAgfSk7XG59XG4iLCJcbiAgICAgIGltcG9ydCBBUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIjtcbiAgICAgIGltcG9ydCBkb21BUEkgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydEZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0QnlTZWxlY3Rvci5qc1wiO1xuICAgICAgaW1wb3J0IHNldEF0dHJpYnV0ZXMgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMuanNcIjtcbiAgICAgIGltcG9ydCBpbnNlcnRTdHlsZUVsZW1lbnQgZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRTdHlsZUVsZW1lbnQuanNcIjtcbiAgICAgIGltcG9ydCBzdHlsZVRhZ1RyYW5zZm9ybUZuIGZyb20gXCIhLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvc3R5bGVUYWdUcmFuc2Zvcm0uanNcIjtcbiAgICAgIGltcG9ydCBjb250ZW50LCAqIGFzIG5hbWVkRXhwb3J0IGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuY3NzXCI7XG4gICAgICBcbiAgICAgIFxuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLnN0eWxlVGFnVHJhbnNmb3JtID0gc3R5bGVUYWdUcmFuc2Zvcm1Gbjtcbm9wdGlvbnMuc2V0QXR0cmlidXRlcyA9IHNldEF0dHJpYnV0ZXM7XG5vcHRpb25zLmluc2VydCA9IGluc2VydEZuLmJpbmQobnVsbCwgXCJoZWFkXCIpO1xub3B0aW9ucy5kb21BUEkgPSBkb21BUEk7XG5vcHRpb25zLmluc2VydFN0eWxlRWxlbWVudCA9IGluc2VydFN0eWxlRWxlbWVudDtcblxudmFyIHVwZGF0ZSA9IEFQSShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCAqIGZyb20gXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vc3R5bGUuY3NzXCI7XG4gICAgICAgZXhwb3J0IGRlZmF1bHQgY29udGVudCAmJiBjb250ZW50LmxvY2FscyA/IGNvbnRlbnQubG9jYWxzIDogdW5kZWZpbmVkO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZm9ybWF0TnVtYmVyUGVyY2VudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgJSAxID09PSAwXG4gICAgPyB2YWx1ZS50b0xvY2FsZVN0cmluZygpXG4gICAgOiB2YWx1ZS50b0xvY2FsZVN0cmluZyh1bmRlZmluZWQsIHtcbiAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICBtYXhpbXVtRnJhY3Rpb25EaWdpdHM6IDIsXG4gICAgICB9KTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZvcm1hdE51bWJlcih2YWx1ZSkge1xuICBsZXQgZm9ybWF0dGVkVmFsdWUgPVxuICAgIHZhbHVlICUgMSA9PT0gMFxuICAgICAgPyBNYXRoLmFicyh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoKVxuICAgICAgOiBNYXRoLmFicyh2YWx1ZSkudG9Mb2NhbGVTdHJpbmcodW5kZWZpbmVkLCB7XG4gICAgICAgICAgbWluaW11bUZyYWN0aW9uRGlnaXRzOiAyLFxuICAgICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMixcbiAgICAgICAgfSk7XG5cbiAgcmV0dXJuIHZhbHVlIDwgMCA/IGAtICQke2Zvcm1hdHRlZFZhbHVlfWAgOiBgJCR7Zm9ybWF0dGVkVmFsdWV9YDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdlbmVyYXRlQ29tYmluZWRZZWFyVGFibGUoZGF0YUFycmF5KSB7XG4gIGNvbnN0IGR5bmFtaWNDYXRlZ29yaWVzID0gW1xuICAgICdHcm9zcyBSZW50JyxcbiAgICAnVmFjYW5jeScsXG4gICAgJ09wZXJhdGluZyBJbmNvbWUnLFxuICAgICdPcGVyYXRpbmcgRXhwZW5zZXMnLFxuICAgICdNYW5hZ2VtZW50IEZlZXMnLFxuICAgICdWYWNhbmN5IExvc3MnLFxuICAgICdOZXQgT3BlcmF0aW5nIEluY29tZSAoTk9JKScsXG4gICAgJ0xvYW4gUGF5bWVudHMnLFxuICAgICdDYXBpdGFsIEV4cGVuZGl0dXJlcycsXG4gICAgJ0Nhc2ggRmxvdycsXG4gIF07XG5cbiAgY29uc3Qgc3RhdGljRXhwZW5zZXMgPSB7XG4gICAgJ1Byb3BlcnR5IFRheGVzJzpcbiAgICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb3BlcnR5VGF4ZXMnKS52YWx1ZSkgfHwgMCxcbiAgICBJbnN1cmFuY2U6IHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2luc3VyYW5jZUNvc3RzJykudmFsdWUpIHx8IDAsXG4gICAgTWFpbnRlbmFuY2U6XG4gICAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWludGVuYW5jZUNvc3RzJykudmFsdWUpIHx8IDAsXG4gICAgVXRpbGl0aWVzOiBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1dGlsaXRpZXMnKS52YWx1ZSkgfHwgMCxcbiAgICBSZW5vdmF0aW9uczogcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVub3ZhdGlvbnMnKS52YWx1ZSkgfHwgMCxcbiAgfTtcblxuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgZGl2LmNsYXNzTGlzdC5hZGQoJ21iLTUnLCAndGFibGUtZGVzaWduJyk7XG5cbiAgLy8g8J+MnyBTdGF0aWMgRXhwZW5zZXMgVGFibGVcbiAgbGV0IHN0YXRpY1RhYmxlID0gYFxuICAgICAgPGg1PkZpeGVkIEFubnVhbCBFeHBlbnNlczwvaDU+XG4gICAgICA8dGFibGUgY2xhc3M9XCJ0YWJsZSB0YWJsZS1ib3JkZXJlZFwiPlxuICAgICAgICA8dGhlYWQgY2xhc3M9XCJjbHItYmdcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6ICMzMzMzMzM7IGNvbG9yOiB3aGl0ZTtcIj5cbiAgICAgICAgICA8dHI+PHRoPkNhdGVnb3J5PC90aD48dGg+QW1vdW50PC90aD48L3RyPlxuICAgICAgICA8L3RoZWFkPlxuICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgJHtPYmplY3QuZW50cmllcyhzdGF0aWNFeHBlbnNlcylcbiAgICAgICAgICAgIC5tYXAoXG4gICAgICAgICAgICAgIChba2V5LCB2YWxdKSA9PiBgXG4gICAgICAgICAgICA8dHI+PHRkPiR7a2V5fTwvdGQ+PHRkPiQke3ZhbC50b0ZpeGVkKDIpfTwvdGQ+PC90cj5cbiAgICAgICAgICBgXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuam9pbignJyl9XG4gICAgICAgIDwvdGJvZHk+XG4gICAgICA8L3RhYmxlPlxuICAgIGA7XG5cbiAgLy8g8J+ThSBZZWFybHkgRGF0YSBUYWJsZSAoRHluYW1pYyBWYWx1ZXMpXG4gIGxldCBkeW5hbWljVGFibGUgPSBgXG4gICAgICA8aDU+WWVhcmx5IEZpbmFuY2lhbHM6IFllYXJzICR7ZGF0YUFycmF5XG4gICAgICAgIC5tYXAoKGQpID0+IGQueWVhcilcbiAgICAgICAgLmpvaW4oJywgJyl9PC9oNT5cbiAgICAgIDx0YWJsZSBjbGFzcz1cInRhYmxlIHRhYmxlLWJvcmRlcmVkXCI+XG4gICAgICAgIDx0aGVhZCBjbGFzcz1cImNsci1iZ1wiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogIzMzMzMzMzsgY29sb3I6IHdoaXRlO1wiPlxuICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgIDx0aD5DYXRlZ29yeTwvdGg+XG4gICAgICAgICAgICAke2RhdGFBcnJheS5tYXAoKGQpID0+IGA8dGg+WWVhciAke2QueWVhcn08L3RoPmApLmpvaW4oJycpfVxuICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGhlYWQ+XG4gICAgICAgIDx0Ym9keT5cbiAgICBgO1xuXG4gIGR5bmFtaWNDYXRlZ29yaWVzLmZvckVhY2goKGNhdCkgPT4ge1xuICAgIGR5bmFtaWNUYWJsZSArPSBgPHRyPjx0ZD4ke2NhdH08L3RkPmA7XG4gICAgZGF0YUFycmF5LmZvckVhY2goKGRhdGEpID0+IHtcbiAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICBzd2l0Y2ggKGNhdCkge1xuICAgICAgICBjYXNlICdHcm9zcyBSZW50JzpcbiAgICAgICAgICB2YWx1ZSA9IGRhdGEuZ3Jvc3NSZW50SW5jb21lO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdWYWNhbmN5JzpcbiAgICAgICAgICB2YWx1ZSA9IGRhdGEudmFjYW5jeUxvc3M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09wZXJhdGluZyBJbmNvbWUnOlxuICAgICAgICAgIHZhbHVlID0gZGF0YS5hZGp1c3RlZFJlbnRJbmNvbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ09wZXJhdGluZyBFeHBlbnNlcyc6XG4gICAgICAgICAgdmFsdWUgPSBkYXRhLm9wZXJhdGluZ0V4cGVuc2VzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNYW5hZ2VtZW50IEZlZXMnOlxuICAgICAgICAgIHZhbHVlID1cbiAgICAgICAgICAgIChkYXRhLmFkanVzdGVkUmVudEluY29tZSAqXG4gICAgICAgICAgICAgIChwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYW5hZ2VtZW50RmVlcycpLnZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIDApKSAvXG4gICAgICAgICAgICAxMDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1ZhY2FuY3kgTG9zcyc6XG4gICAgICAgICAgdmFsdWUgPSBkYXRhLnZhY2FuY3lMb3NzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdOZXQgT3BlcmF0aW5nIEluY29tZSAoTk9JKSc6XG4gICAgICAgICAgdmFsdWUgPSBkYXRhLm5ldE9wZXJhdGluZ0luY29tZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTG9hbiBQYXltZW50cyc6XG4gICAgICAgICAgdmFsdWUgPSAtZGF0YS5hbm51YWxNb3J0Z2FnZVBheW1lbnQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0NhcGl0YWwgRXhwZW5kaXR1cmVzJzpcbiAgICAgICAgICB2YWx1ZSA9IC1kYXRhLmNhcGl0YWxFeHBlbmRpdHVyZXM7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0Nhc2ggRmxvdyc6XG4gICAgICAgICAgdmFsdWUgPSBkYXRhLmNhc2hGbG93O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZHluYW1pY1RhYmxlICs9IGA8dGQ+JCR7dmFsdWUudG9GaXhlZCgyKX08L3RkPmA7XG4gICAgfSk7XG4gICAgZHluYW1pY1RhYmxlICs9IGA8L3RyPmA7XG4gIH0pO1xuXG4gIGR5bmFtaWNUYWJsZSArPSBgPC90Ym9keT48L3RhYmxlPmA7XG5cbiAgLy8g8J+nqSBDb21iaW5lIGFuZCBSZXR1cm5cbiAgZGl2LmlubmVySFRNTCA9IGR5bmFtaWNUYWJsZSArIHN0YXRpY1RhYmxlO1xuICByZXR1cm4gZGl2O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW50ZXJlc3RQcm9qZWN0RHVyYXRpb24oXG4gIHByaW5jaXBhbCxcbiAgbW9udGhseVBtdHMsXG4gIHByb2plY3RNb250aHMsXG4gIG1vbnRobHlJbnRlcmVzdFxuKSB7XG4gIGxldCBpbnRlcmVzdEFjY3J1ZWQgPSAwO1xuICBsZXQgcmVtYWluaW5nQmFsYW5jZSA9IHByaW5jaXBhbDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHByb2plY3RNb250aHM7IGkrKykge1xuICAgIGNvbnN0IGludGVyZXN0ID0gcmVtYWluaW5nQmFsYW5jZSAqIG1vbnRobHlJbnRlcmVzdDtcbiAgICBpbnRlcmVzdEFjY3J1ZWQgKz0gaW50ZXJlc3Q7XG4gICAgcmVtYWluaW5nQmFsYW5jZSArPSBpbnRlcmVzdCAtIG1vbnRobHlQbXRzO1xuICB9XG5cbiAgcmV0dXJuIGludGVyZXN0QWNjcnVlZDtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHBvcHVsYXRlWWVhcnNEcm9wZG93bigpIHtcbiAgY29uc3Qgc2VsZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3llYXJzX3RibCcpO1xuICBzZWxlY3QuaW5uZXJIVE1MID0gJyc7IC8vIENsZWFyIGV4aXN0aW5nIG9wdGlvbnNcblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSAzMDsgaSsrKSB7XG4gICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgb3B0aW9uLnZhbHVlID0gaTtcbiAgICBvcHRpb24udGV4dENvbnRlbnQgPSBgJHtpfSAke2kgPT09IDEgPyAnWWVhcicgOiAnWWVhcnMnfWA7XG5cbiAgICAvLyBTZXQgMTAgeWVhcnMgYXMgdGhlIGRlZmF1bHQgc2VsZWN0ZWQgdmFsdWVcbiAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzZWxlY3QuYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VGFibGVEYXRhKHllYXIsIHJldHVybkRhdGEgPSBmYWxzZSkge1xuICAvLyBHZXQgdmFsdWVzIGFuZCBjb252ZXJ0IHRvIG51bWJlcnNcbiAgbGV0IHByb3BlcnR5UHJpY2UgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb3BlcnR5UHJpY2UnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBkb3duUGF5bWVudCA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZG93blBheW1lbnQnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBsb2FuVGVybSA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbG9hblRlcm0nKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBpbnRlcmVzdFJhdGUgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ludGVyZXN0UmF0ZScpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IG1vbnRobHlSZW50ID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb250aGx5UmVudCcpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IHZhY2FuY3lSYXRlID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2YWNhbmN5UmF0ZScpLnZhbHVlLnRyaW0oKSkgfHwgMDtcbiAgbGV0IHByb3BlcnR5VGF4ZXMgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Byb3BlcnR5VGF4ZXMnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBpbnN1cmFuY2VDb3N0cyA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW5zdXJhbmNlQ29zdHMnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCBtYWludGVuYW5jZUNvc3RzID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtYWludGVuYW5jZUNvc3RzJykudmFsdWUudHJpbSgpKSB8fCAwO1xuICBsZXQgbWFuYWdlbWVudEZlZXMgPVxuICAgIHBhcnNlRmxvYXQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21hbmFnZW1lbnRGZWVzJykudmFsdWUudHJpbSgpKSB8fCAwO1xuICBsZXQgYXBwcmVjaWF0aW9uUmF0ZSA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwcmVjaWF0aW9uUmF0ZScpLnZhbHVlLnRyaW0oKSkgfHwgMztcbiAgbGV0IHJlbnRJbmNyZWFzZVJhdGUgPSAyO1xuICBsZXQgdXRpbGl0aWVzID1cbiAgICBwYXJzZUZsb2F0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd1dGlsaXRpZXMnKS52YWx1ZS50cmltKCkpIHx8IDA7XG4gIGxldCByZW5vdmF0aW9ucyA9XG4gICAgcGFyc2VGbG9hdChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncmVub3ZhdGlvbnMnKS52YWx1ZS50cmltKCkpIHx8IDA7XG5cbiAgaWYgKCF5ZWFyIHx8IHllYXIgPCAwKSByZXR1cm47XG5cbiAgLy8gTG9hbiBjYWxjdWxhdGlvblxuICBsZXQgbG9hbkFtb3VudCA9IHByb3BlcnR5UHJpY2UgLSBkb3duUGF5bWVudDtcbiAgbGV0IG1vbnRobHlSYXRlID0gaW50ZXJlc3RSYXRlIC8gMTAwIC8gMTI7XG4gIGxldCBudW1QYXltZW50cyA9IGxvYW5UZXJtICogMTI7XG4gIGxldCBtb3J0Z2FnZVBheW1lbnQgPVxuICAgIG1vbnRobHlSYXRlID4gMFxuICAgICAgPyAobG9hbkFtb3VudCAqIChtb250aGx5UmF0ZSAqIE1hdGgucG93KDEgKyBtb250aGx5UmF0ZSwgbnVtUGF5bWVudHMpKSkgL1xuICAgICAgICAoTWF0aC5wb3coMSArIG1vbnRobHlSYXRlLCBudW1QYXltZW50cykgLSAxKVxuICAgICAgOiBsb2FuQW1vdW50IC8gbnVtUGF5bWVudHM7XG5cbiAgLy8gQXBwcmVjaWF0aW9uIGFuZCBSZW50IGdyb3d0aFxuICBsZXQgYXBwcmVjaWF0aW9uRmFjdG9yID0gTWF0aC5wb3coMSArIGFwcHJlY2lhdGlvblJhdGUgLyAxMDAsIHllYXIpO1xuICBsZXQgcmVudEZhY3RvciA9IE1hdGgucG93KDEgKyByZW50SW5jcmVhc2VSYXRlIC8gMTAwLCB5ZWFyKTtcblxuICBsZXQgZ3Jvc3NSZW50SW5jb21lID0gbW9udGhseVJlbnQgKiAxMiAqIHJlbnRGYWN0b3I7XG4gIGxldCB2YWNhbmN5TG9zcyA9IGdyb3NzUmVudEluY29tZSAqICh2YWNhbmN5UmF0ZSAvIDEwMCk7XG4gIGxldCBhZGp1c3RlZFJlbnRJbmNvbWUgPSBncm9zc1JlbnRJbmNvbWUgLSB2YWNhbmN5TG9zcztcbiAgbGV0IG1hbmFnZW1lbnRDb3N0ID0gZ3Jvc3NSZW50SW5jb21lICogKG1hbmFnZW1lbnRGZWVzIC8gMTAwKTtcblxuICAvLyBPcGVyYXRpbmcgRXhwZW5zZXNcbiAgbGV0IG9wZXJhdGluZ0V4cGVuc2VzID1cbiAgICB2YWNhbmN5TG9zcyArXG4gICAgcHJvcGVydHlUYXhlcyArXG4gICAgaW5zdXJhbmNlQ29zdHMgK1xuICAgIG1haW50ZW5hbmNlQ29zdHMgK1xuICAgIG1hbmFnZW1lbnRDb3N0ICtcbiAgICB1dGlsaXRpZXMgK1xuICAgIHJlbm92YXRpb25zO1xuXG4gIGxldCBuZXRPcGVyYXRpbmdJbmNvbWUgPSBncm9zc1JlbnRJbmNvbWUgLSBvcGVyYXRpbmdFeHBlbnNlcztcbiAgbGV0IGFubnVhbE1vcnRnYWdlUGF5bWVudCA9IG1vcnRnYWdlUGF5bWVudCAqIDEyO1xuICBsZXQgY2FzaEZsb3dBbm51YWwgPSBuZXRPcGVyYXRpbmdJbmNvbWUgLSBhbm51YWxNb3J0Z2FnZVBheW1lbnQ7XG5cbiAgLy8gSWYgcmV0dXJuRGF0YSBpcyB0cnVlLCBzZW5kIHZhbHVlcyBiYWNrIGluc3RlYWQgb2YgdXBkYXRpbmcgVUlcbiAgaWYgKHJldHVybkRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcixcbiAgICAgIGdyb3NzUmVudEluY29tZSxcbiAgICAgIHZhY2FuY3lMb3NzLFxuICAgICAgYWRqdXN0ZWRSZW50SW5jb21lLFxuICAgICAgb3BlcmF0aW5nRXhwZW5zZXMsXG4gICAgICBuZXRPcGVyYXRpbmdJbmNvbWUsXG4gICAgICBhbm51YWxNb3J0Z2FnZVBheW1lbnQsXG4gICAgICBjYXBpdGFsRXhwZW5kaXR1cmVzOiAxNDI1LCAvLyBvciBkeW5hbWljIGxhdGVyXG4gICAgICBjYXNoRmxvdzogY2FzaEZsb3dBbm51YWwsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybjtcbiAgLy8gRWxlbWVudHMgYmVsb3cgZG9uJ3QgZXhpc3QgaW4gdGhlIERPTVxuXG4gIC8vIFVwZGF0ZSBVSVxuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgneWVhcl9iJykuaW5uZXJIVE1MID0geWVhcjtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2dyb3NzX3JlbnQnKS5pbm5lclRleHQgPSBgJCR7Z3Jvc3NSZW50SW5jb21lLnRvRml4ZWQoXG4gICAgMlxuICApfWA7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2YWNhbmN5X3JhdGUnKS5pbm5lclRleHQgPSBg4oCTICQke3ZhY2FuY3lMb3NzLnRvRml4ZWQoXG4gICAgMlxuICApfWA7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICdvcGVyYXRpbmdfaW5jb21lJ1xuICApLmlubmVyVGV4dCA9IGAkJHthZGp1c3RlZFJlbnRJbmNvbWUudG9GaXhlZCgyKX1gO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAnb3BlcmF0aW5nX2V4cGVuc2VzJ1xuICApLmlubmVyVGV4dCA9IGDigJMgJCR7b3BlcmF0aW5nRXhwZW5zZXMudG9GaXhlZCgyKX1gO1xuICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcbiAgICAnbmV0X29wZXJhdGluZ19pbmNvbWUnXG4gICkuaW5uZXJUZXh0ID0gYCQke25ldE9wZXJhdGluZ0luY29tZS50b0ZpeGVkKDIpfWA7XG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICdsb2FuX3BheW1lbnRzJ1xuICApLmlubmVyVGV4dCA9IGDigJMgJCR7YW5udWFsTW9ydGdhZ2VQYXltZW50LnRvRml4ZWQoMil9YDtcbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nhc2hfZmxvdycpLmlubmVyVGV4dCA9IGAkJHtjYXNoRmxvd0FubnVhbC50b0ZpeGVkKFxuICAgIDJcbiAgKX1gO1xuXG4gIGNvbnNvbGUubG9nKGBEYXRhIGRpc3BsYXllZCBmb3IgeWVhcjogJHt5ZWFyfWApO1xufVxuIiwiaW1wb3J0IGdldFRhYmxlRGF0YSBmcm9tICcuL3RhYmxlLWRhdGEnO1xuaW1wb3J0IGdlbmVyYXRlQ29tYmluZWRZZWFyVGFibGUgZnJvbSAnLi9nZW5lcmF0ZS10YWJsZS1tYXJrdXAnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVUYWJsZVJhbmdlKCkge1xuICBjb25zdCBzZWxlY3RlZFllYXIgPSBwYXJzZUludChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgneWVhcnNfdGJsJykudmFsdWUpO1xuICBjb25zdCB0YWJsZUNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd5ZWFybHlUYWJsZXMnKTtcbiAgdGFibGVDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG5cbiAgbGV0IHllYXJzID0gW107XG4gIGlmIChzZWxlY3RlZFllYXIgPD0gMSkge1xuICAgIHllYXJzID0gWzAsIDEsIDJdO1xuICB9IGVsc2UgaWYgKHNlbGVjdGVkWWVhciA+PSAzMCkge1xuICAgIHllYXJzID0gWzI4LCAyOSwgMzBdO1xuICB9IGVsc2Uge1xuICAgIHllYXJzID0gW3NlbGVjdGVkWWVhciAtIDEsIHNlbGVjdGVkWWVhciwgc2VsZWN0ZWRZZWFyICsgMV07XG4gIH1cblxuICBjb25zdCB0YWJsZURhdGEgPSB5ZWFyc1xuICAgIC5tYXAoKHllYXIpID0+IGdldFRhYmxlRGF0YSh5ZWFyLCB0cnVlKSlcbiAgICAuZmlsdGVyKEJvb2xlYW4pO1xuICBpZiAodGFibGVEYXRhLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBjb21iaW5lZFRhYmxlID0gZ2VuZXJhdGVDb21iaW5lZFllYXJUYWJsZSh0YWJsZURhdGEpO1xuICAgIHRhYmxlQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbWJpbmVkVGFibGUpO1xuICB9XG59XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdGlkOiBtb2R1bGVJZCxcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5uYyA9IHVuZGVmaW5lZDsiLCJpbXBvcnQgJy4vc3R5bGUuY3NzJztcclxuaW1wb3J0ICcuL2J1ZGdldC10YWJsZS5jc3MnO1xyXG5pbXBvcnQgY2FsY3VsYXRlSG91c2VGbGlwIGZyb20gJy4vY2FsY3VsYXRvcnMvaG91c2UtZmxpcCc7XHJcbmltcG9ydCBjYWxjdWxhdGVSZXRpcmVtZW50IGZyb20gJy4vY2FsY3VsYXRvcnMvY2FsY3VsYXRlLXJldGlyZW1lbnQnO1xyXG5pbXBvcnQgY2FsY3VsYXRlUmVudGFsUHJvcGVydHkgZnJvbSAnLi9jYWxjdWxhdG9ycy9yZW50YWwnO1xyXG5pbXBvcnQgdXBkYXRlVGFibGVSYW5nZSBmcm9tICcuL3V0aWxzL3VwZGF0ZS10YWJsZS1yYW5nZSc7XHJcbmltcG9ydCBwb3B1bGF0ZVllYXJzRHJvcGRvd24gZnJvbSAnLi91dGlscy9wb3B1bGF0ZS15ZWFycy1kcm9wZG93bic7XHJcbmltcG9ydCBpbml0aWFsaXplUGRmTGlzdGVuZXJzIGZyb20gJy4uL2Rvd25sb2FkZXJzL3BkZi1ldmVudC1saXN0ZW5lcnMnO1xyXG5cclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICBjb25zdCBpbnB1dHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxyXG4gICAgJyNwdXJjaGFzZVByaWNlLCNwcm9wZXJ0eUFkZHJlc3MsICNyZW5vQ29zdHMsICNob2xkaW5nQ29zdHMsICNkZXNpcmVkUHJvZml0TWFyZ2luLCAjY2xvc2luZ0Nvc3RzLCAjYWZ0ZXJSZXBhaXJWYWx1ZSwjcHJvamVjdE1vbnRocywjcmVzYWxlQ29zdHMsI2Rvd25QYXltZW50UGVyY2VudCwjZ2FwQ29zdHMsI2xvYW5Qb2ludHMsI2hvdXNlTG9hblllYXIsI2hvdXNlaW50ZXJlc3RSYXRlLCNob3VzZU1vbnRobHlSZW50LCNpbnN1cmFuY2UsI3Byb3BlcnR5VGF4ZXNIRiwjZG93blBheW1lbnRUeXBlLCNob3VzZUFubnVhbE1haW50ZW5hbmNlLCNob3VzZUFubnVhbFV0aWxpdGllcydcclxuICApO1xyXG4gIGNvbnN0IGlucHV0MiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXHJcbiAgICAnI2N1cnJlbnRBZ2UsICNyZXRpcmVtZW50QWdlLCAjZXhwZWN0ZWRMaWZlc3BhbiwgI2N1cnJlbnRTYXZpbmdzLCNsaWZlSW5zdXJhbmNlTW9udGhseUNvbnRyaWJ1dGlvbnMsI3dob2xlTGlmZUluc3VyYW5jZSwgI21vbnRobHlDb250cmlidXRpb25zLCAjYW5udWFsUmV0dXJuLCNkZXNpcmVkSW5jb21lLCNpbmZsYXRpb25SYXRlLCNjdXJyZW50UmVhbEVzdGF0ZUVxdWl0eSwjY3VycmVudFN0b2NrVmFsdWUsICNzdG9ja0dyb3d0aFJhdGUsICNyZWFsRXN0YXRlQXBwcmVjaWF0aW9uLCNtb3J0Z2FnZUJhbGFuY2UgLCAjbW9ydGdhZ2VJbnRlcmVzdFJhdGUgLCAjbW9ydGdhZ2VUZXJtJ1xyXG4gICk7XHJcbiAgY29uc3QgaW5wdXQzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcclxuICAgICcjbWFuYWdlbWVudEZlZXMsICNtYWludGVuYW5jZUNvc3RzLCAjaW5zdXJhbmNlQ29zdHMsI3Jlbm92YXRpb25zLCN1dGlsaXRpZXMsI3JlbnRHcm93dGgsI2Nsb3NpbmdDb3N0c1JlbnQsICNwcm9wZXJ0eVRheGVzLCAjdmFjYW5jeVJhdGUsI21vbnRobHlSZW50LCNpbnRlcmVzdFJhdGUsI2xvYW5UZXJtLCNkb3duUGF5bWVudCwjcHJvcGVydHlQcmljZSwjdGltZUR1cmF0aW9uICwgI2FwcHJlY2lhdGlvblJhdGUsICNpbml0aWFsUmVub3ZhdGlvbnMgJ1xyXG4gICk7XHJcblxyXG4gIGlucHV0cy5mb3JFYWNoKChpbnB1dCkgPT4ge1xyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBjYWxjdWxhdGVIb3VzZUZsaXApO1xyXG4gIH0pO1xyXG4gIGlucHV0Mi5mb3JFYWNoKChpbnB1dCkgPT4ge1xyXG4gICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBjYWxjdWxhdGVSZXRpcmVtZW50KTtcclxuICB9KTtcclxuICBpbnB1dDMuZm9yRWFjaCgoaW5wdXQpID0+IHtcclxuICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgY2FsY3VsYXRlUmVudGFsUHJvcGVydHkpO1xyXG4gIH0pO1xyXG5cclxuICBpbml0aWFsaXplUGRmTGlzdGVuZXJzKCk7XHJcblxyXG4gIC8vIEF0dGFjaCBldmVudCBsaXN0ZW5lciB0byBkcm9wZG93biBmb3IgdXBkYXRpbmcgdGFibGUgcmFuZ2VcclxuICBjb25zdCB5ZWFyc0Ryb3Bkb3duID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3llYXJzX3RibCcpO1xyXG4gIGlmICh5ZWFyc0Ryb3Bkb3duKSB7XHJcbiAgICB5ZWFyc0Ryb3Bkb3duLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZVRhYmxlUmFuZ2UpO1xyXG4gIH1cclxuXHJcbiAgLy8gUnVuIGNhbGN1bGF0b3JzXHJcbiAgY2FsY3VsYXRlSG91c2VGbGlwKCk7XHJcbiAgY2FsY3VsYXRlUmV0aXJlbWVudCgpO1xyXG4gIGNhbGN1bGF0ZVJlbnRhbFByb3BlcnR5KCk7XHJcblxyXG4gIC8vIFBvcHVsYXRlIHJlbnRhbCB5ZWFycyBkcm9wZG93blxyXG4gIHBvcHVsYXRlWWVhcnNEcm9wZG93bigpO1xyXG59KTtcclxuIl0sIm5hbWVzIjpbInNldHVwSG91c2VGbGlwUGRmRG93bmxvYWQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndpbmRvdyIsImpzcGRmIiwiaHRtbDJjYW52YXMiLCJqc1BERiIsImRvYyIsImdldFZhbHVlIiwiaWQiLCJlbGVtZW50IiwidmFsdWUiLCJjb21iaW5lZERpdiIsImNyZWF0ZUVsZW1lbnQiLCJzdHlsZSIsInBhZGRpbmciLCJiYWNrZ3JvdW5kQ29sb3IiLCJjb2xvciIsIndpZHRoIiwibWFyZ2luIiwiY29udGVudERpdiIsImFwcGVuZENoaWxkIiwiY2xvbmVOb2RlIiwicmVzdWx0c0RpdiIsImlubmVySFRNTCIsImJvZHkiLCJzY2FsZSIsInVzZUNPUlMiLCJ0aGVuIiwiY2FudmFzIiwiaW1nV2lkdGgiLCJwYWdlSGVpZ2h0IiwiaW50ZXJuYWwiLCJwYWdlU2l6ZSIsImhlaWdodCIsImltZ0hlaWdodCIsImhlaWdodExlZnQiLCJwb3NpdGlvbiIsImltZ0RhdGEiLCJ0b0RhdGFVUkwiLCJhZGRJbWFnZSIsImFkZFBhZ2UiLCJzYXZlIiwicmVtb3ZlIiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJzZXR1cFJldGlyZW1lbnRQZGZEb3dubG9hZCIsInNldHVwUmVudGFsUGRmRG93bmxvYWQiLCJpbml0aWFsaXplUGRmTGlzdGVuZXJzIiwiY2FudmFzMiIsImltZ0RhdGEyIiwiaW1nV2lkdGgyIiwiaW1nSGVpZ2h0MiIsImhlaWdodExlZnQyIiwicG9zaXRpb24yIiwiZm9ybWF0TnVtYmVyIiwicmVuZGVyQXNzZXRCcmVha2Rvd25DaGFydCIsInJlbmRlckluY29tZVNvdXJjZVBpZSIsImNhbGN1bGF0ZVJldGlyZW1lbnQiLCJjdXJyZW50QWdlIiwicmV0aXJlbWVudEFnZSIsImV4cGVjdGVkTGlmZXNwYW4iLCJjdXJyZW50U2F2aW5ncyIsIm1vbnRobHlDb250cmlidXRpb25zIiwiYW5udWFsUmV0dXJuIiwiaW5mbGF0aW9uUmF0ZSIsImRlc2lyZWRJbmNvbWUiLCJyZWFsRXN0YXRlQXBwcmVjaWF0aW9uIiwibW9ydGdhZ2VCYWxhbmNlIiwid2hvbGVMaWZlSW5zdXJhbmNlIiwibGlmZUluc3VyYW5jZU1vbnRobHlDb250cmlidXRpb25zIiwibW9ydGdhZ2VUZXJtIiwibW9ydGdhZ2VJbnRlcmVzdFJhdGUiLCJjdXJyZW50U3RvY2tWYWx1ZSIsImN1cnJlbnRSZWFsRXN0YXRlRXF1aXR5Iiwic3RvY2tHcm93dGhSYXRlIiwiZXJyb3JzIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsImlubmVyVGV4dCIsImlzVmFsaWQiLCJ2YWxpZGF0ZUlucHV0IiwiaW5wdXQiLCJlcnJvckZpZWxkIiwiZmllbGROYW1lIiwibWluIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwibWF4IiwiSW5maW5pdHkiLCJwYXJzZUZsb2F0IiwicGFyc2VJbnQiLCJ5ZWFyc1RvUmV0aXJlbWVudCIsIm4iLCJyIiwidCIsImZ2Q3VycmVudFNhdmluZ3MiLCJNYXRoIiwicG93IiwiZnZDb250cmlidXRpb25zIiwiZnZTdG9jayIsInJlYWxFc3RhdGVSYXRlIiwiYWRqdXN0ZWRNb3J0Z2FnZSIsImZ2UmVhbEVzdGF0ZSIsImlzTmFOIiwibGlmZUluc3VyYW5jZU1vbnRobHkiLCJmdkxpZmVJbnN1cmFuY2VDb250cmlidXRpb25zIiwiY3VycmVudFdob2xlTGlmZVZhbHVlIiwiZnZXaG9sZUxpZmVMdW1wU3VtIiwiZnZXaG9sZUxpZmVJbnN1cmFuY2UiLCJ0b3RhbFNhdmluZ3MiLCJtb3J0Z2FnZUVuZFllYXJzIiwicmVtYWluaW5nWWVhcnMiLCJmdXR1cmVFeHRyYVNhdmluZ3MiLCJtb250aGx5UGF5bWVudCIsImFkanVzdGVkSW5jb21lIiwicHJvamVjdGlvbnMiLCJpIiwicmVhbEVzdGF0ZVZhbHVlIiwicHJpbmNpcGFsIiwidGVybU1vbnRocyIsIm1vbnRobHlSYXRlIiwibW9udGhzUGFpZCIsInJlbWFpbmluZ01vcnRnYWdlIiwibmV0UmVhbEVzdGF0ZSIsImV4dHJhSW52ZXN0bWVudFZhbHVlIiwiZXh0cmFNb250aHMiLCJleHRyYU1vbnRobHkiLCJleHRyYVllYXJzIiwiaW5zdXJhbmNlQ29udHJpYnV0aW9uRlYiLCJwcm9qZWN0ZWRXaG9sZUxpZmVJbnN1cmFuY2UiLCJ0b3RhbEluc3VyYW5jZVZhbHVlIiwicHVzaCIsInllYXIiLCJzdG9ja1ZhbHVlIiwiaW5zdXJhbmNlVmFsdWUiLCJ3aXRoZHJhd2FsWWVhcnMiLCJyZW1haW5pbmdCYWxhbmNlIiwieWVhcmx5V2l0aGRyYXdhbCIsInJldGlyZW1lbnRZZWFycyIsInNob3J0ZmFsbFN1cnBsdXNEaXYiLCJxdWVyeVNlbGVjdG9yIiwic2hvcnRmYWxsU3VycGx1cyIsInRvdGFsU2F2aW5nc0VsIiwidG90YWxTYXZpbmdzQ2FyZCIsInRvdGFsU2F2aW5nc2hlYWQiLCJiYWNrZ3JvdW5kIiwiZGlzcGxheVllYXJzIiwicHJvamVjdGlvbnNEaXYiLCJwcm9qIiwidG90YWwiLCJmb3JtYXROdW1iZXJQZXJjZW50IiwicmVzZXRDYW52YXMiLCJjcmVhdGVQcm9qZWN0Q29zdEJyZWFrZG93bkNoYXJ0IiwiY3JlYXRlQVJWRGlzdHJpYnV0aW9uQ2hhcnQiLCJpbnRlcmVzdFByb2plY3REdXJhdGlvbiIsImNhbGN1bGF0ZUhvdXNlRmxpcCIsInB1cmNoYXNlIiwicmVubyIsImhvbGRpbmciLCJhcnYiLCJkZXNpcmVkUHJvZml0TWFyZ2luIiwiaW50ZXJlc3RSYXRlIiwibG9hblBvaW50cyIsInRlcm1ZZWFycyIsInRvdGFsUGF5bWVudHMiLCJnYXBGdW5kaW5nUmF0ZSIsImRvd25QYXltZW50UGVyY2VudCIsInJlc2FsZUNvc3RQZXJjZW50IiwicmVzYWxlQ29zdHMiLCJhZGRyZXNzIiwibW9udGhzIiwibW9udGhseVJlbnQiLCJhbm51YWxQcm9wZXJ0eVRheGVzIiwiYW5udWFsSW5zdXJhbmNlIiwiYW5udWFsTWFpbnRlbmFuY2UiLCJhbm51YWxVdGlsaXRpZXMiLCJkb3duUGF5bWVudFR5cGUiLCJkb3duUGF5bWVudEJhc2UiLCJjbG9zaW5nIiwiZG93blBheW1lbnQiLCJsb2FuQW1vdW50IiwicHJvcmF0ZWRNYWludGVuYW5jZSIsInByb3JhdGVkVXRpbGl0aWVzIiwibG9hbkZlZXMiLCJwcm9yYXRlZFRheGVzIiwicHJvcmF0ZWRJbnN1cmFuY2UiLCJtb250aGx5TW9ydGdhZ2VQYXltZW50IiwidG90YWxNb3J0Z2FnZVBhaWQiLCJpbnRlcmVzdFBhaWQiLCJsb2FuSW50ZXJlc3QiLCJ0b3RhbFByb2plY3RDb3N0IiwiZ2FwQ29zdHMiLCJnYXBGdW5kaW5nRmVlcyIsInRvdGFsSW52ZXN0bWVudCIsInRvdGFsQ2FzaEludmVzdGVkIiwiZ3Jvc3NQcm9maXQiLCJuZXRQcm9maXQiLCJwcm9maXRNYXJnaW4iLCJjYXNoT25DYXNoUmV0dXJuIiwidG90YWxIb2xkaW5nRXhwZW5zZXMiLCJtb250aGx5UmVudGFsUHJvZml0IiwidG9GaXhlZCIsImJyZWFrRXZlblllYXJzIiwiTnVtYmVyIiwibW9udGhseUhvbGRpbmdDb3N0IiwicmVudGFsVnNGbGlwIiwicHJvZml0TWluUGVyY2VudCIsInByb2ZpdE1pbkRvbGxhciIsInByb2plY3Rpb24iLCJkZWFsIiwicmVxdWlyZWRBUlYiLCJ0b3RhbEludmVzdG1lbnRFeGNsdWRpbmdQdXJjaGFzZSIsInRhcmdldE5ldFByb2ZpdCIsImFsbE90aGVyQ29zdHMiLCJtYXhQdXJjaGFzZVByaWNlIiwibmV0UHJvZml0RWwiLCJuZXRwcm9jYXJkIiwibmV0cHJvY2FyZGhlYWQiLCJwcm9maXRNYXJnaW5FbCIsInByb21hcmNhcmQiLCJwcm9tYXJjYXJkaGVhZCIsInJlbnRhbFZzRmxpcEVsIiwicnZmY2FyZCIsInJ2ZmNhcmRoZWFkIiwiZGVhbENhcmRkIiwiZGVhbENhcmRkaGVhZCIsImludmVzdG1lbnQiLCJyZW5kZXJQb3J0Zm9saW9QaWVDaGFydCIsInJlbmRlckNhc2hGbG93UGllQ2hhcnQiLCJnZXRUYWJsZURhdGEiLCJ1cGRhdGVUYWJsZVJhbmdlIiwiY2FsY3VsYXRlUmVudGFsUHJvcGVydHkiLCJwcm9wZXJ0eVByaWNlIiwidHJpbSIsImluaXRpYWxSZW5vdmF0aW9ucyIsImxvYW5UZXJtIiwidmFjYW5jeVJhdGUiLCJwcm9wZXJ0eVRheGVzIiwiaW5zdXJhbmNlQ29zdHMiLCJtYWludGVuYW5jZUNvc3RzIiwibWFuYWdlbWVudEZlZXMiLCJ1dGlsaXRpZXMiLCJyZW5vdmF0aW9ucyIsInJlbnRHcm93dGgiLCJjbG9zaW5nQ29zdHNQZXJjZW50IiwiY2xvc2luZ0Nvc3RzIiwidGltZUR1cmF0aW9uIiwiYXBwcmVjaWF0aW9uUmF0ZSIsIm51bVBheW1lbnRzIiwibW9ydGdhZ2VQYXltZW50IiwiZ3Jvc3NSZW50SW5jb21lIiwidmFjYW5jeUxvc3MiLCJhZGp1c3RlZFJlbnRJbmNvbWUiLCJvcGVyYXRpbmdFeHBlbnNlcyIsIm5vaSIsImFubnVhbE1vcnRnYWdlUGF5bWVudCIsImNhc2hGbG93QW5udWFsIiwiY2FzaEZsb3dNb250aGx5IiwiY2FwUmF0ZSIsImNvY1JldHVybiIsImRlYnRTZXJ2aWNlUmF0aW8iLCJyZW50UHJvamVjdGlvbnMiLCJhZGp1c3RlZFJlbnRQcm9qZWN0aW9ucyIsIm1vbnRobHlQcm9wZXJ0eVRheGVzIiwibW9udGhseUluc3VyYW5jZSIsIm1vbnRobHlNYWludGVuYW5jZSIsIm1vbnRobHlNYW5hZ2VtZW50RmVlcyIsIm1vbnRobHlVdGlsaXRpZXMiLCJtb250aGx5UmVub3ZhdGlvbnMiLCJ0b3RhbE1vbnRobHlDb3N0cyIsInllYXJSZW50IiwieWVhclZhY2FuY3lMb3NzIiwieWVhckFkanVzdGVkUmVudCIsImRzckVsZW1lbnQiLCJjYW52YXNXcmFwcGVyIiwicGFyZW50Tm9kZSIsIkNoYXJ0IiwicmVnaXN0ZXJhYmxlcyIsInJlZ2lzdGVyIiwiQ2hhcnREYXRhTGFiZWxzIiwiZGF0YSIsImN0eCIsImdldENvbnRleHQiLCJsYWJlbHMiLCJyZWR1Y2UiLCJhIiwiYiIsInR5cGUiLCJkYXRhc2V0cyIsImJvcmRlckNvbG9yIiwiYm9yZGVyV2lkdGgiLCJob3Zlck9mZnNldCIsIm9wdGlvbnMiLCJyZXNwb25zaXZlIiwicGx1Z2lucyIsInRpdGxlIiwiZGlzcGxheSIsInRleHQiLCJmb250Iiwic2l6ZSIsIndlaWdodCIsImxlZ2VuZCIsImJveFdpZHRoIiwidG9vbHRpcCIsImNhbGxiYWNrcyIsImxhYmVsIiwicGFyc2VkIiwicGVyY2VudGFnZSIsInRvTG9jYWxlU3RyaW5nIiwiZGF0YWxhYmVscyIsImZvcm1hdHRlciIsImNvbnRleHQiLCJkYXRhc2V0IiwiZGF0YUluZGV4IiwiZnZTYXZpbmdzIiwiY2hhcnREYXRhIiwiYXNzZXRCcmVha2Rvd25DaGFydCIsImRlc3Ryb3kiLCJtb3J0Z2FnZVBheW1lbnRBbm51YWwiLCJjYXNoRmxvd1BpZUNoYXJ0Iiwic2NhbGVkTW9ydGdhZ2UiLCJzY2FsZWRFeHBlbnNlcyIsInNjYWxlZENhc2hGbG93IiwiY29sb3JzIiwibmV0TGFiZWwiLCJuZXRDb2xvciIsImFicyIsInRvdGFsRmxvdyIsImFjYyIsInZhbCIsIm1hcCIsImludGVyYWN0aW9uIiwibW9kZSIsImludGVyc2VjdCIsImVuYWJsZWQiLCJ0aXRsZUZvbnQiLCJib2R5Rm9udCIsImJveFBhZGRpbmciLCJyYXciLCJhZnRlckJvZHkiLCJ1c2VQb2ludFN0eWxlIiwic3VtIiwiY2hhcnQiLCJhbmltYXRpb24iLCJhbmltYXRlUm90YXRlIiwiYW5pbWF0ZVNjYWxlIiwiZHVyYXRpb24iLCJlYXNpbmciLCJpbmNvbWVTb3VyY2VDaGFydEluc3RhbmNlIiwiY29udHJpYnV0aW9ucyIsInN0b2NrIiwicmVhbEVzdGF0ZSIsImluc3VyYW5jZSIsImRhdGFWYWx1ZXMiLCJwb3J0Zm9saW9QaWVDaGFydCIsInNjYWxlZEluY29tZSIsInByb2ZpdExhYmVsIiwicHJvZml0VmFsdWUiLCJwcm9maXRDb2xvciIsImZhbWlseSIsInRvcCIsImJvdHRvbSIsImNvbWJpbmVkSG9sZGluZyIsImN1dG91dCIsIm1pbmltdW1GcmFjdGlvbkRpZ2l0cyIsIm1heGltdW1GcmFjdGlvbkRpZ2l0cyIsImZvcm1hdHRlZFZhbHVlIiwiZ2VuZXJhdGVDb21iaW5lZFllYXJUYWJsZSIsImRhdGFBcnJheSIsImR5bmFtaWNDYXRlZ29yaWVzIiwic3RhdGljRXhwZW5zZXMiLCJJbnN1cmFuY2UiLCJNYWludGVuYW5jZSIsIlV0aWxpdGllcyIsIlJlbm92YXRpb25zIiwiZGl2IiwiY2xhc3NMaXN0IiwiYWRkIiwic3RhdGljVGFibGUiLCJlbnRyaWVzIiwiX3JlZiIsImtleSIsImpvaW4iLCJkeW5hbWljVGFibGUiLCJkIiwiY2F0IiwibmV0T3BlcmF0aW5nSW5jb21lIiwiY2FwaXRhbEV4cGVuZGl0dXJlcyIsImNhc2hGbG93IiwibW9udGhseVBtdHMiLCJwcm9qZWN0TW9udGhzIiwibW9udGhseUludGVyZXN0IiwiaW50ZXJlc3RBY2NydWVkIiwiaW50ZXJlc3QiLCJwb3B1bGF0ZVllYXJzRHJvcGRvd24iLCJzZWxlY3QiLCJvcHRpb24iLCJ0ZXh0Q29udGVudCIsInNlbGVjdGVkIiwicmV0dXJuRGF0YSIsInJlbnRJbmNyZWFzZVJhdGUiLCJhcHByZWNpYXRpb25GYWN0b3IiLCJyZW50RmFjdG9yIiwibWFuYWdlbWVudENvc3QiLCJsb2ciLCJzZWxlY3RlZFllYXIiLCJ0YWJsZUNvbnRhaW5lciIsInllYXJzIiwidGFibGVEYXRhIiwiZmlsdGVyIiwiQm9vbGVhbiIsImNvbWJpbmVkVGFibGUiLCJpbnB1dHMiLCJxdWVyeVNlbGVjdG9yQWxsIiwiaW5wdXQyIiwiaW5wdXQzIiwieWVhcnNEcm9wZG93biJdLCJzb3VyY2VSb290IjoiIn0=
